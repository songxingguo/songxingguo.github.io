<!DOCTYPE html>













  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


  




  <meta name="description" content="引用类型引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构 ，用于 将数据和功能组织在一起 。它也常被称为 类 ，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。  虽然 引用类型与类看起来相">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="《JavaScript 高级程序设计》学习笔记-引用类型">
<meta property="og:url" content="https://www.songxingguo.com/2018/08/13/JavaScript-reference-type/index.html">
<meta property="og:site_name" content="阿有的生活">
<meta property="og:description" content="引用类型引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构 ，用于 将数据和功能组织在一起 。它也常被称为 类 ，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。  虽然 引用类型与类看起来相">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E6%97%A5%E6%9C%9F%E5%80%BC.png">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E6%97%A5%E6%9C%9F%E5%80%BC%EF%BC%88%E7%BB%AD%EF%BC%89.png">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.png">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/RegExp%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%9E%E6%80%A7.png">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97.png">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/HTML%20%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-typeGlobal%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7.png">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-typeMath%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC.png">
<meta property="og:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/Math%20%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.png">
<meta property="og:updated_time" content="2020-02-18T06:02:54.905Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《JavaScript 高级程序设计》学习笔记-引用类型">
<meta name="twitter:description" content="引用类型引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构 ，用于 将数据和功能组织在一起 。它也常被称为 类 ，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。  虽然 引用类型与类看起来相">
<meta name="twitter:image" content="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E6%97%A5%E6%9C%9F%E5%80%BC.png">






  <link rel="canonical" href="https://www.songxingguo.com/2018/08/13/JavaScript-reference-type/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>《JavaScript 高级程序设计》学习笔记-引用类型 | 阿有的生活</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ea29d0cf9dda7fe5403ba0f70fb2c10d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">阿有的生活</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">爱技术，也爱生活。</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">131</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">8</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">43</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-works">
    <a href="/works/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>作品</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.songxingguo.com/2018/08/13/JavaScript-reference-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="songxingguo">
      <meta itemprop="description" content="< 写文章 && 做分享 />">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿有的生活">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《JavaScript 高级程序设计》学习笔记-引用类型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-13 15:23:00" itemprop="dateCreated datePublished" datetime="2018-08-13T15:23:00+00:00">2018-08-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-18 06:02:54" itemprop="dateModified" datetime="2020-02-18T06:02:54+00:00">2020-02-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/13/JavaScript-reference-type/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/13/JavaScript-reference-type/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/08/13/JavaScript-reference-type/" class="leancloud_visitors" data-flag-title="《JavaScript 高级程序设计》学习笔记-引用类型">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，<strong>引用类型是一种数据结构</strong> ，用于 <strong>将数据和功能组织在一起</strong> 。它也常被称为 <strong>类</strong> ，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<blockquote>
<p>虽然 <strong>引用类型与类看起来相似</strong> ，但 <strong>它们并不是相同的概念</strong> 。为避免混淆，本书将<br>不使用类这个概念。</p>
</blockquote>
<p>如前所述，对象是某个特定引用类型的实例。新对象是 <strong>使用 new 操作符后跟一个构造函数来创建的</strong> 。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这行代码创建了 Object 引用类型的一个新实例，然后把该实例保存在了变量 person 中。使用的构造函数是 Object ，它只为新对象定义了默认的属性和方法。ECMAScript 提供了很多 <strong>原生引用类型</strong>（例如 Object ），以便开发人员用以实现常见的计算任务。</p>
<a id="more"></a>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且， Object 也是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。</p>
<p><strong>创建 Object 实例</strong> 的方式有两种。第一种是 <strong>使用 new 操作符后跟 Object 构造函数</strong> ，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;Nicholas&quot;;</span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure>
<p>另一种方式是 <strong>使用对象字面量表示法</strong> 。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的 person 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">"Nicholas"</span>,</span><br><span class="line">  age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，左边的花括号（ { ）表示对象字面量的开始，因为它出现在了表达式上下文（expression context）中。ECMAScript 中的表达式上下文指的是能够返回一个值（表达式）。赋值操作符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文（statement context）中，例如跟在 if 语句条件的后面，则表示一个语句块的开始。</p>
<p>然后，我们定义了 name 属性，之后是一个冒号，再后面是这个属性的值。在对象字面量中，使用逗号来分隔不同的属性，因此 “Nicholas” 后面是一个逗号。但是，在 age 属性的值 29 的后面不能添加逗号，因为 age 是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在 IE7 及更早版本和 Opera 中导致错误。</p>
<p>在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</span><br><span class="line">  <span class="string">"age"</span> : <span class="number">29</span>,</span><br><span class="line">  <span class="number">5</span> : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子会创建一个对象，包含三个属性： name 、 age 和 5 。但 <strong>这里的数值属性名会自动转换为字符串</strong> 。</p>
<p>另外，使用对象字面量语法时，如果 <strong>留空其花括号</strong> ，则 <strong>可以定义只包含默认属性和方法的对象</strong> ，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;; <span class="comment">//与 与 new Object() 相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子与本节前面的例子是等价的，只不过看起来似乎有点奇怪。关于对象字面量语法，我们推荐只在考虑对象属性名的可读性时使用。</p>
<blockquote>
<p>在通过对象字面量定义对象时，实际上不会调用 Object 构造函数（Firefox 2 及<br>更早版本会调用 Object 构造函数；但 Firefox 3 之后就不会了）。</p>
</blockquote>
<p>虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，<strong>对象字面量也是向函数传递大量可选参数的首选方式</strong> ，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function displayInfo(args) &#123;</span><br><span class="line">  var output = &quot;&quot;;</span><br><span class="line">  if (typeof args.name == &quot;string&quot;)&#123;</span><br><span class="line">    output += &quot;Name: &quot; + args.name + &quot;\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof args.age == &quot;number&quot;) &#123;</span><br><span class="line">    output += &quot;Age: &quot; + args.age + &quot;\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  alert(output);</span><br><span class="line">&#125;</span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  name: &quot;Nicholas&quot;,</span><br><span class="line">  age: 29</span><br><span class="line">&#125;);</span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  name: &quot;Greg&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，函数 displayInfo() 接受一个名为 args 的参数。这个参数可能带有一个名为 name 或 age 的属性，也可能这两个属性都有或者都没有。在这个函数内部，我们通过 typeof 操作符来检测每个属性是否存在，然后再基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，每次都使用一个对象字面量来指定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。</p>
<blockquote>
<p>这种传递参数的模式最适合需要 <strong>向函数传入大量可选参数的情形</strong> 。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。<strong>最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数</strong> 。</p>
</blockquote>
<p>一般来说，访问对象属性时使用的都是 <strong>点表示法</strong> ，这也是很多面向对象语言中通用的语法。不过，在 JavaScript 也可以使用 <strong>方括号表示法</strong> 来访问对象的属性。在使用方括号语法时，应该 <strong>将要访问的属性以字符串的形式放在方括号中</strong> ，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">"name"</span>]); <span class="comment">//"Nicholas"</span></span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是 <strong>可以通过变量来访问属性</strong> ，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line">alert(person[propertyName]); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>如果属性名中包含会导致语法错误的字符，或者 <strong>属性名使用的是关键字或保留字</strong> ，也可以 <strong>使用方括号表示法</strong> 。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于 “first name” 中包含一个空格，所以不能使用点表示法来访问它。然而，<strong>属性名中是可以包含非字母非数字的</strong> ，这时候就可以 <strong>使用方括号表示法来</strong> 访问它们。</p>
<p>通常，<strong>除非必须使用变量来访问属性，否则我们建议使用点表示法</strong> 。</p>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>除了 Object 之外， Array 类型恐怕是 ECMAScript 中最常用的类型了。而且，ECMAScript 中的数组与其他多数语言中的数组有着相当大的区别。虽然 ECMAScript 数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，<strong>ECMAScript 数组</strong> 的每一项可以保存 <strong>任何类型的数据</strong> 。也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。而且，<strong>ECMAScript 数组的大小是可以动态调整的</strong> ，即 <strong>可以随着数据的添加自动增长以容纳新增数据</strong> 。</p>
<p><strong>创建数组</strong> 的基本方式有两种。第一种是 <strong>使用 Array 构造函数</strong> ，如下面的代码所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
<p>如果预先知道数组要保存的项目数量，也可以 <strong>给构造函数传递该数量</strong> ，而该数量会自动变成 length 属性的值。例如，下面的代码将创建 length 值为 20 的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>也可以 <strong>向 Array 构造函数传递数组中应该包含的项</strong> 。以下代码创建了一个包含 3个字符串值的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure>
<p>当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果 <strong>传递的是数值</strong> ，则会 <strong>按照该数值创建包含给定项数的数组</strong> ；而如果 <strong>传递的是其他类型的参数</strong> ，则会创建 <strong>包含那个值的只有一项的数组</strong> 。下面就两个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含 3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含 1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure>
<p>另外，在使用 Array 构造函数时也可以 <strong>省略 new 操作符</strong> 。如下面的例子所示，省略 new 操作符的结果相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含 3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含 1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure>
<p>创建数组的第二种基本方式是 <strong>使用数组字面量表示法</strong> 。数组字面量由 <strong>一对包含数组项的方括号表示</strong> ，<strong>多个数组项之间以逗号隔开</strong> ，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 不要这样！这样会创建一个包含 2 或 3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！这样会创建一个包含 5 或 6 项的数组</span></span><br></pre></td></tr></table></figure>
<p>以上代码的第一行创建了一个包含3个字符串的数组。第二行使用一对空方括号创建了一个空数组。第三行展示了在数组字面量的最后一项添加逗号的结果：在 IE 中， values 会成为一个包含 3 个项且每项的值分别为 1、2 和 undefined 的数组；在其他浏览器中， values 会成为一个包含 2项且值分别为 1 和 2 的数组。原因是 IE8 及之前版本中的 ECMAScript 实现在数组字面量方面存在 bug。由于这个 bug 导致的另一种情况如最后一行代码所示，该行代码可能会创建包含 5 项的数组（在 IE9+、Firefox、Opera、<br>Safari 和 Chrome 中），也可能会创建包含 6 项的数组（在 IE8 及更早版本中）。在像这种省略值的情况下，每一项都将获得 undefined 值；这个结果与调用 Array 构造函数时传递项数在逻辑上是相同的。但是由于 IE 的实现与其他浏览器不一致，因此我们强烈建议不要使用这种语法。</p>
<blockquote>
<p>与对象一样，在 <strong>使用数组字面量表示法</strong> 时，也 <strong>不会调用 Array 构造函数</strong> （Firefox 3 及更早版本除外）。</p>
</blockquote>
<p>在 <strong>读取和设置数组的值</strong> 时，要 <strong>使用方括号并提供相应值的基于 0 的数字索引</strong> ，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 定义一个字符串数组</span></span><br><span class="line">alert(colors[<span class="number">0</span>]); <span class="comment">// 显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>; <span class="comment">// 修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>; <span class="comment">// 新增第四项</span></span><br></pre></td></tr></table></figure>
<p>方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值，就像这个例子中的 colors[0] 会显示 “red” 一样。设置数组的值也使用相同的语法，但会替换指定位置的值。如果设置某个值的索引超过了数组现有项数，如这个例子中的 colors[3] 所示，数组就会自动增加到该索引值加 1 的长度（就这个例子而言，索引是 3，因此数组长度就是 4）。</p>
<p><strong>数组的项数</strong> 保存在其 <strong>length 属性</strong> 中，这个属性始终会返回 0 或更大的值，如下面这个例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line">alert(colors.length); <span class="comment">//3</span></span><br><span class="line">alert(names.length); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>数组的 length 属性很有特点——它 <strong>不是只读的</strong> 。因此，通过 <strong>设置这个属性</strong> ，<strong>可以从数组的末尾移除项或向数组中添加新项</strong> 。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的数组 colors 一开始有 3 个值。将其 length 属性设置为 2 会移除最后一项（位置为 2 的那一项），结果再访问 colors[2] 就会显示 undefined 了。如果将其 length 属性设置为大于数组项数的值，则新增的每一项都会取得 undefined 值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">4</span>;</span><br><span class="line">alert(colors[<span class="number">3</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>在此，虽然 colors 数组包含 3 个项，但把它的 length 属性设置成了 4。这个数组不存在位置 3，所以访问这个位置的值就得到了特殊值 undefined 。</p>
<p><strong>利用 length 属性也可以方便地在数组末尾添加新项</strong> ，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors[colors.length] = <span class="string">"black"</span>; <span class="comment">// （在位置 3 ）添加一种颜色</span></span><br><span class="line">colors[colors.length] = <span class="string">"brown"</span>; <span class="comment">// （在位置 4 ）再添加一种颜色</span></span><br></pre></td></tr></table></figure>
<p>由于数组最后一项的索引始终是 length-1 ，因此下一个新项的位置就是 length 。每当在数组末尾添加一项后，其 length 属性都会自动更新以反应这一变化。换句话说，上面例子第二行中的 colors[colors.length] 为位置 3 添加了一个值，最后一行的 colors[colors.length] 则为位置 4 添加了一个值。<strong>当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值</strong> ，即长度值等于最后一项的索引加 1，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">"black"</span>; <span class="comment">// （在位置 99 ）添加一种颜色</span></span><br><span class="line">alert(colors.length); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们向 colors 数组的位置 99 插入了一个值，结果数组新长度（ length ）就是 100（99+1）。而位置 3 到位置 98 实际上都是不存在的，所以访问它们都将返回 undefined 。</p>
<blockquote>
<p>数组最多可以包含 <strong>4 294 967 295 个项</strong> ，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。</p>
</blockquote>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>自从 ECMAScript 3 做出规定以后，就出现了确定某个对象是不是数组的经典问题。对于<strong>一个网页，或者一个全局作用域而言</strong> ，使用 <strong>instanceof 操作符就能得到满意的结果</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (value instanceof Array)&#123;</span><br><span class="line">  //对数组执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果 <strong>网页中包含多个框架</strong> ，那 <strong>实际上就存在两个以上不同的全局执行环境</strong> ，<strong>从而存在两个以上不同版本的 Array 构造函数</strong> 。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p>
<p>为了解决这个问题，ECMAScript 5 新增了 <strong>Array.isArray() 方法</strong> 。这个方法的目的是 <strong>最终确定某个值到底是不是数组</strong> ，而 <strong>不管它是在哪个全局执行环境中创建的</strong> 。这个方法的用法如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">  <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持 Array.isArray() 方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 10.5+和 Chrome。要在尚未实现这个方法中的浏览器中准确检测数组，请参考 22.1.1 节。</p>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>如前所述，所有对象都具有 toLocaleString() 、 toString() 和 valueOf() 方法。其中，调用数组的 <strong>toString() 方法</strong> 会返回 <strong>由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</strong> 。而调用 <strong>valueOf()</strong> 返回的还是 <strong>数组</strong> 。实际上，为了创建这个字符串会调用数组每一项的 toString() 方法。来看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">alert(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors.valueOf()); <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors); <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们首先显式地调用了 toString() 方法，以便返回数组的字符串表示，每个值的字符串表示拼接成了一个字符串，中间以逗号分隔。接着调用 valueOf() 方法，而最后一行代码直接将数组传递给了 alert() 。由于 alert() 要接收字符串参数，所以它会在后台调用 toString() 方法，由此会得到与直接调用 toString() 方法相同的结果。<br>另外， toLocaleString() 方法经常也会返回与 toString() 和 valueOf() 方法相同的值，但也不总是如此。当调用数组的 toLocaleString() 方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 <strong>toLocaleString() 方法</strong> ，而不是 toString() 方法。请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  toLocaleString : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nikolaos"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  toLocaleString : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Grigorios"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Greg"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people = [person1, person2];</span><br><span class="line">alert(people); <span class="comment">//Nicholas,Greg</span></span><br><span class="line">alert(people.toString()); <span class="comment">//Nicholas,Greg</span></span><br><span class="line">alert(people.toLocaleString()); <span class="comment">//Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure>
<p>我们在这里定义了两个对象： person1 和 person2 。而且还分别为每个对象定义了一个 toString() 方法和一个 toLocaleString() 方法，这两个方法返回不同的值。然后，创建一个包含前面定义的两个对象的数组。在将数组传递给 alert() 时，输出结果是 “Nicholas,Greg” ，因为调用了数组每一项的 toString() 方法（同样，这与下一行显式调用 toString() 方法得到的结果相同）。而当调用数组的 toLocaleString() 方法时，输出结果是 “Nikolaos,Grigorios” ，原因是调用了数组每一项的 toLocaleString() 方法。</p>
<p>数组继承的 toLocaleString() 、 toString() 和 valueOf() 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 <strong>join() 方法</strong> ，则 <strong>可以使用不同的分隔符来构建这个字符串</strong> 。 <strong>join() 方法</strong> 只接收一个参数，即 <strong>用作分隔符的字符串</strong> ，然后 <strong>返回包含所有数组项的字符串</strong> 。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">alert(colors.join(<span class="string">","</span>)); <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors.join(<span class="string">"||"</span>)); <span class="comment">//red||green||blue</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们使用 join() 方法重现了 toString() 方法的输出。在传递逗号的情况下，得到了以逗号分隔的数组值。而在最后一行代码中，我们传递了双竖线符号，结果就得到了字符串 “red|| green||blue” 。如果 <strong>不给 join() 方法传入任何值，或者给它传入 undefined</strong> ，则 <strong>使用逗号作为分隔符</strong> 。IE7 及更早版本会错误的使用字符串 “undefined” 作为分隔符。</p>
<blockquote>
<p>如果数组中的某一项的值是 null 或者 undefined ，那么该值在 join() 、toLocaleString() 、 toString() 和 valueOf() 方法 <strong>返回的结果中以空字符串表示</strong> 。</p>
</blockquote>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>ECMAScript 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表现得就像 <strong>栈</strong> 一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 <strong>LIFO</strong>（Last-In-First-Out，后进先出）的数据结构，也就是 <strong>最新添加的项最早被移除</strong> 。而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——<strong>栈的顶部</strong> 。ECMAScript 为数组专门提供了 push() 和 pop() 方法，以便实现类似栈的行为。</p>
<p><strong>push() 方法</strong> 可以接收任意数量的参数，把它们 <strong>逐个添加到数组末尾</strong> ，并 <strong>返回修改后数组的长度</strong> 。而 <strong>pop() 方法</strong> 则 <strong>从数组末尾移除最后一项</strong> ，<strong>减少数组的 length 值</strong> ，然后 <strong>返回移除的项</strong> 。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>); <span class="comment">// 推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"black"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>以上代码中的 <strong>数组可以看成是栈</strong>（代码本身没有任何区别，而 push() 和 pop() 都是数组默认的方法）。首先，我们使用 <strong>push()</strong> 将两个字符串 <strong>推入数组的末尾</strong> ，并将返回的结果保存在变量 count 中（值为 2）。然后，再推入一个值，而结果仍然保存在 count 中。因为此时数组中包含 3 项，所以 push()返回 3。在调用 <strong>pop()</strong> 时，它会 <strong>返回数组的最后一项</strong> ，即字符串 “black” 。此后，数组中仅剩两项。</p>
<p>可以将栈方法与其他数组方法连用，像下面这个例子一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>];</span><br><span class="line">colors.push(<span class="string">"brown"</span>); <span class="comment">// 添加另一项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>; <span class="comment">// 添加一项</span></span><br><span class="line">alert(colors.length); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"black"</span></span><br></pre></td></tr></table></figure>
<p>在此，我们首先用两个值来初始化一个数组。然后，使用 push() 添加第三个值，再通过直接在位置 3 上赋值来添加第四个值。而在调用 pop() 时，该方法返回了字符串 “black” ，即最后一个添加到数组的值。</p>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>栈数据结构的访问规则是 LIFO（后进先出），而 <strong>队列数据结构</strong> 的访问规则是 FIFO（First-In-First-Out，先进先出）。队列在列表的末端添加项，从列表的前端移除项。由于 push() 是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 <strong>shift()</strong> ，它能够 <strong>移除数组中的第一个项</strong> 并 <strong>返回该项</strong> ，同时 <strong>将数组长度减 1</strong> 。结合 <strong>使用 shift() 和 push() 方法</strong> ，可以 <strong>像使用队列一样使用数组</strong> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">//推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>); <span class="comment">//推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.shift(); <span class="comment">// 取得第一项</span></span><br><span class="line">alert(item); <span class="comment">//"red"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>这个例子首先使用 push() 方法创建了一个包含 3 种颜色名称的数组。代码中加粗的那一行使用 shift() 方法从数组中取得了第一项，即 “red” 。在移除第一项之后， “green” 就变成了第一项，而 “black” 则变成了第二项，数组也只包含两项了。</p>
<p>ECMAScript 还为数组提供了一个 <strong>unshift() 方法</strong>。顾名思义， unshift() 与 shift() 的用途相反：它能在 <strong>数组前端添加任意个项</strong> 并 <strong>返回新数组的长度</strong> 。因此，同时使用 <strong>unshift() 和 pop() 方法</strong> ，可以从 <strong>相反的方向来模拟队列</strong> ，即在数组的前端添加项，从数组末端移除项，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.unshift(<span class="string">"black"</span>); <span class="comment">// 推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"green"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个数组并使用 unshift() 方法先后推入了 3 个值。首先是 “red” 和 “green” ，然后是 “black” ，数组中各项的顺序为 “black” 、 “red” 、 “green” 。在调用 pop() 方法时，移除并返回的是最后一项，即 “green” 。</p>
<blockquote>
<p>IE7 及更早版本对 JavaScript 的实现中存在一个偏差，其 unshift() 方法总是返回 undefined 而不是数组的新长度。IE8 在非兼容模式下会返回正确的长度值。</p>
</blockquote>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>数组中已经存在两个可以直接用来 <strong>重排序的方法</strong> ： <strong>reverse()</strong> 和 <strong>sort()</strong> 。有读者可能猜到了， <strong>reverse() 方法</strong> 会 <strong>反转数组项的顺序</strong> 。请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values); <span class="comment">//5,4,3,2,1</span></span><br></pre></td></tr></table></figure>
<p>这里数组的初始值及顺序是 1、2、3、4、5。而调用数组的 reverse() 方法后，其值的顺序变成了 5、4、3、2、1。这个方法的作用相当直观明了，但不够灵活，因此才有了 sort() 方法。</p>
<p>在默认情况下， <strong>sort() 方法</strong> 按 <strong>升序排列数组项</strong>——即 <strong>最小的值位于最前面，最大的值排在最后面</strong> 。为了实现排序， <strong>sort() 方法</strong> 会调用每个数组项的 <strong>toString() 转型方法</strong> ，然后 <strong>比较得到的字符串</strong> ，以确定如何排序。即使数组中的每一项都是数值， <strong>sort() 方法比较的也是字符串</strong> ，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>可见，即使例子中值的顺序没有问题，但 sort() 方法也会根据测试字符串的结果改变原来的顺序。因为数值 5 虽然小于 10，但在进行字符串比较时， “10” 则位于 “5” 的前面，于是数组的顺序就被修改了。</p>
<p>不用说，这种排序方式在很多情况下都不是最佳方案。因此 <strong>sort() 方法</strong> 可以 <strong>接收一个比较函数作为参数</strong> ，以便我们指定哪个值位于哪个值的前面。</p>
<p>比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给 sort() 方法即可，如下面这个例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>在将比较函数传递到 sort() 方法之后，数值仍然保持了正确的升序。当然，也可以 <strong>通过比较函数产生降序排序的结果</strong> ，只要交换比较函数返回的值即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<p>在这个修改后的例子中，比较函数在第一个值应该位于第二个之后的情况下返回 1，而在第一个值应该在第二个之前的情况下返回-1。交换返回值的意思是让更大的值排位更靠前，也就是对数组按照降序排序。当然，如果 <strong>只想反转数组原来的顺序</strong> ，<strong>使用 reverse() 方法要更快一些</strong> 。</p>
<blockquote>
<p>reverse() 和 sort() 方法的返回值是经过排序之后的数组。</p>
</blockquote>
<p>对于 <strong>数值类型</strong> 或者 <strong>其 valueOf() 方法会返回数值类型的对象类型</strong> ，可以使用一个 <strong>更简单的比较函数</strong> 。这个函数只要用第二个值减第一个值即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1, value2)&#123;</span><br><span class="line">  return value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况。</p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中， <strong>concat() 方法</strong> 可以 <strong>基于当前数组中的所有项创建一个新数组</strong> 。具体来说，这个方法会 <strong>先创建当前数组一个副本</strong> ，然后 <strong>将接收到的参数添加到这个副本的末尾</strong> ，最后 <strong>返回新构建的数组</strong> 。在 <strong>没有给 concat() 方法传递参数</strong> 的情况下，它 <strong>只是复制当前数组并返回副本</strong> 。如果传递给 concat() 方法的是 <strong>一或多个数组</strong> ，则该方法会 <strong>将这些数组中的每一项都添加到结果数组中</strong> 。如果 <strong>传递的值不是数组</strong> ，<strong>这些值就会被简单地添加到结果数组的末尾</strong> 。下面来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</span><br><span class="line">alert(colors); <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors2); <span class="comment">//red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure>
<p>以上代码开始定义了一个包含 3 个值的数组 colors 。然后，基于 colors 调用了 concat() 方法，并传入字符串 “yellow” 和一个包含 “black” 和 “brown” 的数组。最终，结果数组 colors2 中包含了”red” 、 “green” 、 “blue” 、 “yellow” 、 “black” 和 “brown” 。至于原来的数组 colors ，其值仍然保持不变。</p>
<p>下一个方法是 <strong>slice()</strong> ，它能够 <strong>基于当前数组中的一或多个项创建一个新数组 。 slice() 方法可以接受一或两个参数，即要 </strong>返回项的起始和结束位置<strong> 。在只有一个参数的情况下， </strong>slice() 方法<strong> 返回 </strong>从该参数指定位置开始到当前数组末尾的所有项<strong> 。如果有两个参数，该方法 </strong>返回起始和结束位置之间的项<strong> ——但  </strong>不包括结束位置的项<strong> 。注意， </strong>slice() 方法不会影响原始数组** 。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">alert(colors2); <span class="comment">//green,blue,yellow,purple</span></span><br><span class="line">alert(colors3); <span class="comment">//green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，开始定义的数组 colors 包含 5 项。调用 slice() 并传入 1 会得到一个包含 4 项的新数组；因为是从位置 1 开始复制，所以会包含 “green” 而不会包含 “red” 。这个新数组 colors2 中包含的是 “green” 、 “blue” 、 “yellow” 和 “purple” 。接着，我们再次调用 slice() 并传入了 1 和 4，表示复制从位置 1 开始，到位置 3 结束。结果数组 colors3 中包含了 “green” 、 “blue” 和 “yellow” 。</p>
<blockquote>
<p>如果 slice() 方法的 <strong>参数中有一个负数</strong> ，则 <strong>用数组长度加上该数来确定相应的位置</strong> 。例如，在一个包含 5 项的数组上调用 slice(-2,-1) 与调用 slice(3,4) 得到的结果相同。如果结束位置小于起始位置，则返回空数组。</p>
</blockquote>
<p>下面我们来介绍 splice() 方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。<strong>splice()</strong> 的主要用途是 <strong>向数组的中部插入项</strong> ，但使用这种方法的方式则有如下 3 种。</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2) 会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”) 会从当前数组的位置 2 开始插入字符串 “red” 和 “green” 。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red” 和 “green” 。</li>
</ul>
<p>splice() 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述 3 种使用 splice() 方法的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line">alert(colors); <span class="comment">// green,blue</span></span><br><span class="line">alert(removed); <span class="comment">// red，返回的数组中只包含一项</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>); <span class="comment">// 从位置 1 开始插入两项</span></span><br><span class="line">alert(colors); <span class="comment">// green,yellow,orange,blue</span></span><br><span class="line">alert(removed); <span class="comment">// 返回的是一个空数组</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>); <span class="comment">// 插入两项，删除一项</span></span><br><span class="line">alert(colors); <span class="comment">// green,red,purple,orange,blue</span></span><br><span class="line">alert(removed); <span class="comment">// yellow，返回的数组中只包含一项</span></span><br></pre></td></tr></table></figure>
<p>上面的例子首先定义了一个包含 3项的数组 colors 。第一次调用 splice() 方法只是删除了这个数组的第一项，之后 colors 还包含 “green” 和 “blue” 两项。第二次调用 splice() 方法时在位置 1插入了两项，结果 colors 中包含 “green” 、 “yellow” 、 “orange” 和 “blue” 。这一次操作没有删除项，因此返回了一个空数组。最后一次调用 splice() 方法删除了位置 1处的一项，然后又插入了 “red” 和 “purple” 。在完成以<br>上操作之后，数组 colors 中包含的是 “green” 、 “red” 、 “purple” 、 “orange” 和 “blue” 。</p>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript 5 为数组实例添加了两个位置方法： <strong>indexOf()</strong> 和 <strong>lastIndexOf()</strong> 。这两个方法都接收两个参数：<strong>要查找的项</strong> 和（可选的）<strong>表示查找起点位置的索引</strong> 。其中， <strong>indexOf() 方法从数组的开头（位置 0）开始向后查找</strong> ， <strong>lastIndexOf() 方法则从数组的末尾开始向前查找</strong> 。</p>
<p>这两个方法都返回 <strong>要查找的项在数组中的位置</strong> ，或者 <strong>在没找到的情况下返回-1</strong>。在比较第一个参数与数组中的每一项时，会使用 <strong>全等操作符</strong> ；也就是说，<strong>要求查找的项必须严格相等</strong>（就像使用===一样）。以下是几个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">alert(numbers.indexOf(4)); //3</span><br><span class="line">alert(numbers.lastIndexOf(4)); //5</span><br><span class="line">alert(numbers.indexOf(4, 4)); //5</span><br><span class="line">alert(numbers.lastIndexOf(4, 4)); //3</span><br><span class="line"></span><br><span class="line">var person = &#123; name: &quot;Nicholas&quot; &#125;;</span><br><span class="line">var people = [&#123; name: &quot;Nicholas&quot; &#125;];</span><br><span class="line"></span><br><span class="line">var morePeople = [person];</span><br><span class="line"></span><br><span class="line">alert(people.indexOf(person)); //-1</span><br><span class="line">alert(morePeople.indexOf(person)); //0</span><br></pre></td></tr></table></figure>
<p>使用 indexOf() 和 lastIndexOf() 方法查找特定项在数组中的位置非常简单，支持它们的浏览器包括 IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：<strong>要在每一项上运行的函数</strong> 和（可选的）<strong>运行该函数的作用域对象</strong> —— <strong>影响 this 的值</strong> 。传入这些方法中的函数会接收三个参数：<strong>数组项的值</strong> 、<strong>该项在数组中的位置和数组对象本身</strong> 。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这 5 个迭代方法的作用。</p>
<ul>
<li>every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true 。</li>
<li>filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li>forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true 。</li>
</ul>
<p>以上方法都不会修改数组中的包含的值。</p>
<p>在这些方法中，最相似的是 every() 和 some() ，它们都用于 <strong>查询数组中的项是否满足某个条件</strong> 。对 every() 来说，传入的函数必须对 <strong>每一项都返回 true</strong> ，这个方法才 <strong>返回 true</strong> ；否则，它就返回 false 。而 <strong> some() 方法</strong> 则是 <strong>只要传入的函数对数组中的某一项返回 true</strong> ，就会 <strong>返回 true</strong> 。请看以下例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">var everyResult = numbers.every(function(item, index, array)&#123;</span><br><span class="line">  return (item &gt; 2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(everyResult); //false</span><br><span class="line"></span><br><span class="line">var someResult = numbers.some(function(item, index, array)&#123;</span><br><span class="line">  return (item &gt; 2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(someResult); //true</span><br></pre></td></tr></table></figure>
<p>以上代码调用了 every() 和 some() ，传入的函数只要给定项大于2就会返回 true 。对于 every() ，它返回的是 false ，因为只有部分数组项符合条件。对于 some() ，结果就是 true ，因为至少有一项是大于 2 的。</p>
<p>下面再看一看 <strong>filter() 函数</strong> ，它利用指定的函数确定 <strong>是否在返回的数组中包含某一项</strong> 。例如，要返回一个所有数值都大于 2 的数组，可以使用以下代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult); <span class="comment">//[3,4,5,4,3]</span></span><br></pre></td></tr></table></figure>
<p>这里，通过调用 filter() 方法创建并返回了包含 3、4、5、4、3 的数组，因为传入的函数对它们每一项都返回 true 。这个方法对 <strong>查询符合某些条件的所有数组项非常有用</strong> 。</p>
<p><strong>map()</strong> 也返回一个数组，而这个数组的 <strong>每一项都是在原始数组中的对应项上运行传入函数的结果</strong> 。例如，可以给数组中的每一项乘以 2，然后 <strong>返回这些乘积组成的数组</strong> ，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">alert(mapResult); <span class="comment">//[2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure>
<p>以上代码返回的数组中包含给每个数乘以 2 之后的结果。这个方法适合创建包含的项与另一个数组一一对应的数组。</p>
<p>最后一个方法是 <strong>forEach()</strong> ，它只是 <strong>对数组中的每一项运行传入的函数</strong> 。这个方法没有返回值，本质上 <strong>与使用 for 循环迭代数组一样</strong> 。来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。支持这些迭代方法的浏览器有 IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。</p>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>ECMAScript 5 还新增了两个归并数组的方法： <strong>reduce()</strong> 和 <strong>reduceRight()</strong> 。这两个方法都会 <strong>迭代数组的所有项</strong> ，然后 <strong>构建一个最终返回的值</strong> 。其中， <strong>reduce() 方法从数组的第一项开始，逐个遍历到最后</strong> 。而 <strong>reduceRight() 则从数组的最后一项开始，向前遍历到第一项</strong> 。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce() 和 reduceRight() 的函数接收 4 个参数：<strong>前一个值</strong> 、<strong>当前值</strong> 、<strong>项的索引</strong> 和 <strong>数组对象</strong> 。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<p>使用 reduce() 方法可以执行 <strong>求数组中所有值之和</strong> 的操作，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数， prev 是 1， cur 是 2。第二次， prev 是 3（1 加 2 的结果）， cur 是 3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。</p>
<p>reduceRight() 的作用类似，只不过方向相反而已。来看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一次执行回调函数， prev 是 5， cur 是 4。当然，最终结果相同，因为执行的都是简单相加的操作。</p>
<p>使用 reduce() 还是 reduceRight() ，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。</p>
<p>支持这两个归并函数的浏览器有 IE9+、Firefox 3+、Safari 4+、Opera 10.5 和 Chrome。</p>
<h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><p>ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此， Date 类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1月 1 日之前或之后的 285 616 年。</p>
<p>要创建一个日期对象，使用 <strong>new 操作符和 Date 构造函数</strong> 即可，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p>在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript 提供了两个方法： Date.parse() 和 Date.UTC() 。</p>
<p>其中， <strong>Date.parse() 方法</strong> 接收一个表示 <strong>日期的字符串</strong> 参数，然后 <strong>尝试根据这个字符串返回相应日期的毫秒数</strong> 。ECMA-262 没有定义 Date.parse() 应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式：</p>
<ul>
<li>“月/日/年”，如 6/13/2004；</li>
<li>“英文月名 日,年”，如 January 12,2004；</li>
<li>“英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700。</li>
<li>ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ（例如 2004-05-25T00:00:00）。只有兼容 ECMAScript 5的实现支持这种格式。</li>
</ul>
<p>例如，要为 2004 年 5 月 25 日创建一个日期对象，可以使用下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br></pre></td></tr></table></figure>
<p>如果传入 <strong>Date.parse() 方法</strong> 的 <strong>字符串不能表示日期</strong> ，那么它会 <strong>返回 NaN</strong> 。实际上，如果直接 <strong>将表示日期的字符串传递给 Date 构造函数</strong> ，也会在<strong>后台调用 Date.parse()</strong> 。换句话说，下面的代码与前面的例子是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25, 2004"</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码将会得到与前面相同的日期对象。</p>
<blockquote>
<p>日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超出范围的值替换成当前的值，以便生成输出。例如，在解析 “January 32, 2007”时，有的浏览器会将其解释为 “February 1, 2007” 。而 Opera 则倾向于插入当前月份的当前日期，返回 “January 当前日期， 2007” 。也就是说，如果在 2007 年 9 月 21 日运行前面的代码，将会得到 “January 21, 2007” （都是 21 日）。</p>
</blockquote>
<p><strong>Date.UTC() 方法</strong> 同样也返回表示 <strong>日期的毫秒数</strong> ，但它与 Date.parse() 在构建值时使用不同的信息。 Date.UTC() 的参数分别是 <strong>年份</strong> 、<strong>基于 0 的月份</strong>（一月是 0，二月是 1，以此类推）、<strong>月中的哪一天</strong>（1 到 31）、小时数（0 到 23）、<strong>分钟</strong> 、<strong>秒</strong> 以及 <strong>毫秒数</strong> 。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。以下是两个使用 Date.UTC() 方法的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GMT 时间 2000 年 1 月 1 日午夜零时</span></span><br><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// GMT 时间 2005 年 5 月 5 日下午 5:55:55</span></span><br><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure>
<p>这个例子创建了两个日期对象。第一个对象表示 GMT 时间 2000 年 1 月 1 日午夜零时，传入的值一个是表示年份的 2000，一个是表示月份的 0（即一月份）。因为其他参数是自动填充的（即月中的天数为 1，其他所有参数均为 0），所以结果就是该月第一天的午夜零时。第二个对象表示 GMT 时间 2005 年 5 月 5 日下午 5:55:55，即使日期和时间中只包含 5，也需要传入不一样的参数：月份必须是 4（因为月份是基于 0 的）、小时必须设置为 17（因为小时以 0 到 23 表示），剩下的参数就很直观了。</p>
<p>如同模仿 Date.parse() 一样， Date 构造函数也会模仿 Date.UTC() ，但有一点明显不同：日期和时间都基于本地时区而非 GMT 来创建。不过， <strong>Date 构造函数接收的参数仍然与 Date.UTC() 相同</strong> 。</p>
<p>因此，如果第一个参数是数值， Date 构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。据此，可以将前面的例子重写如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地时间 2000 年 1 月 1 日午夜零时</span></span><br><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地时间 2005 年 5 月 5 日下午 5:55:55</span></span><br><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时区创建的。</p>
<p>ECMAScript 5 添加了 <strong>Data.now() 方法</strong> ，返回表示 <strong>调用这个方法时的日期和时间的毫秒数</strong> 。这个方法简化了使用 Data 对象分析代码的工作。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得开始时间</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得停止时间</span></span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now(),</span><br><span class="line">result = stop – start;</span><br></pre></td></tr></table></figure>
<p>支持 Data.now() 方法的浏览器包括 IE9+、Firefox 3+、Safari 3+、Opera 10.5 和 Chrome。在不支持它的浏览器中，使用+操作符把 Data 对象转换成字符串，也可以达到同样的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得开始时间</span></span><br><span class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"><span class="comment">//取得停止时间</span></span><br><span class="line"><span class="keyword">var</span> stop = +<span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">result = stop - start;</span><br></pre></td></tr></table></figure>
<h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他引用类型一样， Date 类型也重写了 toLocaleString() 、 toString() 和 valueOf() 方法；但这些方法返回的值与其他类型中的方法不同。 Date 类型的 toLocaleString() 方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含 AM 或 PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而 toString() 方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是 0 到 23）表示。下面给出了在不同浏览器中调用<br>toLocaleString() 和 toString() 方法，输出 PST（Pacific Standard Time，太平洋标准时间）时间 2007 年 2 月 1 日午夜零时的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Internet Explorer 8</span><br><span class="line">toLocaleString() — Thursday, February 01, 2007 12:00:00 AM</span><br><span class="line">toString() — Thu Feb 1 00:00:00 PST 2007</span><br><span class="line"></span><br><span class="line">Firefox 3.5</span><br><span class="line">toLocaleString() — Thursday, February 01, 2007 12:00:00 AM</span><br><span class="line">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)</span><br><span class="line"></span><br><span class="line">Safari 4</span><br><span class="line">toLocaleString() — Thursday, February 01, 2007 00:00:00</span><br><span class="line">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)</span><br><span class="line"></span><br><span class="line">Chrome 4</span><br><span class="line">toLocaleString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)</span><br><span class="line">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)</span><br><span class="line"></span><br><span class="line">Opera 10</span><br><span class="line">toLocaleString() — 2/1/2007 12:00:00 AM</span><br><span class="line">toString() — Thu, 01 Feb 2007 00:00:00 GMT-0800</span><br><span class="line">​`</span><br></pre></td></tr></table></figure>
<p>显然，这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，<br>toLocaleString() 和 toString() 的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。</p>
<p>至于 Date 类型的 <strong>valueOf() 方法</strong> ，则根本不返回字符串，而是返回 <strong>日期的毫秒</strong> 表示。因此，<strong>可以方便使用比较操作符（小于或大于）来比较日期值</strong> 。请看下面的例子。</p>
<p>​<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2007</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//"January 1, 2007"</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2007</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">//"February 1, 2007"</span></span><br><span class="line"></span><br><span class="line">alert(date1 &lt; date2); <span class="comment">//true</span></span><br><span class="line">alert(date1 &gt; date2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>从逻辑上讲，2007 年 1 月 1 日要早于 2007 年 2 月 1 日，此时如果我们说前者小于后者比较符合常理。而表示 2007 年 1 月 1 日的毫秒值小于表示 2007 年 2 月 1日的毫秒值，因此在首先使用小于操作符比较日期时，返回的结果是 true 。这样，就为我们比较日期提供了极大方便。</p>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><p>Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。</p>
<ul>
<li>toDateString() ——以特定于实现的格式显示星期几、月、日和年；</li>
<li>toTimeString() ——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString() ——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString() ——以特定于实现的格式完整的 UTC 日期。</li>
</ul>
<p>与 toLocaleString() 和 toString() 方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</p>
<blockquote>
<p>除了前面介绍的方法之外，还有一个名叫 toGMTString() 的方法，这是一个与toUTCString() 等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript 推荐现在编写的代码一律使用 toUTCString() 方法。</p>
</blockquote>
<h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><p>到目前为止，剩下还未介绍的 Date 类型的方法（如下表所示），都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC 日期指的是在没有时区偏差的情况下（将日期转换为 GMT 时间）的日期值。</p>
<p><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E6%97%A5%E6%9C%9F%E5%80%BC.png" alt="日期值"></p>
<p><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E6%97%A5%E6%9C%9F%E5%80%BC%EF%BC%88%E7%BB%AD%EF%BC%89.png" alt="日期值（续）"></p>
<h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><p>ECMAScript 通过 RegExp 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正则表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure>
<p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含 <strong>字符类</strong> 、 <strong>限定符</strong> 、<strong>分组</strong> <strong>、</strong>向前查找<strong> 以及 </strong>反向引用** 。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。</p>
<p>正则表达式的匹配模式支持下列 3 个标志。</p>
<ul>
<li>g ：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
<li>i ：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m ：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li>
</ul>
<p>因此，一个正则表达式就是一个模式与上述 3 个标志的组合体。<strong>不同组合产生不同结果</strong> ，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配字符串中所有"at"的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>与其他语言中的正则表达式类似，模式中使用的 <strong>所有元字符都必须转义</strong> 。正则表达式中的元字符包括：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ? * + .]&#125;</span><br></pre></td></tr></table></figure>
<p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。下面给出几个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配第一个" [bc]at"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配所有".at"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中， pattern1 匹配第一个 “bat” 或 “cat” ，不区分大小写。而要想直接匹配 “[bc]at” 的话，就需要像定义 pattern2 一样，对其中的两个方括号进行转义。对于 pattern3 来说，句点表示位于 “at” 之前的任意一个可以构成匹配项的字符。但如果想匹配 “.at” ，则必须对句点本身进行转义，如 pattern4 所示。</p>
<p>前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用 <strong>RegExp 构造函数</strong> ，它接收两个参数：一个是要 <strong>匹配的字符串模式</strong>  ，另一个是可选的 <strong>标志字符串</strong> 。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 与 pattern1 相同，只不过是使用构造函数创建的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure>
<p>在此， pattern1 和 pattern2 是两个完全等价的正则表达式。要注意的是，传递给 RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给 RegExp 构造函数）。由于 RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如 \n （字符\在字符串中通常被转义为\，而在正则表达式字符串中就会变成\\）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用 RegExp 构造函数定义相同模式时使用的字符串。</p>
<p><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="相同模式时使用的字符串"></p>
<p>使用正则表达式字面量和使用 RegExp 构造函数创建的正则表达式不一样。在 ECMAScript 3 中，<strong>正则表达式字面量始终会共享同一个 RegExp 实例</strong> ，而使用 <strong>构造函数创建的每一个新 RegExp 实例都是一个新实例</strong> 。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="literal">null</span>,</span><br><span class="line">   i;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  re = <span class="regexp">/cat/g</span>;</span><br><span class="line">  re.test(<span class="string">"catastrophe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>, <span class="string">"g"</span>);</span><br><span class="line">  re.test(<span class="string">"catastrophe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个循环中，即使是循环体中指定的，但实际上只为 /cat/ 创建了一个 RegExp 实例。由于实例属性（下一节介绍实例属性）不会重置，所以在循环中再次调用 test() 方法会失败。这是因为第一次调用 test() 找到了 “cat” ，但第二次调用是从索引为 3 的字符（上一次匹配的末尾）开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用 test() 就又从开头开始了。</p>
<p>第二个循环使用 RegExp 构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的 RegExp 实例，所以每次调用 test() 都会返回 true 。</p>
<p>ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用 RegExp 构造函数一样，每次都创建新的 RegExp 实例。IE9+、Firefox 4+和 Chrome 都据此做出了修改。</p>
<h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3><p>RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li>global ：布尔值，表示是否设置了 g 标志。</li>
<li>ignoreCase ：布尔值，表示是否设置了 i 标志。</li>
<li>lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。</li>
<li>multiline ：布尔值，表示是否设置了 m 标志。</li>
<li>source ：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul>
<p>通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"></span><br><span class="line">alert(pattern1.global); <span class="comment">//false</span></span><br><span class="line">alert(pattern1.ignoreCase); <span class="comment">//true</span></span><br><span class="line">alert(pattern1.multiline); <span class="comment">//false</span></span><br><span class="line">alert(pattern1.lastIndex); <span class="comment">//0</span></span><br><span class="line">alert(pattern1.source); <span class="comment">//"\[bc\]at"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);</span><br><span class="line"></span><br><span class="line">alert(pattern2.global); <span class="comment">//false</span></span><br><span class="line">alert(pattern2.ignoreCase); <span class="comment">//true</span></span><br><span class="line">alert(pattern2.multiline); <span class="comment">//false</span></span><br><span class="line">alert(pattern2.lastIndex); <span class="comment">//0</span></span><br><span class="line">alert(pattern2.source); <span class="comment">//"\[bc\]at"</span></span><br></pre></td></tr></table></figure>
<p>我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了 RegExp 构造函数，但它们的 source 属性是相同的。可见， source 属性保存的是规范形式的字符串，即 <strong>字面量形式所用的字符串</strong> 。</p>
<h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><p>RegExp 对象的主要方法是 <strong>exec()</strong> ，该方法是专门为 <strong>捕获组</strong> 而设计的。 exec() 接受一个参数，即要应用 <strong>模式的字符串</strong> ，然后返回 <strong>包含第一个匹配项信息的数组</strong> ；或者在 <strong>没有匹配项的情况下返回 null</strong>  。返回的数组虽然是 Array 的实例，但包含两个额外的属性： <strong>index</strong> 和 <strong>input</strong> 。其中， index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">// 0</span></span><br><span class="line">alert(matches.input); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的模式包含两个捕获组。最内部的捕获组匹配 “and baby” ，而包含它的捕获组匹配 “and dad” 或者 “and dad and baby” 。当把字符串传入 exec() 方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组 matchs 的 index 属性值为 0。数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。</p>
<p>对于 exec() 方法而言，即使在模式中设置了全局标志（ g ），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新匹配项，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern1.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">matches = pattern1.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern2.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//cat</span></span><br><span class="line">alert(pattern2.lastIndex); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">matches = pattern2.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">//5</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//bat</span></span><br><span class="line">alert(pattern2.lastIndex); <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的第一个模式 pattern1 不是全局模式，因此每次调用 exec() 返回的都是第一个匹配项（ “cat” ）。而第二个模式 pattern2 是全局模式，因此每次调用 exec() 都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的 lastIndex 属性的变化情况。在全局匹配模式下， lastIndex 的值在每次调用 exec() 后都会增加，而在非全局模式下则始终保持不变。</p>
<blockquote>
<p>IE 的 JavaScript 实现在 lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex 属性每次也会变化。</p>
</blockquote>
<p>正则表达式的第二个方法是 <strong>test()</strong> ，它接受一个字符串参数。<strong>在模式与该参数匹配的情况下返回 true</strong> ；否则，<strong>返回 false</strong> 。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此， <strong>test() 方法经常被用在 if 语句中</strong> ，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">  alert(<span class="string">"The pattern was matched."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为什么无效就无关紧要了。</p>
<p>RegExp 实例继承的 toLocaleString() 和 toString() 方法都会返回 <strong>正则表达式的字面量</strong> ，与创建正则表达式的方式无关。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"gi"</span>);</span><br><span class="line">alert(pattern.toString()); <span class="comment">// /\[bc\]at/gi</span></span><br><span class="line">alert(pattern.toLocaleString()); <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure>
<p>即使上例中的模式是通过调用 RegExp 构造函数创建的，但 toLocaleString() 和 toString()方法仍然会像它是以字面量形式创建的一样显示其字符串表示。</p>
<blockquote>
<p>正则表达式的 valueOf() 方法返回正则表达式本身。</p>
</blockquote>
<h3 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h3><p>RegExp 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名（Opera 是例外，它不支持短属性名）。下表列出了 RegExp 构造函数的属性。</p>
<p><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/RegExp%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="RegExp 构造函数的属性"></p>
<p>使用这些属性可以从 exec() 或 test() 执行的操作中提取出更具体的信息。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</span></span><br><span class="line"><span class="comment">* Internet Explorer 不支持 multiline 属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">  alert(<span class="built_in">RegExp</span>.input); <span class="comment">// this has been a short summer</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// this has been a</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// short</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>.lastParen); <span class="comment">// s</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>.multiline); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个模式，匹配任何一个字符后跟 hort ，而且把第一个字符放在了一个捕获组中。RegExp 构造函数的各个属性返回了下列值：</p>
<ul>
<li>input 属性返回了原始字符串；</li>
<li>leftContext 属性返回了单词 short 之前的字符串，而 rightContext 属性则返回了 short之后的字符串；</li>
<li>lastMatch 属性返回最近一次与整个正则表达式匹配的字符串，即 short ；</li>
<li>lastParen 属性返回最近一次匹配的捕获组，即例子中的 s 。</li>
</ul>
<p>如前所述，例子使用的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都不是有效的 ECMAScript 标识符，因此必须通过 <strong>方括号语法</strong> 来访问它们，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</span></span><br><span class="line"><span class="comment">* Internet Explorer 不支持 multiline 属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">  alert(<span class="built_in">RegExp</span>.$_); <span class="comment">// this has been a short summer</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]); <span class="comment">// this has been a</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]); <span class="comment">// summer</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]); <span class="comment">// short</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]); <span class="comment">// s</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语法是 RegExp.$1 、 RegExp.$2 … RegExp.$9 ，分别用于存储第一、第二……第九个匹配的捕获组。在调用 exec() 或 test() 方法时，这些属性会被自动填充。然后，我们就可以像下面这样来使用它们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">  alert(<span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">//sh</span></span><br><span class="line">  alert(<span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">//t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个包含两个捕获组的模式，并用该模式测试了一个字符串。即使 test() 方法只返回一个布尔值，但 RegExp 构造函数的属性 $1 和 $2 也会被匹配相应捕获组的字符串自动填充。</p>
<h3 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h3><p>尽管 ECMAScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是 Perl）所支持的高级正则表达式特性。下面列出了 ECMAScript 正则表达式不支持的特性（要了解更多相关信息，请访问 <a href="http://www.regular-expressions.info" target="_blank" rel="noopener">www.regular-expressions.info</a> ）。</p>
<ul>
<li>匹配字符串开始和结尾的 \A 和 \Z 锚（但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。）</li>
<li>向后查找（lookbehind）（但完全支持向前查找（lookahead）。）</li>
<li>并集和交集类</li>
<li>原子组（atomic grouping）</li>
<li>Unicode 支持（单个字符除外，如 \uFFFF ）</li>
<li>命名的捕获组（但支持编号的捕获组。）</li>
<li>s （single，单行）和 x （free-spacing，无间隔）匹配模式</li>
<li>条件匹配</li>
<li>正则表达式注释</li>
</ul>
<p>即使存在这些限制，ECMAScript 正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹配任务。</p>
<h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>说起来 ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于<strong>函数</strong> 实际上是 <strong>对象</strong> 。<strong>每个函数都是 Function 类型的实例</strong> ，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此 <strong>函数名</strong> 实际上也是一个<strong>指向函数对象的指针</strong> ，不会与某个函数绑定。函数通常是使用 <strong>函数声明</strong> 语法定义的，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与下面使用 <strong>函数表达式</strong> 定义函数的方式几乎相差无几。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码定义了变量 sum 并将其初始化为一个函数。有读者可能会注意到，<strong>function 关键字后面没有函数名</strong> 。这是因为在使用函数表达式定义函数时，没有必要使用函数名——<strong>通过变量 sum 即可以引用函数</strong> 。另外，还要注意 <strong>函数末尾有一个分号</strong> ，就像 <strong>声明其他变量时一样</strong> 。</p>
<p>最后一种定义函数的方式是使用 <strong>Function 构造函数</strong> 。 Function 构造函数可以接收 <strong>任意数量的参数</strong> ，但 <strong>最后一个参数始终都被看成是函数体</strong> ，而 <strong>前面的参数则枚举出了新函数的参数</strong> 。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>
<p>从技术角度讲，这是一个函数表达式。但是，我们 <strong>不推荐</strong> 读者使用这种方法定义函数，因为这种语法会 <strong>导致解析两次代码</strong>（第一次是解析常规 ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。</p>
<p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，<strong>一个函数可能会有多个名字</strong> ，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherSum = sum;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>以上代码首先定义了一个名为 sum() 的函数，用于求两个值的和。然后，又声明了变量 anotherSum ，并将其设置为与 sum 相等（将 sum 的值赋给 anotherSum ）。注意，使用不带圆括号的函数名是访问函数指针，而非调用函数。此时， anotherSum 和 sum 就都指向了同一个函数，因此 anotherSum() 也可以被调用并返回结果。即使 <strong>将 sum 设置为 null</strong> ，<strong>让它与函数“断绝关系”</strong> ，但仍然可以正常调用 anotherSum() 。</p>
<h3 id="没有重载（深入理解）"><a href="#没有重载（深入理解）" class="headerlink" title="没有重载（深入理解）"></a>没有重载（深入理解）</h3><p>将函数名想象为指针，也有助于理解为什么 ECMAScript 中 <strong>没有函数重载</strong> 的概念。以下是曾在第 3章使用过的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure>
<p>显然，这个例子中声明了两个同名函数，而结果则是 <strong>后面的函数覆盖了前面的函数</strong> 。以上代码实际上与下面的代码没有什么区别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure>
<p>通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——<strong>在创建第二个函数时</strong> ，<strong>实际上覆盖了引用第一个函数的变量 addSomeNumber </strong> 。</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率 <strong>先读取函数声明</strong> ，并 <strong>使其在执行任何代码之前可用</strong>（可以访问）；至于 <strong>函数表达式</strong> ，则 <strong>必须等到解析器执行到它所在的代码行</strong>，<strong>才会真正被解释执行</strong> 。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为 <strong>函数声明提升</strong>（function declaration hoisting）的过程，<strong>读取并将函数声明添加到执行环境中</strong> 。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到 <strong>源代码树的顶部</strong> 。所以，<strong>即使声明函数的代码在调用它的代码后面</strong> ，<strong>JavaScript 引擎也能把函数声明提升到顶部</strong> 。如果像下面例子所示的，把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(10,10));</span><br><span class="line">var sum = function(num1, num2)&#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，<strong>在执行到函数所在的语句之前</strong> ，<strong>变量 sum 中不会保存有对函数的引用</strong> ；而且，由于 <strong>第一行代码就会导致“unexpected identifier”（意外标识符）错误</strong> ，实际上也不会执行到下一行。</p>
<p>除了 <strong>什么时候可以通过变量访问函数</strong> 这一点区别之外，函数声明与函数表达式的语法其实是等价的。</p>
<blockquote>
<p>也可以同时使用函数声明和函数表达式，例如 var sum = function sum(){} 。不过，这种语法在 Safari 中会导致错误。</p>
</blockquote>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>因为 ECMAScript 中的函数名本身就是变量，所以 <strong>函数也可以作为值来使用</strong> 。也就是说，不仅 <strong>可以像传递参数一样把一个函数传递给另一个函数</strong> ，而且 <strong>可以将一个函数作为另一个函数的结果返回</strong> 。来看一看下面的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</span><br><span class="line">alert(result1); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">"Nicholas"</span>);</span><br><span class="line">alert(result2); <span class="comment">//"Hello, Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>这里的 callSomeFunction() 函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给 callSomeFunction() 的是 add10 和 getGreeting ，而不是执行它们之后的结果。</p>
<p>当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 sort() 方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个 return 操作符。在内部函数接收到 propertyName 参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;];</span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</span><br><span class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</span><br><span class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Zachary</span></span><br></pre></td></tr></table></figure>
<p>这里，我们创建了一个包含两个对象的数组 data 。其中，每个对象都包含一个 name 属性和一个 age 属性。在默认情况下， sort() 方法会调用每个对象的 toString() 方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用 createComparisonFunction(“name”) 方法创建了一个比较函数，以便按照每个对象的 name 属性值进行排序。而结果排在前面的第一项是 name为 “Nicholas” ， age 是 29 的对象。然后，我们又使用了 createComparisonFunction(“age”) 返回的比较函数，这次是按照对象的 age 属性排序。得到的结果是 name 值为 “Zachary” ， age 值是 28的<br>对象排在了第一位。</p>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>在函数内部，有两个特殊的对象： <strong>arguments</strong> 和 <strong>this</strong> 。其中， arguments 在第 3 章曾经介绍过，它是一个 <strong>类数组对象</strong> ，<strong>包含着传入函数中的所有参数</strong> 。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 <strong>callee 的属性</strong> ，该属性是一个指针，<strong>指向拥有这个 arguments 对象的函数</strong> 。请看下面这个非常经典的阶乘函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了 <strong>消除这种紧密耦合的现象</strong>  ，可以像下面这样使用 <strong>arguments.callee</strong> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个重写后的 factorial() 函数的函数体内，<strong>没有再引用函数名 factorial</strong> 。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueFactorial = factorial;</span><br><span class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">//120</span></span><br><span class="line">alert(factorial(<span class="number">5</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>在此，变量 trueFactorial 获得了 factorial 的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回 0 的函数赋值给 factorial 变量。如果像原来的 factorial()那样不使用 arguments.callee ，调用 trueFactorial() 就会返回 0。可是，在解除了函数体内的代码与函数名的耦合状态之后， trueFactorial() 仍然能够正常地计算阶乘；至于 factorial() ，它现在只是一个返回 0 的函数。</p>
<p>函数内部的另一个特殊对象是 this ，其行为与 Java 和 C#中的 this 大致类似。换句话说， <strong>this</strong> 引用的是 <strong>函数据以执行的环境对象</strong> ——或者也可以说是 this 值（当在网页的  <strong>全局作用域中调用函数</strong> 时，<strong>this 对象引用的就是 window</strong> ）。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">//"red"</span></span><br><span class="line"></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数 sayColor() 是在全局作用域中定义的，它引用了 this 对象。由于 <strong>在调用函数之前</strong> ，<strong>this 的值并不确定</strong> ，因此 this 可能会在代码执行过程中引用不同的对象。当 <strong>在全局作用域中调用 sayColor()</strong> 时， <strong>this 引用的是全局对象 window</strong> ；换句话说，<strong>对 this.color 求值会转换成对 window.color 求值</strong> ，于是结果就返回了 “red” 。而当 <strong>把这个函数赋给对象 o 并调用 o.sayColor()
</strong> 时， <strong>this 引用的是对象 o</strong> ，因此对 this.color 求值会转换成对 o.color 求值，结果就返回了 “blue” 。</p>
<blockquote>
<p>请读者一定要牢记，<strong>函数的名字</strong> 仅仅是 <strong>一个包含指针的变量而已</strong> 。因此，<strong>即使是在不同的环境中执行</strong>，<strong>全局的 sayColor() 函数与 o.sayColor() 指向的仍然是同一个函数</strong> 。</p>
</blockquote>
<p>ECMAScript 5 也规范化了另一个函数对象的属性： <strong>caller</strong> 。除了 Opera 的早期版本不支持，其他浏览器都支持这个 ECMAScript 3 并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是 <strong>在全局作用域中调用当前函数</strong> ，它的 <strong>值为 null</strong> 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>以上代码会导致警告框中显示 outer() 函数的源代码。因为 outer() 调用了 inter() ，所以 inner.caller 就指向 outer() 。为了实现更松散的耦合，也 <strong>可以通过 arguments.callee.caller 来访问相同的信息</strong> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>IE、Firefox、Chrome 和 Safari 的所有版本以及 Opera 9.6 都支持 caller 属性。<br>当函数在严格模式下运行时，访问 arguments.callee 会导致错误。ECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined 。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。</p>
<p>严格模式还有一个限制：<strong>不能为函数的 caller 属性赋值</strong> ，<strong>否则会导致错误</strong>。</p>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>前面曾经提到过，ECMAScript 中的 <strong>函数是对象</strong> ，因此 <strong>函数也有属性和方法</strong> 。每个函数都包含两个属性： <strong>length</strong> 和 <strong>prototype</strong> 。其中， <strong>length 属性</strong> 表示 <strong>函数希望接收的命名参数的个数</strong> ，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  alert(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(sayName.length); <span class="comment">//1</span></span><br><span class="line">alert(sum.length); <span class="comment">//2</span></span><br><span class="line">alert(sayHi.length); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>以上代码定义了 3 个函数，但每个函数接收的命名参数个数不同。首先， sayName() 函数定义了一个参数，因此其 length 属性的值为 1。类似地， sum() 函数定义了两个参数，结果其 length 属性中保存的值为 2。而 sayHi() 没有命名参数，所以其 length 值为 0。</p>
<p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <strong>prototype 属性</strong> 了。对于 ECMAScript 中的引用类型而言， <strong>prototype 是保存它们所有实例方法的真正所在</strong> 。换句话说，<strong>诸如 toString() 和 valueOf() 等方法实际上都保存在 prototype 名下</strong> ，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时， prototype 属性的作用是极为重要的（第 6 章将详细介绍）。在 ECMAScript 5 中， prototype 属性是不可枚举的，因此使用 for-in 无法发现。</p>
<p>每个函数都包含两个非继承而来的方法： <strong>apply()</strong> 和 <strong>call()</strong> 。这两个方法的用途都是 <strong>在特定的作用域中调用函数</strong> ，实际上等于 <strong>设置函数体内 this 对象的值</strong> 。首先，<strong> apply() 方法</strong> 接收两个参数：一个是 <strong>在其中运行函数的作用域</strong> ，另一个是 <strong>参数数组</strong> 。其中，第二个参数可以是 <strong>Array 的实例</strong> ，也可以是 <strong>arguments 对象</strong> 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入 arguments 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中， callSum1() 在执行 sum() 函数时传入了 this 作为 this 值（因为是在全局作用域中调用的，所以传入的就是 window 对象）和 arguments 对象。而 callSum2 同样也调用了 sum() 函数，但它传入的则是 this 和一个参数数组。这两个函数都会正常执行并返回正确的结果。</p>
<blockquote>
<p>在 <strong>严格模式</strong> 下，<strong>未指定环境对象而调用函数，则 this 值不会转型为 window</strong> 。除非明确把函数添加到某个对象或者调用 apply() 或 call() ，否则 this 值将是 undefined 。</p>
</blockquote>
<p><strong>call() 方法</strong> 与 apply() 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是 <strong>this 值没有变化</strong> ，变化的是 <strong>其余参数都直接传递给函数</strong>  。换句话说，在使用 call() 方法时，<strong>传递给函数的参数必须逐个列举出来</strong> ，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在使用 call() 方法的情况下， callSum() 必须明确地传入每一个参数。结果与使用 apply() 没有什么不同。至于是使用 apply() 还是 call() ，完全取决于你采取哪种给函数传递参数的方式最方便。</p>
<p>如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply()肯定更方便；否则，选择 call() 可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）</p>
<p>事实上，<strong>传递参数</strong> 并非 apply() 和 call() 真正的用武之地；它们真正强大的地方是 <strong>能够扩充函数赖以运行的作用域</strong> 。下面来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">//red</span></span><br><span class="line"></span><br><span class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(o); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>这个例子是在前面说明 this 对象的示例基础上修改而成的。这一次， sayColor() 也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示 “red” ——因为对 this.color 的求值会转换成对 window.color 的求值。而 sayColor.call(this) 和 sayColor.call(window) ，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示 “red” 。但是，当运行 sayColor.call(o) 时，函数的执行环境就不一样了，因为此时函数体内的 this 对象指向了 o ，于是结果显示的是 “blue” 。</p>
<p>使用 call() （或 apply() ）来扩充作用域的最大好处，就是 <strong>对象不需要与方法有任何耦合关系</strong> 。</p>
<p>在前面例子的第一个版本中，我们是先将 sayColor() 函数放到了对象 o 中，然后再通过 o 来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。</p>
<p>ECMAScript 5 还定义了一个方法： <strong>bind()</strong> 。这个方法会 <strong>创建一个函数的实例</strong> ，其 <strong>this 值会被绑定到传给 bind() 函数的值</strong> 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>在这里， sayColor() 调用 bind() 并传入对象 o ，<strong>创建了 o bjectSayColor() 函数</strong> 。 <strong>objectSayColor() 函数的 this 值等于 o</strong> ，因此 <strong>即使是在全局作用域中调用这个函数</strong> ，也会看到 “blue” 。这种技巧的优点请参考第 22 章。</p>
<p>支持 bind() 方法的浏览器有 IE9+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome。</p>
<p>每个函数继承的 toLocaleString() 和 toString() 方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf() 方法同样也只返回函数代码。</p>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型： <strong>Boolean</strong> 、 <strong>Number</strong> 和 <strong>String</strong> 。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。</p>
<p>实际上，<strong>每当读取一个基本类型值的时候</strong> ，后台就会 <strong>创建一个对应的基本包装类型的对象</strong> ，从而让我们 <strong>能够调用一些方法来操作这些数据</strong> 。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的 <strong>substring() 方法</strong> ，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>
<p>(1) 创建 String 类型的一个实例；<br>(2) 在实例上调用指定的方法；<br>(3) 销毁这个实例。</p>
<p>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。</p>
<p><strong>引用类型</strong> 与 <strong>基本包装类型</strong> 的主要区别就是 <strong>对象的生存期</strong> 。<strong>使用 new 操作符创建的引用类型的实例</strong> 在 <strong>执行流离开当前作用域之前都一直保存在内存中</strong> 。而 <strong>自动创建的基本包装类型的对象</strong> ，则 <strong>只存在于一行代码的执行瞬间</strong> ，然后 <strong>立即被销毁</strong> 。这意味着我们 <strong>不能在运行时为基本类型值添加属性和方法</strong> 。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line">s1.color = <span class="string">"red"</span>;</span><br><span class="line">alert(s1.color); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>在此，第二行代码试图为字符串 s1 添加一个 color 属性。但是，当第三行代码再次访问 s1 时，其 color 属性不见了。问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。</p>
<p>第三行代码又创建自己的 String 对象，而该对象没有 color 属性。</p>
<p>当然，<strong>可以显式地调用 Boolean 、 Number 和 String 来创建基本包装类型的对象</strong> 。不过，应该 <strong>在绝对必要的情况下再这样做</strong> ，因为 <strong>这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值</strong> 。对 <strong>基本包装类型的实例</strong> 调用 <strong>typeof 会返回 “object”</strong> ，而且 <strong>所有基本包装类型的对象都会被转换为布尔值 true</strong> 。</p>
<p>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到 Number 的实例，传入布尔值参数就会得到 Boolean 的实例。</p>
<p>要注意的是，使用 <strong>new 调用基本包装类型的构造函数</strong> ，与直接 <strong>调用同名的转型函数</strong> 是不一样的。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> number); <span class="comment">//"number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<strong>变量 number 中保存的是基本类型的值 25</strong> ，而 <strong>变量 obj 中保存的是 Number 的实例</strong> 。要了解有关转型函数的更多信息，请参考第 3 章。</p>
<p>尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。</p>
<h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>Boolean 类型是与布尔值对应的引用类型。要创建 Boolean 对象，可以像下面这样调用 Boolean 构造函数并传入 true 或 false 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> booleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>Boolean 类型的实例重写了 <strong>valueOf() 方法</strong> ，返回 <strong>基本类型值 true 或 false</strong> ；重写了 <strong>toString() 方法</strong>  ，<strong>返回字符串 “true” 和 “false”</strong> 。可是， Boolean 对象在 ECMAScript 中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;</span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用 false 值创建了一个 Boolean 对象。然后，将这个对象与基本类型值 true 构成了逻辑与表达式。在布尔运算中， false &amp;&amp; true 等于 false 。可是，示例中的这行代码是对 falseObject 而不是对它的值（ false ）进行求值。前面讨论过，布尔表达式中的所有对象都会被转换为 true ，因此 falseObject 对象在布尔表达式中代表的是 true 。结果， true &amp;&amp; true 当然就等于 true 了。</p>
<p>基本类型与引用类型的布尔值还有两个区别。首先，<strong>typeof 操作符对基本类型返回 “boolean” ，而对引用类型返回 “object”</strong> 。其次，由于 Boolean 对象是 Boolean 类型的实例，所以 <strong>使用 instanceof 操作符测试 Boolean 对象会返回 true ，而测试基本类型的布尔值则返回 false</strong> 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> falseObject); <span class="comment">//object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> falseValue); <span class="comment">//boolean</span></span><br><span class="line">alert(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line">alert(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>理解基本类型的布尔值与 Boolean 对象之间的区别非常重要——当然，我们的建议是 <strong>永远不要使用 Boolean 对象</strong> 。</p>
<h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 <strong>Number 构造函数时向其中传递相应的数值</strong> 。下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>与 Boolean 类型一样， Number 类型也重写了 valueOf() 、 toLocaleString() 和 toString() 方法。重写后的 <strong>valueOf() 方法</strong> 返回 <strong>对象表示的基本类型的数值</strong> ，另外两个方法则返回 <strong>字符串形式的数值</strong> 。我们在第 3 章还介绍过，<strong>可以为 toString() 方法传递一个表示基数的参数</strong> ，告诉它返回几进制数值的字符串形式，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toString()); <span class="comment">//"10"</span></span><br><span class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">//"1010"</span></span><br><span class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">//"12"</span></span><br><span class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">//"10"</span></span><br><span class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">//"a"</span></span><br></pre></td></tr></table></figure>
<p>除了继承的方法之外， Number 类型还提供了一些用于将数值格式化为字符串的方法。<br>其中， <strong>toFixed() 方法</strong> 会 <strong>按照指定的小数位返回数值的字符串表示</strong> ，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toFixed(<span class="number">2</span>)); <span class="comment">//"10.00"</span></span><br></pre></td></tr></table></figure>
<p>这里给 toFixed() 方法传入了数值 2 ，意思是显示几位小数。于是，这个方法返回了 “10.00” ，即以 0 填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.005</span>;</span><br><span class="line">alert(num.toFixed(<span class="number">2</span>)); <span class="comment">//"10.01"</span></span><br></pre></td></tr></table></figure>
<p>能够自动舍入的特性，使得 <strong>toFixed() 方法很适合处理货币值</strong> 。但需要注意的是，不<strong>同浏览器给这个方法设定的舍入规则可能会有所不同</strong> 。在给 toFixed() 传入 0 的情况下，IE8 及之前版本不能正确舍入范围在{(-0.94,-0.5],[ 0.5,0.94)}之间的值。对于这个范围内的值，IE 会返回 0，而不是-1 或 1；其他浏览器都能返回正确的值。IE9 修复了这个问题。</p>
<blockquote>
<p>toFixed() 方法可以表示带有 0 到 20 个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数。</p>
</blockquote>
<p>另外可用于格式化数值的方法是 <strong>toExponential()</strong> ，该方法返回 <strong>以指数表示法</strong>（也称 e 表示法）表示的数值的字符串形式。与 toFixed() 一样， toExponential() 也接收一个参数，而且该参数同样也是 <strong>指定输出结果中的小数位数</strong> 。看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toExponential(<span class="number">1</span>)); <span class="comment">//"1.0e+1"</span></span><br></pre></td></tr></table></figure>
<p>以上代码输出了 “1.0e+1” ；不过，这么小的数值一般不必使用 e 表示法。如果你想得到表示 <strong>某个数值的最合适的格式</strong> ，就应该使用 <strong>toPrecision() 方法</strong> 。</p>
<p>对于一个数值来说， <strong>toPrecision() 方法</strong> 可能会返回 <strong>固定大小（fixed）格式</strong> ，也可能返回 <strong>指数（exponential）格式</strong> ；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示 <strong>数值的所有数字的位数</strong>（不包括指数部分）。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</span><br><span class="line">alert(num.toPrecision(<span class="number">1</span>)); <span class="comment">//"1e+2"</span></span><br><span class="line">alert(num.toPrecision(<span class="number">2</span>)); <span class="comment">//"99"</span></span><br><span class="line">alert(num.toPrecision(<span class="number">3</span>)); <span class="comment">//"99.0"</span></span><br></pre></td></tr></table></figure>
<p>以上代码首先完成的任务是以一位数来表示 99，结果是 “1e+2” ，即 100。因为一位数无法准确地表示 99，因此 toPrecision() 就将它向上舍入为 100，这样就可以使用一位数来表示它了。而接下来的用两位数表示 99，当然还是 “99” 。最后，在想以三位数表示 99时， toPrecision() 方法返回了 “99.0” 。</p>
<p>实际上， toPrecision() 会根据要处理的数值决定到底是调用 toFixed() 还是调用 toExponential() 。而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。</p>
<blockquote>
<p>toPrecision() 方法可以表现 1 到 21 位小数。某些浏览器支持的范围更大，但这是典型实现的范围。</p>
</blockquote>
<p>与 Boolean 对象类似， Number 对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化 Number 类型，而原因与显式创建 Boolean 对象一样。具体来讲，就是在 <strong>使用 typeof 和 instanceof 操作符测试基本类型数值与引用类型数值</strong> 时，<strong>得到的结果完全不同</strong> ，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> numberValue = <span class="number">10</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> numberObject); <span class="comment">//"object"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> numberValue); <span class="comment">//"number"</span></span><br><span class="line">alert(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line">alert(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>在使用 typeof 操作符测试基本类型数值时，始终会返回 “number” ，而在测试 Number 对象时，则会返回 “object” 。类似地， Number 对象是 Number 类型的实例，而基本类型的数值则不是。</p>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf() 、 toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。</p>
<p>String 类型的每个实例都有一个 <strong>length 属性</strong> ，表示 <strong>字符串中包含多个字符</strong> 。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.length); <span class="comment">//"11"</span></span><br></pre></td></tr></table></figure>
<p>这个例子输出了字符串 “hello world” 中的字符数量，即 “11” 。应该注意的是，即使<strong>字符串中包含双字节字符</strong>（不是占一个字节的 ASCII 字符），<strong>每个字符也仍然算一个字符</strong> 。</p>
<p>String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。</p>
<ul>
<li><h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4><p>两个用于 <strong>访问字符串中特定字符</strong> 的方法是： <strong>charAt()</strong> 和 <strong>charCodeAt()</strong> 。这两个方法都接收一个参数，即 <strong>基于 0 的字符位置</strong> 。其中， <strong>charAt() 方法</strong> 以 <strong>单字符字符串</strong> 的形式返回 <strong>给定位置的那个字符</strong>（ECMAScript 中没有字符类型）。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.charAt(<span class="number">1</span>)); <span class="comment">//"e"</span></span><br></pre></td></tr></table></figure>
<p>字符串 “hello world” 位置 1 处的字符是 “e” ，因此调用 charAt(1) 就返回了 “e” 。如果你想得到的不是字符而是 <strong>字符编码</strong> ，那么就要像下面这样使用 <strong>charCodeAt()</strong> 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.charCodeAt(<span class="number">1</span>)); <span class="comment">// 输出"101"</span></span><br></pre></td></tr></table></figure>
<p>这个例子输出的是 “101” ，也就是小写字母 “e” 的字符编码。</p>
<p>ECMAScript 5 还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用<strong>方括号加数字索引</strong> 来 <strong>访问字符串中的特定字符</strong>，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue[<span class="number">1</span>]); <span class="comment">//"e"</span></span><br></pre></td></tr></table></figure>
<p>使用方括号表示法访问个别字符的语法得到了 IE8 及 Firefox、Safari、Chrome 和 Opera 所有版本的支持。如果是在 IE7 及更早版本中使用这种语法，会返回 undefined 值（尽管根本不是特殊的 undefined 值）。</p>
</li>
<li><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><p>下面介绍与操作字符串有关的几个方法。第一个就是 <strong>concat()</strong> ，用于 <strong>将一或多个字符串拼接起来</strong> ，返回 <strong>拼接得到的新字符串</strong> 。先来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>);</span><br><span class="line">alert(result); <span class="comment">//"hello world"</span></span><br><span class="line">alert(stringValue); <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过 stringValue 调用 concat() 方法返回的结果是 “hello world” ——但 stringValue 的值则保持不变。实际上， <strong>concat() 方法</strong> 可以接受 <strong>任意多个参数</strong> ，也就是说可以通过它 <strong>拼接任意多个字符串</strong> 。再看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</span><br><span class="line">alert(result); <span class="comment">//"hello world!"</span></span><br><span class="line">alert(stringValue); <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure>
<p>这个例子将 “world” 和 “!” 拼接到了 “hello” 的末尾。虽然 concat() 是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符（+）。而且，<strong>使用加号操作符在大多数情况下都比使用 concat()方法要简便易行</strong>（特别是在拼接多个字符串的情况下）。</p>
<p>ECMAScript还提供了三个 <strong>基于子字符串创建新字符串</strong> 的方法： <strong>slice()</strong> 、 <strong>substr()</strong> 和 <strong>substring()</strong> 。这三个方法都会返回 <strong>被操作字符串的一个子字符串</strong> ，而且也都接受一或两个参数。第一个参数指定 <strong>子字符串的开始位置</strong> ，第二个参数（在指定的情况下）表示 <strong>子字符串到哪里结束</strong> 。具体来说， slice() 和 substring() 的第二个参数指定的是 <strong>子字符串最后一个字符后面的位置</strong> 。而 substr() 的第二个参数指定的则是返回的 <strong>字符个数</strong> 。如果 <strong>没有给这些方法传递第二个参数</strong> ，则 <strong>将字符串的长度作为结束位置</strong> 。与 concat() 方法一样， slice() 、 substr() 和 substring() 也 <strong>不会修改字符串本身的值</strong> ——它们只是<br>返回 <strong>一个基本类型的字符串值，对原始字符串没有任何影响</strong> 。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">//"lo worl"</span></span><br></pre></td></tr></table></figure>
<p>这个例子比较了以相同方式调用 slice() 、 substr() 和 substring() 得到的结果，而且多数情况下的结果是相同的。在只指定一个参数 3 的情况下，这三个方法都返回 “lo world” ，因为 “hello”中的第二个 “l” 处于位置 3。而在指定两个参数 3 和 7 的情况下， slice() 和 substring() 返回 “lo w”（ “world” 中的 “o” 处于位置 7，因此结果中不包含 “o” ），但 substr() 返回 “lo worl” ，因为它的第二个参数指定的是要返回的字符个数。</p>
<p>在传递给这些方法的参数是 <strong>负值</strong> 的情况下，它们的行为就不尽相同了。其中， <strong>slice() 方法</strong> 会将 <strong>传入的负值与字符串的长度相加</strong> ， <strong>substr() 方法</strong> 将 <strong>负的第一个参数加上字符串的长度</strong> ，而将 <strong>负的第二个参数转换为 0</strong> 。最后， <strong>substring() 方法</strong> 会把 <strong>所有负值参数都转换为 0</strong> 。下面来看例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.slice(<span class="number">-3</span>)); <span class="comment">//"rld"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">-3</span>)); <span class="comment">//"hello world"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">-3</span>)); <span class="comment">//"rld"</span></span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"hel"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"" （空字符串）</span></span><br></pre></td></tr></table></figure>
<p>这个例子清晰地展示了上述三个方法之间的不同行为。在给 slice() 和 substr() 传递一个负值参数时，它们的行为相同。这是因为 -3 会被转换为 8 （字符串长度加参数 11+(-3)=8），实际上相当于调用了 slice(8) 和 substr(8) 。但 substring() 方法则返回了全部字符串，因为它将 -3 转换成了 0 。</p>
<blockquote>
<p>IE 的 JavaScript 实现在处理向 substr() 方法传递负值的情况时存在问题，它会<br>返回原始的字符串。IE9 修复了这个问题。</p>
</blockquote>
<p>当第二个参数是负值时，这三个方法的行为各不相同。 slice() 方法会把第二个参数转换为 7，这就相当于调用了 slice(3,7) ，因此返回 “lo w” 。 substring() 方法会把第二个参数转换为 0，使调用变成了 substring(3,0) ，而由于这个方法会将较小的数作为开始位置，将较大的数作为结束位置，因此最终相当于调用了 substring(0,3) 。substr() 也会将第二个参数转换为 0，这也就意味着返回包含零个字符的字符串，也就是一个空字符串。</p>
</li>
<li><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><p>有两个可以从字符串中查找子字符串的方法： <strong>indexOf()</strong> 和 <strong>lastIndexOf()</strong> 。这两个方法都是 <strong>从一个字符串中搜索给定的子字符串</strong> ，然后 <strong>返子字符串的位置</strong>（如果没有找到该子字符串，则返回 -1 ）。</p>
<p>这两个方法的区别在于： <strong>indexOf() 方法从字符串的开头向后搜索子字符串</strong> ，而 <strong>lastIndexOf() 方法是从字符串的末尾向前搜索子字符串</strong> 。还是来看一个例子吧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.indexOf(<span class="string">"o"</span>)); <span class="comment">//4</span></span><br><span class="line">alert(stringValue.lastIndexOf(<span class="string">"o"</span>)); <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<p>子字符串 “o” 第一次出现的位置是 4，即 “hello” 中的 “o” ；最后一次出现的位置是 7，即 “world” 中的”o” 。如果 “o” 在这个字符串中仅出现了一次，那么 indexOf() 和 lastIndexOf() 会返回相同的位置值。</p>
<p>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf() 会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而 lastIndexOf() 则会从指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.indexOf(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">//7</span></span><br><span class="line">alert(stringValue.lastIndexOf(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>在将第二个参数 6 传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于 indexOf() 是从位置 6（字母 “w” ）开始向后搜索，结果在位置 7 找到了 “o” ，因此它返回 7。而 lastIndexOf() 是从位置 6 开始向前搜索。结果找到了 “hello” 中的 “o” ，因此它返回 4。在使用第二个参数的情况下，<strong>可以通过循环调用 indexOf() 或 lastIndexOf() 来找到所有匹配的子字符串</strong> ，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"Lorem ipsum dolor sit amet, consectetur adipisicing elit"</span>;</span><br><span class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> pos = stringValue.indexOf(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(pos &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">  positions.push(pos);</span><br><span class="line">  pos = stringValue.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(positions); <span class="comment">//"3,24,32,35,52"</span></span><br></pre></td></tr></table></figure>
<p>这个例子通过不断增加 indexOf() 方法开始查找的位置，遍历了一个长字符串。在循环之外，首先找到了 “e” 在字符串中的初始位置；而进入循环后，则每次都给 indexOf() 传递上一次的位置加 1。</p>
<p>这样，就确保了 <strong>每次新搜索都从上一次找到的子字符串的后面开始</strong> 。每次搜索返回的位置依次被保存在数组 positions 中，以便将来使用。</p>
</li>
<li><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h4><p>ECMAScript 5 为所有字符串定义了 <strong>trim() 方法</strong> 。这个方法会 <strong>创建一个字符串的副本</strong> ，<strong>删除前置及后缀的所有空格</strong> ，然后 <strong>返回结果</strong> 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">" hello world "</span>;</span><br><span class="line"><span class="keyword">var</span> trimmedStringValue = stringValue.trim();</span><br><span class="line">alert(stringValue); <span class="comment">//" hello world "</span></span><br><span class="line">alert(trimmedStringValue); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
<p>由于 trim() 返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个方法的浏览器有 IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和 Chrome。此外，Firefox 3.5+、Safari 5+和 Chrome 8+还支持非标准的 <strong>trimLeft()</strong> 和 <strong>trimRight()</strong> 方法，分别 <strong>用于删除字符串开头和末尾的空格</strong> 。</p>
</li>
<li><h4 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h4><p>接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript 中涉及字符串大小写转换的方法有 4 个： <strong>toLowerCase()</strong> 、 <strong>toLocaleLowerCase()</strong> 、 <strong>toUpperCase()</strong> 和 <strong>toLocaleUpperCase()</strong> 。</p>
<p>其中， toLowerCase() 和 toUpperCase() 是两个经典的方法，借鉴自 java.lang.String 中的同名方法。而 <strong>toLocaleLowerCase()</strong> 和 <strong>toLocaleUpperCase()</strong> 方法则是 <strong>针对特定地区的实现</strong> 。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.toLocaleUpperCase()); <span class="comment">//"HELLO WORLD"</span></span><br><span class="line">alert(stringValue.toUpperCase()); <span class="comment">//"HELLO WORLD"</span></span><br><span class="line">alert(stringValue.toLocaleLowerCase()); <span class="comment">//"hello world"</span></span><br><span class="line">alert(stringValue.toLowerCase()); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
<p>以上代码调用的 toLocaleUpperCase() 和 toUpperCase() 都返回了 “HELLO WORLD” ，就像调用 toLocaleLowerCase() 和 toLowerCase() 都返回 “hello world” 一样。一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。</p>
</li>
<li><h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4><p>String 类型定义了几个用于 <strong>在字符串中匹配模式</strong> 的方法。第一个方法就是 <strong>match()</strong> ，在字符串上调用这个方法，本质上 <strong>与调用 RegExp 的 exec() 方法相同</strong> 。 <strong>match() 方法</strong> 只接受一个参数，要么是一个 <strong>正则表达式</strong> ，要么是 一个 <strong>RegExp 对象</strong> 。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与 pattern.exec(text)相同</span></span><br><span class="line"><span class="keyword">var</span> matches = text.match(pattern);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//"cat"</span></span><br><span class="line">alert(pattern.lastIndex); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>本例中的 match() 方法返回了一个数组；如果是调用 RegExp 对象的 exec() 方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组：<strong>数组的第一项是与整个模式匹配的字符串</strong> ，<strong>之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串</strong> 。</p>
<p>另一个用于查找模式的方法是 <strong>search()</strong> 。这个方法的唯一参数与 match() 方法的参数相同：由字符串或 RegExp 对象指定的一个 <strong>正则表达式</strong> 。 <strong>search() 方法返回字符串中第一个匹配项的索引</strong> ；如果 <strong>没有找到匹配项</strong> ，则 <strong>返回 -1</strong> 。而且， search() 方法始终是 <strong>从字符串开头向后查找模式</strong> 。看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line">alert(pos); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的 search() 方法返回 1 ，即 “at” 在字符串中第一次出现的位置。</p>
<p>为了简化 <strong>替换子字符串</strong> 的操作，ECMAScript 提供了 <strong>replace() 方法</strong> 。这个方法接受两个参数：第一个参数可以是一个 <strong>RegExp 对象</strong> 或者 <strong>一个字符串</strong>（这个字符串不会被转换成正则表达式），第二个参数可以是一个 <strong>字符串</strong> 或者一个 <strong>函数</strong> 。如果第一个参数是字符串，那么只会替换第一个子字符串。<strong>要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（ g ）标志</strong> ，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>);</span><br><span class="line">alert(result); <span class="comment">//"cond, bat, sat, fat"</span></span><br><span class="line"></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>);</span><br><span class="line">alert(result); <span class="comment">//"cond, bond, sond, fond"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，首先传入 replace() 方法的是字符串 “at” 和替换用的字符串 “ond” 。替换的结果是把 “cat” 变成了 “cond” ，但字符串中的其他字符并没有受到影响。然后，通过将第一个参数修改为带有全局标志的正则表达式，就将全部 “at” 都替换成了 “ond” 。</p>
<p>如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，<strong>将正则表达式操作得到的值插入到结果字符串中</strong> 。下表列出了 ECMAScript 提供的这些特殊的字符序列。</p>
<p><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97.png" alt="特殊的字符序列"></p>
<p>通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($1)"</span>);</span><br><span class="line">alert(result); <span class="comment">//word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure>
<p>在此，每个以 “at” 结尾的单词都被替换了，替换结果是 “word” 后跟一对圆括号，而圆括号中是被字符序列 $1 所替换的单词。</p>
<p>replace() 方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace() 方法的第二个参数可以实现更加精细的替换操作，请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(match)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&lt;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&gt;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&amp;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"\""</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;quot;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">alert(htmlEscape(<span class="string">"&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"</span>));</span><br><span class="line"><span class="comment">//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</span></span><br></pre></td></tr></table></figure>
<p>这里，我们为插入 HTML 代码定义了函数 htmlEscape() ，这个函数能够转义 4 个字符：小于号、大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定义一个能够针对每个匹配的字符返回特定 HTML 实体的函数。</p>
<p>最后一个与模式匹配有关的方法是 <strong>split()</strong> ，这个方法可以 <strong>基于指定的分隔符将一个字符串分割成多个子字符串</strong> ，并 <strong>将结果放在一个数组中</strong> 。分隔符可以是 <strong>字符串</strong>，也可以是一个 <strong>RegExp 对象</strong>（这个方法不会将字符串看成正则表达式）。 split() 方法可以接受可选的第二个参数，用于 <strong>指定数组的大小</strong> ，<strong>以便确保返回的数组不会超过既定大小</strong> 。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</span><br><span class="line"><span class="keyword">var</span> colors1 = colorText.split(<span class="string">","</span>); <span class="comment">//["red", "blue", "green", "yellow"]</span></span><br><span class="line"><span class="keyword">var</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>); <span class="comment">//["red", "blue"]</span></span><br><span class="line"><span class="keyword">var</span> colors3 = colorText.split(<span class="regexp">/[^\,]+/</span>); <span class="comment">//["", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中， colorText 是逗号分隔的颜色名字符串。基于该字符串调用 split(“,”) 会得到一个包含其中颜色名的数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可以为 split() 方法传递第二个参数 2。最后，通过使用正则表达式，还可以取得包含逗号字符的数组。</p>
<p>需要注意的是，在最后一次调用 split() 返回的数组中，第一项和最后一项是两个空字符串。之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头（即子字符串 “red” ）和末尾（即子字符串 “yellow” ）。</p>
<p>对 split() 中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。</p>
<ul>
<li>IE8 及之前版本会忽略捕获组。ECMA-262 规定应该把捕获组拼接到结果数组中。IE9 能正确地在结果中包含捕获组。</li>
<li>Firefox 3.6 及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262 规定没有匹配项的捕获组在结果数组中应该用 undefined 表示。</li>
</ul>
<p>在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览器下多做一些测试。</p>
<blockquote>
<p>要了解关于 split() 方法以及捕获组的跨浏览器问题的更多讨论，请参考 Steven Levithan 的文章“JavaScript split bugs： Fixed!”（ <a href="http://blog.stevenlevithan.com/archives/cross-browser-split" target="_blank" rel="noopener">http://blog.stevenlevithan.com/archives/cross-browser-split</a> ）。</p>
</blockquote>
</li>
<li><h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h4><p>与操作字符串有关的最后一个方法是 <strong>localeCompare()</strong> ，这个方法 <strong>比较两个字符串</strong> ，并返回下列值中的一个：</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是 -1 ，具体的值要视实现而定）；</li>
<li>如果字符串等于字符串参数，则返回 0 ；</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1 ，具体的值同样要视实现而定）。</li>
</ul>
<p>下面是几个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>;</span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"brick"</span>)); <span class="comment">//1</span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"yellow"</span>)); <span class="comment">//0</span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"zoo"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<p>这个例子比较了字符串 “yellow” 和另外几个值： “brick” 、 “yellow” 和 “zoo” 。因为 “brick” 在字母表中排在 “yellow” 之前，所以 localeCompare() 返回了 1 ；而 “yellow” 等于 “yellow” ，所以 localeCompare() 返回了 0 ；最后， “zoo” 在字母表中排在 “yellow” 后面，所以 localeCompare() 返回了 -1 。再强调一次，因为 localeCompare() 返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineOrder</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = stringValue.localeCompare(value);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    alert(<span class="string">"The string 'yellow' comes before the string '"</span> + value + <span class="string">"'."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    alert(<span class="string">"The string 'yellow' comes after the string '"</span> + value + <span class="string">"'."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"The string 'yellow' is equal to the string '"</span> + value + <span class="string">"'."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">determineOrder(<span class="string">"brick"</span>);</span><br><span class="line">determineOrder(<span class="string">"yellow"</span>);</span><br><span class="line">determineOrder(<span class="string">"zoo"</span>);</span><br></pre></td></tr></table></figure>
<p>使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。</p>
<p>localeCompare() 方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。比如，美国以英语作为 ECMAScript 实现的标准语言，因此 localeCompare() 就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他地区恐怕就不是这种情况了。</p>
</li>
<li><h4 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h4><p>另外， String 构造函数本身还有一个静态方法： <strong>fromCharCode()</strong> 。这个方法的任务是 <strong>接收一或多个字符编码</strong> ，然后 <strong>将它们转换成一个字符串</strong> 。从本质上来看，这个方法 <strong>与实例方法 charCodeAt() 执行的是相反的操作</strong> 。来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们给 fromCharCode() 传递的是字符串 “hello” 中每个字母的字符编码。</p>
</li>
<li><h4 id="HTML-方法"><a href="#HTML-方法" class="headerlink" title="HTML 方法"></a>HTML 方法</h4><p>早期的 Web 浏览器提供商觉察到了使用 JavaScript 动态格式化 HTML 的需求。于是，这些提供商就扩展了标准，实现了一些专门用于简化常见 HTML 格式化任务的方法。下表列出了这些 HTML 方法。不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。</p>
<p><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/HTML%20%E6%96%B9%E6%B3%95.png" alt="HTML 方法"></p>
</li>
</ul>
<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>ECMA-262 对 <strong>内置对象</strong> 的定义是：“ <strong>由 ECMAScript 实现提供的、不依赖于宿主环境的对象</strong> ，这些对象 <strong>在 ECMAScript 程序执行之前就已经存在了</strong> 。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 Object 、 Array 和 String 。ECMA-262 还定义了两个单体内置对象： <strong>Global</strong> 和 <strong>Math</strong> 。</p>
<h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><p>Global （全局）对象可以说是 ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。本书前面介绍过的那些函数，诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ，实际上全都是 Global对象的方法。除此之外， Global 对象还包含其他一些方法。</p>
<ul>
<li><h4 id="URI-编码方法"><a href="#URI-编码方法" class="headerlink" title="URI 编码方法"></a>URI 编码方法</h4><p>Global 对象的 <strong>encodeURI()</strong> 和 <strong>encodeURIComponent()</strong> 方法可以 <strong>对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码</strong> ，<strong>以便发送给浏览器</strong> 。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们 <strong>用特殊的 UTF-8 编码替换所有无效的字符</strong> ，从而让浏览器能够接受和理解。</p>
<p>其中， <strong>encodeURI()</strong> 主要用于 <strong>整个 URI</strong>（例如， <a href="http://www.wrox.com/illegal" target="_blank" rel="noopener">http://www.wrox.com/illegal</a> value.htm ），而 <strong>encodeURIComponent()</strong> 主要用于<strong>对 URI 中的某一段</strong>（例如前面 URI 中的 illegal value.htm ）进行编码。</p>
<p>它们的主要区别在于， <strong>encodeURI() 不会对本身属于 URI 的特殊字符进行编码</strong> ，例如冒号、正斜杠、问号和井字号；而 <strong>encodeURIComponent() 则会对它发现的任何非标准字符进行编码</strong> 。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.htm#start"</span></span><br><span class="line">alert(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"></span><br><span class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span></span><br><span class="line">alert(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
<p>使用 <strong>encodeURI() 编码</strong> 后的结果是除了空格之外的其他字符都原封不动，<strong>只有空格被替换成了 %20</strong> 。而 <strong>encodeURIComponent() 方法</strong> 则会 <strong>使用对应的编码替换所有非字母数字字符</strong> 。这也正是可以对整个 URI使用 encodeURI() ，而只能对附加在现有 URI后面的字符串使用 encodeURIComponent()的原因所在。</p>
<blockquote>
<p>一般来说 ，我们使用 encodeURIComponent() 方法的时候要比使用 encodeURI() 更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。</p>
</blockquote>
<p>与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 <strong>decodeURI() </strong> 和 <strong>decodeURIComponent()</strong> 。其中， <strong>decodeURI() 只能对使用 encodeURI() 替换的字符进行解码</strong> 。例如，它可将 %20 替换成一个空格，但不会对 %23 作任何处理，因为 %23 表示井字号（ # ），而井字号不是使用 encodeURI() 替换的。同样地， <strong>decodeURIComponent() 能够解码使用 encodeURIComponent() 编码的所有字符</strong> ，即 <strong>它可以解码任何特殊字符的编码</strong> 。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start</span></span><br><span class="line">alert(<span class="built_in">decodeURI</span>(uri));</span><br><span class="line"></span><br><span class="line"><span class="comment">//http://www.wrox.com/illegal value.htm#start</span></span><br><span class="line">alert(<span class="built_in">decodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
<p>这里，变量 uri 包含着一个由 encodeURIComponent() 编码的字符串。在第一次调用 decodeURI()输出的结果中，只有 %20 被替换成了空格。而在第二次调用 decodeURIComponent() 输出的结果中，所有特殊字符的编码都被替换成了原来的字符，得到了一个未经转义的字符串（但这个字符串并不是一个有效的 URI）。</p>
<blockquote>
<p>URI 方法 encodeURI() 、 encodeURIComponent() 、 decodeURI() 和 decodeURIComponent() 用于替代已经被ECMA-262第3版废弃的 escape() 和 unescape()方法。URI方法能够编码所有 Unicode字符，而原来的方法只能正确地编码 ASCII字符。因此在开发实践中，特别是在产品级的代码中，一定要使用URI方法，不要使用 escape()和 unescape() 方法。</p>
</blockquote>
</li>
<li><h4 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval() 方法"></a>eval() 方法</h4><blockquote>
<p>整个 ECMAScript 语言中 <strong>最强大的一个方法</strong> ： <strong>eval()</strong> 。</p>
</blockquote>
<p>eval() 方法就像一个完整的 <strong>ECMAScript 解析器</strong> ，它只接受一个参数，即要 <strong>执行的 ECMAScript（或 JavaScript）字符串</strong> 。看下面的例子：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"alert('hi')"</span>);</span><br></pre></td></tr></table></figure>
<p> 这行代码的作用等价于下面这行代码：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"hi"</span>);</span><br></pre></td></tr></table></figure>
 <!-- more -->
<p> 当解析器发现代码中调用 eval() 方法时，它会 <strong>将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置</strong> 。 <strong>通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链</strong> 。这意味着 <strong>通过 eval() 执行代码可以引用在包含环境中定义的变量</strong> ，举个例子：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"alert(msg)"</span>); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
<p> 可见，变量 msg 是在 eval() 调用环境之外定义的，但其调用的 alert() 仍然能够显示 “hello world”。 这是因为上面的第二行代码最终被替换成了一行真正的代码。同样地，我们 <strong>可以在 eval() 调用中定义一个函数，然后在调用的外部代码中引用这个函数</strong> ：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"function sayHIi() &#123; alert ('hi'); &#125;"</span>);</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>
<p> 显然，函数 sayHi() 是在 eval() 内部定义的。但由于对 eval() 的调用最终会被替换成定义的实际代码，因此可以在下一行调用 sayHi()。<strong>对于变量也一样</strong> ：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"var msg =  'hello world'"</span>);</span><br><span class="line">alert(msg);</span><br></pre></td></tr></table></figure>
<p> 在 eval() 中创建的 <strong>变量或函数都不会被提升</strong> ，因为在解析代码的时候，他们被包含在一个字符串中；它们 <strong>只在 eval() 执行的时候创建</strong> 。</p>
<p><strong>严格模式</strong> 下，<strong>在外部访问不到 eval() 中创建的任何变量或函数</strong> ，因此前面两个例子都会导致错误。同样，<strong>严格模式</strong> 下，<strong>为 eval 赋值也会导致错误</strong> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line">evval = <span class="string">"hi"</span>; <span class="comment">//causes error</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>能够解释代码字符串的能力非常强大，但也非常危险</strong> 。因此在使用 eval() 时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序的安全的代码（即所谓的 <strong>代码注入</strong> ）。</p>
</blockquote>
</li>
<li><h4 id="Global-对象属性"><a href="#Global-对象属性" class="headerlink" title="Global 对象属性"></a>Global 对象属性</h4><p>下表列出了 Global 对象的所有属性。</p>
<p><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-typeGlobal%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7.png" alt="Global 对象的所有属性"></p>
<!-- | 属性           | 说明                    |
| -------------- | ----------------------- |
| undefined      | 特殊值 undefined        |
| NaN            | 特殊值 NaN              |
| Infinity       | 特殊值 Infinity         |
| Object         | 构造函数 Object         |
| Array          | 构造函数 Array          |
| Function       | 构造函数 Function       |
| Boolean        | 构造函数 Boolean        |
| String         | 构造函数 String         |
| Number         | 构造函数 Number         |
| Date           | 构造函数 Date           |
| RegExp         | 构造函数 RegExp         |
| Error          | 构造函数 Error          |
| EvalError      | 构造函数 EvalError      |
| RangeError     | 构造函数 RangeError     |
| ReferenceError | 构造函数 ReferenceError |
| SyntaxError    | 构造函数 SyntaxError    |
| Type Error     | 构造函数 TypeError      |
| URIError       | 构造函数 URIError       | -->
<p>ECMAScript 5 明确禁止给 undefined 、NaN 和 Infinity 赋值，这样做即使在非严格模式下也会导致错误。</p>
</li>
<li><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><p>ECMAaScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是 <strong>将这个全局对象作为 window 对象的一部分加以实现的</strong> 。因此，在全局作用域中声明的所有变量和函数，就都 <strong>成为了 window 对象的属性</strong> 。来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">window</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.sayColor(); <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 color 的全局变量和一个名为 sayColor() 的全局函数。在 sayColor() 内部我们通过 window.color 来访问 color 变量，以说明全局变量是 window 对象的属性。然后，又使用 window.sayColor() 来直接通过 window 对象调用这个函数，结果显示在了警告框中。</p>
<blockquote>
<p>JavaScript 中的 window 对象除了扮演 ECMAScript 规定的 Global 对象的角色外，还承担的了很多别的任务。</p>
</blockquote>
<p>另一种 <strong>取得 Global 对象的方法</strong> 是使用以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个立即调用的函数表达式，返回 this 的值。如前所述，<strong>在没有给函数明确指定 this 值的情况下</strong> （无论是通过 <strong>将函数添加为对象的方法</strong> ，还是通过 <strong>call()</strong> 或 <strong>apply()</strong> ）, <strong>this 值等于 Global 对象</strong> 。而像这样通过简单的返回 this 来取得 Global 对象，<strong>在任何执行环境下都是可行的</strong> 。</p>
</li>
</ul>
<h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><p>  ECMAScript 还为保存数学公式和信息提供了一个公共位置，即 <strong>Math 对象</strong> 。与我们在 JavaScript 直接编写的计算功能相比， <strong>Math 对象提供的计算功能执行起来要快得多</strong> 。Math 对象中还 <strong>提供了辅助完成这些计算的属性和方法</strong> 。</p>
<ul>
<li><h4 id="Math-对象的属性"><a href="#Math-对象的属性" class="headerlink" title="Math 对象的属性"></a>Math 对象的属性</h4><p>Math 对象包含的 <strong>属性大多数是</strong> 数学计算中可能会用到的一些 <strong>特殊值</strong> 。下表列出了这些属性。</p>
<p><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-typeMath%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC.png" alt="Math 对象的属性"></p>
<!-- | 属性         | 说明                                |
| ------------ | ----------------------------------- |
| Math.E       | 自然对数的底数，即常量 e 的值       |
| Math.LN1.0   | 10 的自然对数                       |
| Math.LN2     | 2 的自然对数                        |
| Math.LOG2E   | 以 2 为底 e 的对数                  |
| Math.LOG10E  | 以 10 为底 e 的对数                 |
| Math.PI      | π 的值                              |
| Math.SQRT1_2 | 1/2 的平方根（即 2 的平方根的倒数） |
| Math.SQRT2   | 2 的平方根                          | -->
</li>
</ul>
<ul>
<li><h4 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min() 和 max() 方法"></a>min() 和 max() 方法</h4><p>  min() 和 max() 方法 <strong>用于确定一组数值中的最小值和最大值</strong> 。这两个方法都可以 <strong>接受任意多个数值参数</strong> ，如下面的例子所示。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line">alert(max); <span class="comment">//54</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line">alert(min); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>  对于 3、34、32 和 16， Math.max() 返回 54， 而 Math.min() 返回 3。 这两个方法经常被用于避免多余的循环和在 if 语句中确定一组数的最大值。</p>
<p>  <strong>要找到数值中的最大或最小值</strong> ，可以像下面这样使用 apply() 方法。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class="line">var max = Math.max.apply(Math, values);</span><br></pre></td></tr></table></figure>
<p>  这个技巧的关键是把 <strong>Math 对象</strong> 作为 <strong>apply() 的第一个参数</strong> ，从而 <strong>正确地设置 this 值</strong> 。然后，可以将 <strong>任何数值</strong> 作为 <strong>第二个参数</strong>。</p>
</li>
<li><h4 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h4><p>下面将介绍  <strong>将小数值舍入为整数</strong> 的几个方法： <strong>Math.ceil()</strong> 、 <strong>Math.floor()</strong> 和 <strong>Math.round()</strong> 。这三个方法分别遵循下列舍入规则：</p>
<ul>
<li><p>Math.ceil() 执行 <strong>向上舍入</strong>  ，即它总是 <strong>将数值向上舍入为最接近的整数</strong> 。</p>
</li>
<li><p>Math.floor() 执行 <strong>向下舍入</strong>，即它总是 <strong>将数值向下舍入为最接近的整数</strong> 。</p>
</li>
<li><p>Math.round() 执行 <strong>标准舍入</strong> ，即它总是 <strong>将数值四舍五入为最接近的整数</strong> （这也是我我们在数学课上学到的舍入规则）。</p>
</li>
</ul>
<p>下面是使用这些方法的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Math</span>.ceil(<span class="number">25.9</span>));  <span class="comment">//26</span></span><br><span class="line">alert(<span class="built_in">Math</span>.ceil(<span class="number">25.5</span>));  <span class="comment">//26</span></span><br><span class="line">alert(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>));  <span class="comment">//26</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Math</span>.round(<span class="number">25.9</span>)); <span class="comment">//26</span></span><br><span class="line">alert(<span class="built_in">Math</span>.round(<span class="number">25.5</span>)); <span class="comment">//26</span></span><br><span class="line">alert(<span class="built_in">Math</span>.round(<span class="number">25.1</span>)); <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>)); <span class="comment">//25</span></span><br><span class="line">alert(<span class="built_in">Math</span>.floor(<span class="number">25.5</span>)); <span class="comment">//25</span></span><br><span class="line">alert(<span class="built_in">Math</span>.floor(<span class="number">25.1</span>)); <span class="comment">//25</span></span><br></pre></td></tr></table></figure>
<p>对于介于 25 和 26 之间的数值， Math.ceil() 始终返回 26，因为它执行的是向上舍入。Math.round() 方法只在大于等于 25.5 时返回 26；否则返回 25。最后， Math.floor() 对介于25 和 26 之间的数值都返回 25。</p>
</li>
<li><h4 id="random-方法"><a href="#random-方法" class="headerlink" title="random() 方法"></a>random() 方法</h4><p>Math.random() 方法 <strong>返回大于等于 0 小于 1 的一个随机数</strong> 。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示名人名言和新闻事件。套用下面的公式，就 <strong>可以利用 Math.random() 从某个整数范围内随机选择一个值</strong> 。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</span><br></pre></td></tr></table></figure>
<p>公式中用到了 Math.floor() 方法，这是因为 Math.random() 总是返回一个小数值。而用这个小数值乘以一个整数，然后在加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想 <strong>选择一个 1 到 10 之间的数值</strong> ，可以像下面这样编写代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>总共 10 个可能的值（1 到 10）， 而第一个可能的值是 1.如果想要选择一个介于 2 到 10 之间的值，就应该将上面的代码改成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">9</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>从 2 数到 10 要数 9 个数，因此可能值的总数就是 9，而第一个可能的值就是 2.多数情况下，其实都 <strong>可以通过一个函数来计算可能的总数和第一个可能的值</strong> ，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> choices = upperValue - lowerValue + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = selectFrom(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">alert(num); <span class="comment">//介于 2 和 10 之间（包括 2 和 10）的一个数值</span></span><br></pre></td></tr></table></figure>
<p>函数 seclectFrom() 接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加上 1 得到了可能的总数，然后它又把这些数值套用到了前面的公式中。这样，通过调用 selectFrom(2, 10) 就可以得到一个介于 2 和 10 之间（包括 2 和 10）的数值了。利用这个函数，可以方便 <strong>从数值中随机取出一项</strong> ，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"purple"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">var</span> color = colors[selectFrom(<span class="number">0</span>, colors.length - <span class="number">1</span>)];</span><br><span class="line">alert(color); <span class="comment">//可能是数组中包含的任何一个字符串</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，传递给 selectFrom() 的第二个参数是数组的长度减 1，也就是数组中最后一项的位置。</p>
</li>
<li><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>下面我们给出一个表格，其中列出了这些没有介绍到的 Math 对象的方法。<br><img src="https://graphbed.qiniu.songxingguo.com/JavaScript-reference-type/Math%20%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.png" alt=" Math 对象的方法"></p>
<!-- | 方法                 | 说明                    |
| -------------------- | ----------------------- |
| Math.abs(num)        | 返回 num 的绝对值       |
| Math.exp(num)        | 返回 Math.E 的 num 次幂 |
| Math.log(num)        | 返回 num 的自然对数     |
| Math.pow(num, power) | 返回 num 的 power 次幂  |
| Math.sqrt(num)       | 返回 num 的平方根       |
| Math.acos(x)         | 返回 x 的反余弦值       |
| Math.asin(x)         | 返回 x 的反正弦值       |
| Math.atan(x)         | 返回 x 的反正切值       |
| Math.atan2(y, x)     | 返回 y/x 的反正切值     |
| Math.cos(x)          | 返回 x  的余弦值        |
| Math.sin(x)          | 返回 x 的正弦值         |
| Math.tan(x)          | 返回 x 的正切值         | -->
<p>虽然 ECMA-262 规定了这些方法，但不同实现可能会对方法采用不同的算法。毕竟，计算某个值的正弦、余弦和正切的方式多种多样。也正是因为如此，<strong>这些方法在不同的实现中可能会有不同的精度</strong> 。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>  <strong>对象</strong> 在 JavaScript 中被称为 <strong>引用类型的值</strong> ，而且 <strong>有一些内置的引用类型可以用来创建特定的对象</strong> ，现简要总结如下：</p>
<ul>
<li><p>引用类型与传统面向对象程序设计中的类 <strong>相似</strong> ，但 <strong>实现不同</strong> ；</p>
</li>
<li><p>Object 是一个基础类型，其他 <strong>所有类型都从 Object 继承了基本的行为</strong> ；</p>
</li>
<li><p>Array 类型是 <strong>一组值的有序列表</strong> ，同时提供了 <strong>操作</strong> 和 转换这些值的功能** ；</p>
</li>
<li><p>Date 类型提供了有关 <strong>日期</strong> 和 <strong>时间</strong> 信息，包括 <strong>当前日期和时间</strong> 以及 <strong>相关的计算功能</strong> ；</p>
</li>
<li><p>RegExp 类型是 <strong>ECMAScript 支持正则表达式的一个接口</strong> ，提供了 <strong>最基本的和一些高级的正则表达式功能</strong> ；</p>
</li>
</ul>
<p>函数实际上是 Function 类型的实例，因此 <strong>函数也是对象</strong> ；而这一点正是 JavaScript 最有特色的地方。由于函数是对象，所以 <strong>函数也拥有方法</strong> ，<strong>可以用来增强其行为</strong> 。</p>
<p>因为有了 <strong>基本包装类型</strong> ，所以 JavaScript 中 <strong>基本类型值可以被当作对象来访问</strong> 。三种基本包装类型分别是： <strong>Boolean</strong> 、 <strong>Number</strong> 和 <strong>String</strong> 。以下是它们共同的特征：</p>
<ul>
<li><p>每个包装类型都映射到 <strong>同名的基本类型</strong> ；</p>
</li>
<li><p>在 <strong>读取模式</strong> 下访问 <strong>基本类型值</strong> 时，就 <strong>会创建对应的基本包装类型的一个对象</strong> ，从而方便了数据操作；</p>
</li>
<li><p>操作基本数据类型值的语句一经执行完毕，就会 <strong>立即销毁新创建的包装对象</strong> 。</p>
</li>
</ul>
<p>在 <strong>所有代码执行之前</strong> ，作用域中已经存在两个内置对象：<strong>Global</strong> 和 <strong>Math</strong> 。在大多数 ECMAScript 实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 <strong>Window 对象</strong> 。<strong>全局变量和函数</strong> 都是 <strong>Global 对象属性</strong> 。Math 对象提供了很多属性和方法，用来完成复杂的数学计算任务。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/13/web-front-end-interview-jQuery/" rel="next" title="Web前端面试题目及详解汇总 -jQuery部分">
                <i class="fa fa-chevron-left"></i> Web前端面试题目及详解汇总 -jQuery部分
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/14/jQuery/" rel="prev" title="jQuery教程">
                jQuery教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.ico" alt="songxingguo">
            
              <p class="site-author-name" itemprop="name">songxingguo</p>
              <p class="site-description motion-element" itemprop="description">< 写文章 && 做分享 /></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">131</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/songxingguo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i></a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引用类型"><span class="nav-number">1.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-类型"><span class="nav-number">1.1.</span> <span class="nav-text">Object 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-类型"><span class="nav-number">1.2.</span> <span class="nav-text">Array 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检测数组"><span class="nav-number">1.2.1.</span> <span class="nav-text">检测数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换方法"><span class="nav-number">1.2.2.</span> <span class="nav-text">转换方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈方法"><span class="nav-number">1.2.3.</span> <span class="nav-text">栈方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列方法"><span class="nav-number">1.2.4.</span> <span class="nav-text">队列方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重排序方法"><span class="nav-number">1.2.5.</span> <span class="nav-text">重排序方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作方法"><span class="nav-number">1.2.6.</span> <span class="nav-text">操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位置方法"><span class="nav-number">1.2.7.</span> <span class="nav-text">位置方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代方法"><span class="nav-number">1.2.8.</span> <span class="nav-text">迭代方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并方法"><span class="nav-number">1.2.9.</span> <span class="nav-text">归并方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date-类型"><span class="nav-number">1.3.</span> <span class="nav-text">Date 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承的方法"><span class="nav-number">1.3.1.</span> <span class="nav-text">继承的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期格式化方法"><span class="nav-number">1.3.2.</span> <span class="nav-text">日期格式化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期-时间组件方法"><span class="nav-number">1.3.3.</span> <span class="nav-text">日期/时间组件方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RegExp-类型"><span class="nav-number">1.4.</span> <span class="nav-text">RegExp 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp-实例属性"><span class="nav-number">1.4.1.</span> <span class="nav-text">RegExp 实例属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp-实例方法"><span class="nav-number">1.4.2.</span> <span class="nav-text">RegExp 实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp-构造函数属性"><span class="nav-number">1.4.3.</span> <span class="nav-text">RegExp 构造函数属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式的局限性"><span class="nav-number">1.4.4.</span> <span class="nav-text">模式的局限性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function-类型"><span class="nav-number">1.5.</span> <span class="nav-text">Function 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#没有重载（深入理解）"><span class="nav-number">1.5.1.</span> <span class="nav-text">没有重载（深入理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明与函数表达式"><span class="nav-number">1.5.2.</span> <span class="nav-text">函数声明与函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为值的函数"><span class="nav-number">1.5.3.</span> <span class="nav-text">作为值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数内部属性"><span class="nav-number">1.5.4.</span> <span class="nav-text">函数内部属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数属性和方法"><span class="nav-number">1.5.5.</span> <span class="nav-text">函数属性和方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本包装类型"><span class="nav-number">1.6.</span> <span class="nav-text">基本包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Boolean-类型"><span class="nav-number">1.6.1.</span> <span class="nav-text">Boolean 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-类型"><span class="nav-number">1.6.2.</span> <span class="nav-text">Number 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-类型"><span class="nav-number">1.6.3.</span> <span class="nav-text">String 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符方法"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">字符方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串操作方法"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">字符串操作方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串位置方法"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">字符串位置方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trim-方法"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">trim() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串大小写转换方法"><span class="nav-number">1.6.3.5.</span> <span class="nav-text">字符串大小写转换方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的模式匹配方法"><span class="nav-number">1.6.3.6.</span> <span class="nav-text">字符串的模式匹配方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#localeCompare-方法"><span class="nav-number">1.6.3.7.</span> <span class="nav-text">localeCompare() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fromCharCode-方法"><span class="nav-number">1.6.3.8.</span> <span class="nav-text">fromCharCode() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTML-方法"><span class="nav-number">1.6.3.9.</span> <span class="nav-text">HTML 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单体内置对象"><span class="nav-number">1.7.</span> <span class="nav-text">单体内置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Global-对象"><span class="nav-number">1.7.1.</span> <span class="nav-text">Global 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URI-编码方法"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">URI 编码方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eval-方法"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">eval() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Global-对象属性"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">Global 对象属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#window-对象"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">window 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-对象"><span class="nav-number">1.7.2.</span> <span class="nav-text">Math 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-对象的属性"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">Math 对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#min-和-max-方法"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">min() 和 max() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#舍入方法"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">舍入方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#random-方法"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">random() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他方法"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">其他方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">1.8.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">songxingguo</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '5KNE77KGRoBwz0eTtPxWksTj-gzGzoHsz',
        appKey: '2oU4tvtGWAXp5i6kWAnhd2rm',
        placeholder: 'Just go go',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: true
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":90,"vOffset":-25},"mobile":{"show":true},"react":{"opacityDefault":1,"opacityOnHover":0.2},"log":false});</script></body>
</html>

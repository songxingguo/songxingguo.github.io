<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#34495e">
  <title>koa学习笔记 | 阿有的博客</title>
  <link rel="alternate" href="path/of/rss" type="application/atom+xml">
  <link rel="shortcut icon" type="image/ico" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  

  

  

  

</head>

<body>
  <div class="mobile-header">
    <span><i class="iconfont icon-turnon" id="mobile-nav-toggle"></i></span>
    <div class="mobile-logo">
      <a href="/.">SongXingguo‘s blog</a>
    </div>
  </div>
  <div class="page" id="mobile-nav-panel">
    <div class="container">
      <header class="site-nav">
      <div class="nav-content">
        <div class="logo">
          <a href="/">SongXingguo‘s blog</a>
        </div>
        <nav class="navbar">
          <ul>
            
              <li class="menu-item">
                <a href="/" class="menu-item-link"><i class="iconfont icon-home"></i>首页</a>
              </li>
            
              <li class="menu-item">
                <a href="/archives" class="menu-item-link"><i class="iconfont icon-archive"></i>归档</a>
              </li>
            
              <li class="menu-item">
                <a href="/categories" class="menu-item-link"><i class="iconfont icon-category"></i>分类</a>
              </li>
            
              <li class="menu-item">
                <a href="/tags" class="menu-item-link"><i class="iconfont icon-tags"></i>标签</a>
              </li>
            
              <li class="menu-item">
                <a href="/works" class="menu-item-link"><i class="iconfont icon-works"></i>作品</a>
              </li>
            
              <li class="menu-item">
                <a href="/about" class="menu-item-link"><i class="iconfont icon-about"></i>关于</a>
              </li>
            
          </ul>
        </nav>
      </div>
</header>

      <div class="banner">
  <div class="show">
    <!-- <img src="/" alt="banner"> -->
    <div class="banner-title">
      
        <div class="post-title">
          koa学习笔记
            <div class="post-tags">
    		    
              <a class="tag-link" href="/tags/koa/">koa</a>
            
    	      </div>
        </div>
      
    </div>
  </div>
</div>

      <main class="main"id="main">
          <article class="post">
  

  <header>
    <div class="post-title mobile-post-title">
      <h1>koa学习笔记</h1>
        <div class="post-tags">
        
          <a class="tag-link" href="/tags/koa/">koa</a>
        
        </div>
    </div>
    <div class="post-meta">
      <span class="post-time"><i class="iconfont icon-calendar"></i>2018-06-30</span>
      
          
            <i class="iconfont icon-divide"></i>
            <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
            <a class="post-category" href="/categories/后端技术/">后端技术</a>
          
      
      <!----------------------------------->
        
      <!----------------------------------->
    </div>
  </header>
  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装"><span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Babel-实现-Async-方法"><span class="toc-text">使用 Babel 实现 Async 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用程序"><span class="toc-text">应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#级联"><span class="toc-text">级联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置"><span class="toc-text">设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#app-listen-…"><span class="toc-text">app.listen(…)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#app-callback"><span class="toc-text">app.callback()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#app-use-function"><span class="toc-text">app.use(function)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#app-context"><span class="toc-text">app.context</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#错误处理"><span class="toc-text">错误处理</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>


  <div class="post-content">
    <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>Koa 依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持.</p>
</blockquote>
<p>你可以使用自己喜欢的版本管理器快速安装支持的 node 版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install 7</span><br><span class="line">npm i koa</span><br><span class="line">node app.js</span><br></pre></td></tr></table></figure>
<h3 id="使用-Babel-实现-Async-方法"><a href="#使用-Babel-实现-Async-方法" class="headerlink" title="使用 Babel 实现 Async 方法"></a>使用 Babel 实现 Async 方法</h3><blockquote>
<p>要在 node &lt; 7.6 版本的 Koa 中使用 async 方法, 我们推荐使用 <a href="https://babel.bootcss.com/docs/usage/babel-register/" target="_blank" rel="noopener">babel’s require hook</a>.</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;babel-register&apos;);</span><br><span class="line">// 应用的其余 require 需要被放到 hook 后面</span><br><span class="line">const app = require(&apos;./app&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要解析和编译 async 方法, 你至少应该有 <a href="https://babel.bootcss.com/docs/plugins/transform-async-to-generator/" target="_blank" rel="noopener">transform-async-to-generator</a> 或 <a href="https://babel.bootcss.com/docs/plugins/transform-async-to-module-method/" target="_blank" rel="noopener">transform-async-to-module-method</a> 插件.</p>
</blockquote>
<p>  新建 .babelrc 文件：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-async-to-generator&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  你也可以用 <a href="https://babel.bootcss.com/docs/plugins/preset-env/" target="_blank" rel="noopener">env preset</a> 的 target 参数 “node”: “current” 替代.</p>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><blockquote>
<p>Koa 应用程序是 <strong>一个包含一组中间件函数的对象</strong> ，它是 <strong>按照类似堆栈的方式组织和执行的</strong> 。 Koa 类似于你可能遇到过的许多其他中间件系统，例如 Ruby 的 Rack ，Connect 等，然而，一个关键的设计点是 <strong>在其低级中间件层中提供高级“语法糖”</strong> 。 这提高了 <strong>互操作性</strong> ，<strong>稳健性</strong> ，并使 <strong>书写中间件更加愉快</strong> 。<br>这包括诸如 <strong>内容协商</strong> ，<strong>缓存清理</strong> ，<strong>代理支持</strong> 和 <strong>重定向</strong> 等常见任务的方法。 尽管 <strong>提供了相当多的有用的方法 Koa 仍保持了一个很小的体积</strong> ，因为没有捆绑中间件。</p>
</blockquote>
<p>第一个Koa应用 hello world :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><blockquote>
<p>Koa 中间件以更传统的方式级联，您可能习惯使用类似的工具 - 之前难以让用户友好地使用 node 的回调。然而，使用 async 功能，我们可以实现 “真实” 的中间件。对比 Connect 的实现，通过一系列功能直接传递控制，直到一个返回，Koa 调用“下游”，然后控制流回“上游”。</p>
</blockquote>
<p> 下面以 “Hello World” 的响应作为示例，当请求开始时首先 <strong>请求流</strong> 通过 <strong>x-response-time</strong> 和 <strong>logging</strong>  中间件，然后继续移交控制给 <strong>response 中间件</strong> 。 当一个中间件调用 <strong>next() </strong> 则该函数 <strong>暂停并将控制传递给定义的下一个中间件</strong> 。 当在下游没有更多的中间件执行后，<strong>堆栈将展开并且每个中间件恢复执行其上游行为</strong> 。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">// logger</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  await next();</span><br><span class="line">  const rt = ctx.response.get(&apos;X-Response-Time&apos;);</span><br><span class="line">  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// x-response-time</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  const start = Date.now();</span><br><span class="line">  await next();</span><br><span class="line">  const ms = Date.now() - start;</span><br><span class="line">  ctx.set(&apos;X-Response-Time&apos;, `$&#123;ms&#125;ms`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// response</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>应用程序设置是 app 实例上的属性，目前支持如下：</p>
<p>app.env 默认是 NODE_ENV 或 “development”<br>app.proxy 当真正的代理头字段将被信任时<br>app.subdomainOffset 对于要忽略的 .subdomains 偏移[2]</p>
<h4 id="app-listen-…"><a href="#app-listen-…" class="headerlink" title="app.listen(…)"></a>app.listen(…)</h4><p>Koa 应用程序不是 HTTP 服务器的1对1展现。 可以将一个或多个 Koa 应用程序安装在一起以形成具有单个HTTP服务器的更大应用程序。</p>
<p>创建并返回 HTTP 服务器，将给定的参数传递给 Server#listen()。这些内容都记录在 nodejs.org.</p>
<p>以下是一个无作用的 Koa 应用程序被绑定到 3000 端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<p>这里的 app.listen(…) 方法只是以下方法的语法糖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">http.createServer(app.callback()).listen(3000);</span><br></pre></td></tr></table></figure>
<p>这意味着您可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const https = require(&apos;https&apos;);</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">http.createServer(app.callback()).listen(3000);</span><br><span class="line">https.createServer(app.callback()).listen(3001);</span><br></pre></td></tr></table></figure>
<h4 id="app-callback"><a href="#app-callback" class="headerlink" title="app.callback()"></a>app.callback()</h4><p>返回适用于 http.createServer() 方法的回调函数来处理请求。你也可以使用此回调函数将 koa 应用程序挂载到 Connect/Express 应用程序中。</p>
<h4 id="app-use-function"><a href="#app-use-function" class="headerlink" title="app.use(function)"></a>app.use(function)</h4><p>将给定的中间件方法添加到此应用程序。参阅 <a href="https://github.com/koajs/koa/wiki#middleware" target="_blank" rel="noopener">Middleware</a> 获取更多信息.</p>
<p>app.keys=<br>设置签名的 Cookie 密钥。</p>
<p>这些被传递给 <a href="https://github.com/crypto-utils/keygrip" target="_blank" rel="noopener">KeyGrip</a>，但是你也可以传递你自己的 KeyGrip 实例。</p>
<p>例如，以下是可以接受的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.keys = [&apos;im a newer secret&apos;, &apos;i like turtle&apos;];</span><br><span class="line">app.keys = new KeyGrip([&apos;im a newer secret&apos;, &apos;i like turtle&apos;], &apos;sha256&apos;);</span><br></pre></td></tr></table></figure>
<p>这些密钥可以倒换，并在使用 { signed: true } 参数签名 Cookie 时使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.set(&apos;name&apos;, &apos;tobi&apos;, &#123; signed: true &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="app-context"><a href="#app-context" class="headerlink" title="app.context"></a>app.context</h4><p>app.context 是从其创建 ctx 的原型。您可以通过编辑 app.context 为 ctx 添加其他属性。这对于将 ctx 添加到整个应用程序中使用的属性或方法非常有用，这可能会更加有效（不需要中间件）和/或 更简单（更少的 require()），而更多地依赖于ctx，这可以被认为是一种反模式。</p>
<p>例如，要从 ctx 添加对数据库的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.context.db = db();</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">  console.log(ctx.db);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong><br>ctx 上的许多属性都是使用 getter ，setter 和 Object.defineProperty() 定义的。你只能通过在 app.context 上使用 Object.defineProperty() 来编辑这些属性（不推荐）。查阅  <a href="https://github.com/koajs/koa/issues/652" target="_blank" rel="noopener">https://github.com/koajs/koa/issues/652</a>.<br>安装的应用程序目前使用其父级的 ctx 和设置。 因此，安装的应用程序只是一组中间件。</p>
</blockquote>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，将所有错误输出到 stderr，除非 app.silent 为 true。 当 err.status 是 404 或 err.expose 是 true 时默认错误处理程序也不会输出错误。 要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个 “error” 事件侦听器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class="line">  log.error(&apos;server error&apos;, err)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果 req/res 期间出现错误，并且 _无法_ 响应客户端，Context实例仍然被传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.on(&apos;error&apos;, (err, ctx) =&gt; &#123;</span><br><span class="line">  log.error(&apos;server error&apos;, err, ctx)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当发生错误 _并且_ 仍然可以响应客户端时，也没有数据被写入 socket 中，Koa 将用一个 500 “内部服务器错误” 进行适当的响应。在任一情况下，为了记录目的，都会发出应用级 “错误”。</p>

  </div>
  <div class="post-footer">the end</div>
</article>

          
  <nav class="pagination post-nav">
    
      <a href="/2018/07/01/knex.js-note/">
        <span class="prev-post"><i class="iconfont icon-back"></i>knex.js 学习笔记</span>
      </a>
    
    
      <a href="/2018/06/30/knex.js-query/">
        <span class="next-post">knex.js中文文档-查询<i class="iconfont icon-more"></i></span>
      </a>
    
  </nav>


          
  


      </main>
    </div>
    <footer>
      <div class="social-links">
        
          
            <a href="https://github.com/songxingguo"><i class="iconfont icon-github"></i></a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
      
        <div class="quote">
          <p>专注，极致，快</p>
        </div>
      
      <div class="copyright">
        <p>
          由 <a href="https://hexo.io/">Hexo</a> 强力驱动
          <span>|</span>
          主题 - <a href="https://github.com/wa-ri/hexo-theme-ztopic">ztopic</a>
          <span>|</span>
          Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        <p>
          <span>
          
          &copy;
          
            2018
          
          </span>
          <i class="iconfont icon-circle"></i>
          <span>songxingguo</span>
        </p>
      </div>
</footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <div id="mobile-nav">
  <nav id="mobile-nav-menu">
    
      <a href="/" class="mobile-nav-link"><i class="iconfont icon-home"></i>首页</a>
    
      <a href="/archives" class="mobile-nav-link"><i class="iconfont icon-archive"></i>归档</a>
    
      <a href="/categories" class="mobile-nav-link"><i class="iconfont icon-category"></i>分类</a>
    
      <a href="/tags" class="mobile-nav-link"><i class="iconfont icon-tags"></i>标签</a>
    
      <a href="/works" class="mobile-nav-link"><i class="iconfont icon-works"></i>作品</a>
    
      <a href="/about" class="mobile-nav-link"><i class="iconfont icon-about"></i>关于</a>
    
    <div class="mobile-intro"><i class="iconfont icon-pen"></i>写文章，做分享</div>
  </nav>
</div>


  <script src="/libs/jQuery/jquery-3.2.1.min.js"></script>
  <script src="/libs/slideout/slideout.min.js"></script>
  
    <link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css">
    <script src="/libs/fancybox/jquery.fancybox.pack.js"></script>
  
  

  <script src="/js/ztopic.js"></script>
</body>
</html>

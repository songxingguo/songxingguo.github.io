<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#34495e">
  <title>阿有的博客</title>
  <link rel="alternate" href="path/of/rss" type="application/atom+xml">
  <link rel="shortcut icon" type="image/ico" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  

  

  

  

</head>

<body>
  <div class="mobile-header">
    <span><i class="iconfont icon-turnon" id="mobile-nav-toggle"></i></span>
    <div class="mobile-logo">
      <a href="/.">SongXingguo‘s blog</a>
    </div>
  </div>
  <div class="page" id="mobile-nav-panel">
    <div class="container">
      <header class="site-nav">
      <div class="nav-content">
        <div class="logo">
          <a href="/">SongXingguo‘s blog</a>
        </div>
        <nav class="navbar">
          <ul>
            
              <li class="menu-item">
                <a href="/" class="menu-item-link"><i class="iconfont icon-home"></i>首页</a>
              </li>
            
              <li class="menu-item">
                <a href="/archives" class="menu-item-link"><i class="iconfont icon-archive"></i>归档</a>
              </li>
            
              <li class="menu-item">
                <a href="/categories" class="menu-item-link"><i class="iconfont icon-category"></i>分类</a>
              </li>
            
              <li class="menu-item">
                <a href="/tags" class="menu-item-link"><i class="iconfont icon-tags"></i>标签</a>
              </li>
            
              <li class="menu-item">
                <a href="/works" class="menu-item-link"><i class="iconfont icon-works"></i>作品</a>
              </li>
            
              <li class="menu-item">
                <a href="/about" class="menu-item-link"><i class="iconfont icon-about"></i>关于</a>
              </li>
            
          </ul>
        </nav>
      </div>
</header>

      <div class="banner">
  <div class="show">
    <!-- <img src="/" alt="banner"> -->
    <div class="banner-title">
      
        <div class="intro">
          写文章，做分享
        </div>
      
    </div>
  </div>
</div>

      <main class="main"id="main">
          <section class="posts">
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/27/JavaScript-form-script/">《JavaScript 高级程序设计》学习笔记-表单脚本</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-27</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/27/JavaScript-form-script/"
                   data-title="《JavaScript 高级程序设计》学习笔记-表单脚本">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h1><p>JavaScript 最初的一个应用，就是分担服务器处理表单的责任，打破处处依赖服务器的局面。尽管目前的 Web 和 JavaScript 已经有了长足的发展，但 Web 表单的变化并不明显。由于 Web 表单没有为许多常见任务提供现成的解决手段，很多开发人员不仅会在验证表单时使用 JavaScirpt，而且还增强了一些标准表单控件的默认行为。</p>
          <div id="read-more">
            <a href="/2018/08/27/JavaScript-form-script/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/26/JavaScript-event/">《JavaScript 高级程序设计》学习笔记-事件</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-26</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/26/JavaScript-event/"
                   data-title="《JavaScript 高级程序设计》学习笔记-事件">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>JavaScript 与 HTML 之间的交互是通过事件实现的</strong> 。<strong>事件</strong> ，<strong>就是文档或浏览器窗口中发生的一些特定的交互瞬间</strong> 。<strong>可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码</strong> 。这种在传统软件工程中被称为 <strong>观察员模式的模型</strong> ，<strong>支持页面的行为（JavaScript 代码）与页面的外观（HTML 和 CSS 代码）之间的松散耦合</strong> 。</p>
<p>事件最早是在 IE3 和 Netscape Navigator 2中出现的，当时是作为分担服务器运算负载的一种手段。在 IE4 和 Navigator 4发布时，这两种浏览器都提供了相似但不相同的 API，这些 API 并存经过了好几个主要版本。<strong>DOM2 级规范开始尝试以一种符合逻辑的方式来标准化 DOM 事件</strong> 。IE9、Firefox、Opera、Safari 和 Chrome 全都已经实现了“DOM2 级事件”模块的核心部分。IE8 是最后一个仍然使用其专有事件系统的主要浏览器。</p>
<p><strong>浏览器的事件系统相对比较复杂</strong> 。尽管所有主要浏览器已经实现了“DOM2 级事件”，但这个规范本身并没有涵盖所有事件类型。浏览器对象模型（BOM）也支持一些事件，这些事件与文档对象模型（DOM）事件之间的关系并不十分清晰，因为 BOM事件长期没有规范可以遵循（HTML5 后来给出了详细的说明）。<strong>随着 DOM3 级的出现，增强后的 DOM 事件 API 变得更加繁琐</strong> 。<strong>使用事件有时相对简单，有时则非常复杂，难易程度会因你的需求而不同</strong> 。不过，有关事件的一些核心概念是一定要理解的。</p>
          <div id="read-more">
            <a href="/2018/08/26/JavaScript-event/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/25/JavaScript-DOM2-and-DOM3/">《JavaScript 高级程序设计》学习笔记-DOM2和DOM3</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-25</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/25/JavaScript-DOM2-and-DOM3/"
                   data-title="《JavaScript 高级程序设计》学习笔记-DOM2和DOM3">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h1><p><strong>DOM1 级主要定义的是 HTML 和 XML 文档的底层结构</strong> 。<strong>DOM2 和 DOM3 级则在这个结构的基础上引入了更多的交互能力</strong> ，<strong>也支持了更高级的 XML 特性</strong> 。为此，DOM2 和 DOM3 级分为许多模块（模块之间具有某种关联），分别描述了 DOM 的某个非常具体的子集。这些模块如下。</p>
<ul>
<li><p>DOM2 级 <strong>核心</strong>（DOM Level 2 Core）：在 1 级核心基础上构建，<strong>为节点添加了更多方法和属性</strong> 。</p>
</li>
<li><p>DOM2 级 <strong>视图</strong>（DOM Level 2 Views）：<strong>为文档定义了基于样式信息的不同视图</strong> 。</p>
</li>
<li><p>DOM2 级 <strong>事件</strong>（DOM Level 2 Events）：说明了 <strong>如何使用事件与 DOM 文档交互</strong> 。</p>
</li>
<li><p>DOM2 级 <strong>样式</strong>（DOM Level 2 Style）：定义了 <strong>如何以编程方式来访问和改变 CSS 样式信息</strong> 。</p>
</li>
<li><p>DOM2 级 <strong>遍历和范围</strong>（DOM Level 2 Traversal and Range）：<strong>引入了遍历 DOM 文档和选择其特定部分的新接口</strong> 。</p>
</li>
<li><p>DOM2 级 <strong>HTML</strong>（DOM Level 2 HTML）：在 1 级 HTML 基础上构建，<strong>添加了更多属性、方法和新接口</strong> 。</p>
</li>
</ul>
<p>本章探讨除“DOM2 级事件”之外的所有模块，“DOM2 级事件”模块将在第 13 章进行全面讲解。</p>
<blockquote>
<p>DOM3 级又增加了“XPath”模块和“加载与保存”（Load and Save）模块。这些模块将在第 18 章讨论。</p>
</blockquote>
          <div id="read-more">
            <a href="/2018/08/25/JavaScript-DOM2-and-DOM3/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/23/JavaScript-DOM-extend/">《JavaScript 高级程序设计》学习笔记-DOM扩展</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-23</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/23/JavaScript-DOM-extend/"
                   data-title="《JavaScript 高级程序设计》学习笔记-DOM扩展">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="DOM-扩展"><a href="#DOM-扩展" class="headerlink" title="DOM 扩展"></a>DOM 扩展</h1><p>尽管 DOM 作为 API 已经非常完善了，但为了实现更多的功能，仍然会有一些标准或专有的扩展。2008 年之前，浏览器中几乎所有的 DOM扩展都是专有的。此后，W3C 着手将一些已经成为事实标准的专有扩展标准化并写入规范当中。</p>
<p>对 DOM 的两个主要的扩展是 <strong>Selectors API</strong>（选择符 API）和 <strong>HTML5</strong> 。这两个扩展都源自开发社区，而将某些常见做法及 API 标准化一直是众望所归。此外，还有一个不那么引人瞩目的 <strong>Element Traversal（元素遍历）规范</strong> ，<strong>为 DOM 添加了一些属性</strong> 。虽然前述两个主要规范（特别是 HTML5）已经涵盖了大量的 DOM 扩展，但专有扩展依然存在。本章也会介绍专有的 DOM 扩展。</p>
          <div id="read-more">
            <a href="/2018/08/23/JavaScript-DOM-extend/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/21/JavaScript-DOM/">《JavaScript 高级程序设计》学习笔记-DOM</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-21</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/21/JavaScript-DOM/"
                   data-title="《JavaScript 高级程序设计》学习笔记-DOM">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p><strong>DOM</strong>（文档对象模型）是 <strong>针对 HTML 和 XML 文档的一个 API</strong>（应用程序编程接口）。<strong>DOM</strong> 描绘了 <strong>一个层次化的节点树</strong> ，<strong>允许开发人员添加、移除和修改页面的某一部分</strong> 。<strong>DOM 脱胎于</strong> Netscape 及微软公司创始的 <strong>DHTML</strong>（动态 HTML），但现在 <strong>它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式</strong> 。</p>
<p>1998 年 10 月 DOM１级规范成为 W3C 的推荐标准，<strong>为基本的文档结构及查询提供了接口</strong> 。本章主要讨论与浏览器中的 HTML 页面相关的 DOM1 级的特性和应用，以及 JavaScript 对 DOM1 级的实现。IE、Firefox、Safari、Chrome 和 Opera 都非常完善地实现了 DOM。</p>
<blockquote>
<p>注意，<strong>IE 中的所有 DOM 对象都是以 COM 对象的形式实现的</strong> 。这意味着 <strong>IE 中的 DOM 对象与原生 JavaScript 对象的行为或活动特点并不一致</strong>。本章将较多地谈及这些差异。</p>
</blockquote>
          <div id="read-more">
            <a href="/2018/08/21/JavaScript-DOM/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/21/JavaScript-customer-service-test/">《JavaScript 高级程序设计》学习笔记-客户端检测</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-21</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/21/JavaScript-customer-service-test/"
                   data-title="《JavaScript 高级程序设计》学习笔记-客户端检测">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="客服端检测"><a href="#客服端检测" class="headerlink" title="客服端检测"></a>客服端检测</h1><p>浏览器提供商虽然在实现公共接口方面投入了很多精力，但结果仍然是每一种浏览器都有各自的长处，也都有各自的缺点。即使是那些跨平台的浏览器，<strong>虽然从技术上看版本相同</strong>，<strong>也照样存在不一致性问题</strong> 。<strong>面对普遍存在的不一致性问题</strong> ，开发人员要么采取迁就各方的“最小公分母”策略，要么（也是更常见的）就得 <strong>利用各种客户端检测方法</strong> ，来突破或者规避种种局限性。迄今为止，客户端检测仍然是 Web 开发领域中一个饱受争议的话题。一谈到这个话题，人们总会不约而同地提到浏览器应该支持一组最常用的公共功能。在理想状态下，确实应该如此。但是，在现实当中，浏览器之间的差异以及不同浏览器的“怪癖”（quirk），多得简直不胜枚举。因此，<strong>客户端检测除了是一种补救措施之外，更是一种行之有效的开发策略</strong> 。检测 Web 客户端的手段很多，而且各有利弊。但最重要的还是要知道，<strong>不到万不得已</strong> ，就 <strong>不要使用客户端检测</strong> 。<strong>只要能找到更通用的方法</strong> ，就 <strong>应该优先采用更通用的方法</strong> 。一言以蔽之，<strong>先设计最通用的方案</strong> ，<strong>然后再使用特定于浏览器的技术增强该方案</strong> 。</p>
          <div id="read-more">
            <a href="/2018/08/21/JavaScript-customer-service-test/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/20/JavaScript-BOM/">《JavaScript 高级程序设计》学习笔记-BOM</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-20</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/20/JavaScript-BOM/"
                   data-title="《JavaScript 高级程序设计》学习笔记-BOM">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 <strong>BOM（浏览器对象模型）则无疑才是真正的核心</strong> 。<strong>BOM</strong> 提供了很多对象，<strong>用于访问浏览器的功能</strong>，<strong>这些功能与任何网页内容无关</strong> 。多年来，<strong>缺少事实上的规范导致 BOM 既有意思又有问题</strong> ，因为 <strong>浏览器提供商会按照各自的想法随意去扩展它</strong> 。于是，浏览器之间共有的对象就成为了事实上的标准。这些对象在浏览器中得以存在，很大程度上是由于它们提供了与浏览器的互操作性。<strong>W3C 为了把浏览器中 JavaScript 最基本的部分标准化</strong> ，<strong>已经将 BOM 的主要方面纳入了 HTML5 的规范中</strong> 。</p>
          <div id="read-more">
            <a href="/2018/08/20/JavaScript-BOM/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/17/JavaScript-function-expression/">《JavaScript 高级程序设计》学习笔记-函数表达式</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-17</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/17/JavaScript-function-expression/"
                   data-title="《JavaScript 高级程序设计》学习笔记-函数表达式">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p>函数表达式是 JavaScript 中的一个既强又容易令人困惑的特性。定义函数的方式有两种：一种是 <strong>函数声明</strong> ，另一种就是 <strong>函数表达式</strong> 。<strong>函数声明</strong> 的语法是这样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是 function 关键字，然后是函数的名字，这就是指定函数名的方式。Firefox、Safari、Chrome 和 Opera 都给函数定义了一个非标准的 name 属性，通过这个属性可以访问到给函数指定的名字。这个属性的值永远等于跟在 function 关键字后面的标识符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只是 Firefox、Safari、Chrome 和 Opera 有效</span></span><br><span class="line">alert(functionName.name); <span class="comment">// "fcuntionName"</span></span><br></pre></td></tr></table></figure>
          <div id="read-more">
            <a href="/2018/08/17/JavaScript-function-expression/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/14/JavaScript-object-oriented/">《JavaScript 高级程序设计》学习笔记-面向对象程序设计</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-14</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/14/JavaScript-object-oriented/"
                   data-title="《JavaScript 高级程序设计》学习笔记-面向对象程序设计">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h1><p>面向对象（Object-Oriented, OO）的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。前面提到过，<strong>ECMAScript 中没有类的概念</strong> ，因此 <strong>它的对象也与基于类的语言中的对象有所不同</strong> 。</p>
<p>ECMA-262 把对象定义为：“<strong>无序属性集合，其属性可以包含基本值、对象或者函数。</strong> ”严格来讲，这就是相当于说 <strong>对象是一组没有特定顺序的值</strong> 。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因）， 我们可以把 ECMAScript 的对象想象成<strong>散列表</strong> ：<strong>无非就是一组名值对</strong> ，<strong>其中值可以是数据和函数</strong> 。</p>
<p><strong>每个对象</strong> 都是 <strong>基于一个引用类型创建的</strong>，这个 <strong>引用类型</strong> 可以是 <strong>原生类型</strong> ，也可以是 <strong>开发人员定义的类型</strong>。</p>
          <div id="read-more">
            <a href="/2018/08/14/JavaScript-object-oriented/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/08/13/JavaScript-reference-type/">《JavaScript 高级程序设计》学习笔记-引用类型</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-08-13</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/读书笔记/">读书笔记</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/08/13/JavaScript-reference-type/"
                   data-title="《JavaScript 高级程序设计》学习笔记-引用类型">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，<strong>引用类型是一种数据结构</strong> ，用于 <strong>将数据和功能组织在一起</strong> 。它也常被称为 <strong>类</strong> ，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<blockquote>
<p>虽然 <strong>引用类型与类看起来相似</strong> ，但 <strong>它们并不是相同的概念</strong> 。为避免混淆，本书将<br>不使用类这个概念。</p>
</blockquote>
<p>如前所述，对象是某个特定引用类型的实例。新对象是 <strong>使用 new 操作符后跟一个构造函数来创建的</strong> 。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这行代码创建了 Object 引用类型的一个新实例，然后把该实例保存在了变量 person 中。使用的构造函数是 Object ，它只为新对象定义了默认的属性和方法。ECMAScript 提供了很多 <strong>原生引用类型</strong>（例如 Object ），以便开发人员用以实现常见的计算任务。</p>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且， Object 也是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。</p>
<p><strong>创建 Object 实例</strong> 的方式有两种。第一种是 <strong>使用 new 操作符后跟 Object 构造函数</strong> ，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;Nicholas&quot;;</span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure>
<p>另一种方式是 <strong>使用对象字面量表示法</strong> 。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的 person 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">"Nicholas"</span>,</span><br><span class="line">  age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，左边的花括号（ { ）表示对象字面量的开始，因为它出现在了表达式上下文（expression context）中。ECMAScript 中的表达式上下文指的是能够返回一个值（表达式）。赋值操作符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文（statement context）中，例如跟在 if 语句条件的后面，则表示一个语句块的开始。</p>
<p>然后，我们定义了 name 属性，之后是一个冒号，再后面是这个属性的值。在对象字面量中，使用逗号来分隔不同的属性，因此 “Nicholas” 后面是一个逗号。但是，在 age 属性的值 29 的后面不能添加逗号，因为 age 是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在 IE7 及更早版本和 Opera 中导致错误。</p>
<p>在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</span><br><span class="line">  <span class="string">"age"</span> : <span class="number">29</span>,</span><br><span class="line">  <span class="number">5</span> : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子会创建一个对象，包含三个属性： name 、 age 和 5 。但 <strong>这里的数值属性名会自动转换为字符串</strong> 。</p>
<p>另外，使用对象字面量语法时，如果 <strong>留空其花括号</strong> ，则 <strong>可以定义只包含默认属性和方法的对象</strong> ，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;; <span class="comment">//与 与 new Object() 相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子与本节前面的例子是等价的，只不过看起来似乎有点奇怪。关于对象字面量语法，我们推荐只在考虑对象属性名的可读性时使用。</p>
<blockquote>
<p>在通过对象字面量定义对象时，实际上不会调用 Object 构造函数（Firefox 2 及<br>更早版本会调用 Object 构造函数；但 Firefox 3 之后就不会了）。</p>
</blockquote>
<p>虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，<strong>对象字面量也是向函数传递大量可选参数的首选方式</strong> ，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function displayInfo(args) &#123;</span><br><span class="line">  var output = &quot;&quot;;</span><br><span class="line">  if (typeof args.name == &quot;string&quot;)&#123;</span><br><span class="line">    output += &quot;Name: &quot; + args.name + &quot;\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof args.age == &quot;number&quot;) &#123;</span><br><span class="line">    output += &quot;Age: &quot; + args.age + &quot;\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  alert(output);</span><br><span class="line">&#125;</span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  name: &quot;Nicholas&quot;,</span><br><span class="line">  age: 29</span><br><span class="line">&#125;);</span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  name: &quot;Greg&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，函数 displayInfo() 接受一个名为 args 的参数。这个参数可能带有一个名为 name 或 age 的属性，也可能这两个属性都有或者都没有。在这个函数内部，我们通过 typeof 操作符来检测每个属性是否存在，然后再基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，每次都使用一个对象字面量来指定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。</p>
<blockquote>
<p>这种传递参数的模式最适合需要 <strong>向函数传入大量可选参数的情形</strong> 。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。<strong>最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数</strong> 。</p>
</blockquote>
<p>一般来说，访问对象属性时使用的都是 <strong>点表示法</strong> ，这也是很多面向对象语言中通用的语法。不过，在 JavaScript 也可以使用 <strong>方括号表示法</strong> 来访问对象的属性。在使用方括号语法时，应该 <strong>将要访问的属性以字符串的形式放在方括号中</strong> ，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">"name"</span>]); <span class="comment">//"Nicholas"</span></span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是 <strong>可以通过变量来访问属性</strong> ，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line">alert(person[propertyName]); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>如果属性名中包含会导致语法错误的字符，或者 <strong>属性名使用的是关键字或保留字</strong> ，也可以 <strong>使用方括号表示法</strong> 。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于 “first name” 中包含一个空格，所以不能使用点表示法来访问它。然而，<strong>属性名中是可以包含非字母非数字的</strong> ，这时候就可以 <strong>使用方括号表示法来</strong> 访问它们。</p>
<p>通常，<strong>除非必须使用变量来访问属性，否则我们建议使用点表示法</strong> 。</p>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>除了 Object 之外， Array 类型恐怕是 ECMAScript 中最常用的类型了。而且，ECMAScript 中的数组与其他多数语言中的数组有着相当大的区别。虽然 ECMAScript 数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，<strong>ECMAScript 数组</strong> 的每一项可以保存 <strong>任何类型的数据</strong> 。也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。而且，<strong>ECMAScript 数组的大小是可以动态调整的</strong> ，即 <strong>可以随着数据的添加自动增长以容纳新增数据</strong> 。</p>
<p><strong>创建数组</strong> 的基本方式有两种。第一种是 <strong>使用 Array 构造函数</strong> ，如下面的代码所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
<p>如果预先知道数组要保存的项目数量，也可以 <strong>给构造函数传递该数量</strong> ，而该数量会自动变成 length 属性的值。例如，下面的代码将创建 length 值为 20 的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>也可以 <strong>向 Array 构造函数传递数组中应该包含的项</strong> 。以下代码创建了一个包含 3个字符串值的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure>
<p>当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果 <strong>传递的是数值</strong> ，则会 <strong>按照该数值创建包含给定项数的数组</strong> ；而如果 <strong>传递的是其他类型的参数</strong> ，则会创建 <strong>包含那个值的只有一项的数组</strong> 。下面就两个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含 3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含 1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure>
<p>另外，在使用 Array 构造函数时也可以 <strong>省略 new 操作符</strong> 。如下面的例子所示，省略 new 操作符的结果相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含 3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含 1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure>
<p>创建数组的第二种基本方式是 <strong>使用数组字面量表示法</strong> 。数组字面量由 <strong>一对包含数组项的方括号表示</strong> ，<strong>多个数组项之间以逗号隔开</strong> ，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 不要这样！这样会创建一个包含 2 或 3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！这样会创建一个包含 5 或 6 项的数组</span></span><br></pre></td></tr></table></figure>
<p>以上代码的第一行创建了一个包含3个字符串的数组。第二行使用一对空方括号创建了一个空数组。第三行展示了在数组字面量的最后一项添加逗号的结果：在 IE 中， values 会成为一个包含 3 个项且每项的值分别为 1、2 和 undefined 的数组；在其他浏览器中， values 会成为一个包含 2项且值分别为 1 和 2 的数组。原因是 IE8 及之前版本中的 ECMAScript 实现在数组字面量方面存在 bug。由于这个 bug 导致的另一种情况如最后一行代码所示，该行代码可能会创建包含 5 项的数组（在 IE9+、Firefox、Opera、<br>Safari 和 Chrome 中），也可能会创建包含 6 项的数组（在 IE8 及更早版本中）。在像这种省略值的情况下，每一项都将获得 undefined 值；这个结果与调用 Array 构造函数时传递项数在逻辑上是相同的。但是由于 IE 的实现与其他浏览器不一致，因此我们强烈建议不要使用这种语法。</p>
<blockquote>
<p>与对象一样，在 <strong>使用数组字面量表示法</strong> 时，也 <strong>不会调用 Array 构造函数</strong> （Firefox 3 及更早版本除外）。</p>
</blockquote>
<p>在 <strong>读取和设置数组的值</strong> 时，要 <strong>使用方括号并提供相应值的基于 0 的数字索引</strong> ，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 定义一个字符串数组</span></span><br><span class="line">alert(colors[<span class="number">0</span>]); <span class="comment">// 显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>; <span class="comment">// 修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>; <span class="comment">// 新增第四项</span></span><br></pre></td></tr></table></figure>
<p>方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值，就像这个例子中的 colors[0] 会显示 “red” 一样。设置数组的值也使用相同的语法，但会替换指定位置的值。如果设置某个值的索引超过了数组现有项数，如这个例子中的 colors[3] 所示，数组就会自动增加到该索引值加 1 的长度（就这个例子而言，索引是 3，因此数组长度就是 4）。</p>
<p><strong>数组的项数</strong> 保存在其 <strong>length 属性</strong> 中，这个属性始终会返回 0 或更大的值，如下面这个例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line">alert(colors.length); <span class="comment">//3</span></span><br><span class="line">alert(names.length); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>数组的 length 属性很有特点——它 <strong>不是只读的</strong> 。因此，通过 <strong>设置这个属性</strong> ，<strong>可以从数组的末尾移除项或向数组中添加新项</strong> 。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的数组 colors 一开始有 3 个值。将其 length 属性设置为 2 会移除最后一项（位置为 2 的那一项），结果再访问 colors[2] 就会显示 undefined 了。如果将其 length 属性设置为大于数组项数的值，则新增的每一项都会取得 undefined 值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">4</span>;</span><br><span class="line">alert(colors[<span class="number">3</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>在此，虽然 colors 数组包含 3 个项，但把它的 length 属性设置成了 4。这个数组不存在位置 3，所以访问这个位置的值就得到了特殊值 undefined 。</p>
<p><strong>利用 length 属性也可以方便地在数组末尾添加新项</strong> ，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors[colors.length] = <span class="string">"black"</span>; <span class="comment">// （在位置 3 ）添加一种颜色</span></span><br><span class="line">colors[colors.length] = <span class="string">"brown"</span>; <span class="comment">// （在位置 4 ）再添加一种颜色</span></span><br></pre></td></tr></table></figure>
<p>由于数组最后一项的索引始终是 length-1 ，因此下一个新项的位置就是 length 。每当在数组末尾添加一项后，其 length 属性都会自动更新以反应这一变化。换句话说，上面例子第二行中的 colors[colors.length] 为位置 3 添加了一个值，最后一行的 colors[colors.length] 则为位置 4 添加了一个值。<strong>当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值</strong> ，即长度值等于最后一项的索引加 1，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">"black"</span>; <span class="comment">// （在位置 99 ）添加一种颜色</span></span><br><span class="line">alert(colors.length); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们向 colors 数组的位置 99 插入了一个值，结果数组新长度（ length ）就是 100（99+1）。而位置 3 到位置 98 实际上都是不存在的，所以访问它们都将返回 undefined 。</p>
<blockquote>
<p>数组最多可以包含 <strong>4 294 967 295 个项</strong> ，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。</p>
</blockquote>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>自从 ECMAScript 3 做出规定以后，就出现了确定某个对象是不是数组的经典问题。对于<strong>一个网页，或者一个全局作用域而言</strong> ，使用 <strong>instanceof 操作符就能得到满意的结果</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (value instanceof Array)&#123;</span><br><span class="line">  //对数组执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果 <strong>网页中包含多个框架</strong> ，那 <strong>实际上就存在两个以上不同的全局执行环境</strong> ，<strong>从而存在两个以上不同版本的 Array 构造函数</strong> 。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p>
<p>为了解决这个问题，ECMAScript 5 新增了 <strong>Array.isArray() 方法</strong> 。这个方法的目的是 <strong>最终确定某个值到底是不是数组</strong> ，而 <strong>不管它是在哪个全局执行环境中创建的</strong> 。这个方法的用法如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">  <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持 Array.isArray() 方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 10.5+和 Chrome。要在尚未实现这个方法中的浏览器中准确检测数组，请参考 22.1.1 节。</p>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>如前所述，所有对象都具有 toLocaleString() 、 toString() 和 valueOf() 方法。其中，调用数组的 <strong>toString() 方法</strong> 会返回 <strong>由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</strong> 。而调用 <strong>valueOf()</strong> 返回的还是 <strong>数组</strong> 。实际上，为了创建这个字符串会调用数组每一项的 toString() 方法。来看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">alert(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors.valueOf()); <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors); <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们首先显式地调用了 toString() 方法，以便返回数组的字符串表示，每个值的字符串表示拼接成了一个字符串，中间以逗号分隔。接着调用 valueOf() 方法，而最后一行代码直接将数组传递给了 alert() 。由于 alert() 要接收字符串参数，所以它会在后台调用 toString() 方法，由此会得到与直接调用 toString() 方法相同的结果。<br>另外， toLocaleString() 方法经常也会返回与 toString() 和 valueOf() 方法相同的值，但也不总是如此。当调用数组的 toLocaleString() 方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 <strong>toLocaleString() 方法</strong> ，而不是 toString() 方法。请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  toLocaleString : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nikolaos"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  toLocaleString : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Grigorios"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Greg"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people = [person1, person2];</span><br><span class="line">alert(people); <span class="comment">//Nicholas,Greg</span></span><br><span class="line">alert(people.toString()); <span class="comment">//Nicholas,Greg</span></span><br><span class="line">alert(people.toLocaleString()); <span class="comment">//Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure>
<p>我们在这里定义了两个对象： person1 和 person2 。而且还分别为每个对象定义了一个 toString() 方法和一个 toLocaleString() 方法，这两个方法返回不同的值。然后，创建一个包含前面定义的两个对象的数组。在将数组传递给 alert() 时，输出结果是 “Nicholas,Greg” ，因为调用了数组每一项的 toString() 方法（同样，这与下一行显式调用 toString() 方法得到的结果相同）。而当调用数组的 toLocaleString() 方法时，输出结果是 “Nikolaos,Grigorios” ，原因是调用了数组每一项的 toLocaleString() 方法。</p>
<p>数组继承的 toLocaleString() 、 toString() 和 valueOf() 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 <strong>join() 方法</strong> ，则 <strong>可以使用不同的分隔符来构建这个字符串</strong> 。 <strong>join() 方法</strong> 只接收一个参数，即 <strong>用作分隔符的字符串</strong> ，然后 <strong>返回包含所有数组项的字符串</strong> 。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">alert(colors.join(<span class="string">","</span>)); <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors.join(<span class="string">"||"</span>)); <span class="comment">//red||green||blue</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们使用 join() 方法重现了 toString() 方法的输出。在传递逗号的情况下，得到了以逗号分隔的数组值。而在最后一行代码中，我们传递了双竖线符号，结果就得到了字符串 “red|| green||blue” 。如果 <strong>不给 join() 方法传入任何值，或者给它传入 undefined</strong> ，则 <strong>使用逗号作为分隔符</strong> 。IE7 及更早版本会错误的使用字符串 “undefined” 作为分隔符。</p>
<blockquote>
<p>如果数组中的某一项的值是 null 或者 undefined ，那么该值在 join() 、toLocaleString() 、 toString() 和 valueOf() 方法 <strong>返回的结果中以空字符串表示</strong> 。</p>
</blockquote>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>ECMAScript 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表现得就像 <strong>栈</strong> 一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 <strong>LIFO</strong>（Last-In-First-Out，后进先出）的数据结构，也就是 <strong>最新添加的项最早被移除</strong> 。而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——<strong>栈的顶部</strong> 。ECMAScript 为数组专门提供了 push() 和 pop() 方法，以便实现类似栈的行为。</p>
<p><strong>push() 方法</strong> 可以接收任意数量的参数，把它们 <strong>逐个添加到数组末尾</strong> ，并 <strong>返回修改后数组的长度</strong> 。而 <strong>pop() 方法</strong> 则 <strong>从数组末尾移除最后一项</strong> ，<strong>减少数组的 length 值</strong> ，然后 <strong>返回移除的项</strong> 。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>); <span class="comment">// 推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"black"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>以上代码中的 <strong>数组可以看成是栈</strong>（代码本身没有任何区别，而 push() 和 pop() 都是数组默认的方法）。首先，我们使用 <strong>push()</strong> 将两个字符串 <strong>推入数组的末尾</strong> ，并将返回的结果保存在变量 count 中（值为 2）。然后，再推入一个值，而结果仍然保存在 count 中。因为此时数组中包含 3 项，所以 push()返回 3。在调用 <strong>pop()</strong> 时，它会 <strong>返回数组的最后一项</strong> ，即字符串 “black” 。此后，数组中仅剩两项。</p>
<p>可以将栈方法与其他数组方法连用，像下面这个例子一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>];</span><br><span class="line">colors.push(<span class="string">"brown"</span>); <span class="comment">// 添加另一项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>; <span class="comment">// 添加一项</span></span><br><span class="line">alert(colors.length); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"black"</span></span><br></pre></td></tr></table></figure>
<p>在此，我们首先用两个值来初始化一个数组。然后，使用 push() 添加第三个值，再通过直接在位置 3 上赋值来添加第四个值。而在调用 pop() 时，该方法返回了字符串 “black” ，即最后一个添加到数组的值。</p>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>栈数据结构的访问规则是 LIFO（后进先出），而 <strong>队列数据结构</strong> 的访问规则是 FIFO（First-In-First-Out，先进先出）。队列在列表的末端添加项，从列表的前端移除项。由于 push() 是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 <strong>shift()</strong> ，它能够 <strong>移除数组中的第一个项</strong> 并 <strong>返回该项</strong> ，同时 <strong>将数组长度减 1</strong> 。结合 <strong>使用 shift() 和 push() 方法</strong> ，可以 <strong>像使用队列一样使用数组</strong> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">//推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>); <span class="comment">//推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.shift(); <span class="comment">// 取得第一项</span></span><br><span class="line">alert(item); <span class="comment">//"red"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>这个例子首先使用 push() 方法创建了一个包含 3 种颜色名称的数组。代码中加粗的那一行使用 shift() 方法从数组中取得了第一项，即 “red” 。在移除第一项之后， “green” 就变成了第一项，而 “black” 则变成了第二项，数组也只包含两项了。</p>
<p>ECMAScript 还为数组提供了一个 <strong>unshift() 方法</strong>。顾名思义， unshift() 与 shift() 的用途相反：它能在 <strong>数组前端添加任意个项</strong> 并 <strong>返回新数组的长度</strong> 。因此，同时使用 <strong>unshift() 和 pop() 方法</strong> ，可以从 <strong>相反的方向来模拟队列</strong> ，即在数组的前端添加项，从数组末端移除项，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.unshift(<span class="string">"black"</span>); <span class="comment">// 推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"green"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个数组并使用 unshift() 方法先后推入了 3 个值。首先是 “red” 和 “green” ，然后是 “black” ，数组中各项的顺序为 “black” 、 “red” 、 “green” 。在调用 pop() 方法时，移除并返回的是最后一项，即 “green” 。</p>
<blockquote>
<p>IE7 及更早版本对 JavaScript 的实现中存在一个偏差，其 unshift() 方法总是返回 undefined 而不是数组的新长度。IE8 在非兼容模式下会返回正确的长度值。</p>
</blockquote>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>数组中已经存在两个可以直接用来 <strong>重排序的方法</strong> ： <strong>reverse()</strong> 和 <strong>sort()</strong> 。有读者可能猜到了， <strong>reverse() 方法</strong> 会 <strong>反转数组项的顺序</strong> 。请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values); <span class="comment">//5,4,3,2,1</span></span><br></pre></td></tr></table></figure>
<p>这里数组的初始值及顺序是 1、2、3、4、5。而调用数组的 reverse() 方法后，其值的顺序变成了 5、4、3、2、1。这个方法的作用相当直观明了，但不够灵活，因此才有了 sort() 方法。</p>
<p>在默认情况下， <strong>sort() 方法</strong> 按 <strong>升序排列数组项</strong>——即 <strong>最小的值位于最前面，最大的值排在最后面</strong> 。为了实现排序， <strong>sort() 方法</strong> 会调用每个数组项的 <strong>toString() 转型方法</strong> ，然后 <strong>比较得到的字符串</strong> ，以确定如何排序。即使数组中的每一项都是数值， <strong>sort() 方法比较的也是字符串</strong> ，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>可见，即使例子中值的顺序没有问题，但 sort() 方法也会根据测试字符串的结果改变原来的顺序。因为数值 5 虽然小于 10，但在进行字符串比较时， “10” 则位于 “5” 的前面，于是数组的顺序就被修改了。</p>
<p>不用说，这种排序方式在很多情况下都不是最佳方案。因此 <strong>sort() 方法</strong> 可以 <strong>接收一个比较函数作为参数</strong> ，以便我们指定哪个值位于哪个值的前面。</p>
<p>比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给 sort() 方法即可，如下面这个例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>在将比较函数传递到 sort() 方法之后，数值仍然保持了正确的升序。当然，也可以 <strong>通过比较函数产生降序排序的结果</strong> ，只要交换比较函数返回的值即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<p>在这个修改后的例子中，比较函数在第一个值应该位于第二个之后的情况下返回 1，而在第一个值应该在第二个之前的情况下返回-1。交换返回值的意思是让更大的值排位更靠前，也就是对数组按照降序排序。当然，如果 <strong>只想反转数组原来的顺序</strong> ，<strong>使用 reverse() 方法要更快一些</strong> 。</p>
<blockquote>
<p>reverse() 和 sort() 方法的返回值是经过排序之后的数组。</p>
</blockquote>
<p>对于 <strong>数值类型</strong> 或者 <strong>其 valueOf() 方法会返回数值类型的对象类型</strong> ，可以使用一个 <strong>更简单的比较函数</strong> 。这个函数只要用第二个值减第一个值即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1, value2)&#123;</span><br><span class="line">  return value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况。</p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中， <strong>concat() 方法</strong> 可以 <strong>基于当前数组中的所有项创建一个新数组</strong> 。具体来说，这个方法会 <strong>先创建当前数组一个副本</strong> ，然后 <strong>将接收到的参数添加到这个副本的末尾</strong> ，最后 <strong>返回新构建的数组</strong> 。在 <strong>没有给 concat() 方法传递参数</strong> 的情况下，它 <strong>只是复制当前数组并返回副本</strong> 。如果传递给 concat() 方法的是 <strong>一或多个数组</strong> ，则该方法会 <strong>将这些数组中的每一项都添加到结果数组中</strong> 。如果 <strong>传递的值不是数组</strong> ，<strong>这些值就会被简单地添加到结果数组的末尾</strong> 。下面来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</span><br><span class="line">alert(colors); <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors2); <span class="comment">//red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure>
<p>以上代码开始定义了一个包含 3 个值的数组 colors 。然后，基于 colors 调用了 concat() 方法，并传入字符串 “yellow” 和一个包含 “black” 和 “brown” 的数组。最终，结果数组 colors2 中包含了”red” 、 “green” 、 “blue” 、 “yellow” 、 “black” 和 “brown” 。至于原来的数组 colors ，其值仍然保持不变。</p>
<p>下一个方法是 <strong>slice()</strong> ，它能够 <strong>基于当前数组中的一或多个项创建一个新数组 。 slice() 方法可以接受一或两个参数，即要 </strong>返回项的起始和结束位置<strong> 。在只有一个参数的情况下， </strong>slice() 方法<strong> 返回 </strong>从该参数指定位置开始到当前数组末尾的所有项<strong> 。如果有两个参数，该方法 </strong>返回起始和结束位置之间的项<strong> ——但  </strong>不包括结束位置的项<strong> 。注意， </strong>slice() 方法不会影响原始数组** 。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">alert(colors2); <span class="comment">//green,blue,yellow,purple</span></span><br><span class="line">alert(colors3); <span class="comment">//green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，开始定义的数组 colors 包含 5 项。调用 slice() 并传入 1 会得到一个包含 4 项的新数组；因为是从位置 1 开始复制，所以会包含 “green” 而不会包含 “red” 。这个新数组 colors2 中包含的是 “green” 、 “blue” 、 “yellow” 和 “purple” 。接着，我们再次调用 slice() 并传入了 1 和 4，表示复制从位置 1 开始，到位置 3 结束。结果数组 colors3 中包含了 “green” 、 “blue” 和 “yellow” 。</p>
<blockquote>
<p>如果 slice() 方法的 <strong>参数中有一个负数</strong> ，则 <strong>用数组长度加上该数来确定相应的位置</strong> 。例如，在一个包含 5 项的数组上调用 slice(-2,-1) 与调用 slice(3,4) 得到的结果相同。如果结束位置小于起始位置，则返回空数组。</p>
</blockquote>
<p>下面我们来介绍 splice() 方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。<strong>splice()</strong> 的主要用途是 <strong>向数组的中部插入项</strong> ，但使用这种方法的方式则有如下 3 种。</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2) 会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”) 会从当前数组的位置 2 开始插入字符串 “red” 和 “green” 。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red” 和 “green” 。</li>
</ul>
<p>splice() 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述 3 种使用 splice() 方法的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line">alert(colors); <span class="comment">// green,blue</span></span><br><span class="line">alert(removed); <span class="comment">// red，返回的数组中只包含一项</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>); <span class="comment">// 从位置 1 开始插入两项</span></span><br><span class="line">alert(colors); <span class="comment">// green,yellow,orange,blue</span></span><br><span class="line">alert(removed); <span class="comment">// 返回的是一个空数组</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>); <span class="comment">// 插入两项，删除一项</span></span><br><span class="line">alert(colors); <span class="comment">// green,red,purple,orange,blue</span></span><br><span class="line">alert(removed); <span class="comment">// yellow，返回的数组中只包含一项</span></span><br></pre></td></tr></table></figure>
<p>上面的例子首先定义了一个包含 3项的数组 colors 。第一次调用 splice() 方法只是删除了这个数组的第一项，之后 colors 还包含 “green” 和 “blue” 两项。第二次调用 splice() 方法时在位置 1插入了两项，结果 colors 中包含 “green” 、 “yellow” 、 “orange” 和 “blue” 。这一次操作没有删除项，因此返回了一个空数组。最后一次调用 splice() 方法删除了位置 1处的一项，然后又插入了 “red” 和 “purple” 。在完成以<br>上操作之后，数组 colors 中包含的是 “green” 、 “red” 、 “purple” 、 “orange” 和 “blue” 。</p>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript 5 为数组实例添加了两个位置方法： <strong>indexOf()</strong> 和 <strong>lastIndexOf()</strong> 。这两个方法都接收两个参数：<strong>要查找的项</strong> 和（可选的）<strong>表示查找起点位置的索引</strong> 。其中， <strong>indexOf() 方法从数组的开头（位置 0）开始向后查找</strong> ， <strong>lastIndexOf() 方法则从数组的末尾开始向前查找</strong> 。</p>
<p>这两个方法都返回 <strong>要查找的项在数组中的位置</strong> ，或者 <strong>在没找到的情况下返回-1</strong>。在比较第一个参数与数组中的每一项时，会使用 <strong>全等操作符</strong> ；也就是说，<strong>要求查找的项必须严格相等</strong>（就像使用===一样）。以下是几个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">alert(numbers.indexOf(4)); //3</span><br><span class="line">alert(numbers.lastIndexOf(4)); //5</span><br><span class="line">alert(numbers.indexOf(4, 4)); //5</span><br><span class="line">alert(numbers.lastIndexOf(4, 4)); //3</span><br><span class="line"></span><br><span class="line">var person = &#123; name: &quot;Nicholas&quot; &#125;;</span><br><span class="line">var people = [&#123; name: &quot;Nicholas&quot; &#125;];</span><br><span class="line"></span><br><span class="line">var morePeople = [person];</span><br><span class="line"></span><br><span class="line">alert(people.indexOf(person)); //-1</span><br><span class="line">alert(morePeople.indexOf(person)); //0</span><br></pre></td></tr></table></figure>
<p>使用 indexOf() 和 lastIndexOf() 方法查找特定项在数组中的位置非常简单，支持它们的浏览器包括 IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：<strong>要在每一项上运行的函数</strong> 和（可选的）<strong>运行该函数的作用域对象</strong> —— <strong>影响 this 的值</strong> 。传入这些方法中的函数会接收三个参数：<strong>数组项的值</strong> 、<strong>该项在数组中的位置和数组对象本身</strong> 。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这 5 个迭代方法的作用。</p>
<ul>
<li>every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true 。</li>
<li>filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li>forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true 。</li>
</ul>
<p>以上方法都不会修改数组中的包含的值。</p>
<p>在这些方法中，最相似的是 every() 和 some() ，它们都用于查询数组中的项是否满足某个条件。对 every() 来说，传入的函数必须对每一项都返回 true ，这个方法才返回 true ；否则，它就返回 false 。而 some() 方法则是只要传入的函数对数组中的某一项返回 true ，就会返回 true 。请看以下例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">var everyResult = numbers.every(function(item, index, array)&#123;</span><br><span class="line">  return (item &gt; 2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(everyResult); //false</span><br><span class="line"></span><br><span class="line">var someResult = numbers.some(function(item, index, array)&#123;</span><br><span class="line">  return (item &gt; 2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(someResult); //true</span><br></pre></td></tr></table></figure>
<p>以上代码调用了 every() 和 some() ，传入的函数只要给定项大于2就会返回 true 。对于 every() ，它返回的是 false ，因为只有部分数组项符合条件。对于 some() ，结果就是 true ，因为至少有一项是大于 2 的。</p>
<p>下面再看一看 filter() 函数，它利用指定的函数确定是否在返回的数组中包含某一项。例如，要返回一个所有数值都大于 2 的数组，可以使用以下代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult); <span class="comment">//[3,4,5,4,3]</span></span><br></pre></td></tr></table></figure>
<p>这里，通过调用 filter() 方法创建并返回了包含 3、4、5、4、3 的数组，因为传入的函数对它们每一项都返回 true 。这个方法对查询符合某些条件的所有数组项非常有用。<br>map() 也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果。例如，可以给数组中的每一项乘以 2，然后返回这些乘积组成的数组，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">alert(mapResult); <span class="comment">//[2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure>
<p>以上代码返回的数组中包含给每个数乘以 2 之后的结果。这个方法适合创建包含的项与另一个数组<br>一一对应的数组。<br>最后一个方法是 forEach() ，它只是对数组中的每一项运行传入的函数。这个方法没有返回值，<br>本质上与使用 for 循环迭代数组一样。来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line"><span class="comment">//执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。支持这些迭代方法的浏览器有<br>IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。</p>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>ECMAScript 5 还新增了两个归并数组的方法： reduce() 和 reduceRight() 。这两个方法都会迭<br>代数组的所有项，然后构建一个最终返回的值。其中， reduce() 方法从数组的第一项开始，逐个遍历<br>到最后。而 reduceRight() 则从数组的最后一项开始，向前遍历到第一项。<br>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce() 和 reduceRight() 的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这<br>个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第<br>一个参数是数组的第一项，第二个参数就是数组的第二项。<br>使用 reduce() 方法可以执行求数组中所有值之和的操作，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数， prev 是 1， cur 是 2。第二次， prev 是 3（1 加 2 的结果）， cur 是 3（数组<br>的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。<br>reduceRight() 的作用类似，只不过方向相反而已。来看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一次执行回调函数， prev 是 5， cur 是 4。当然，最终结果相同，因为执行的都<br>是简单相加的操作。<br>使用 reduce() 还是 reduceRight() ，主要取决于要从哪头开始遍历数组。除此之外，它们完全<br>相同。<br>支持这两个归并函数的浏览器有 IE9+、Firefox 3+、Safari 4+、Opera 10.5 和 Chrome。</p>
<h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><p>ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此， Date<br>类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970 年 1 月 1 日午夜（零时）开始经过<br>的毫秒数来保存日期。在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1<br>月 1 日之前或之后的 285 616 年。<br>要创建一个日期对象，使用 new 操作符和 Date 构造函数即可，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p>在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根<br>据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午<br>夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript 提供了两个方法： Date.parse()<br>和 Date.UTC() 。<br>其中， Date.parse() 方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日<br>期的毫秒数。ECMA-262 没有定义 Date.parse() 应该支持哪种日期格式，因此这个方法的行为因实现<br>而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式：</p>
<p>  “月/日/年”，如 6/13/2004；<br>  “英文月名 日,年”，如 January 12,2004；<br>  “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700。<br>  ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ（例如 2004-05-25T00:00:00）。只有兼容<br>ECMAScript 5的实现支持这种格式。<br>例如，要为 2004 年 5 月 25 日创建一个日期对象，可以使用下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br></pre></td></tr></table></figure>
<p>如果传入 Date.parse() 方法的字符串不能表示日期，那么它会返回 NaN 。实际上，如果直接将表<br>示日期的字符串传递给 Date 构造函数，也会在后台调用 Date.parse() 。换句话说，下面的代码与前<br>面的例子是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25, 2004"</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码将会得到与前面相同的日期对象。<br>日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超<br>出范围的值替换成当前的值，以便生成输出。例如，在解析 “January 32, 2007”<br>时，有的浏览器会将其解释为 “February 1, 2007” 。而 Opera 则倾向于插入当前月<br>份的当前日期，返回 “January 当前日期， 2007” 。也就是说，如果在 2007 年 9 月<br>21 日运行前面的代码，将会得到 “January 21, 2007” （都是 21 日）。<br>Date.UTC() 方法同样也返回表示日期的毫秒数，但它与 Date.parse() 在构建值时使用不同的信<br>息。 Date.UTC() 的参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推）、月中的哪一天<br>（1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必<br>需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。以下是两个<br>使用 Date.UTC() 方法的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GMT 时间 2000 年 1 月 1 日午夜零时</span></span><br><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// GMT 时间 2005 年 5 月 5 日下午 5:55:55</span></span><br><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure>
<p>这个例子创建了两个日期对象。第一个对象表示 GMT 时间 2000 年 1 月 1 日午夜零时，传入的值一<br>个是表示年份的 2000，一个是表示月份的 0（即一月份）。因为其他参数是自动填充的（即月中的天数<br>为 1，其他所有参数均为 0），所以结果就是该月第一天的午夜零时。第二个对象表示 GMT 时间 2005<br>年 5 月 5 日下午 5:55:55，即使日期和时间中只包含 5，也需要传入不一样的参数：月份必须是 4（因为<br>月份是基于 0 的）、小时必须设置为 17（因为小时以 0 到 23 表示），剩下的参数就很直观了。<br>如同模仿 Date.parse() 一样， Date 构造函数也会模仿 Date.UTC() ，但有一点明显不同：日期<br>和时间都基于本地时区而非 GMT 来创建。不过， Date 构造函数接收的参数仍然与 Date.UTC() 相同。</p>
<p>因此，如果第一个参数是数值， Date 构造函数就会假设该值是日期中的年份，而第二个参数是月份，<br>以此类推。据此，可以将前面的例子重写如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地时间 2000 年 1 月 1 日午夜零时</span></span><br><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 本地时间 2005 年 5 月 5 日下午 5:55:55</span></span><br><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时<br>区创建的。<br>ECMAScript 5 添加了 Data.now() 方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方<br>法简化了使用 Data 对象分析代码的工作。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得开始时间</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"><span class="comment">//取得停止时间</span></span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now(),</span><br><span class="line">result = stop – start;</span><br></pre></td></tr></table></figure>
<p>支持 Data.now() 方法的浏览器包括 IE9+、Firefox 3+、Safari 3+、Opera 10.5 和 Chrome。在不支<br>持它的浏览器中，使用+操作符把 Data 对象转换成字符串，也可以达到同样的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得开始时间</span></span><br><span class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"><span class="comment">//取得停止时间</span></span><br><span class="line"><span class="keyword">var</span> stop = +<span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">result = stop - start;</span><br></pre></td></tr></table></figure>
<h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他引用类型一样， Date 类型也重写了 toLocaleString() 、 toString() 和 valueOf() 方法；<br>但这些方法返回的值与其他类型中的方法不同。 Date 类型的 toLocaleString() 方法会按照与浏览器<br>设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含 AM 或 PM，但不会包含时<br>区信息（当然，具体的格式会因浏览器而异）。而 toString() 方法则通常返回带有时区信息的日期和<br>时间，其中时间一般以军用时间（即小时的范围是 0 到 23）表示。下面给出了在不同浏览器中调用<br>toLocaleString() 和 toString() 方法，输出 PST（Pacific Standard Time，太平洋标准时间）时间 2007<br>年 2 月 1 日午夜零时的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Internet Explorer 8</span><br><span class="line">toLocaleString() — Thursday, February 01, 2007 12:00:00 AM</span><br><span class="line">toString() — Thu Feb 1 00:00:00 PST 2007</span><br><span class="line">Firefox 3.5</span><br><span class="line">toLocaleString() — Thursday, February 01, 2007 12:00:00 AM</span><br><span class="line">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)</span><br><span class="line">Safari 4</span><br><span class="line">toLocaleString() — Thursday, February 01, 2007 00:00:00</span><br><span class="line">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)</span><br><span class="line">Chrome 4</span><br><span class="line">toLocaleString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)</span><br><span class="line">toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)</span><br><span class="line">Opera 10</span><br><span class="line">toLocaleString() — 2/1/2007 12:00:00 AM</span><br><span class="line">toString() — Thu, 01 Feb 2007 00:00:00 GMT-0800</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>显然，这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，<br>toLocaleString() 和 toString() 的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有<br>什么价值。<br>至于 Date 类型的 valueOf() 方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以<br>方便使用比较操作符（小于或大于）来比较日期值。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2007</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//"January 1, 2007"</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2007</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">//"February 1, 2007"</span></span><br><span class="line">alert(date1 &lt; date2); <span class="comment">//true</span></span><br><span class="line">alert(date1 &gt; date2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>从逻辑上讲，2007 年 1 月 1 日要早于 2007 年 2 月 1 日，此时如果我们说前者小于后者比较符合常<br>理。而表示 2007 年 1 月 1 日的毫秒值小于表示 2007 年 2 月 1日的毫秒值，因此在首先使用小于操作符<br>比较日期时，返回的结果是 true 。这样，就为我们比较日期提供了极大方便。</p>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><p>Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。<br> toDateString() ——以特定于实现的格式显示星期几、月、日和年；<br> toTimeString() ——以特定于实现的格式显示时、分、秒和时区；<br> toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年；<br> toLocaleTimeString() ——以特定于实现的格式显示时、分、秒；<br> toUTCString() ——以特定于实现的格式完整的 UTC 日期。<br>与 toLocaleString() 和 toString() 方法一样，以上这些字符串格式方法的输出也是因浏览器<br>而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</p>
<blockquote>
<p>除了前面介绍的方法之外，还有一个名叫 toGMTString() 的方法，这是一个与<br>toUTCString() 等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript 推<br>荐现在编写的代码一律使用 toUTCString() 方法。</p>
</blockquote>
<h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><p>到目前为止，剩下还未介绍的 Date 类型的方法（如下表所示），都是直接取得和设置日期值中特<br>定部分的方法了。需要注意的是，UTC 日期指的是在没有时区偏差的情况下（将日期转换为 GMT 时间）<br>的日期值。</p>
<p><img src="/2018/08/13/JavaScript-reference-type/" alt="表格"></p>
<h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><p>ECMAScript 通过 RegExp 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正<br>则表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure>
<p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、<br>向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。<br>正则表达式的匹配模式支持下列 3 个标志。<br> g ：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即<br>停止；<br> i ：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；<br> m ：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模<br>式匹配的项。<br>因此，一个正则表达式就是一个模式与上述 3 个标志的组合体。不同组合产生不同结果，如下面的<br>例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配字符串中所有"at"的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：<br>( [ { \ ^ $ | ) ? * + .]}<br>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，<br>就必须对它们进行转义。下面给出几个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配第一个" [bc]at"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配所有".at"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中， pattern1 匹配第一个 “bat” 或 “cat” ，不区分大小写。而要想直接匹配 “[bc]at”<br>的话，就需要像定义 pattern2 一样，对其中的两个方括号进行转义。对于 pattern3 来说，句点表示<br>位于 “at” 之前的任意一个可以构成匹配项的字符。但如果想匹配 “.at” ，则必须对句点本身进行转义，<br>如 pattern4 所示。<br>前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用<br>RegExp 构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以<br>使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 与 pattern1 相同，只不过是使用构造函数创建的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure>
<p>在此， pattern1 和 pattern2 是两个完全等价的正则表达式。要注意的是，传递给 RegExp 构造<br>函数的两个参数都是字符串（不能把正则表达式字面量传递给 RegExp 构造函数）。由于 RegExp 构造<br>函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那<br>些已经转义过的字符也是如此，例如 \n （字符\在字符串中通常被转义为\，而在正则表达式字符串中就<br>会变成\\）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用 RegExp 构造函数定义<br>相同模式时使用的字符串。</p>
<p><img src="/2018/08/13/JavaScript-reference-type/" alt="表格"></p>
<p>使用正则表达式字面量和使用 RegExp 构造函数创建的正则表达式不一样。在 ECMAScript 3 中，<br>正则表达式字面量始终会共享同一个 RegExp 实例，而使用构造函数创建的每一个新 RegExp 实例都是</p>
<p>一个新实例。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="literal">null</span>,</span><br><span class="line">i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">re = <span class="regexp">/cat/g</span>;</span><br><span class="line">re.test(<span class="string">"catastrophe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>, <span class="string">"g"</span>);</span><br><span class="line">re.test(<span class="string">"catastrophe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个循环中，即使是循环体中指定的，但实际上只为 /cat/ 创建了一个 RegExp 实例。由于实<br>例属性（下一节介绍实例属性）不会重置，所以在循环中再次调用 test() 方法会失败。这是因为第一<br>次调用 test() 找到了 “cat” ，但第二次调用是从索引为 3 的字符（上一次匹配的末尾）开始的，所以<br>就找不到它了。由于会测试到字符串末尾，所以下一次再调用 test() 就又从开头开始了。<br>第二个循环使用 RegExp 构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的<br>RegExp 实例，所以每次调用 test() 都会返回 true 。<br>ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用 RegExp 构造函数一样，每次都创<br>建新的 RegExp 实例。IE9+、Firefox 4+和 Chrome 都据此做出了修改。</p>
<h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3><p>RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。<br> global ：布尔值，表示是否设置了 g 标志。<br> ignoreCase ：布尔值，表示是否设置了 i 标志。<br> lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。<br> multiline ：布尔值，表示是否设置了 m 标志。<br> source ：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。<br>通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含<br>在模式声明中。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line">alert(pattern1.global); <span class="comment">//false</span></span><br><span class="line">alert(pattern1.ignoreCase); <span class="comment">//true</span></span><br><span class="line">alert(pattern1.multiline); <span class="comment">//false</span></span><br><span class="line">alert(pattern1.lastIndex); <span class="comment">//0</span></span><br><span class="line">alert(pattern1.source); <span class="comment">//"\[bc\]at"</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);</span><br><span class="line">alert(pattern2.global); <span class="comment">//false</span></span><br><span class="line">alert(pattern2.ignoreCase); <span class="comment">//true</span></span><br><span class="line">alert(pattern2.multiline); <span class="comment">//false</span></span><br><span class="line">alert(pattern2.lastIndex); <span class="comment">//0</span></span><br><span class="line">alert(pattern2.source); <span class="comment">//"\[bc\]at"</span></span><br></pre></td></tr></table></figure>
<p>我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了 RegExp 构造函数，但它们的<br>source 属性是相同的。可见， source 属性保存的是规范形式的字符串，即字面量形式所用的字符串。</p>
<h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><p>RegExp 对象的主要方法是 exec() ，该方法是专门为捕获组而设计的。 exec() 接受一个参数，即<br>要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null 。<br>返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input 。其中， index 表示匹配<br>项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配<br>的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。<br>请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">// 0</span></span><br><span class="line">alert(matches.input); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的模式包含两个捕获组。最内部的捕获组匹配 “and baby” ，而包含它的捕获组匹配 “and<br>dad” 或者 “and dad and baby” 。当把字符串传入 exec() 方法中之后，发现了一个匹配项。因为整个<br>字符串本身与模式匹配，所以返回的数组 matchs 的 index 属性值为 0。数组中的第一项是匹配的整个<br>字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。<br>对于 exec() 方法而言，即使在模式中设置了全局标志（ g ），它每次也只会返回一个匹配项。在不<br>设置全局标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。而在设<br>置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新匹配项，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern1.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex); <span class="comment">//0</span></span><br><span class="line">matches = pattern1.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex); <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern2.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//cat</span></span><br><span class="line">alert(pattern2.lastIndex); <span class="comment">//3</span></span><br><span class="line">matches = pattern2.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">//5</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//bat</span></span><br><span class="line">alert(pattern2.lastIndex); <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的第一个模式 pattern1 不是全局模式，因此每次调用 exec() 返回的都是第一个匹配<br>项（ “cat” ）。而第二个模式 pattern2 是全局模式，因此每次调用 exec() 都会返回字符串中的下一个<br>匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的 lastIndex 属性的变化情况。在全局<br>匹配模式下， lastIndex 的值在每次调用 exec() 后都会增加，而在非全局模式下则始终保持不变。<br>IE 的 JavaScript 实现在 lastIndex 属性上存在偏差，即使在非全局模式下，<br>lastIndex 属性每次也会变化。<br>正则表达式的第二个方法是 test() ，它接受一个字符串参数。在模式与该参数匹配的情况下返回<br>true ；否则，返回 false 。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的<br>情况下，使用这个方法非常方便。因此， test() 方法经常被用在 if 语句中，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">alert(<span class="string">"The pattern was matched."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输入的文本与模式匹配，则显示<br>一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为<br>什么无效就无关紧要了。<br>RegExp 实例继承的 toLocaleString() 和 toString() 方法都会返回正则表达式的字面量，与创<br>建正则表达式的方式无关。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"gi"</span>);</span><br><span class="line">alert(pattern.toString()); <span class="comment">// /\[bc\]at/gi</span></span><br><span class="line">alert(pattern.toLocaleString()); <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure>
<p>即使上例中的模式是通过调用 RegExp 构造函数创建的，但 toLocaleString() 和 toString()<br>方法仍然会像它是以字面量形式创建的一样显示其字符串表示。<br>正则表达式的 valueOf() 方法返回正则表达式本身。</p>
<h3 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h3><p>RegExp 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独<br>特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名<br>（Opera 是例外，它不支持短属性名）。下表列出了 RegExp 构造函数的属性。</p>
<p><img src="/2018/08/13/JavaScript-reference-type/" alt="表格"></p>
<p>使用这些属性可以从 exec() 或 test() 执行的操作中提取出更具体的信息。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</span></span><br><span class="line"><span class="comment">* Internet Explorer 不支持 multiline 属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">alert(<span class="built_in">RegExp</span>.input); <span class="comment">// this has been a short summer</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// this has been a</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// short</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>.lastParen); <span class="comment">// s</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>.multiline); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个模式，匹配任何一个字符后跟 hort ，而且把第一个字符放在了一个捕获组中。<br>RegExp 构造函数的各个属性返回了下列值：<br> input 属性返回了原始字符串；<br> leftContext 属性返回了单词 short 之前的字符串，而 rightContext 属性则返回了 short<br>之后的字符串；<br> lastMatch 属性返回最近一次与整个正则表达式匹配的字符串，即 short ；<br> lastParen 属性返回最近一次匹配的捕获组，即例子中的 s 。<br>如前所述，例子使用的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都<br>不是有效的 ECMAScript 标识符，因此必须通过方括号语法来访问它们，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</span></span><br><span class="line"><span class="comment">* Internet Explorer 不支持 multiline 属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">alert(<span class="built_in">RegExp</span>.$_); <span class="comment">// this has been a short summer</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]); <span class="comment">// this has been a</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]); <span class="comment">// summer</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]); <span class="comment">// short</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]); <span class="comment">// s</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语<br>法是 RegExp.$1 、 RegExp.$2 … RegExp.$9 ，分别用于存储第一、第二……第九个匹配的捕获组。在<br>调用 exec() 或 test() 方法时，这些属性会被自动填充。然后，我们就可以像下面这样来使用它们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">alert(<span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">//sh</span></span><br><span class="line">alert(<span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">//t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个包含两个捕获组的模式，并用该模式测试了一个字符串。即使 test() 方法只返回<br>一个布尔值，但 RegExp 构造函数的属性 $1 和 $2 也会被匹配相应捕获组的字符串自动填充。</p>
<h3 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h3><p>尽管 ECMAScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是 Perl）所支<br>持的高级正则表达式特性。下面列出了 ECMAScript 正则表达式不支持的特性（要了解更多相关信息，<br>请访问 <a href="http://www.regular-expressions.info）。" target="_blank" rel="noopener">www.regular-expressions.info）。</a><br>  匹配字符串开始和结尾的 \A 和 \Z 锚<br>（但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。）<br>  向后查找（lookbehind）<br>（但完全支持向前查找（lookahead）。）<br>  并集和交集类<br>  原子组（atomic grouping）<br>  Unicode 支持（单个字符除外，如 \uFFFF ）<br>  命名的捕获组<br>（但支持编号的捕获组。）<br> s （single，单行）和 x （free-spacing，无间隔）匹配模式<br>  条件匹配<br>  正则表达式注释<br>即使存在这些限制，ECMAScript 正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹<br>配任务。</p>
<h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>说起来 ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际<br>上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函<br>数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函<br>数声明语法定义的，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与下面使用函数表达式定义函数的方式几乎相差无几。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码定义了变量 sum 并将其初始化为一个函数。有读者可能会注意到， function 关键字后面<br>没有函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量 sum 即可以引<br>用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。<br>最后一种定义函数的方式是使用 Function 构造函数。 Function 构造函数可以接收任意数量的参数，<br>但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>
<p>从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语<br>法会导致解析两次代码（第一次是解析常规 ECMAScript代码，第二次是解析传入构造函数中的字符串），<br>从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。<br>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话<br>说，一个函数可能会有多个名字，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line"><span class="keyword">var</span> anotherSum = sum;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>以上代码首先定义了一个名为 sum() 的函数，用于求两个值的和。然后，又声明了变量 anotherSum ，<br>并将其设置为与 sum 相等（将 sum 的值赋给 anotherSum ）。注意，使用不带圆括号的函数名是访问函<br>数指针，而非调用函数。此时， anotherSum 和 sum 就都指向了同一个函数，因此 anotherSum() 也<br>可以被调用并返回结果。即使将 sum 设置为 null ，让它与函数“断绝关系”，但仍然可以正常调用<br>anotherSum() 。</p>
<h3 id="没有重载（深入理解）"><a href="#没有重载（深入理解）" class="headerlink" title="没有重载（深入理解）"></a>没有重载（深入理解）</h3><p>将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。以下是曾在第 3<br>章使用过的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure>
<p>显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际<br>上与下面的代码没有什么区别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure>
<p>通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——在创建第二个函数时，实际上覆盖<br>了引用第一个函数的变量 addSomeNumber 。</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环<br>境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行<br>任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真<br>正被解释执行。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升<br>（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript<br>引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后<br>面，JavaScript 引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价<br>的函数表达式，就会在执行期间导致错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(10,10));</span><br><span class="line">var sum = function(num1, num2)&#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声<br>明。换句话说，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用；而且，由于第一<br>行代码就会导致“unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。<br>除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。<br>也可以同时使用函数声明和函数表达式，例如 var sum = function sum(){} 。<br>不过，这种语法在 Safari 中会导致错误。</p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以<br>像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看<br>一看下面的函数。<br>function callSomeFunction(someFunction, someArgument){<br>return someFunction(someArgument);<br>}<br>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。<br>然后，就可以像下面的例子一样传递函数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</span><br><span class="line">alert(result1); <span class="comment">//20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">"Nicholas"</span>);</span><br><span class="line">alert(result2); <span class="comment">//"Hello, Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>这里的 callSomeFunction() 函数是通用的，即无论第一个参数中传递进来的是什么函数，它都<br>会返回执行第一个参数后的结果。还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后<br>面的那对圆括号。因此上面例子中传递给 callSomeFunction() 的是 add10 和 getGreeting ，而不<br>是执行它们之后的结果。</p>
<p>当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个<br>对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 sort() 方法的比较函数要接收<br>两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，<br>可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函<br>数的定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line"><span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line"><span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数<br>前面加了一个 return 操作符。在内部函数接收到 propertyName 参数后，它会使用方括号表示法来<br>取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下<br>面例子中这样使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;];</span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</span><br><span class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Nicholas</span></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</span><br><span class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Zachary</span></span><br></pre></td></tr></table></figure>
<p>这里，我们创建了一个包含两个对象的数组 data 。其中，每个对象都包含一个 name 属性和一个<br>age 属性。在默认情况下， sort() 方法会调用每个对象的 toString() 方法以确定它们的次序；但得<br>到的结果往往并不符合人类的思维习惯。因此，我们调用 createComparisonFunction(“name”) 方<br>法创建了一个比较函数，以便按照每个对象的 name 属性值进行排序。而结果排在前面的第一项是 name<br>为 “Nicholas” ， age 是 29 的对象。然后，我们又使用了 createComparisonFunction(“age”) 返回<br>的比较函数，这次是按照对象的 age 属性排序。得到的结果是 name 值为 “Zachary” ， age 值是 28的<br>对象排在了第一位。</p>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>在函数内部，有两个特殊的对象： arguments 和 this 。其中， arguments 在第 3 章曾经介绍过，<br>它是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，<br>但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。<br>请看下面这个非常经典的阶乘函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变<br>的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为<br>了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial 。这样，无论引用<br>函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueFactorial = factorial;</span><br><span class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">//120</span></span><br><span class="line">alert(factorial(<span class="number">5</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>在此，变量 trueFactorial 获得了 factorial 的值，实际上是在另一个位置上保存了一个函数<br>的指针。然后，我们又将一个简单地返回 0 的函数赋值给 factorial 变量。如果像原来的 factorial()<br>那样不使用 arguments.callee ，调用 trueFactorial() 就会返回 0。可是，在解除了函数体内的代<br>码与函数名的耦合状态之后， trueFactorial() 仍然能够正常地计算阶乘；至于 factorial() ，它现<br>在只是一个返回 0 的函数。<br>函数内部的另一个特殊对象是 this ，其行为与 Java 和 C#中的 this 大致类似。换句话说， this<br>引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时，<br>this 对象引用的就是 window ）。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); <span class="comment">//"red"</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数 sayColor() 是在全局作用域中定义的，它引用了 this 对象。由于在调用函数之前，<br>this 的值并不确定，因此 this 可能会在代码执行过程中引用不同的对象。当在全局作用域中调用<br>sayColor() 时， this 引用的是全局对象 window ；换句话说，对 this.color 求值会转换成对<br>window.color 求值，于是结果就返回了 “red” 。而当把这个函数赋给对象 o 并调用 o.sayColor()<br>时， this 引用的是对象 o ，因此对 this.color 求值会转换成对 o.color 求值，结果就返回了 “blue” 。<br>请读者一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是<br>在不同的环境中执行，全局的 sayColor() 函数与 o.sayColor() 指向的仍然是同一<br>个函数。<br>ECMAScript 5 也规范化了另一个函数对象的属性： caller 。除了 Opera 的早期版本不支持，其他<br>浏览器都支持这个 ECMAScript 3 并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，<br>如果是在全局作用域中调用当前函数，它的值为 null 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>以上代码会导致警告框中显示 outer() 函数的源代码。因为 outer() 调用了 inter() ，所以<br>inner.caller 就指向 outer() 。为了实现更松散的耦合，也可以通过 arguments.callee.caller<br>来访问相同的信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>IE、Firefox、Chrome 和 Safari 的所有版本以及 Opera 9.6 都支持 caller 属性。<br>当函数在严格模式下运行时，访问 arguments.callee 会导致错误。ECMAScript 5 还定义了<br>arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是<br>undefined 。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。以上变化都是为<br>了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。<br>严格模式还有一个限制：不能为函数的 caller 属性赋值，否则会导致错误。</p>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>前面曾经提到过，ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个<br>属性： length 和 prototype 。其中， length 属性表示函数希望接收的命名参数的个数，如下面的例<br>子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">alert(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">alert(sayName.length); <span class="comment">//1</span></span><br><span class="line">alert(sum.length); <span class="comment">//2</span></span><br><span class="line">alert(sayHi.length); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>以上代码定义了 3 个函数，但每个函数接收的命名参数个数不同。首先， sayName() 函数定义了一<br>个参数，因此其 length 属性的值为 1。类似地， sum() 函数定义了两个参数，结果其 length 属性中<br>保存的值为 2。而 sayHi() 没有命名参数，所以其 length 值为 0。<br>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于<br>ECMAScript 中的引用类型而言， prototype 是保存它们所有实例方法的真正所在。换句话说，诸如<br>toString() 和 valueOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访<br>问罢了。在创建自定义引用类型以及实现继承时， prototype 属性的作用是极为重要的（第 6 章将详<br>细介绍）。在 ECMAScript 5 中， prototype 属性是不可枚举的，因此使用 for-in 无法发现。<br>每个函数都包含两个非继承而来的方法： apply() 和 call() 。这两个方法的用途都是在特定的作<br>用域中调用函数，实际上等于设置函数体内 this 对象的值。首先， apply() 方法接收两个参数：一个<br>是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是<br>arguments 对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入 arguments 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中， callSum1() 在执行 sum() 函数时传入了 this 作为 this 值（因为是在全局<br>作用域中调用的，所以传入的就是 window 对象）和 arguments 对象。而 callSum2 同样也调用了<br>sum() 函数，但它传入的则是 this 和一个参数数组。这两个函数都会正常执行并返回正确的结果。<br>在严格模式下，未指定环境对象而调用函数，则 this 值不会转型为 window 。<br>除非明确把函数添加到某个对象或者调用 apply() 或 call() ，否则 this 值将是<br>undefined 。<br>call() 方法与 apply() 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()<br>方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用<br>call() 方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在使用 call() 方法的情况下， callSum() 必须明确地传入每一个参数。结果与使用 apply() 没有<br>什么不同。至于是使用 apply() 还是 call() ，完全取决于你采取哪种给函数传递参数的方式最方便。<br>如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply()<br>肯定更方便；否则，选择 call() 可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所<br>谓。）<br>事实上，传递参数并非 apply() 和 call() 真正的用武之地；它们真正强大的地方是能够扩充函数<br>赖以运行的作用域。下面来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(o); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>这个例子是在前面说明 this 对象的示例基础上修改而成的。这一次， sayColor() 也是作为全局<br>函数定义的，而且当在全局作用域中调用它时，它确实会显示 “red” ——因为对 this.color 的求值会转换成对 window.color 的求值。而 sayColor.call(this) 和 sayColor.call(window) ，则是两<br>种显式地在全局作用域中调用函数的方式，结果当然都会显示 “red” 。但是，当运行 sayColor.call(o)<br>时，函数的执行环境就不一样了，因为此时函数体内的 this 对象指向了 o ，于是结果显示的是 “blue” 。<br>使用 call() （或 apply() ）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。<br>在前面例子的第一个版本中，我们是先将 sayColor() 函数放到了对象 o 中，然后再通过 o 来调用它的；<br>而在这里重写的例子中，就不需要先前那个多余的步骤了。<br>ECMAScript 5 还定义了一个方法： bind() 。这个方法会创建一个函数的实例，其 this 值会被绑<br>定到传给 bind() 函数的值。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>在这里， sayColor() 调用 bind() 并传入对象 o ，创建了 o bjectSayColor() 函数。 object-<br>SayColor() 函数的 this 值等于 o ，因此即使是在全局作用域中调用这个函数，也会看到 “blue” 。这<br>种技巧的优点请参考第 22 章。<br>支持 bind() 方法的浏览器有 IE9+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome。<br>每个函数继承的 toLocaleString() 和 toString() 方法始终都返回函数的代码。返回代码的格<br>式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表<br>示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个<br>方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的<br>valueOf() 方法同样也只返回函数代码。<br>5.6 基本包装类型<br>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型： Boolean 、 Number 和<br>String 。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。<br>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们<br>能够调用一些方法来操作这些数据。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的<br>substring() 方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上<br>讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，<br>后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要<br>从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>
<p>(1) 创建 String 类型的一个实例；<br>(2) 在实例上调用指定的方法；<br>(3) 销毁这个实例。<br>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean<br>和 Number 类型对应的布尔值和数字值。<br>引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，<br>在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一<br>行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来看<br>下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line">s1.color = <span class="string">"red"</span>;</span><br><span class="line">alert(s1.color); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>在此，第二行代码试图为字符串 s1 添加一个 color 属性。但是，当第三行代码再次访问 s1 时，<br>其 color 属性不见了。问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。<br>第三行代码又创建自己的 String 对象，而该对象没有 color 属性。<br>当然，可以显式地调用 Boolean 、 Number 和 String 来创建基本包装类型的对象。不过，应该在<br>绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的<br>值。对基本包装类型的实例调用 typeof 会返回 “object” ，而且所有基本包装类型的对象都会被转换<br>为布尔值 true 。<br>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到 Number 的实<br>例，传入布尔值参数就会得到 Boolean 的实例。<br>要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。<br>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> number); <span class="comment">//"number"</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，变量 number 中保存的是基本类型的值 25，而变量 obj 中保存的是 Number 的实<br>例。要了解有关转型函数的更多信息，请参考第 3 章。<br>尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。<br>而每个基本包装类型都提供了操作相应值的便捷方法。</p>
<h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>Boolean 类型是与布尔值对应的引用类型。要创建 Boolean 对象，可以像下面这样调用 Boolean<br>构造函数并传入 true 或 false 值。<br>var booleanObject = new Boolean(true);<br>Boolean 类型的实例重写了 valueOf() 方法，返回基本类型值 true 或 false ；重写了 toString()<br>方法，返回字符串 “true” 和 “false” 。可是， Boolean 对象在 ECMAScript 中的用处不大，因为它经<br>常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;</span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用 false 值创建了一个 Boolean 对象。然后，将这个对象与基本类型值 true<br>构成了逻辑与表达式。在布尔运算中， false &amp;&amp; true 等于 false 。可是，示例中的这行代码是对<br>falseObject 而不是对它的值（ false ）进行求值。前面讨论过，布尔表达式中的所有对象都会被转<br>换为 true ，因此 falseObject 对象在布尔表达式中代表的是 true 。结果， true &amp;&amp; true 当然就等<br>于 true 了。<br>基本类型与引用类型的布尔值还有两个区别。首先， typeof 操作符对基本类型返回 “boolean” ，<br>而对引用类型返回 “object” 。其次，由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof<br>操作符测试 Boolean 对象会返回 true ，而测试基本类型的布尔值则返回 false 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> falseObject); <span class="comment">//object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> falseValue); <span class="comment">//boolean</span></span><br><span class="line">alert(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line">alert(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>理解基本类型的布尔值与 Boolean 对象之间的区别非常重要——当然，我们的建议是永远不要使<br>用 Boolean 对象。</p>
<h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其<br>中传递相应的数值。下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>与 Boolean 类型一样， Number 类型也重写了 valueOf() 、 toLocaleString() 和 toString()<br>方法。重写后的 valueOf() 方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。我们在第 3 章还介绍过，可以为 toString() 方法传递一个表示基数的参数，告诉它返回几进制<br>数值的字符串形式，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toString()); <span class="comment">//"10"</span></span><br><span class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">//"1010"</span></span><br><span class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">//"12"</span></span><br><span class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">//"10"</span></span><br><span class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">//"a"</span></span><br></pre></td></tr></table></figure>
<p>除了继承的方法之外， Number 类型还提供了一些用于将数值格式化为字符串的方法。<br>其中， toFixed() 方法会按照指定的小数位返回数值的字符串表示，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toFixed(<span class="number">2</span>)); <span class="comment">//"10.00"</span></span><br></pre></td></tr></table></figure>
<p>这里给 toFixed() 方法传入了数值 2 ，意思是显示几位小数。于是，这个方法返回了 “10.00” ，即<br>以 0 填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值<br>就会舍入，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.005</span>;</span><br><span class="line">alert(num.toFixed(<span class="number">2</span>)); <span class="comment">//"10.01"</span></span><br></pre></td></tr></table></figure>
<p>能够自动舍入的特性，使得 toFixed() 方法很适合处理货币值。但需要注意的是，不同浏览器给<br>这个方法设定的舍入规则可能会有所不同。在给 toFixed() 传入 0 的情况下，IE8 及之前版本不能正确<br>舍入范围在{(-0.94,-0.5],[ 0.5,0.94)}之间的值。对于这个范围内的值，IE 会返回 0，而不是1 或 1；其他<br>浏览器都能返回正确的值。IE9 修复了这个问题。<br>toFixed() 方法可以表示带有 0 到 20 个小数位的数值。但这只是标准实现的范<br>围，有些浏览器也可能支持更多位数。<br>另外可用于格式化数值的方法是 toExponential() ，该方法返回以指数表示法（也称 e 表示法）<br>表示的数值的字符串形式。与 toFixed() 一样， toExponential() 也接收一个参数，而且该参数同样<br>也是指定输出结果中的小数位数。看下面的例子。<br>var num = 10;<br>alert(num.toExponential(1)); //“1.0e+1”<br>以上代码输出了 “1.0e+1” ；不过，这么小的数值一般不必使用 e 表示法。如果你想得到表示某个<br>数值的最合适的格式，就应该使用 toPrecision() 方法。<br>对于一个数值来说， toPrecision() 方法可能会返回固定大小（fixed）格式，也可能返回指数<br>（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的<br>位数（不包括指数部分）。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</span><br><span class="line">alert(num.toPrecision(<span class="number">1</span>)); <span class="comment">//"1e+2"</span></span><br><span class="line">alert(num.toPrecision(<span class="number">2</span>)); <span class="comment">//"99"</span></span><br><span class="line">alert(num.toPrecision(<span class="number">3</span>)); <span class="comment">//"99.0"</span></span><br></pre></td></tr></table></figure>
<p>以上代码首先完成的任务是以一位数来表示 99，结果是 “1e+2” ，即 100。因为一位数无法准确地<br>表示 99，因此 toPrecision() 就将它向上舍入为 100，这样就可以使用一位数来表示它了。而接下来的<br>用两位数表示 99，当然还是 “99” 。最后，在想以三位数表示 99时， toPrecision() 方法返回了 “99.0” 。<br>实际上， toPrecision() 会根据要处理的数值决定到底是调用 toFixed() 还是调用 toExponential() 。<br>而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。<br>toPrecision() 方法可以表现 1 到 21 位小数。某些浏览器支持的范围更大，但<br>这是典型实现的范围。<br>与 Boolean 对象类似， Number 对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍<br>然不建议直接实例化 Number 类型，而原因与显式创建 Boolean 对象一样。具体来讲，就是在使用<br>typeof 和 instanceof 操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，如下面的<br>例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> numberValue = <span class="number">10</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> numberObject); <span class="comment">//"object"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> numberValue); <span class="comment">//"number"</span></span><br><span class="line">alert(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line">alert(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>在使用 typeof 操作符测试基本类型数值时，始终会返回 “number” ，而在测试 Number 对象时，<br>则会返回 “object” 。类似地， Number 对象是 Number 类型的实例，而基本类型的数值则不是。</p>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf() 、 toLocale-<br>String() 和 toString() 方法，都返回对象所表示的基本字符串值。<br>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.length); <span class="comment">//"11"</span></span><br></pre></td></tr></table></figure>
<p>这个例子输出了字符串 “hello world” 中的字符数量，即 “11” 。应该注意的是，即使字符串中包<br>含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。<br>String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。</p>
<ul>
<li><h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4>两个用于访问字符串中特定字符的方法是： charAt() 和 charCodeAt() 。这两个方法都接收一个<br>参数，即基于 0 的字符位置。其中， charAt() 方法以单字符字符串的形式返回给定位置的那个字符<br>（ECMAScript 中没有字符类型）。例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.charAt(<span class="number">1</span>)); <span class="comment">//"e"</span></span><br></pre></td></tr></table></figure>
<p>字符串 “hello world” 位置 1 处的字符是 “e” ，因此调用 charAt(1) 就返回了 “e” 。如果你想得到<br>的不是字符而是字符编码，那么就要像下面这样使用 charCodeAt() 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.charCodeAt(<span class="number">1</span>)); <span class="comment">// 输出"101"</span></span><br></pre></td></tr></table></figure>
<p>这个例子输出的是 “101” ，也就是小写字母 “e” 的字符编码。<br>ECMAScript 5还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数<br>字索引来访问字符串中的特定字符，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue[<span class="number">1</span>]); <span class="comment">//"e"</span></span><br></pre></td></tr></table></figure>
<p>使用方括号表示法访问个别字符的语法得到了 IE8 及 Firefox、Safari、Chrome 和 Opera 所有版本的<br>支持。如果是在 IE7 及更早版本中使用这种语法，会返回 undefined 值（尽管根本不是特殊的<br>undefined 值）。</p>
<ul>
<li><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4></li>
</ul>
<p>下面介绍与操作字符串有关的几个方法。第一个就是 concat() ，用于将一或多个字符串拼接起来，<br>返回拼接得到的新字符串。先来看一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>);</span><br><span class="line">alert(result); <span class="comment">//"hello world"</span></span><br><span class="line">alert(stringValue); <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过 stringValue 调用 concat() 方法返回的结果是 “hello world” ——但<br>stringValue 的值则保持不变。实际上， concat() 方法可以接受任意多个参数，也就是说可以通过它<br>拼接任意多个字符串。再看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</span><br><span class="line">alert(result); <span class="comment">//"hello world!"</span></span><br><span class="line">alert(stringValue); <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure>
<p>这个例子将 “world” 和 “!” 拼接到了 “hello” 的末尾。虽然 concat() 是专门用来拼接字符串的方<br>法，但实践中使用更多的还是加号操作符（+）。而且，使用加号操作符在大多数情况下都比使用 concat()<br>方法要简便易行（特别是在拼接多个字符串的情况下）。<br>ECMAScript还提供了三个基于子字符串创建新字符串的方法： slice() 、 substr() 和 substring() 。<br>这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字<br>符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说， slice() 和<br>substring() 的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr() 的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与<br>concat() 方法一样， slice() 、 substr() 和 substring() 也不会修改字符串本身的值——它们只是<br>返回一个基本类型的字符串值，对原始字符串没有任何影响。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">//"lo worl"</span></span><br></pre></td></tr></table></figure>
<p>这个例子比较了以相同方式调用 slice() 、 substr() 和 substring() 得到的结果，而且多数情<br>况下的结果是相同的。在只指定一个参数 3 的情况下，这三个方法都返回 “lo world” ，因为 “hello”<br>中的第二个 “l” 处于位置 3。而在指定两个参数 3 和 7 的情况下， slice() 和 substring() 返回 “lo w”<br>（ “world” 中的 “o” 处于位置 7，因此结果中不包含 “o” ），但 substr() 返回 “lo worl” ，因为它的第二<br>个参数指定的是要返回的字符个数。<br>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中， slice() 方法会将传<br>入的负值与字符串的长度相加， substr() 方法将负的第一个参数加上字符串的长度，而将负的第二个<br>参数转换为 0。最后， substring() 方法会把所有负值参数都转换为 0。下面来看例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.slice(<span class="number">-3</span>)); <span class="comment">//"rld"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">-3</span>)); <span class="comment">//"hello world"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">-3</span>)); <span class="comment">//"rld"</span></span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"hel"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"" （空字符串）</span></span><br></pre></td></tr></table></figure>
<p>这个例子清晰地展示了上述三个方法之间的不同行为。在给 slice() 和 substr() 传递一个负值<br>参数时，它们的行为相同。这是因为 -3 会被转换为 8 （字符串长度加参数 11+(3)=8），实际上相当<br>于调用了 slice(8) 和 substr(8) 。但 substring() 方法则返回了全部字符串，因为它将 -3 转换<br>成了 0 。<br>IE 的 JavaScript 实现在处理向 substr() 方法传递负值的情况时存在问题，它会<br>返回原始的字符串。IE9 修复了这个问题。<br>当第二个参数是负值时，这三个方法的行为各不相同。 slice() 方法会把第二个参数转换为 7，这<br>就相当于调用了 slice(3,7) ，因此返回 “lo w” 。 substring() 方法会把第二个参数转换为 0，使调<br>用变成了 substring(3,0) ，而由于这个方法会将较小的数作为开始位置，将较大的数作为结束位置，<br>因此最终相当于调用了 substring(0,3) 。 substr() 也会将第二个参数转换为 0，这也就意味着返回<br>包含零个字符的字符串，也就是一个空字符串。</p>
<ul>
<li><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4>有两个可以从字符串中查找子字符串的方法： indexOf() 和 lastIndexOf() 。这两个方法都是从<br>一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回 -1 ）。<br>这两个方法的区别在于： indexOf() 方法从字符串的开头向后搜索子字符串，而 lastIndexOf() 方法<br>是从字符串的末尾向前搜索子字符串。还是来看一个例子吧。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.indexOf(<span class="string">"o"</span>)); <span class="comment">//4</span></span><br><span class="line">alert(stringValue.lastIndexOf(<span class="string">"o"</span>)); <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<p>子字符串 “o” 第一次出现的位置是 4，即 “hello” 中的 “o” ；最后一次出现的位置是 7，即 “world” 中的<br>“o” 。如果 “o” 在这个字符串中仅出现了一次，那么 indexOf() 和 lastIndexOf() 会返回相同的位置值。<br>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，<br>indexOf() 会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而 lastIndexOf() 则会从<br>指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.indexOf(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">//7</span></span><br><span class="line">alert(stringValue.lastIndexOf(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>在将第二个参数 6 传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于<br>indexOf() 是从位置 6（字母 “w” ）开始向后搜索，结果在位置 7 找到了 “o” ，因此它返回 7。而 last-<br>IndexOf() 是从位置 6 开始向前搜索。结果找到了 “hello” 中的 “o” ，因此它返回 4。在使用第二个<br>参数的情况下，可以通过循环调用 indexOf() 或 lastIndexOf() 来找到所有匹配的子字符串，如下<br>面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"Lorem ipsum dolor sit amet, consectetur adipisicing elit"</span>;</span><br><span class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> pos = stringValue.indexOf(<span class="string">"e"</span>);</span><br><span class="line"><span class="keyword">while</span>(pos &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">positions.push(pos);</span><br><span class="line">pos = stringValue.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">alert(positions); <span class="comment">//"3,24,32,35,52"</span></span><br></pre></td></tr></table></figure>
<p>这个例子通过不断增加 indexOf() 方法开始查找的位置，遍历了一个长字符串。在循环之外，首<br>先找到了 “e” 在字符串中的初始位置；而进入循环后，则每次都给 indexOf() 传递上一次的位置加 1。<br>这样，就确保了每次新搜索都从上一次找到的子字符串的后面开始。每次搜索返回的位置依次被保存在<br>数组 positions 中，以便将来使用。</p>
<ul>
<li><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h4></li>
</ul>
<p>ECMAScript 5 为所有字符串定义了 trim() 方法。这个方法会创建一个字符串的副本，删除前置及<br>后缀的所有空格，然后返回结果。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">" hello world "</span>;</span><br><span class="line"><span class="keyword">var</span> trimmedStringValue = stringValue.trim();</span><br><span class="line">alert(stringValue); <span class="comment">//" hello world "</span></span><br><span class="line">alert(trimmedStringValue); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
<p>由于 trim() 返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个<br>方法的浏览器有 IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和 Chrome。此外，Firefox 3.5+、Safari 5+<br>和 Chrome 8+还支持非标准的 trimLeft() 和 trimRight() 方法，分别用于删除字符串开头和末尾的<br>空格。</p>
<ul>
<li><h4 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h4></li>
</ul>
<p>接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript 中涉及字符串大小写转换的方<br>法有 4 个： toLowerCase() 、 toLocaleLowerCase() 、 toUpperCase() 和 toLocaleUpperCase() 。<br>其中， toLowerCase() 和 toUpperCase() 是两个经典的方法，借鉴自 java.lang.String 中的同名<br>方法。而 toLocaleLowerCase() 和 toLocaleUpperCase() 方法则是针对特定地区的实现。对有些地<br>区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小<br>写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.toLocaleUpperCase()); <span class="comment">//"HELLO WORLD"</span></span><br><span class="line">alert(stringValue.toUpperCase()); <span class="comment">//"HELLO WORLD"</span></span><br><span class="line">alert(stringValue.toLocaleLowerCase()); <span class="comment">//"hello world"</span></span><br><span class="line">alert(stringValue.toLowerCase()); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
<p>以上代码调用的 toLocaleUpperCase() 和 toUpperCase() 都返回了 “HELLO WORLD” ，就像调用<br>toLocaleLowerCase() 和 toLowerCase() 都返回 “hello world” 一样。一般来说，在不知道自己的<br>代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。</p>
<ul>
<li><h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4></li>
</ul>
<p>String 类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是 match() ，在字符串上<br>调用这个方法，本质上与调用 RegExp 的 exec() 方法相同。 match() 方法只接受一个参数，要么是一<br>个正则表达式，要么是一个 RegExp 对象。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="comment">//与 pattern.exec(text)相同</span></span><br><span class="line"><span class="keyword">var</span> matches = text.match(pattern);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//"cat"</span></span><br><span class="line">alert(pattern.lastIndex); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>本例中的 match() 方法返回了一个数组；如果是调用 RegExp 对象的 exec() 方法并传递本例中的<br>字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每<br>一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。</p>
<p>另一个用于查找模式的方法是 search() 。这个方法的唯一参数与 match() 方法的参数相同：由字<br>符串或 RegExp 对象指定的一个正则表达式。 search() 方法返回字符串中第一个匹配项的索引；如果没<br>有找到匹配项，则返回 -1 。而且， search() 方法始终是从字符串开头向后查找模式。看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line">alert(pos); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的 search() 方法返回 1 ，即 “at” 在字符串中第一次出现的位置。<br>为了简化替换子字符串的操作，ECMAScript 提供了 replace() 方法。这个方法接受两个参数：第<br>一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参<br>数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替<br>换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（ g ）标志，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>);</span><br><span class="line">alert(result); <span class="comment">//"cond, bat, sat, fat"</span></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>);</span><br><span class="line">alert(result); <span class="comment">//"cond, bond, sond, fond"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，首先传入 replace() 方法的是字符串 “at” 和替换用的字符串 “ond” 。替换的结果<br>是把 “cat” 变成了 “cond” ，但字符串中的其他字符并没有受到影响。然后，通过将第一个参数修改为带<br>有全局标志的正则表达式，就将全部 “at” 都替换成了 “ond” 。<br>如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入<br>到结果字符串中。下表列出了 ECMAScript 提供的这些特殊的字符序列。</p>
<p><img src="/2018/08/13/JavaScript-reference-type/" alt="表格"></p>
<p>通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($1)"</span>);</span><br><span class="line">alert(result); <span class="comment">//word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure>
<p>在此，每个以 “at” 结尾的单词都被替换了，替换结果是 “word” 后跟一对圆括号，而圆括号中是被<br>字符序列 $1 所替换的单词。<br>replace() 方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的<br>情况下，会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在<br>正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹<br>配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始<br>字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace() 方法的第<br>二个参数可以实现更加精细的替换操作，请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(match)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"&lt;"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"&gt;"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"&amp;"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"\""</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&amp;quot;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">alert(htmlEscape(<span class="string">"&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"</span>));</span><br><span class="line"><span class="comment">//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</span></span><br></pre></td></tr></table></figure>
<p>这里，我们为插入 HTML 代码定义了函数 htmlEscape() ，这个函数能够转义 4 个字符：小于号、<br>大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定<br>义一个能够针对每个匹配的字符返回特定 HTML 实体的函数。<br>最后一个与模式匹配有关的方法是 split() ，这个方法可以基于指定的分隔符将一个字符串分割成<br>多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个 RegExp 对象（这个方<br>法不会将字符串看成正则表达式）。 split() 方法可以接受可选的第二个参数，用于指定数组的大小，<br>以便确保返回的数组不会超过既定大小。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</span><br><span class="line"><span class="keyword">var</span> colors1 = colorText.split(<span class="string">","</span>); <span class="comment">//["red", "blue", "green", "yellow"]</span></span><br><span class="line"><span class="keyword">var</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>); <span class="comment">//["red", "blue"]</span></span><br><span class="line"><span class="keyword">var</span> colors3 = colorText.split(<span class="regexp">/[^\,]+/</span>); <span class="comment">//["", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中， colorText 是逗号分隔的颜色名字符串。基于该字符串调用 split(“,”) 会得到<br>一个包含其中颜色名的数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可<br>以为 split() 方法传递第二个参数 2。最后，通过使用正则表达式，还可以取得包含逗号字符的数组。<br>需要注意的是，在最后一次调用 split() 返回的数组中，第一项和最后一项是两个空字符串。之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头（即子字符串 “red” ）和末尾（即子<br>字符串 “yellow” ）。<br>对 split() 中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现<br>匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。<br>  IE8 及之前版本会忽略捕获组。ECMA-262 规定应该把捕获组拼接到结果数组中。IE9 能正确地<br>在结果中包含捕获组。<br>  Firefox 3.6 及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262 规<br>定没有匹配项的捕获组在结果数组中应该用 undefined 表示。<br>在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览<br>器下多做一些测试。<br>要了解关于 split() 方法以及捕获组的跨浏览器问题的更多讨论，请参考 Steven<br>Levithan 的文章“JavaScript split bugs：Fixed!”（<a href="http://blog.stevenlevithan.com/archives/" target="_blank" rel="noopener">http://blog.stevenlevithan.com/archives/</a><br>cross-browser-split）。</p>
<ul>
<li><h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h4></li>
</ul>
<p>与操作字符串有关的最后一个方法是 localeCompare() ，这个方法比较两个字符串，并返回下列<br>值中的一个：<br>  如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是 -1 ，具体<br>的值要视实现而定）；<br>  如果字符串等于字符串参数，则返回 0 ；<br>  如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1 ，具体的<br>值同样要视实现而定）。<br>下面是几个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>;</span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"brick"</span>)); <span class="comment">//1</span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"yellow"</span>)); <span class="comment">//0</span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"zoo"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<p>这个例子比较了字符串 “yellow” 和另外几个值： “brick” 、 “yellow” 和 “zoo” 。因为 “brick” 在<br>字母表中排在 “yellow” 之前，所以 localeCompare() 返回了 1 ；而 “yellow” 等于 “yellow” ，所以<br>localeCompare() 返回了 0 ；最后， “zoo” 在字母表中排在 “yellow” 后面，所以 localeCompare()<br>返回了 -1 。再强调一次，因为 localeCompare() 返回的数值取决于实现，所以最好是像下面例子所示<br>的这样使用这个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineOrder</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.localeCompare(value);</span><br><span class="line"><span class="keyword">if</span> (result &lt; <span class="number">0</span>)&#123;</span><br><span class="line">alert(<span class="string">"The string 'yellow' comes before the string '"</span> + value + <span class="string">"'."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">alert(<span class="string">"The string 'yellow' comes after the string '"</span> + value + <span class="string">"'."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">"The string 'yellow' is equal to the string '"</span> + value + <span class="string">"'."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">determineOrder(<span class="string">"brick"</span>);</span><br><span class="line">determineOrder(<span class="string">"yellow"</span>);</span><br><span class="line">determineOrder(<span class="string">"zoo"</span>);</span><br></pre></td></tr></table></figure>
<p>使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。<br>localeCompare() 方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个<br>方法的行为。比如，美国以英语作为 ECMAScript 实现的标准语言，因此 localeCompare() 就是区分<br>大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他<br>地区恐怕就不是这种情况了。</p>
<ul>
<li><h4 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h4></li>
</ul>
<p>另外， String 构造函数本身还有一个静态方法： fromCharCode() 。这个方法的任务是接收一或<br>多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 charCodeAt()<br>执行的是相反的操作。来看一个例子：<br>alert(String.fromCharCode(104, 101, 108, 108, 111)); //“hello”<br>StringTypeFromCharCodeExample01.htm<br>在这里，我们给 fromCharCode() 传递的是字符串 “hello” 中每个字母的字符编码。</p>
<ul>
<li><h4 id="HTML-方法"><a href="#HTML-方法" class="headerlink" title="HTML 方法"></a>HTML 方法</h4>早期的 Web 浏览器提供商觉察到了使用 JavaScript 动态格式化 HTML 的需求。于是，这些提供商就<br>扩展了标准，实现了一些专门用于简化常见 HTML 格式化任务的方法。下表列出了这些 HTML 方法。<br>不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。</li>
</ul>
<p><img src="/2018/08/13/JavaScript-reference-type/" alt="表格"></p>
<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><ul>
<li><h4 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval() 方法"></a>eval() 方法</h4><blockquote>
<p>整个 ECMAScript 语言中 <strong>最强大的一个方法</strong> ： <strong>eval()</strong> 。</p>
</blockquote>
<p>eval() 方法就像一个完整的 <strong>ECMAScript 解析器</strong> ，它只接受一个参数，即要 <strong>执行的 ECMAScript（或 JavaScript）字符串</strong> 。看下面的例子：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"alert('hi')"</span>);</span><br></pre></td></tr></table></figure>
<p> 这行代码的作用等价于下面这行代码：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"hi"</span>);</span><br></pre></td></tr></table></figure></li></ul>
          <div id="read-more">
            <a href="/2018/08/13/JavaScript-reference-type/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
      
    </div>
    </article>
  
</section>

          
     <nav class="pagination">
    
      <a href="/">
        <span class="prev"><i class="iconfont icon-back"></i>上一页</span>
      </a>
    
    
      <a href="/page/3/">
        <span class="next">下一页<i class="iconfont icon-more"></i></span>
      </a>
    
  </nav>


          

      </main>
    </div>
    <footer>
      <div class="social-links">
        
          
            <a href="https://github.com/songxingguo"><i class="iconfont icon-github"></i></a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
      
        <div class="quote">
          <p>专注，极致，快</p>
        </div>
      
      <div class="copyright">
        <p>
          由 <a href="https://hexo.io/">Hexo</a> 强力驱动
          <span>|</span>
          主题 - <a href="https://github.com/wa-ri/hexo-theme-ztopic">ztopic</a>
          <span>|</span>
          Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        <p>
          <span>
          
          &copy;
          
            2018
          
          </span>
          <i class="iconfont icon-circle"></i>
          <span>songxingguo</span>
        </p>
      </div>
</footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <div id="mobile-nav">
  <nav id="mobile-nav-menu">
    
      <a href="/" class="mobile-nav-link"><i class="iconfont icon-home"></i>首页</a>
    
      <a href="/archives" class="mobile-nav-link"><i class="iconfont icon-archive"></i>归档</a>
    
      <a href="/categories" class="mobile-nav-link"><i class="iconfont icon-category"></i>分类</a>
    
      <a href="/tags" class="mobile-nav-link"><i class="iconfont icon-tags"></i>标签</a>
    
      <a href="/works" class="mobile-nav-link"><i class="iconfont icon-works"></i>作品</a>
    
      <a href="/about" class="mobile-nav-link"><i class="iconfont icon-about"></i>关于</a>
    
    <div class="mobile-intro"><i class="iconfont icon-pen"></i>写文章，做分享</div>
  </nav>
</div>


  <script src="/libs/jQuery/jquery-3.2.1.min.js"></script>
  <script src="/libs/slideout/slideout.min.js"></script>
  
    <link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css">
    <script src="/libs/fancybox/jquery.fancybox.pack.js"></script>
  
  
  <script src="//cdn1.lncld.net/static/js/3.2.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
        appId: "MNdCoL1O2i2njgRy8WVYgAwf-gzGzoHsz",
        appKey: "hil0yQTQDbO8nzaxFKqeSqyK"
      });
  </script>
  <script>
  (function (window) {
      $(document).ready(function () {
        visits();
      });
    function visits() {
      var $visits = $('.post-visits');

      function updateVisits(dom, time) {
        var text = dom.text() + ' ' + time;
        dom.text(text);
      }

      function addCounter(Counter) {
        var query = new AV.Query(Counter);

        var url = $visits.data('url').trim();
        var title = $visits.data('title').trim();

        query.equalTo('url', url);
        query.find().then(function (results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.save(null, {
              fetchWhenSave: true
            }).then(function (counter) {
              counter.increment('time', 1);
              return counter.save();
            }).then(function (counter) {
              updateVisits($visits, counter.get('time'));
            });
          } else {
            var newcounter = new Counter();
            newcounter.set('title', title);
            newcounter.set('url', url);
            newcounter.set('time', 1);

            newcounter.save().then(function (counter) {
              updateVisits($visits, newcounter.get('time'));
            });
          }
        }, function (error) {
          console.log('Error:' + error.code + " " + error.message);
        });
      }

      function showTime(Counter) {
        $visits.each(function () {
          var $this = $(this);
          var query = new AV.Query(Counter);
          var url = $this.data('url').trim();

          query.equalTo('url', url);
          query.find().then(function (results) {
            if (results.length === 0) {
              updateVisits($this, 0);
            } else {
              var counter = results[0];
              updateVisits($this, counter.get('time'));
            }
          }, function (error) {
            console.log('Error:' + error.code + " " + error.message);
          });
        })
      }

      if (typeof AV === 'object') {
        var Counter = AV.Object.extend('Counter');
        if ($visits.length === 1) {
          addCounter(Counter);
        } else {
          showTime(Counter);
        }
      }
    }
  })(window);
  </script>


  <script src="/js/ztopic.js"></script>
</body>
</html>

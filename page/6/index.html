<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#34495e">
  <title>阿有的博客</title>
  <link rel="alternate" href="path/of/rss" type="application/atom+xml">
  <link rel="shortcut icon" type="image/ico" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  

  

  

  

</head>

<body>
  <div class="mobile-header">
    <span><i class="iconfont icon-turnon" id="mobile-nav-toggle"></i></span>
    <div class="mobile-logo">
      <a href="/.">SongXingguo‘s blog</a>
    </div>
  </div>
  <div class="page" id="mobile-nav-panel">
    <div class="container">
      <header class="site-nav">
      <div class="nav-content">
        <div class="logo">
          <a href="/">SongXingguo‘s blog</a>
        </div>
        <nav class="navbar">
          <ul>
            
              <li class="menu-item">
                <a href="/" class="menu-item-link"><i class="iconfont icon-home"></i>首页</a>
              </li>
            
              <li class="menu-item">
                <a href="/archives" class="menu-item-link"><i class="iconfont icon-archive"></i>归档</a>
              </li>
            
              <li class="menu-item">
                <a href="/categories" class="menu-item-link"><i class="iconfont icon-category"></i>分类</a>
              </li>
            
              <li class="menu-item">
                <a href="/tags" class="menu-item-link"><i class="iconfont icon-tags"></i>标签</a>
              </li>
            
              <li class="menu-item">
                <a href="/works" class="menu-item-link"><i class="iconfont icon-works"></i>作品</a>
              </li>
            
              <li class="menu-item">
                <a href="/about" class="menu-item-link"><i class="iconfont icon-about"></i>关于</a>
              </li>
            
          </ul>
        </nav>
      </div>
</header>

      <div class="banner">
  <div class="show">
    <!-- <img src="/" alt="banner"> -->
    <div class="banner-title">
      
        <div class="intro">
          写文章，做分享
        </div>
      
    </div>
  </div>
</div>

      <main class="main"id="main">
          <section class="posts">
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/07/13/Windows/">Windows 10  常见问题处理</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-07-13</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/操作系统/">操作系统</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/07/13/Windows/"
                   data-title="Windows 10  常见问题处理">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h3 id="解决文件正在被使用问题"><a href="#解决文件正在被使用问题" class="headerlink" title="解决文件正在被使用问题"></a>解决文件正在被使用问题</h3><p>该问题解决分为两步，第一步，找到进程号；第二步，杀死它。</p>
<ul>
<li><p>复制被占用的文件路径</p>
<p>复制路径。</p>
<p><img src="http://p9myzkds7.bkt.clouddn.com/windows/%E5%A4%8D%E5%88%B6%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E8%B7%AF%E5%BE%84.png" alt="复制文件路径"></p>
</li>
</ul>
          <div id="read-more">
            <a href="/2018/07/13/Windows/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/Windows/">Windows</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/07/11/paper-writing/">论文书写</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-07-11</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/论文/">论文</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/07/11/paper-writing/"
                   data-title="论文书写">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>综合课程设计刚刚结束，在这次综合课程设计，是我第一次真正意义上的写了一次正规的论文，虽说只是得了一个良，但是心里依然很满足了，因为在整个过程中我学会了很多书写论文在格式上的要求以及对WPS工具（Word文档）的使用，为了不让记忆随着时间的流逝而消失，我打算将所有记忆在忘记之前封存于我的博客之中。</p>
<p>本文将从论文格式、WPS工具（Word文档）的使用、总结三个方面诉说我对于论文书写的一些看法。</p>
<p><a href="http://p9myzkds7.bkt.clouddn.com/paper/%E7%BB%BC%E5%90%88%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%AE%BA%E6%96%87%EF%BC%89%20.docx" target="_blank" rel="noopener">最终论文下载</a></p>
<p>特别说明：该论文格式要求为 <strong>重庆理工大学软件工程专业毕业论文格式</strong> 要求。</p>
          <div id="read-more">
            <a href="/2018/07/11/paper-writing/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/07/01/knex-js-other/">knex.js中文文档-其他</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-07-01</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/数据库/">数据库</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/07/01/knex-js-other/"
                   data-title="knex.js中文文档-其他">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h3 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h3><p>有时您可能需要在查询中使用原始表达式。原始查询对象可以在任何地方注入，并且使用正确的绑定可以确保正确地转义您的值，从而防止SQL注入攻击。</p>
<ul>
<li><h4 id="Raw-Parameter-Binding"><a href="#Raw-Parameter-Binding" class="headerlink" title="Raw Parameter Binding"></a>Raw Parameter Binding</h4><p>  人们可以参数化SQL给予knex.raw(sql, bindings)。参数可以是位置命名的。也可以选择参数是否应该被视为值或作为sql标识符，例如在’TableName.ColumnName’引用的情况下。</p>
<p>  例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">knex(&apos;users&apos;)</span><br><span class="line">.select(knex.raw(&apos;count(*) as user_count, status&apos;))</span><br><span class="line">.where(knex.raw(1))</span><br><span class="line">.orWhere(knex.raw(&apos;status &lt;&gt; ?&apos;, [1]))</span><br><span class="line">.groupBy(&apos;status&apos;)</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as user_count, status from `users` where 1 or status &lt;&gt; 1 group by `status`</span><br></pre></td></tr></table></figure></li></ul>
          <div id="read-more">
            <a href="/2018/07/01/knex-js-other/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/knexjs/">knexjs</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/07/01/knex.js-note/">knex.js 学习笔记</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-07-01</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/数据库/">数据库</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/07/01/knex.js-note/"
                   data-title="knex.js 学习笔记">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <ul>
<li><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><ul>
<li><p>内连接<br>— .join(table, first, [operator], second)</p>
<p>连接构建器可用于指定表之间的连接，第一个参数是连接表，后三个参数分别是第一个连接列，连接操作符和第二个连接列。(等同于自然连接）</p>
<p>  例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">knex(&apos;book as b&apos;)</span><br><span class="line">  .join(&apos;book_borrow as bb&apos;, &apos;b.book_id&apos;, &apos;bb.book_id&apos;)</span><br><span class="line">  .select(&apos;book_name as bookName&apos;, &apos;borrow_end_date as endDate&apos;, knex.raw(&apos;DATEDIFF( borrow_end_date,NOW()) as count&apos;))</span><br><span class="line">  .where(&#123;user_id: userId&#125;)</span><br><span class="line">  .orderBy(&apos;borrow_end_date&apos;).first()</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    `book_name` AS `bookName`,</span><br><span class="line">    `borrow_end_date` AS `endDate`,</span><br><span class="line">    DATEDIFF(borrow_end_date, NOW()) AS `count`</span><br><span class="line">FROM</span><br><span class="line">    `book` AS `b`</span><br><span class="line">INNER JOIN `book_borrow` AS `bb` ON `b`.`book_id` = `bb`.`book_id`</span><br><span class="line">WHERE</span><br><span class="line">    `user_id` = &apos;1&apos;</span><br><span class="line">ORDER BY</span><br><span class="line">    `borrow_end_date` ASC</span><br><span class="line">LIMIT 1</span><br></pre></td></tr></table></figure></li></ul></li></ul>
          <div id="read-more">
            <a href="/2018/07/01/knex.js-note/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/knexjs/">knexjs</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/06/30/koa学习笔记/">koa学习笔记</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-06-30</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/后端技术/">后端技术</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/06/30/koa学习笔记/"
                   data-title="koa学习笔记">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>Koa 依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持.</p>
</blockquote>
<p>你可以使用自己喜欢的版本管理器快速安装支持的 node 版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install 7</span><br><span class="line">npm i koa</span><br><span class="line">node app.js</span><br></pre></td></tr></table></figure>
<h3 id="使用-Babel-实现-Async-方法"><a href="#使用-Babel-实现-Async-方法" class="headerlink" title="使用 Babel 实现 Async 方法"></a>使用 Babel 实现 Async 方法</h3><blockquote>
<p>要在 node &lt; 7.6 版本的 Koa 中使用 async 方法, 我们推荐使用 <a href="https://babel.bootcss.com/docs/usage/babel-register/" target="_blank" rel="noopener">babel’s require hook</a>.</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;babel-register&apos;);</span><br><span class="line">// 应用的其余 require 需要被放到 hook 后面</span><br><span class="line">const app = require(&apos;./app&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要解析和编译 async 方法, 你至少应该有 <a href="https://babel.bootcss.com/docs/plugins/transform-async-to-generator/" target="_blank" rel="noopener">transform-async-to-generator</a> 或 <a href="https://babel.bootcss.com/docs/plugins/transform-async-to-module-method/" target="_blank" rel="noopener">transform-async-to-module-method</a> 插件.</p>
</blockquote>
<p>  新建 .babelrc 文件：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-async-to-generator&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  你也可以用 <a href="https://babel.bootcss.com/docs/plugins/preset-env/" target="_blank" rel="noopener">env preset</a> 的 target 参数 “node”: “current” 替代.</p>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><blockquote>
<p>Koa 应用程序是 <strong>一个包含一组中间件函数的对象</strong> ，它是 <strong>按照类似堆栈的方式组织和执行的</strong> 。 Koa 类似于你可能遇到过的许多其他中间件系统，例如 Ruby 的 Rack ，Connect 等，然而，一个关键的设计点是 <strong>在其低级中间件层中提供高级“语法糖”</strong> 。 这提高了 <strong>互操作性</strong> ，<strong>稳健性</strong> ，并使 <strong>书写中间件更加愉快</strong> 。<br>这包括诸如 <strong>内容协商</strong> ，<strong>缓存清理</strong> ，<strong>代理支持</strong> 和 <strong>重定向</strong> 等常见任务的方法。 尽管 <strong>提供了相当多的有用的方法 Koa 仍保持了一个很小的体积</strong> ，因为没有捆绑中间件。</p>
</blockquote>
<p>第一个Koa应用 hello world :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><blockquote>
<p>Koa 中间件以更传统的方式级联，您可能习惯使用类似的工具 - 之前难以让用户友好地使用 node 的回调。然而，使用 async 功能，我们可以实现 “真实” 的中间件。对比 Connect 的实现，通过一系列功能直接传递控制，直到一个返回，Koa 调用“下游”，然后控制流回“上游”。</p>
</blockquote>
<p> 下面以 “Hello World” 的响应作为示例，当请求开始时首先 <strong>请求流</strong> 通过 <strong>x-response-time</strong> 和 <strong>logging</strong>  中间件，然后继续移交控制给 <strong>response 中间件</strong> 。 当一个中间件调用 <strong>next() </strong> 则该函数 <strong>暂停并将控制传递给定义的下一个中间件</strong> 。 当在下游没有更多的中间件执行后，<strong>堆栈将展开并且每个中间件恢复执行其上游行为</strong> 。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">// logger</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  await next();</span><br><span class="line">  const rt = ctx.response.get(&apos;X-Response-Time&apos;);</span><br><span class="line">  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// x-response-time</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  const start = Date.now();</span><br><span class="line">  await next();</span><br><span class="line">  const ms = Date.now() - start;</span><br><span class="line">  ctx.set(&apos;X-Response-Time&apos;, `$&#123;ms&#125;ms`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// response</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>应用程序设置是 app 实例上的属性，目前支持如下：</p>
<p>app.env 默认是 NODE_ENV 或 “development”<br>app.proxy 当真正的代理头字段将被信任时<br>app.subdomainOffset 对于要忽略的 .subdomains 偏移[2]</p>
<h4 id="app-listen-…"><a href="#app-listen-…" class="headerlink" title="app.listen(…)"></a>app.listen(…)</h4><p>Koa 应用程序不是 HTTP 服务器的1对1展现。 可以将一个或多个 Koa 应用程序安装在一起以形成具有单个HTTP服务器的更大应用程序。</p>
<p>创建并返回 HTTP 服务器，将给定的参数传递给 Server#listen()。这些内容都记录在 nodejs.org.</p>
<p>以下是一个无作用的 Koa 应用程序被绑定到 3000 端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<p>这里的 app.listen(…) 方法只是以下方法的语法糖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">http.createServer(app.callback()).listen(3000);</span><br></pre></td></tr></table></figure>
<p>这意味着您可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const https = require(&apos;https&apos;);</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">http.createServer(app.callback()).listen(3000);</span><br><span class="line">https.createServer(app.callback()).listen(3001);</span><br></pre></td></tr></table></figure>
<h4 id="app-callback"><a href="#app-callback" class="headerlink" title="app.callback()"></a>app.callback()</h4><p>返回适用于 http.createServer() 方法的回调函数来处理请求。你也可以使用此回调函数将 koa 应用程序挂载到 Connect/Express 应用程序中。</p>
<h4 id="app-use-function"><a href="#app-use-function" class="headerlink" title="app.use(function)"></a>app.use(function)</h4><p>将给定的中间件方法添加到此应用程序。参阅 <a href="https://github.com/koajs/koa/wiki#middleware" target="_blank" rel="noopener">Middleware</a> 获取更多信息.</p>
<p>app.keys=<br>设置签名的 Cookie 密钥。</p>
<p>这些被传递给 <a href="https://github.com/crypto-utils/keygrip" target="_blank" rel="noopener">KeyGrip</a>，但是你也可以传递你自己的 KeyGrip 实例。</p>
<p>例如，以下是可以接受的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.keys = [&apos;im a newer secret&apos;, &apos;i like turtle&apos;];</span><br><span class="line">app.keys = new KeyGrip([&apos;im a newer secret&apos;, &apos;i like turtle&apos;], &apos;sha256&apos;);</span><br></pre></td></tr></table></figure>
<p>这些密钥可以倒换，并在使用 { signed: true } 参数签名 Cookie 时使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.set(&apos;name&apos;, &apos;tobi&apos;, &#123; signed: true &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="app-context"><a href="#app-context" class="headerlink" title="app.context"></a>app.context</h4><p>app.context 是从其创建 ctx 的原型。您可以通过编辑 app.context 为 ctx 添加其他属性。这对于将 ctx 添加到整个应用程序中使用的属性或方法非常有用，这可能会更加有效（不需要中间件）和/或 更简单（更少的 require()），而更多地依赖于ctx，这可以被认为是一种反模式。</p>
<p>例如，要从 ctx 添加对数据库的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.context.db = db();</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">  console.log(ctx.db);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong><br>ctx 上的许多属性都是使用 getter ，setter 和 Object.defineProperty() 定义的。你只能通过在 app.context 上使用 Object.defineProperty() 来编辑这些属性（不推荐）。查阅  <a href="https://github.com/koajs/koa/issues/652" target="_blank" rel="noopener">https://github.com/koajs/koa/issues/652</a>.<br>安装的应用程序目前使用其父级的 ctx 和设置。 因此，安装的应用程序只是一组中间件。</p>
</blockquote>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，将所有错误输出到 stderr，除非 app.silent 为 true。 当 err.status 是 404 或 err.expose 是 true 时默认错误处理程序也不会输出错误。 要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个 “error” 事件侦听器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class="line">  log.error(&apos;server error&apos;, err)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果 req/res 期间出现错误，并且 _无法_ 响应客户端，Context实例仍然被传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.on(&apos;error&apos;, (err, ctx) =&gt; &#123;</span><br><span class="line">  log.error(&apos;server error&apos;, err, ctx)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当发生错误 _并且_ 仍然可以响应客户端时，也没有数据被写入 socket 中，Koa 将用一个 500 “内部服务器错误” 进行适当的响应。在任一情况下，为了记录目的，都会发出应用级 “错误”。</p>

        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/koa/">koa</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/06/30/knex.js-query/">knex.js中文文档-查询</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-06-30</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/数据库/">数据库</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/06/30/knex.js-query/"
                   data-title="knex.js中文文档-查询">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h3 id="knexjs-简介"><a href="#knexjs-简介" class="headerlink" title="knexjs 简介"></a>knexjs 简介</h3><p> &emsp;&emsp;Knex.js是为Postgres，MSSQL，MySQL，MariaDB，SQLite3，Oracle和Amazon Redshift设计的“包含电池”SQL查询构建器，其设计灵活，便于携带并且使用起来非常有趣。它具有传统的节点样式回调以及用于清洁异步流控制的承诺接口，流接口，全功能查询和模式构建器，事务支持（带保存点），连接池 以及不同查询客户和方言之间的标准化响应。<a href="https://knexjs.org/#Installation-node" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li><h4 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h4><p>&emsp;&emsp;Knex的主要目标环境是Node.js，您需要安装该knex库，然后安装适当的数据库库：pg适用于PostgreSQL和Amazon Redshift，mysql适用于MySQL或MariaDB，sqlite3适用于SQLite3或mssql适用于MSSQL。</p>
</li>
</ul>
<hr>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ npm install knex --save</span><br><span class="line"></span><br><span class="line"># Then add one of the following (adding a --save) flag:</span><br><span class="line">$ npm install pg</span><br><span class="line">$ npm install sqlite3</span><br><span class="line">$ npm install mysql</span><br><span class="line">$ npm install mysql2</span><br><span class="line">$ npm install mariasql</span><br><span class="line">$ npm install strong-oracle</span><br><span class="line">$ npm install oracle</span><br><span class="line">$ npm install mssql</span><br></pre></td></tr></table></figure>
          <div id="read-more">
            <a href="/2018/06/30/knex.js-query/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/knexjs/">knexjs</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/06/29/refresh-boot/">小米MIX 2线刷步骤</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-06-29</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/操作系统/">操作系统</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/06/29/refresh-boot/"
                   data-title="小米MIX 2线刷步骤">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h3 id="刷机背景"><a href="#刷机背景" class="headerlink" title="刷机背景"></a>刷机背景</h3><p> MIUI 10首批机型在6月19日进行公测，作为小米发烧友的我也迫不及待想用上MIUI 10, 在<a href="http://www.miui.com/zt/miuirom/download.php" target="_blank" rel="noopener">MIUI 10首批机型公测下载</a> 中刷机包有两种，分别是卡刷包 和 线刷包。<a href="http://www.miui.com/shuaji-329.html" target="_blank" rel="noopener">卡刷包刷机</a> 就将刷机包下载到手机，使用手机的版本升级进行刷机，操作比较简单，但是要求只能是相同版本升级，跨版本就不行，比如：稳定版刷机到开发版就是不行的。当然了如果想进行跨版本的升级就只能使用线刷包，比较麻烦，下面我就说一下线刷过程，我只是将刷机步骤资源整合一下，具体步骤会通过链接查看。</p>
<ul>
<li>刷机机型为 小米MIX 2</li>
<li>刷机系统为 稳定版9.6.xx(具体那个版本记不清了）</li>
</ul>
<hr>
<h3 id="线刷大体思路"><a href="#线刷大体思路" class="headerlink" title="线刷大体思路"></a>线刷大体思路</h3><ol>
<li>线刷会清除数据，刷机前做好数据备份</li>
<li>打开开发者选项，绑定绑定账号和设备（可能是出于安全考虑，绑定之后需要72小时之后才能进行解锁BL）</li>
<li>小米手机解锁BL和上锁BL教程    </li>
<li>下载刷机包</li>
<li>下载刷机工具进行刷机</li>
</ol>
<p>友情提示：线刷的时候需要解锁BL，会降低系统安全性，但是使用刷机工具刷机之后会重新给系统上锁BL,所以刷机的小伙伴们，可以放心大胆的刷机。<br></p>
          <div id="read-more">
            <a href="/2018/06/29/refresh-boot/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/06/20/flex-layout/">Flex布局</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-06-20</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/前端技术/">前端技术</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/06/20/flex-layout/"
                   data-title="Flex布局">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>Flex布局分为：父容器和子容器，主轴和交叉轴。</p>
</li>
<li><p>关于Flex的属性一共有 <strong>13</strong> 个，分别是：</p>
<ol>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>flex-basis</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex</li>
<li>order</li>
<li>algn-self</li>
<li>display</li>
</ol>
</li>
</ul>
          <div id="read-more">
            <a href="/2018/06/20/flex-layout/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/Flex/">Flex</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/06/18/push-source-code/">将博客源码推送到github上</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-06-18</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/博客搭建/">博客搭建</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/06/18/push-source-code/"
                   data-title="将博客源码推送到github上">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <ul>
<li><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p> 已经搭建了一个Hexo博客</p>
</li>
<li><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p> &emsp;&emsp;使用命令 <code>Hexo d</code> 推送到github上的是Hexo生成的静态文件，而如果我们 换一台电脑就无法编辑博客了，所以我们需要把Hexo博客的源码推送到github上，方便我们在其他电脑上也能进行博客的编辑。也保证博客文章不会丢失。(但需要注意的是github上的仓库是开源的，也就是说所有人的都可以看到你的源代码）</p></li></ul>
          <div id="read-more">
            <a href="/2018/06/18/push-source-code/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/Hexo/">Hexo</a> <a class="tag-link" href="/tags/github/">github</a>
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2018/06/15/WeChat-Basics/">微信小程序基础学习</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2018-06-15</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/微信小程序/">微信小程序</a>
              
          
          <!---------------------------------------->
            
              <i class="iconfont icon-divide"></i>
              <div class="post-visits"
                   data-url="/2018/06/15/WeChat-Basics/"
                   data-title="微信小程序基础学习">
                  阅读次数
                </div>
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul>
<li><h4 id="模板的作用"><a href="#模板的作用" class="headerlink" title="模板的作用"></a>模板的作用</h4><p> 避免重复开发，提升效率。</p>
<p> 模板类似与React的组件思想提高重用性，但是模板只是只是包括视图和样式，并且两者需要分别引入对应的目标文件中。</p>
</li>
<li><h4 id="模板的定义"><a href="#模板的定义" class="headerlink" title="模板的定义"></a>模板的定义</h4><ol>
<li><p>创建模板文件</p>
<p><img src="http://p9myzkds7.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6.png" alt="模板文件"></p>
<ul>
<li>一个模板wxml文件中可以创建多个template，通过name进行区分。</li>
<li>ES6的扩展语法：<strong>…</strong> , 可以用于将数据解构之后传给模板使用。</li>
</ul>
</li>
<li><p>.xml文件中定义模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template name=&quot;list-item&quot;&gt;</span><br><span class="line">   &lt;view class=&quot;kind-list-item&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
          <div id="read-more">
            <a href="/2018/06/15/WeChat-Basics/">阅读更多</a>
          </div>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
        <a class="tag-link" href="/tags/WeChat/">WeChat</a>
      
    </div>
    </article>
  
</section>

          
     <nav class="pagination">
    
      <a href="/page/5/">
        <span class="prev"><i class="iconfont icon-back"></i>上一页</span>
      </a>
    
    
      <a href="/page/7/">
        <span class="next">下一页<i class="iconfont icon-more"></i></span>
      </a>
    
  </nav>


          

      </main>
    </div>
    <footer>
      <div class="social-links">
        
          
            <a href="https://github.com/songxingguo"><i class="iconfont icon-github"></i></a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
      
        <div class="quote">
          <p>专注，极致，快</p>
        </div>
      
      <div class="copyright">
        <p>
          由 <a href="https://hexo.io/">Hexo</a> 强力驱动
          <span>|</span>
          主题 - <a href="https://github.com/wa-ri/hexo-theme-ztopic">ztopic</a>
          <span>|</span>
          Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        <p>
          <span>
          
          &copy;
          
            2018
          
          </span>
          <i class="iconfont icon-circle"></i>
          <span>songxingguo</span>
        </p>
      </div>
</footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <div id="mobile-nav">
  <nav id="mobile-nav-menu">
    
      <a href="/" class="mobile-nav-link"><i class="iconfont icon-home"></i>首页</a>
    
      <a href="/archives" class="mobile-nav-link"><i class="iconfont icon-archive"></i>归档</a>
    
      <a href="/categories" class="mobile-nav-link"><i class="iconfont icon-category"></i>分类</a>
    
      <a href="/tags" class="mobile-nav-link"><i class="iconfont icon-tags"></i>标签</a>
    
      <a href="/works" class="mobile-nav-link"><i class="iconfont icon-works"></i>作品</a>
    
      <a href="/about" class="mobile-nav-link"><i class="iconfont icon-about"></i>关于</a>
    
    <div class="mobile-intro"><i class="iconfont icon-pen"></i>写文章，做分享</div>
  </nav>
</div>


  <script src="/libs/jQuery/jquery-3.2.1.min.js"></script>
  <script src="/libs/slideout/slideout.min.js"></script>
  
    <link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css">
    <script src="/libs/fancybox/jquery.fancybox.pack.js"></script>
  
  
  <script src="//cdn1.lncld.net/static/js/3.2.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
        appId: "MNdCoL1O2i2njgRy8WVYgAwf-gzGzoHsz",
        appKey: "hil0yQTQDbO8nzaxFKqeSqyK"
      });
  </script>
  <script>
  (function (window) {
      $(document).ready(function () {
        visits();
      });
    function visits() {
      var $visits = $('.post-visits');

      function updateVisits(dom, time) {
        var text = dom.text() + ' ' + time;
        dom.text(text);
      }

      function addCounter(Counter) {
        var query = new AV.Query(Counter);

        var url = $visits.data('url').trim();
        var title = $visits.data('title').trim();

        query.equalTo('url', url);
        query.find().then(function (results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.save(null, {
              fetchWhenSave: true
            }).then(function (counter) {
              counter.increment('time', 1);
              return counter.save();
            }).then(function (counter) {
              updateVisits($visits, counter.get('time'));
            });
          } else {
            var newcounter = new Counter();
            newcounter.set('title', title);
            newcounter.set('url', url);
            newcounter.set('time', 1);

            newcounter.save().then(function (counter) {
              updateVisits($visits, newcounter.get('time'));
            });
          }
        }, function (error) {
          console.log('Error:' + error.code + " " + error.message);
        });
      }

      function showTime(Counter) {
        $visits.each(function () {
          var $this = $(this);
          var query = new AV.Query(Counter);
          var url = $this.data('url').trim();

          query.equalTo('url', url);
          query.find().then(function (results) {
            if (results.length === 0) {
              updateVisits($this, 0);
            } else {
              var counter = results[0];
              updateVisits($this, counter.get('time'));
            }
          }, function (error) {
            console.log('Error:' + error.code + " " + error.message);
          });
        })
      }

      if (typeof AV === 'object') {
        var Counter = AV.Object.extend('Counter');
        if ($visits.length === 1) {
          addCounter(Counter);
        } else {
          showTime(Counter);
        }
      }
    }
  })(window);
  </script>


  <script src="/js/ztopic.js"></script>
</body>
</html>

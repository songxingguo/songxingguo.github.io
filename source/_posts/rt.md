title: 《大话数据结构》-读书笔记-排序
author: songxingguo
tags: []
categories:
  - 数据结构
date: 2018-10-14 09:26:00
---
## 排序

### 排序的基本概念与分类

假设含有n个记录的序列为{r1 ,r2 ,......,rn }，其相应的关键字分别为{k1 ,k2 ,......,kn }，需确定1,2,......,n的一种排列p1 ,p2 ,......,pn ，使其相 应的关键字满足kp1 ≤kp2 ≤......≤kpn （非递减或非递增）关系，即使得序列成为一个按关键字有序的序列{rp1 ,rp2 ,......,rpn }，这样的操作就 称为排序。

<!-- more -->

#### 排序的稳定性

根据两个相同数字在排序过程是否交换原有位置，排序分为：稳定排序和不稳定排序。

也正是由于排序不仅是针对主关键字，那么对于次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结 果可能会存在不唯一的情况，我们给出了稳定与不稳定排序的定义。

假设ki =kj (1≤i≤n,1≤j≤n,i≠j），且在排序前的序列中ri 领先于rj （即i<j）。如果排序后ri 仍领先于rj ，则称所用的排序方法是稳定的；反之， 若可能使得排序后的序列中rj 领先ri ，则称所用的排序方法是不稳定的。



#### 内排序与外排序 

根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。

内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序 过程需要在内外存之间多次交换数据才能进行。

对于内排序来说，排序算法的性能主要是受3个方面影响：

1．时间性能

排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中， 主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，事实 上，移动可以通过改变记录的存储方式来予以避免（这个我们在讲解具体的算法时再谈）。总之，高效率的内排序算法应该是具有尽可能少 的关键字比较次数和尽可能少的记录移动次数。

2．辅助空间

评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需 要的其他存储空间。

3．算法的复杂性

注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。

根据排序过程中借助的主要操作，我们把内排序分为：插入排序、交换排序、选择排序和归并排序。

按照算法的复杂度分为两大类，冒泡排序、简单选择排序和直接插入排序属于简单算法，而希尔排序、堆排序、归并排序、快速排序属于改进算法。

#### 排序用到的结构与函数

先提供一个用于排序用的顺序表结构：

```c
/* 用于要排序数组个数最大值，可根据需要修改 */ 
#define MAXSIZE 10         
typedef struct {    
  /* 用于存储要排序数组，r[0]用作哨兵或临时变量 */    
  int r[MAXSIZE + 1];        
  /* 用于记录顺序表的长度 */    
  int length;            
} SqList;
```
另外，由于排序最最常用到的操作是数组两元素的交换，我们将它写成函数：

```c
/* 交换L中数组r的下标为i和j的值 */ 
void swap(SqList *L, int i, int j) {    
  int temp = L->r[i];    
  L->r[i] = L->r[j];    
  L->r[j] = temp; 
}
```
```js
/* 交换arr中数组下标为i和j的值 */ 
function swap(arr, i, j) {
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
```
### 冒泡排序

#### 最简单排序实现

冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。

```c
/* 对顺序表L作交换排序(冒泡排序初级版) */
void BubbleSort0(SqList * L) {
  int i,
  j;
  for (i = 1; i < L - >length; i++) {
    for (j = i + 1; j <= L - >length; j++) {
      if (L - >r[i] > L - >r[j]) {
        /* 交换L->r[i]与L->r[j]的值 */
        swap(L, i, j);
      }
    }
  }
}
```
```js
/* 对顺序表arr作交换排序(冒泡排序初级版) */
function BubbleSort(arr) {
  for (var i = 0; i < arr.length; i++) {
    for (var j = i + i; j <= length; j++) {
       /* 交换arr[i]和arr[j]的值 */
       swap(arr, i, j);
    }
  }
}
```

这段代码严格意义上说，不算是标准的冒泡排序算法，因为它不满足“两两比较相邻记录”的冒泡排序思想，它更应该是最最简单的交换排序而已。它的思路就是让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。

![最简单冒泡排序]()

它应该算是最最容易写出的排序代码了，不过这个简单易懂的代码，却是有缺陷的。观察后发现，在排序好1和2的位置后，对其余关键字的排序没有什么帮助（数字3反而还被换到了最后一位）。也就是说，这个算法的效率是非常低的。

#### 冒泡排序算法

```c
/* 对顺序表L作冒泡排序 */
void BubbleSort(SqList * L) {
  int i,
  j;
  for (i = 1; i < L - >length; i++) {
    /* 注意j是从后往前循环 */
    for (j = L - >length - 1; j >= i; j--) {
      /* 若前者大于后者(注意这里与上一算法差异) */
      if (L - >r[j] > L - >r[j + 1]) {
        /* 交换L->r[j]与L->r[j+1]的值 */
        swap(L, j, j + 1);
      }
    }
  }
}
```
```js
function BubbleSort(arr) {
  for(var i = 0; i < arr.length; i++) {
    /* 注意j是从后往前循环 */
    for (j = arr.length - 1; j >= i; j--) {
      /* 若前者大于后者(注意这里与上一算法差异) */
      if (r[j] > r[j + 1]) {
        /* 交换arr[j]与arr[j+1]的值 */
        swap(arr, j, j + 1);
      }
    }
  }
}
```



<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML教程]]></title>
    <url>%2F2018%2F09%2F10%2FHTML%2F</url>
    <content type="text"><![CDATA[HTML 教程- (HTML5 标准)超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于 创建网页的标准标记语言 。 您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。 在本教程中，您将学习如何使用 HTML 来创建站点。 HTML 很容易学习！相信您能很快学会它！ HTML 实例本教程包含了数百个 HTML 实例。 使用本站的编辑器，您可以轻松实现在线修改 HTML，并查看实例运行结果。 注意：对于中文网页需要使用 声明编码，否则会出现乱码。有些浏览器(如 360 浏览器)会设置 GBK 为 默认编码 ，则你需要设置为 &lt;meta charset=&quot;gbk&quot;&gt; 。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML文档的后缀名 .html .htm 以上两种后缀名没有区别，都可以使用。 HTML 简介HTML 实例1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 实例解析 &lt;!DOCTYPE html&gt; 声明为 HTML5 文档 &lt;html&gt; 元素是 HTML 页面的根元素 &lt;head&gt; 元素包含了文档的元（meta）数据，如 定义网页编码格式为 utf-8。 &lt;title&gt; 元素描述了文档的标题 &lt;body&gt; 元素包含了可见的页面内容 &lt;h1&gt; 元素定义一个大标题 &lt;p&gt; 元素定义一个段落 什么是HTML?HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言: HyperText Markup Language HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 文档包含了HTML 标签及文本内容 HTML文档也叫做 web 页面 HTML 标签HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 1&lt;标签&gt;内容&lt;/标签&gt; HTML 元素“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思. 但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例: HTML 元素: 1&lt;p&gt;这是一个段落。&lt;/p&gt; Web 浏览器Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。 浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户： HTML 网页结构下面是一个可视化的HTML页面结构： 只有 &lt;body&gt; -区域 (-白色部分) -才会在浏览器中显示。 HTML版本从初期的网络诞生后，已经出现了许多HTML版本: &lt;!DOCTYPE&gt; 声明&lt;!DOCTYPE&gt;声明有助于浏览器中正确显示网页。 网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。 doctype 声明是不区分大小写的，以下方式均可： 1234567&lt;!DOCTYPE html&gt; &lt;!DOCTYPE HTML&gt; &lt;!doctype html&gt; &lt;!Doctype Html&gt; 通用声明HTML5 1&lt;!DOCTYPE html&gt; HTML 4.01 12&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt; XHTML 1.0 12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 查看完整网页声明类型 DOCTYPE 参考手册。 中文编码目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8。 HTML 实例 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; HTML 基础HTML 标题HTML 标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签来定义的. 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这是一个标题&lt;/h2&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt; HTML 段落HTML 段落是通过标签 &lt;p&gt; 来定义的. 12&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是另外一个段落。&lt;/p&gt; HTML 链接HTML 链接是通过标签 &lt;a&gt; 来定义的. 1&lt;a href="http://www.runoob.com"&gt;这是一个链接 `&lt;/a&gt;` 提示:在 href 属性中指定链接的地址。 HTML 图像HTML 图像是通过标签 &lt;img&gt; 来定义的. 1&lt;img src="/images/logo.png" width="258" height="39" /&gt; 注意： 图像的名称和尺寸是以属性的形式提供的。 HTML 元素HTML 文档由 HTML 元素定义。 HTML 元素 *开始标签常被称为起始标签（opening tag），结束标签常称为闭合标签（closing tag）。 HTML 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 注释: 您将在本教程的下一章中学习更多有关属性的内容。 嵌套的 HTML 元素HTML 文档由嵌套的 HTML 元素构成。 HTML 文档实例12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;这是第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 以上实例包含了三个 HTML 元素。 HTML 实例解析&lt;p&gt; 元素: 1&lt;p&gt;这是第一个段落。&lt;/p&gt; 这个 &lt;p&gt; 元素定义了 HTML 文档中的一个段落。这个元素拥有一个开始标签 &lt;p&gt; 以及一个结束标签 &lt;/p&gt;.元素内容是: 这是第一个段落。 &lt;body&gt; 元素: 123&lt;body&gt;&lt;p&gt;这是第一个段落。&lt;/p&gt;&lt;/body&gt; &lt;body&gt; 元素定义了 HTML 文档的主体。这个元素拥有一个开始标签 &lt;body&gt; 以及一个结束标签 &lt;/body&gt;。元素内容是另一个 HTML 元素（p 元素）。 &lt;html&gt; 元素： 1234567&lt;html&gt;&lt;body&gt;&lt;p&gt;这是第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;html&gt; 元素定义了整个 HTML 文档。这个元素拥有一个开始标签 &lt;html&gt; ，以及一个结束标签 &lt;/html&gt;.元素内容是另一个 HTML 元素（body 元素）。 不要忘记结束标签即使您忘记了使用结束标签，大多数浏览器也会正确地显示 HTML： 12&lt;p&gt;这是一个段落&lt;p&gt;这是一个段落 以上实例在浏览器中也能正常显示，因为关闭标签是可选的。 但不要依赖这种做法。忘记使用结束标签会产生不可预料的结果或错误。 HTML 空元素没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 &lt;br&gt; 就是没有关闭标签的空元素（&lt;br&gt; 标签定义换行）。 在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。 在开始标签中添加斜杠，比如 &lt;br /&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。 即使 &lt;br&gt; 在所有浏览器中都是有效的，但使用 &lt;br /&gt; 其实是更长远的保障。 HTML 提示：使用小写标签HTML 标签对大小写不敏感：&lt;P&gt; 等同于 &lt;p&gt;。许多网站都使用大写的 HTML 标签。 菜鸟教程使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。 HTML 属性属性是 HTML 元素提供的附加信息。 HTML 属性 HTML 元素可以设置属性 属性可以在元素中添加附加信息 属性一般描述于开始标签 属性总是以名称/值对的形式出现，比如：name=”value”。 属性实例HTML 链接由 &lt;a&gt; 标签定义。链接的地址在 href 属性中指定： 1&lt;a href="http://www.runoob.com"&gt;这是一个链接&lt;/a&gt; HTML 属性常用引用属性值属性值应该始终被包括在引号内。 双引号是最常用的，不过使用单引号也没有问题。 Remark提示: 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name=’John “ShotGun” Nelson’ HTML 提示：使用小写属性属性和属性值对大小写不敏感。 不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性/属性值。 而新版本的 (X)HTML 要求使用小写属性。 HTML 属性参考手册查看完整的HTML属性列表: HTML 标签参考手册。 下面列出了适用于大多数 HTML 元素的属性： HTML 标题HTML 标题标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 标签进行定义的. &lt;h1&gt; 定义最大的标题。 &lt;h6&gt; 定义最小的标题。 123&lt;h1&gt;这是一个标题。&lt;/h1&gt;&lt;h2&gt;这是一个标题。&lt;/h2&gt;&lt;h3&gt;这是一个标题。&lt;/h3&gt; 注释: 浏览器会自动地在标题的前后添加空行。 标题很重要请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题。 搜索引擎使用标题为您的网页的结构和内容编制索引。 因为用户可以通过标题来快速浏览您的网页，所以用标题来呈现文档结构是很重要的。 应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。 HTML 水平线&lt;hr&gt; 标签在 HTML 页面中创建水平线。 hr 元素可用于分隔内容。 12345&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;这是一个段落。&lt;/p&gt; HTML 注释可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。 注释写法如下: 1&lt;!-- 这是一个注释 --&gt; 注释: 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。 HTML 提示 - 如何查看源代码你是否看过一些网页然后惊叹它是如何实现的的。 如果您想找到其中的奥秘，只需要单击右键，然后选择”查看源文件”（IE）或”查看页面源代码”（Firefox），其他浏览器的做法也是类似的。这么做会打开一个包含页面 HTML 代码的窗口。 HTML 段落HTML 可以将文档分割为若干段落。 HTML 段落段落是通过 &lt;p&gt; 标签定义的。 12&lt;p&gt;这是一个段落 &lt;/p&gt;&lt;p&gt;这是另一个段落&lt;/p&gt; 注意：浏览器会自动地在段落的前后添加空行。（&lt;/p&gt; 是块级元素） 不要忘记结束标签即使忘了使用结束标签，大多数浏览器也会正确地将 HTML 显示出来： 12&lt;p&gt;这是一个段落&lt;p&gt;这是另一个段落 上面的例子在大多数浏览器中都没问题，但不要依赖这种做法。忘记使用结束标签会产生意想不到的结果和错误。 注释: 在未来的 HTML 版本中，不允许省略结束标签。 HTML 折行如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 &lt;br /&gt; 标签： &lt;p&gt; 这个 &lt;br&gt; 段落 &lt;br&gt; 演示了分行的效果 &lt;/p&gt; &lt;br /&gt; 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。 HTML 输出- 使用提醒我们无法确定 HTML 被显示的确切效果。屏幕的大小，以及对窗口的调整都可能导致不同的结果。 对于 HTML，您无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。 当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。 HTML 文本格式化HTML 文本格式化1234567加粗文本斜体文本电脑自动输出这是 下标 和 上标 HTML 格式化标签HTML 使用标签 &lt;b&gt;(“bold”) 与 &lt;i&gt;(“italic”) 对输出的文本进行格式, 如：粗体 or 斜体 这些HTML标签被称为格式化标签（请查看底部完整标签参考手册）。 通常标签 &lt;strong&gt; 替换加粗标签 &lt;b&gt; 来使用, &lt;em&gt; 替换 &lt;i&gt; 标签使用。然而，这些标签的含义是不同的：&lt;b&gt; 与 &lt;i&gt; 定义粗体或斜体文本。&lt;strong&gt; 或者 &lt;em&gt; 意味着你要呈现的文本是重要的，所以要突出显示。现今所有主要浏览器都能渲染各种效果的字体。不过，未来浏览器可能会支持更好的渲染效果。 HTML 文本格式化标签 HTML “计算机输出” 标签 HTML 引文, 引用, 及标签定义 HTML 链接HTML 使用超级链接与网络上的另一个文档相连。几乎可以在所有的网页中找到链接。点击链接可以从一张页面跳转到另一张页面。 HTML 超链接（链接）HTML使用标签 &lt;a&gt;来设置超文本链接。 超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。 当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。 在标签 &lt;a&gt; 中使用了href属性来描述链接的地址。 默认情况下，链接将以以下形式出现在浏览器中： 一个未访问过的链接显示为蓝色字体并带有下划线。 访问过的链接显示为紫色并带有下划线。 点击链接时，链接显示为红色并带有下划线。 注意：如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示。 HTML 链接语法链接的 HTML 代码很简单。它类似这样： 1&lt;a href="url"&gt;链接文本&lt;/a&gt; href 属性描述了链接的目标。. 1&lt;a href="http://www.runoob.com/"&gt;访问菜鸟教程&lt;/a&gt; 上面这行代码显示为：访问菜鸟教程 点击这个超链接会把用户带到菜鸟教程的首页。 提示: “链接文本” 不必一定是文本。图片或其他 HTML 元素都可以成为链接。 HTML 链接 - target 属性使用 target 属性，你可以定义被链接的文档在何处显示。 下面的这行会在新窗口打开文档： 1&lt;a href="http://www.runoob.com/" target="_blank"&gt;访问菜鸟教程!&lt;/a&gt; HTML 链接- id 属性id属性可用于创建在一个HTML文档书签标记。 提示: 书签是不以任何特殊的方式显示，在HTML文档中是不显示的，所以对于读者来说是隐藏的。 在HTML文档中插入ID: 1&lt;a id="tips"&gt;有用的提示部分&lt;/a&gt; 在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”： 1&lt;a href="#tips"&gt;访问有用的提示部分&lt;/a&gt; 或者，从另一个页面创建一个链接到”有用的提示部分(id=”tips”）”： 12&lt;a href="http://www.runoob.com/html/html-links.html#tips"&gt;访问有用的提示部分 &lt;/a&gt; 基本的注意事项 - 有用的提示注释： 请始终将正斜杠添加到子文件夹。假如这样书写链接：href=”http://www.runoob.com/html “，就会向服务器产生两次 HTTP 请求。这是因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href=”http://www.runoob.com/html/ “。 HTML 链接标签 HTML &lt;head&gt;HTML &lt;head&gt; 元素 元素包含了所有的头部标签元素。在 &lt;head&gt; 元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。 可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt;, and &lt;base&gt;. HTML &lt;title&gt; 元素&lt;title&gt; 标签定义了不同文档的标题。 &lt;title&gt; 在 HTML/XHTML 文档中是必须的。 &lt;title&gt; 元素: 定义了浏览器工具栏的标题 当网页添加到收藏夹时，显示在收藏夹中的标题 显示在搜索引擎结果页面的标题 一个简单的 HTML 文档: 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt; &lt;body&gt;文档内容......&lt;/body&gt; &lt;/html&gt; HTML &lt;base&gt; 元素&lt;base&gt; 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接: 123&lt;head&gt;&lt;base href="http://www.runoob.com/images/" target="_blank"&gt;&lt;/head&gt; HTML &lt;link&gt; 元素&lt;link&gt; 标签定义了文档与外部资源之间的关系。 &lt;link&gt; 标签通常用于链接到样式表: 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; HTML &lt;style&gt; 元素&lt;style&gt; 标签定义了HTML文档的样式文件引用地址. 在 &lt;style&gt; 元素中你也可以直接添加样式来渲染 HTML 文档: 123456&lt;head&gt;&lt;style type="text/css"&gt;body &#123;background-color:yellow&#125;p &#123;color:blue&#125;&lt;/style&gt;&lt;/head&gt; HTML &lt;meta&gt; 元素meta标签描述了一些基本的元数据。 &lt;meta&gt; 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。 META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。 元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。 &lt;meta&gt; 一般放置于 &lt;head&gt; 区域 &lt;meta&gt; 标签- 使用实例为搜索引擎定义关键词: 1&lt;meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript"&gt; 为网页定义描述内容: 1&lt;meta name="description" content="免费 Web &amp; 编程 教程"&gt; 定义网页作者: 1&lt;meta name="author" content="Runoob"&gt; 每30秒钟刷新当前页面: 1&lt;meta http-equiv="refresh" content="30"&gt; HTML &lt;script&gt; 元素&lt;script&gt; 标签用于加载脚本文件，如： JavaScript。 &lt;script&gt; 元素在以后的章节中会详细描述。 HTML head 元素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记- 变量、作用域和内存问题]]></title>
    <url>%2F2018%2F08%2F31%2FJavaScript-variables-scopes-and-memory%2F</url>
    <content type="text"><![CDATA[变量、作用域和内存问题按照 ECMA-262 的定义，JavaScript 的变量与其他语言的变量有很大区别。JavaScript 变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但 JavaScript 变量实际的复杂程度还远不止如此。 基本类型和引用类型的值ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第 3 章讨论了 5 种基本数据类型： Undefined 、 Null 、 Boolean 、 Number 和 String 。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。 引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置 ，也就是说 不能直接操作对象的内存空间 。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的（这种说法不严密，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。——图灵社区“壮壮的前端之路”注）。 在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript 放弃了这一传统。 动态的属性定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法 。请看下面的例子：**123var person = new Object();person.name = "Nicholas";alert(person.name); //"Nicholas" 以上代码创建了一个对象并将其保存在了变量 person 中。然后，我们为该对象添加了一个名为 name 的属性，并将字符串值 “Nicholas” 赋给了这个属性。紧接着，又通过 alert() 函数访问了这个新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。 但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如： 123var name = "Nicholas";name.age = 27;alert(name.age); //undefined 在这个例子中，我们为字符串 name 定义了一个名为 age 的属性，并为该属性赋值 27。但在下一行访问这个属性时，发现该属性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。 复制变量值除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。来看一个例子： 12var num1 = 5;var num2 = num1; 在此， num1 中保存的值是 5。当使用 num1 的值来初始化 num2 时， num2 中也保存了值 5。但 num2 中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。下图形象地展示了复制基本类型值的过程。 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，如下面的例子所示： 1234var obj1 = new Object();var obj2 = obj1;obj1.name = "Nicholas";alert(obj2.name); //"Nicholas" 首先，变量 obj1 保存了一个对象的新实例。然后，这个值被复制到了 obj2 中；换句话说， obj1 和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。图 4-2 展示了保存在变量对象中的变量和保存在堆中的对象之间的这种关系。 传递参数ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。请看下面这个例子： 12345678function addTen(num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);alert(count); //20，没有变化alert(result); //30 这里的函数 addTen() 有一个参数 num ，而参数实际上是函数的局部变量。在调用这个函数时，变量 count 作为参数被传递给函数，这个变量的值是20。于是，数值20被复制给参数 num 以便在 addTen() 中使用。在函数内部，参数 num 的值被加上了 10，但这一变化不会影响函数外部的 count 变量。参数 num 与变量 count 互不相识，它们仅仅是具有相同的值。假如 num 是按引用传递的话，那么变量 count 的值也将变成 30，从而反映函数内部的修改。当然，使用数值等基本类型值来说明按值传递参数比较简单，但如果使用对象，那问题就不怎么好理解了。再举一个例子： 123456function setName(obj) &#123; obj.name = "Nicholas";&#125;var person = new Object();setName(person);alert(person.name); //"Nicholas" 以上代码中创建一个对象，并将其保存在了变量 person 中。然后，这个变量被传递到 setName() 函数中之后就被复制给了 obj 。在这个函数内部， obj 和 person 引用的是同一个对象。换句话说，即使这个变量是按值传递的， obj 也会按引用来访问同一个对象。于是，当在函数内部为 obj 添加 name 属性后，函数外部的 person 也将有所反映；因为 person 指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子： 12345678function setName(obj) &#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;var person = new Object();setName(person);alert(person.name); //&quot;Nicholas&quot; 这个例子与前一个例子的唯一区别，就是在 setName() 函数中添加了两行代码：一行代码为 obj 重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的 name 属性。在把 person 传递给 setName() 后，其 name 属性被设置为 “Nicholas” 。然后，又将一个新对象赋给变量 obj ，同时将其 name 属性设置为 “Greg” 。如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值为 “Greg” 的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是 “Nicholas” 。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 可以把 ECMAScript 函数的参数想象成局部变量。 检测类型要检测一个变量是不是基本数据类型？第 3 章介绍的 typeof 操作符是最佳的工具。说得更具体一点， typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。如果变量的值是一个对象或 null ，则 typeof 操作符会像下面例子中所示的那样返回 “object” ： 123456789101112var s = "Nicholas";var b = true;var i = 22;var u;var n = null;var o = new Object();alert(typeof s); //stringalert(typeof i); //numberalert(typeof b); //booleanalert(typeof u); //undefinedalert(typeof n); //objectalert(typeof o); //object 虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof 操作符，其语法如下所示： 1result = variable instanceof constructor 如果变量是给定引用类型（根据它的原型链来识别；第 6 章将介绍原型链）的实例，那么 instanceof 操作符就会返回 true 。请看下面的例子： 123alert(person instanceof Object); // 变量 person 是 Object 吗？alert(colors instanceof Array); // 变量 colors 是 Array 吗？alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？ 根据规定，所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造函数时， instanceof 操作符始终会返回 true 。当然，如果使用 instanceof 操作符检测基本类型的值，则该操作符始终会返回 false ，因为基本类型不是对象。 使用 typeof 操作符检测函数时，该操作符会返回 “function” 。在 Safari 5 及之前版本和 Chrome 7 及之前版本中使用 typeof 检测正则表达式时，由于规范的原因，这个操作符也返回 “function” 。ECMA-262 规定任何在内部实现 [[Call]] 方法的对象都应该在应用 typeof 操作符时返回 “function” 。由于上述浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回 “function” 。在 IE 和 Firefox中，对正则表达式应用 typeof 会返回 “object” 。 执行环境及作用域执行环境（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。 请看下面的示例代码： 12345678910var color = "blue";function changeColor()&#123; if (color === "blue")&#123; color = "red"; &#125; else &#123; color = "blue"; &#125;&#125;changeColor();alert("Color is now " + color); 在这个简单的例子中，函数 changeColor() 的作用域链包含两个对象：它自己的变量对象（其中定义着 arguments 对象）和全局环境的变量对象。可以在函数内部访问变量 color ，就是因为可以在这个作用域链中找到它。 此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示： 1234567891011121314var color = "blue";function changeColor()&#123; var anotherColor = "red"; function swapColors()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; // 这里可以访问 color、anotherColor 和 tempColor &#125; // 这里可以访问 color 和 anotherColor，但不能访问 tempColor swapColors();&#125;// 这里只能访问 colorchangeColor(); 以上代码共涉及 3 个执行环境：全局环境、 changeColor() 的局部环境和 swapColors() 的局部环境。全局环境中有一个变量 color 和一个函数 changeColor() 。 changeColor() 的局部环境中有一个名为 anotherColor 的变量和一个名为 swapColors() 的函数，但它也可以访问全局环境中的变量 color 。 swapColors() 的局部环境中有一个变量 tempColor ，该变量只能在这个环境中访问到。 无论全局环境还是 changeColor() 的局部环境都无权访问 tempColor 。然而，在 swapColors() 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。下图形象地展示了前面这个例子的作用域链。 上图中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的 swapColors() 而言，其作用域链中包含 3 个对象： swapColors() 的变量对象、 changeColor() 的变量对象和全局变量对象。 swapColors() 的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。 changeColor() 的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问 swapColors() 的环境。 函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。 延长作用域链虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长： try-catch 语句的 catch 块； with 语句。 这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 下面看一个例子。 1234567function buildUrl() &#123; var qs = "?debug=true"; with(location)&#123; var url = href + qs; &#125; return url;&#125; 在此， with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。 buildUrl() 函数中定义了一个变量 qs 。当在 with 语句中引用变量 href 时（实际引用的是 location.href ），可以在当前执行环境的变量对象中找到。当引用变量 qs 时，引用的则是在 buildUrl() 中定义的那个变量，而该变量位于函数环境的变量对象中。至于 with 语句内部，则定义了一个名为 url 的变量，因而 url 就成了函数执行环境的一部分，所以可以作为函数的值被返回。 在 IE8 及之前版本的 JavaScript 实现中，存在一个与标准不一致的地方，即在 catch 语句中捕获的错误对象会被添加到执行环境的变量对象，而不是 catch 语句的变量对象中。换句话说，即使是在 catch 块的外部也可以访问到错误对象。IE9 修复了这个问题。 没有块级作用域JavaScript 没有块级作用域经常会导致理解上的困惑。在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域（如果用 ECMAScript 的话来讲，就是它们自己的执行环境），因而支持根据条件来定义变量。例如，下面的代码在 JavaScript 中并不会得到想象中的结果： 1234if (true) &#123; var color = &quot;blue&quot;;&#125;alert(color); //&quot;blue&quot; 这里是在一个 if 语句中定义了变量 color 。如果是在 C、C++或 Java中， color 会在 if 语句执行完毕后被销毁。但在 JavaScript 中， if 语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用 for 语句时尤其要牢记这一差异，例如： 1234for (var i=0; i &lt; 10; i++)&#123; doSomething(i);&#125;alert(i); //10 对于有块级作用域的语言来说， for 语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于 JavaScript 来说，由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在于循环外部的执行环境中。 声明变量使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。如下所示： 123456function add(num1, num2) &#123;var sum = num1 + num2; return sum;&#125;var result = add(10, 20); //30alert(sum); //由于 sum 不是有效的变量，因此会导致错误 以上代码中的函数 add() 定义了一个名为 sum 的局部变量，该变量包含加法操作的结果。虽然结果值从函数中返回了，但变量 sum 在函数外部是访问不到的。如果省略这个例子中的 var 关键字，那么当 add() 执行完毕后， sum 也将可以访问到： 123456function add(num1, num2) &#123; sum = num1 + num2; return sum;&#125;var result = add(10, 20); //30alert(sum); //30 这个例子中的变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完 add() 之后，添加到全局环境中的变量 sum 将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。 在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。 查询标识符 当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。 通过下面这个示例，可以理解查询标识符的过程： 12345var color = "blue";function getColor()&#123; return color;&#125;alert(getColor()); //"blue" 调用本例中的函数 getColor() 时会引用变量 color 。为了确定变量 color 的值，将开始一个两步的搜索过程。首先，搜索 getColor() 的变量对象，查找其中是否包含一个名为 color 的标识符。 在没有找到的情况下，搜索继续到下一个变量对象（全局环境的变量对象），然后在那里找到了名为 color 的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。下图形象地展示了上述搜索过程。 在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符，如下面的例子所示： 123456var color = "blue";function getColor()&#123; var color = "red"; return color;&#125;alert(getColor()); //"red" 修改后的代码在 getColor() 函数中声明了一个名为 color 的局部变量。调用函数时，该变量就会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量 color 的值。搜索过程首先从局部环境中开始，而且在这里发现了一个名为 color 的变量，其值为 “red” 。因为变量已经找到了，所以搜索即行停止， return 语句就使用这个局部变量，并为函数会返回 “red” 。也就是说，任何位于局部变量 color 的声明之后的代码，如果不使用 window.color 都无法访问全局 color变量。 变量查询也不是没有代价的。很明显，访问局部变 量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript 引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。 垃圾收集JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。 下面我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。 标记清除JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到 2008 年为止，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript 实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 引用计数另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。 Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。请看下面这个例子： 123456function problem()&#123; var objectA = new Object(); var objectB = new Object(); objectA.someOtherObject = objectB; objectB.anotherObject = objectA;&#125; 在这个例子中， objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后， objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，Netscape 在 Navigator 4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。 我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM（Component Object Model，组件对象模型）对象的形式实现的，而 COM 对象的垃圾收集机制采用的就是引用计数策略。因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题： 1234var element = document.getElementById(&quot;some_element&quot;);var myObject = new Object();myObject.element = element;element.someObject = myObject; 这个例子在一个 DOM 元素（ element ）与一个原生 JavaScript 对象（ myObject ）之间创建了循环引用。其中，变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有一个属性名叫 someObject 回指 myObject 。由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收。 为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生JavaScript 对象与 DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用： 12myObject.element = null;element.someObject = null; 将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 为了解决上述问题，IE9 把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。 导致循环引用的情况不止这些，其他一些情况将在本书中陆续介绍。 性能问题垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一次，不禁让人联想到 IE 因此而声名狼藉的性能问题。IE 的垃圾收集器是根据内存分配量运行的，具体一点说就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64KB 的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。 随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。如果垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。 事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。在 IE 中，调用 window.CollectGarbage() 方法会立即执行垃圾收集。在 Opera 7 及更高版本中，调用 window.opera.collect() 也会启动垃圾收集例程。 管理内存使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示： 12345678910function createPerson(name)&#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson("Nicholas");// 手工解除 globalPerson 的引用globalPerson = null; 在这个例子中，变量 globalPerson 取得了 createPerson() 函数返回的值。在 createPerson() 函数内部，我们创建了一个对象并将其赋给局部变量 localPerson ，然后又为该对象添加了一个名为 name 的属性。最后，当调用这个函数时， localPerson 以函数值的形式返回并赋给全局变量 globalPerson 。由于 localPerson 在 createPerson() 函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用。但是对于全局变量 globalPerson 而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。 不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。 小结JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下 5 种基本数据类型： Undefined 、 Null 、 Boolean 、 Number 和 String 。基本类型值和引用类型值具有以下特点： 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象； 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。 所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结： 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分； 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链； 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境； 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据； 变量的执行环境有助于确定应该何时释放内存。 JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对 JavaScript 的垃圾收集例程作如下总结。 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。 “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript 引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记- 基本概念]]></title>
    <url>%2F2018%2F08%2F30%2FJavaScript-basic-concepts%2F</url>
    <content type="text"><![CDATA[基本概念任何语言的核心都必然会描述这门语言最基本的工作原理。而描述的内容通常都要涉及这门语言的 语法 、操作符 、数据类型 、内置功能 等用于构建复杂解决方案的基本概念。如前所述，ECMA-262 通过叫做 ECMAScript 的“伪语言”为我们描述了 JavaScript 的所有这些基本概念。 目前，ECMA-262 第 3 版中定义的 ECMAScript 是各浏览器实现最多的一个版本。ECMA-262 第 5 版是浏览器接下来实现的版本，但截止到 2011 年底，还没有浏览器完全实现了这个版本。为此，本章将主要按照第 3 版定义的 ECMAScript 介绍这门语言的基本概念，并就第 5 版的变化给出说明。 语法ECMAScript 的语法大量借鉴了 C 及其他类 C 语言（如 Java 和 Perl）的语法。因此，熟悉这些语言的开发人员在接受 ECMAScript 更加宽松的语法时，一定会有一种轻松自在的感觉。 区分大小写要理解的第一个概念就是 ECMAScript 中的一切（变量、函数名和操作符）都 区分大小写 。这也就意味着，变量名 test 和变量名 Test 分别表示两个不同的变量 ，而 函数名不能使用 typeof ，因为它是一个关键字（3.2 节介绍关键字），但 typeOf 则完全可以是一个有效的函数名 。 标识符所谓 标识符 ，就是指 变量、函数、属性的名字 ，或者 函数的参数 。标识符可以是按照下列格式规则组合起来的一或多个字符： 第一个字符必须是一个字母、下划线（ _ ）或一个美元符号（ $ ）； 其他字符可以是字母、下划线、美元符号或数字 。 标识符中的字母也可以包含扩展的 ASCII 或 Unicode字母字符（如 À和 Æ），但我们 不推荐这样做 。 按照惯例，ECMAScript 标识符 采用 驼峰大小写格式 ，也就是第一个字母小写，剩下的每个单词的首字母大写，例如： 123firstSecondmyCardoSomethingImportant 虽然没有谁强制要求必须采用这种格式，但为了与 ECMAScript 内置的函数和对象命名格式保持一致，可以将其当作一种最佳实践。 不能把关键字、保留字、 true 、 false 和 null 用作标识符。3.2节将介绍更多相关内容。 注释ECMAScript 使用 C 风格的注释，包括 单行注释和 块级注释 。单行注释以两个斜杠开头 ，如下所示： 1// 单行注释 块级注释以一个斜杠和一个星号（ / ）开头，以一个星号和一个斜杠（ / ）结尾 ，如下所示： 1234/** 这是一个多行* （块级）注释*/ 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性（这种格式在企业级应用中用得比较多）。 严格模式ECMAScript 5 引入了 严格模式（strict mode）的概念。严格模式 是 为 JavaScript 定义了一种不同的解析与执行模型 。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式 ，可以在顶部添加如下代码： 1&quot;use strict&quot;; 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个 编译指示（pragma），用于 告诉支持的 JavaScript 引擎切换到严格模式 。这是为不破坏 ECMAScript 3 语法而特意选定的语法。 在函数内部的上方包含这条编译指示 ，也可以 指定函数在严格模式下执行 ： 1234function doSomething()&#123; "use strict"; //函数体&#125; 严格模式下，JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括 IE10+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome。 语句ECMAScript 中的语句以一个分号结尾 ；如果 省略分号 ，则 由解析器确定语句的结尾 ，如下例所示： 12var sum = a + b // 即使没有分号也是有效的语句——不推荐var diff = a - b; // 有效的语句——推荐 虽然语句结尾的分号不是必需的，但我们建议任何时候都不要省略它。因为 加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地 通过删除多余的空格来压缩 ECMAScript 代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能 ，因为这样 解析器就不必再花时间推测应该在哪里插入分号了 。 可以使用 C 风格的语法把多条语句组合到一个代码块中，即 代码块以左花括号（ { ）开头，以右花括号（ } ）结尾 ： 1234if (test)&#123; test = false; alert(test);&#125; 虽然条件控制语句（如 if 语句）只在执行多条语句的情况下才要求使用代码块，但最佳实践是 始终在控制语句中使用代码块 ——即使 代码块中只有一条语句 ，例如： 123456if (test) alert(test); // 有效但容易出错，不要使用if (test)&#123; // 推荐使用 alert(test);&#125; 在控制语句中 使用代码块可以让编码意图更加清晰 ，而且 也能降低修改代码时出错的几率 。 关键字和保留字ECMA-262 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符 。以下就是 ECMAScript 的全部关键字（带 * 号上标的是第 5 版新增的关键字）： ECMA-262 还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。以下是 ECMA-262 第 3 版定义的全部保留字： 第 5 版把在非严格模式下运行时的保留字缩减为下列这些： 在严格模式下，第 5 版还对以下保留字施加了限制： 注意， let 和 yield 是第 5 版新增的保留字；其他保留字都是第 3 版定义的。为了最大程度地保证兼容性，建议读者将第 3 版定义的保留字外加 let 和 yield 作为编程时的参考。 在实现 ECMAScript 3 的 JavaScript 引擎中使用关键字作标识符，会导致“Identifier Expected”错误。而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。 第 5 版对使用关键字和保留字的规则进行了少许修改。关键字和保留字虽然仍然不能作为标识符使用，但现在可以用作对象的属性名。一般来说，最好都不要使用关键字和保留字作为标识符和属性名，以便与将来的 ECMAScript 版本兼容。 除了上面列出的保留字和关键字，ECMA-262 第 5 版对 eval 和 arguments 还施加了限制。在 严格模式 下，这两个名字也不能作为标识符或属性名 ，否则会抛出错误。 变量ECMAScript 的变量 是 松散类型 的，所谓 松散类型 就是 可以用来保存任何类型的数据 。换句话说，每个变量仅仅是一个用于保存值的占位符而已 。定义变量时要使用 var 操作符（注意 var 是一个关键字），后跟变量名（即一个标识符），如下所示： 1var message; 这行代码定义了一个名为 message 的变量，该变量可以用来保存任何值（像这样 未经过初始化的变量 ，会保存一个特殊的值—— undefined ，相关内容将在 3.4 节讨论）。ECMAScript 也支持直接初始化变量 ，因此在定义变量的同时就可以设置变量的值，如下所示： 1var message = "hi"; 在此，变量 message 中保存了一个字符串值 “hi” 。像这样初始化变量并不会把它标记为字符串类型；初始化的过程就是给变量赋一个值那么简单 。因此，可以在修改变量值的同时修改值的类型 ，如下所示： 12var message = "hi";message = 100; // 有效，但不推荐 在这个例子中，变量 message 一开始保存了一个字符串值 “hi” ，然后该值又被一个数字值 100 取代。虽然我们不建议修改变量所保存值的类型，但这种操作在 ECMAScript 中完全有效。 有一点必须注意，即用 var 操作符定义的变量 将成为定义该变量的作用域中的 局部变量 。也就是说，如果在 函数中使用 var 定义一个变量 ，那么这个变量在 函数退出后就会被销毁 ，例如： 12345function test()&#123; var message = "hi"; // 局部变量&#125;test();alert(message); // 错误！ 这里，变量 message 是在函数中使用 var 定义的。当函数被调用时，就会创建该变量并为其赋值。 而在此之后，这个变量又会立即被销毁，因此例子中的下一行代码就会导致错误。不过，可以像下面这样 省略 var 操作符 ，从而 创建一个全局变量 ： 12345function test()&#123; message = "hi"; // 全局变量&#125;test();alert(message); // "hi" 这个例子省略了 var 操作符，因而 message 就成了全局变量。这样，只要调用过一次 test() 函数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。 虽然 省略 var 操作符可以定义全局变量 ，但这也 不是我们推荐的做法 。因为在局部作用域中定义的全局变量很难维护，而且如果有意地忽略了 var 操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误 。 可以使用 一条语句定义多个变量 ，只要像下面这样把 每个变量（初始化或不初始化均可）用逗号分隔开即可 ： 123var message = &quot;hi&quot;, found = false, age = 29; 这个例子定义并初始化了 3 个变量。同样由于 ECMAScript 是松散类型的，因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高可读性 。 在 严格模式 下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误 。 数据类型ECMAScript 中有 5 种简单数据类型 （也称为基本数据类型）： Undefined 、 Null 、 Boolean 、 Number 和 String 。还有 1种复杂数据类型 —— Object ， Object 本质上是 由一组无序的名值对组成的 。ECMAScript 不支持任何创建自定义类型的机制 ，而 所有值最终都将是上述 6 种数据类型之一 。乍一看，好像只有 6 种数据类型不足以表示所有数据；但是，由于 ECMAScript 数据类型具有动态性，因此的确没有再定义其他数据类型的必要了。 typeof 操作符鉴于 ECMAScript 是松散类型的，因此需要有一种手段来 检测给定变量的数据类型 —— typeof 就是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串： “undefined” ——如果这个值未定义； “boolean” ——如果这个值是布尔值； “string” ——如果这个值是字符串； “number” ——如果这个值是数值； “object” ——如果这个值是对象或 null ； “function” ——如果这个值是函数。 下面是几个使用 typeof 操作符的例子： 1234var message = "some string";alert(typeof message); // "string"alert(typeof(message)); // "string"alert(typeof 95); // "number" 这几个例子说明， typeof 操作符 的操作数可以是 变量（ message ），也可以是 数值字面量 。注意，typeof 是一个操作符而不是函数 ，因此例子中的 圆括号尽管可以使用，但不是必需的 。 有些时候， typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null 会返回 “object” ，因为 特殊值 null 被认为是一个空的对象引用 。Safari 5 及之前版本、Chrome 7 及之前版本在对正则表达式调用 typeof 操作符时会返回 “function” ，而其他浏览器在这种情况下会返回 “object” 。 从技术角度讲，函数在 ECMAScript中是对象 ，不是一种数据类型。然而，函数也确实有一些特殊的属性 ，因此 通过 typeof 操作符来区分函数和其他对象是有必要的 。 Undefined 类型Undefined 类型 只有一个值，即特殊的 undefined 。在使用 var 声明变量 但 未对其加以初始化 时，这个变量的值就是 undefined ，例如： 12var message;alert(message == undefined); //true 这个例子只声明了变量 message ，但未对其进行初始化。比较这个变量与 undefined 字面量，结果表明它们是相等的。这个例子与下面的例子是等价的： 12var message = undefined;alert(message == undefined); //true 这个例子使用 undefined 值显式初始化了变量 message 。但我们没有必要这么做，因为未经初始化的值默认就会取得 undefined 值。 一般而言，不存在需要显式地把一个变量设置为 undefined 值的情况。字面值undefined 的主要目的是用于比较 ，而 ECMA-262 第 3 版之前的版本中并没有规定这个值。第 3 版引入这个值是为了正式区分空对象指针与未经初始化的变量。 不过，包含 undefined 值的变量与尚未定义的变量还是不一样的 。看看下面这个例子： 1234567var message; // 这个变量声明之后默认取得了 undefined 值// 下面这个变量并没有声明// var agealert(message); // "undefined"alert(age); // 产生错误 运行以上代码，第一个警告框会显示变量 message 的值，即 “undefined” 。而第二个警告框——由于传递给 alert() 函数的是尚未声明的变量 age ——则会导致一个错误。对于 尚未声明过的变量 ，只能执行一项操作，即 使用 typeof 操作符检测其数据类型（对未经声明的变量调用 delete 不会导致错误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。 然而，令人困惑的是：对 未初始化的变量 执行 typeof 操作符会返回 undefined 值 ，而对 未声明的变量 执行 typeof 操作符同样也会返回 undefined 值 。来看下面的例子： 1234567var message; // 这个变量声明之后默认取得了 undefined 值// 下面这个变量并没有声明// var agealert(typeof message); // "undefined"alert(typeof age); // "undefined" 结果表明，对未初始化和未声明的变量执行 typeof 操作符都返回了 undefined 值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。 即便 未初始化的变量会自动被赋予 undefined 值 ，但 显式地初始化变量依然是明智的选择 。如果能够做到这一点，那么 当 typeof 操作符返回 “undefined” 值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化 。 Null 类型Null 类型 是第二个只有一个值的数据类型，这个特殊的值是 null 。从逻辑角度来看， null 值 表示 一个空对象指针 ，而 这也正是使用 typeof 操作符检测 null 值时会返回 “object” 的原因 ，如下面的例子所示： 12var car = null;alert(typeof car); // &quot;object&quot; 如果 定义的变量准备在将来用于保存对象 ，那么最好将该变量 初始化为 null 而不是其他值。这样一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用 ，如下面的例子所示： 123if (car != null)&#123; // 对 car 对象执行某些操作&#125; 实际上， undefined 值是派生自 null 值的 ，因此 ECMA-262规定对它们的相等性测试要返回 true ： 1alert(null == undefined); //true 这里，位于 null 和 undefined 之间的相等操作符（ == ）总是返回 true ，不过要注意的是，这个操作符出于比较的目的会转换其操作数（本章后面将详细介绍相关内容）。 尽管 null 和 undefined 有这样的关系 ，但 它们的用途完全不同 。如前所述，无论在什么情况下都 没有必要把一个变量的值显式地设置为 undefined ，可是同样的规则对 null 却不适用。换句话说，只要意在保存对象的变量还 没有真正保存对象 ，就 应该明确地让该变量保存 null 值 。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined 。 Boolean 类型Boolean 类型 是 ECMAScript 中使用得最多的一种类型，该类型只有两个字面值： true 和 false 。这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于 0 。以下是为变量赋 Boolean 类型值的例子： 12var found = true;var lost = false; 需要注意的是， Boolean 类型 的 字面值 true 和 false 是 区分大小写 的。也就是说， True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。 虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。要 将一个值转换为其对应的 Boolean 值 ，可以 调用转型函数 Boolean() ，如下例所示： 12var message = "Hello world!";var messageAsBoolean = Boolean(message); 在这个例子中，字符串 message 被转换成了一个 Boolean 值，该值被保存在 messageAsBoolean 变量中。可以对任何数据类型的值调用 Boolean() 函数，而且总会返回一个 Boolean 值 。至于返回的这个值是 true 还是 false ，取决于要转换值的数据类型及其实际值。下表给出了 各种数据类型及其对应的转换规则 。 （n/a（或 N/A），是 not applicable的缩写，意思是“不适用”。） 这些 转换规则 对 理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换非常重要 ，请看下面的代码： 1234var message = "Hello world!";if (message)&#123; alert("Value is true");&#125; 运行这个示例，就会显示一个警告框，因为字符串 message 被自动转换成了对应的 Boolean 值（ true ）。由于存在这种自动执行的 Boolean 转换，因此确切地知道在流控制语句中使用的是什么变量至关重要。错误地使用一个对象而不是一个 Boolean 值，就有可能彻底改变应用程序的流程。 Number 类型Number 类型 应该是 ECMAScript 中最令人关注的数据类型了，这种类型使用 IEEE754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262 定义了不同的数值字面量格式。 最基本的数值字面量格式是 十进制整数，十进制整数可以像下面这样直接在代码中输入： 1var intNum = 55; // 整数 除了以十进制表示外，整数还可以通过 八进制（以 8 为基数）或 十六进制（以 16 为基数）的字面值来表示。其中，八进制字面值 的 第一位必须是零（0），然后是 八进制数字序列（0～7）。如果 字面值中的数值超出了范围 ，那么 前导零将被忽略 ，后面的数值将被当作十进制数值解析 。请看下面的例子： 123var octalNum1 = 070; // 八进制的 56var octalNum2 = 079; // 无效的八进制数值——解析为 79var octalNum3 = 08; // 无效的八进制数值——解析为 8 八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。 十六进制字面值 的 前两位必须是 0x ，后跟任何十六进制数字（0～9 及 A～F）。其中，字母 A～F 可以大写，也可以小写 。如下面的例子所示： 12var hexNum1 = 0xA; // 十六进制的 10var hexNum2 = 0x1f; // 十六进制的 31 在进行 算术计算 时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值 。 鉴于 JavaScript 中保存数值的方式，可以保存正零（+0）和负零（-0） 。正零和负零被认为相等 ，但为了读者更好地理解上下文，这里特别做此说明。 浮点数值所谓 浮点数值 ，就是 该数值中必须包含一个小数点 ，并且小数点后面必须至少有一位数字。虽然 小数点前面可以没有整数 ，但我们 不推荐这种写法 。以下是浮点数值的几个例子： 123var floatNum1 = 1.1;var floatNum2 = 0.1;var floatNum3 = .1; // 有效，但不推荐 由于 保存浮点数值 需要的 内存空间是保存整数值的两倍 ，因此 ECMAScript会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存 。同样地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数 ，如下面的例子所示： 12var floatNum1 = 1.; // 小数点后面没有数字——解析为 1var floatNum2 = 10.0; // 整数——解析为 10 对于那些 极大或极小的数值 ，可以 用 e 表示法（即科学计数法）表示的浮点数值表示。用 e 表示法 表示的数值等于 e 前面的数值乘以 10 的指数次幂 。ECMAScript 中 e 表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点数），中间是一个大写或小写的字母 E，后面是 10 的幂中的指数，该幂值将用来与前面的数相乘。下面是一个使用 e 表示法表示数值的例子： 1var floatNum = 3.125e7; // 等于 31250000 在这个例子中，使用 e 表示法表示的变量 floatNum 的形式虽然简洁，但它的实际值则是 31250000。在此，e 表示法的实际含义就是“3.125 乘以 10 7 ”。 也可以使用 e 表示法表示极小的数值，如 0.00000000000000003，这个数值可以使用更简洁的 3e-17表示。在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值（例如，0.0000003 会被转换成 3e-7）。 浮点数值的最高精度是 17 位小数 ，但 在进行算术计算时其精确度远远不如整数 。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。例如： 123if (a + b == 0.3)&#123; // 不要做这样的测试！ alert("You got 0.3.");&#125; 在这个例子中，我们测试的是两个数的和是不是等于 0.3。如果这两个数是 0.05 和 0.25，或者是 0.15 和 0.15 都不会有问题。而如前所述，如果这两个数是 0.1 和 0.2，那么测试将无法通过。因此，永远不要测试某个特定的浮点数值 。 关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于 IEEE754 数值的浮点计算的通病 ，ECMAScript 并非独此一家；其他使用相同数值格式的语言也存在这个问题。 数值范围由于内存的限制，ECMAScript 并不能保存世界上所有的数值。ECMAScript 能够表示的 最小数值 保存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324 ；能够表示的 最大数值 保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308 。如果某次计算的结果得到了一个 超出 JavaScript 数值范围的值 ，那么 这个数值将被自动转换成特殊的 Infinity 值 。具体来说，如果 这个数值是负数 ，则会被转换成 -Infinity （负无穷），如果 这个数值是正数 ，则会被转换成 Infinity （正无穷）。 如上所述，如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。要想 确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用 isFinite() 函数 。这个函数在参数位于最小与最大数值之间时会返回 true ，如下面的例子所示： 12var result = Number.MAX_VALUE + Number.MAX_VALUE;alert(isFinite(result)); //false 尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。 访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以得到负和正 Infinity 的值。可以想见，这两个属性中分别保存着 -Infinity 和 Infinity 。 NaNNaN ，即 非数值（Not a Number）是一个特殊的数值，这个数值用于表示 一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以 0都会导致错误，从而停止代码执行。但在 ECMAScript中，任何数值除以 0 会返回 NaN （原书如此，但实际上只有 0除以 0 才会返回 NaN，正数除以 0 返回 Infinity，负数除以 0返回-Infinity。） ，因此不会影响其他代码的执行。 NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 NaN /10）都会返回 NaN ，这个特点在多步计算中有可能导致问题。其次， NaN 与任何值都不相等 ，包括 NaN 本身。例如，下面的代码会返回 false ： 1alert(NaN == NaN); //false 针对 NaN 的这两个特点，ECMAScript 定义了 isNaN() 函数 。这个函数接受一个参数，该参数可以是 任何类型 ，而函数会帮我们确定这个参数是否“不是数值”。 isNaN() 在接收到一个值之后，会尝试将这个值转换为数值 。某些不是数值的值会直接转换为数值，例如字符串 “10” 或 Boolean 值。而 任何不能被转换为数值的值都会导致这个函数返回 true 。请看下面的例子： 12345alert(isNaN(NaN)); //truealert(isNaN(10)); //false（10 是一个数值）alert(isNaN("10")); //false（可以被转换成数值 10）alert(isNaN("blue")); //true（不能转换成数值）alert(isNaN(true)); //false（可以被转换成数值 1） 这个例子测试了 5 个不同的值。测试的第一个值是 NaN 本身，结果当然会返回 true 。然后分别测试了数值 10 和字符串 “10” ，结果这两个测试都返回了 false ，因为前者本身就是数值，而后者可以被转换成数值。但是，字符串 “blue” 不能被转换成数值，因此函数返回了 true 。由于 Boolean 值 true可以转换成数值 1，因此函数返回 false 。 尽管有点儿不可思议，但 isNaN() 确实也适用于对象 。在基于对象调用 isNaN()函数时，会首先调用对象的 valueOf() 方法 ，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString() 方法 ，再测试返回值。而这个过程也是 ECMAScript中内置函数和操作符的一般执行流程，更详细的内容请参见 3.5 节。 数值转换有 3 个函数可以 把非数值转换为数值 ： Number() 、 parseInt() 和 parseFloat() 。第一个函数，即转型函数 Number() 可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3个函数对于同样的输入会有返回不同的结果。 Number() 函数的转换规则如下。 如果是 Boolean 值， true 和 false 将分别被转换为 1 和 0。 如果是数字值，只是简单的传入和返回。 如果是 null 值，返回 0。 如果是 undefined ，返回 NaN 。 如果是字符串，遵循下列规则： 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即 “1”会变成 1， “123” 会变成 123，而 “011” 会变成 11（注意：前导的零被忽略了）； 如果字符串中包含有效的浮点格式，如 “1.1” ，则将其转换为对应的浮点数值（同样，也会忽略前导零）； 如果字符串中包含有效的十六进制格式，例如 “0xf” ，则将其转换为相同大小的十进制整数值； 如果字符串是空的（不包含任何字符），则将其转换为 0； 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN 。 如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN ，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。 根据这么多的规则使用 Number() 把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。 1234var num1 = Number("Hello world!"); //NaNvar num2 = Number(""); //0var num3 = Number("000011"); //11var num4 = Number(true); //1 首先，字符串 “Hello world!” 会被转换为 NaN ，因为其中不包含任何有意义的数字值。空字符串会被转换为 0。字符串 “000011” 会被转换为 11，因为忽略了其前导的零。最后， true 值被转换为 1。 一元加操作符（3.5.1 节将介绍）的操作与 Number() 函数相同。 由于 Number() 函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parseInt() 函数。 parseInt() 函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号， parseInt()就会返回 NaN ；也就是说，用 parseInt() 转换空字符串会返回 NaN （ Number() 对空字符返回 0）。如果第一个字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如， “1234blue” 会被转换为 1234，因为 “blue” 会被完全忽略。类似地， “22.5” 会被转换为 22，因为小数点并不是有效的数字字符。 如果字符串中的第一个字符是数字字符， parseInt() 也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以 “0x” 开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以 “0” 开头且后跟数字字符，则会将其当作一个八进制数来解析。 为了更好地理解 parseInt() 函数的转换规则，下面给出一些例子： 1234567var num1 = parseInt("1234blue"); // 1234var num2 = parseInt(""); // NaNvar num3 = parseInt("0xA"); // 10（十六进制数）var num4 = parseInt(22.5); // 22var num5 = parseInt("070"); // 56（八进制数）var num6 = parseInt("70"); // 70（十进制数）var num7 = parseInt("0xf"); // 15（十六进制数） 在使用 parseInt() 解析像八进制字面量的字符串时，ECMAScript 3和 5 存在分歧。例如： 12//ECMAScript 3 认为是 56（八进制），ECMAScript 5 认为是 70（十进制）var num = parseInt("070"); 在 ECMAScript 3 JavaScript 引擎中， “070” 被当成八进制字面量，因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中， parseInt() 已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成 “70” ，结果就得到十进制的 70。在 ECMAScript 5 中，即使是在非严格模式下也会如此。 为了消除在使用 parseInt() 函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第二个参数，可以保证得到正确的结果，例如： 1var num = parseInt("0xAF", 16); //175 实际上，如果指定了 16 作为第二个参数，字符串可以不带前面的 “0x” ，如下所示： 12var num1 = parseInt("AF", 16); //175var num2 = parseInt("AF"); //NaN 这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉 parseInt() 要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就自动终止了。 指定基数会影响到转换的输出结果。例如： 1234var num1 = parseInt("10", 2); //2 （按二进制解析）var num2 = parseInt("10", 8); //8 （按八进制解析）var num3 = parseInt("10", 10); //10 （按十进制解析）var num4 = parseInt("10", 16); //16 （按十六进制解析） 不指定基数意味着让 parseInt() 决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。 多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是非常必要的。 与 parseInt() 函数类似， parseFloat() 也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，”22.34.5” 将会被转换为 22.34。 除了第一个小数点有效之外， parseFloat() 与 parseInt() 的第二个区别在于它始终都会忽略前导的零。 parseFloat() 可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 parseFloat() 只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零）， parseFloat() 会返回整数。以下是使用 parseFloat() 转换数值的几个典型示例。 123456var num1 = parseFloat("1234blue"); //1234 （整数）var num2 = parseFloat("0xA"); //0var num3 = parseFloat("22.5"); //22.5var num4 = parseFloat("22.34.5"); //22.34var num5 = parseFloat("0908.5"); //908.5var num6 = parseFloat("3.125e7"); //31250000 String 类型String 类型 用于 表示由零或多个 16 位 Unicode 字符组成的字符序列 ，即字符串 。字符串可以由双引号（”）或单引号（’）表示 ，因此下面两种字符串的写法都是有效的： 12var firstName = "Nicholas";var lastName = 'Zakas'; 与 PHP 中的双引号和单引号会影响对字符串的解释方式不同，ECMAScript 中的这两种语法形式没有什么区别。用双引号表示的字符串和用单引号表示的字符串完全相同。不过，以双引号开头的字符串也必须以双引号结尾 ，而 以单引号开头的字符串必须以单引号结尾 。例如，下面这种字符串表示法会导致语法错误： 1var firstName = &apos;Nicholas&quot;; // 语法错误（左右引号必须匹配） 字符字面量String 数据类型包含一些特殊的字符字面量，也叫 转义序列 ，用于表示 非打印字符 ，或者 具有其他用途的字符 。这些字符字面量如下表所示： 这些 字符字面量可以出现在字符串中的任意位置 ，而且 也将被作为一个字符来解析 ，如下面的例子所示： 1var text = "This is the letter sigma: \u03a3."; 这个例子中的变量 text 有 28 个字符，其中 6 个字符长的转义序列表示 1 个字符。任何字符串的长度都可以通过访问其 length 属性取得，例如： 1alert(text.length); // 输出 28 这个属性返回的字符数包括 16 位字符的数目。如果 字符串中包含双字节字符 ，那么 length 属性可能不会精确地返回字符串中的字符数目 。 字符串的特点ECMAScript 中的 字符串是不可变的 ，也就是说，字符串一旦创建 ，它们的值就不能改变 。要 改变某个变量保存的字符串 ，首先要 销毁原来的字符串 ，然后再 用另一个包含新值的字符串填充该变量 ，例如： 12var lang = "Java";lang = lang + "Script"; 以上示例中的变量 lang 开始时包含字符串 “Java” 。而第二行代码把 lang 的值重新定义为 “Java”与 “Script” 的组合，即 “JavaScript” 。实现这个操作的过程如下：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充 “Java” 和 “Script” ，最后一步是销毁原来的字符串 “Java” 和字符串 “Script” ，因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版本的浏览器（例如版本低于 1.0 的 Firefox、IE6 等）中拼接字符串时速度很慢的原因所在。但这些浏览器后来的版本已经解决了这个低效率问题。 转换为字符串要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString() 方法（第 5 章将讨论这个方法的特点）。这个方法唯一要做的就是返回相应值的字符串表现。来看下面的例子： 1234var age = 11;var ageAsString = age.toString(); // 字符串"11"var found = true;var foundAsString = found.toString(); // 字符串"true" 数值、布尔值、对象 和 字符串值（没错，每个字符串也都有一个 toString() 方法，该方法返回字符串的一个副本）都有 toString() 方法 。但 null 和 undefined 值没有这个方法 。 多数情况下，调用 toString() 方法不必传递参数。但是，在调用数值的 toString() 方法时，可以传递一个参数：输出数值的基数 。默认情况 下， toString() 方法以十进制格式返回数值的字符串表示 。而通过 传递基数 ， toString() 可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值 。下面给出几个例子： 123456var num = 10;alert(num.toString()); // "10"alert(num.toString(2)); // "1010"alert(num.toString(8)); // "12"alert(num.toString(10)); // "10"alert(num.toString(16)); // "a" 通过这个例子可以看出，通过指定基数， toString() 方法会改变输出的值。而数值 10 根据基数的不同，可以在输出时被转换为不同的数值格式。注意，默认的（没有参数的）输出值与指定基数 10 时的输出值相同。 在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String() ，这个函数能够将任何类型的值转换为字符串。 String() 函数遵循下列转换规则： 如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 null ，则返回 “null” ； 如果值是 undefined ，则返回 “undefined” 。 下面再看几个例子： 12345678var value1 = 10;var value2 = true;var value3 = null;var value4;alert(String(value1)); // "10"alert(String(value2)); // "true"alert(String(value3)); // "null"alert(String(value4)); // "undefined" 这里先后转换了 4 个值：数值、布尔值、 null 和 undefined 。数值和布尔值的转换结果与调用 toString() 方法得到的结果相同。因为 null 和 undefined 没有 toString() 方法，所以 String() 函数就返回了这两个值的字面量。 要把某个值转换为字符串，可以使用加号操作符（3.5 节讨论）把它与一个字符串（ “” ）加在一起。 Object 类型ECMAScript 中的对象其实就是 一组数据和功能的集合 。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建 。而 创建 Object 类型的实例 并 为其添加属性和（或）方法 ，就 可以创建自定义对象 ，如下所示： 1var o = new Object(); 这个语法与 Java 中创建对象的语法相似；但在 ECMAScript 中，如果 不给构造函数传递参数 ，则 可以省略后面的那一对圆括号 。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这 不是推荐的做法 ）： 1var o = new Object; // 有效，但不推荐省略圆括号 仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想：即在 ECMAScript 中，（就像 Java 中的 java.lang.Object 对象一样） Object 类型是所有它的实例的基础 。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object 的每个实例都具有下列属性和方法。 constructor ：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object() 。 hasOwnProperty(propertyName) ：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如： o.hasOwnProperty(“name”) ）。 isPrototypeOf(object) ：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。 propertyIsEnumerable(propertyName) ：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。 toLocaleString() ：返回对象的字符串表示，该字符串与执行环境的地区对应。 toString() ：返回对象的字符串表示。 valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。 由于在 ECMAScript 中 Object 是所有对象的基础，因此 所有对象都具有这些基本的属性和方法 。第 5 章和第 6 章将详细介绍 Object 与其他对象的关系。 从技术角度讲，ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此 宿主对象可能会也可能不会继承 Object 。 操作符ECMA-262 描述了一组 用于操作数据值的操作符 ，包括 算术操作符（如加号和减号）、位操作符 、关系操作符 和 相等操作符 。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf() 和（或） toString() 方法，以便取得可以操作的值。 一元操作符只能操作一个值的操作符 叫做 一元操作符 。一元操作符是 ECMAScript 中最简单的操作符。 递增和递减操作符递增和递减操作符直接借鉴自 C，而且各有两个版本：前置型和后置型。顾名思义，前置型应该位于要操作的变量之前，而后置型则应该位于要操作的变量之后 。因此，在使用前置递增操作符给一个数值加 1 时，要把两个加号（++）放在这个数值变量前面，如下所示： 12var age = 29;++age; 在这个例子中，前置递增操作符把 age 的值变成了 30（为 29 加上了 1）。实际上，执行这个前置递增操作与执行以下操作的效果相同： 12var age = 29;age = age + 1; 执行前置递减操作的方法也类似，结果会从一个数值中减去 1。使用前置递减操作符时，要把两个减号（ – ）放在相应变量的前面，如下所示： 12var age = 29;--age; 这样， age 变量的值就减少为 28（从 29 中减去了 1）。执行前置递增和递减操作 时，变量的值都是在语句被求值以前改变的 。（在计算机科学领域，这种情况通常被称作副效应。）请看下面这个例子。 1234var age = 29;var anotherAge = --age + 2;alert(age); // 输出 28alert(anotherAge); // 输出 30 这个例子中变量 anotherAge 的初始值等于变量 age 的值前置递减之后加 2。由于先执行了减法操作， age 的值变成了 28，所以再加上 2 的结果就是 30。 由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。再看一个例子： 1234var num1 = 2;var num2 = 20;var num3 = --num1 + num2; // 等于 21var num4 = num1 + num2; // 等于 21 在这里， num3 之所以等于 21 是因为 num1 先减去了 1 才与 num2 相加。而变量 num4 也等于 21 是因为相应的加法操作使用了 num1 减去 1 之后的值。 后置型递增和递减操作符的语法不变（仍然分别是 ++ 和 – ），只不过要放在变量的后面而不是前面。 后置递增和递减与前置递增和递减有一个非常重要的区别，即 递增和递减操作是在包含它们的语句被求值之后才执行的 。这个区别在某些情况下不是什么问题，例如： 12var age = 29;age++; 把递增操作符放在变量后面并不会改变语句的结果，因为递增是这条语句的唯一操作。但是，当语句中还包含其他操作时，上述区别就会非常明显了。请看下面的例子： 1234var num1 = 2;var num2 = 20;var num3 = num1-- + num2; // 等于 22var num4 = num1 + num2; // 等于 21 这里仅仅将前置递减改成了后置递减，就立即可以看到差别。在前面使用前置递减的例子中， num3 和 num4 最后都等于 21。而在这个例子中， num3 等于 22， num4 等于 21。差别的根源在于，这里在计算 num3 时使用了 num1 的原始值（2）完成了加法计算，而 num4 则使用了递减后的值（1）。 所有这 4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN （第 4 章将详细讨论）。字符串变量变成数值变量。 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。 在应用于浮点数值时，执行加减 1 的操作。 在应用于对象时，先调用对象的 valueOf() 方法（第 5 章将详细讨论）以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN ，则在调用 toString() 方法后再应用前述规则。对象变量变成数值变量。 以下示例展示了上面的一些规则： 1234567891011121314var s1 = "2";var s2 = "z";var b = false;var f = 1.1;var o = &#123; valueOf: function() &#123; return -1; &#125;&#125;;s1++; // 值变成数值 3s2++; // 值变成 NaNb++; // 值变成数值 1f--; // 值变成 0.10000000000000009（由于浮点舍入错误所致）o--; // 值变成数值-2 一元加和减操作符绝大多数开发人员对一元加和减操作符都不会陌生，而且这两个 ECMAScript 操作符的作用与数学书上讲的完全一样。一元加操作符以一个加号（+）表示， 放在数值前面 ，对数值不会产生任何影响 ，如下面的例子所示： 12var num = 25;num = +num; // 仍然是 25 不过，在 对非数值应用一元加操作符 时，该操作符会像 Number() 转型函数 一样对这个值执行转换。 换句话说，布尔值 false 和 true 将被转换为 0 和 1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的 valueOf() 和（或） toString() 方法，再 转换得到的值 。 下面的例子展示了对不同数据类型应用一元加操作符的结果： 12345678910111213141516var s1 = "01";var s2 = "1.1";var s3 = "z";var b = false;var f = 1.1;var o = &#123; valueOf: function() &#123; return -1; &#125;&#125;;s1 = +s1; // 值变成数值 1s2 = +s2; // 值变成数值 1.1s3 = +s3; // 值变成 NaNb = +b; // 值变成数值 0f = +f; // 值未变，仍然是 1.1o = +o; // 值变成数值-1 一元减操作符主要用于表示负数 ，例如将 1 转换成-1。下面的例子演示了这个简单的转换过程： 12var num = 25;num = -num; // 变成了-25 在将一元减操作符应用于数值时，该值会变成负数（如上面的例子所示）。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下面的例子所示： 12345678910111213141516var s1 = "01";var s2 = "1.1";var s3 = "z";var b = false;var f = 1.1;var o = &#123; valueOf: function() &#123; return -1; &#125;&#125;;s1 = -s1; // 值变成了数值-1s2 = -s2; // 值变成了数值-1.1s3 = -s3; // 值变成了 NaNb = -b; // 值变成了数值 0f = -f; // 变成了-1.1o = -o; // 值变成了数值 1 一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。 位操作符位操作符用于在最基本的层次上，即 按内存中表示数值的位来操作数值 。ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先 将 64 位的值转换成 32 位的整数 ，然后 执行操作 ，最后再 将结果转换回 64 位 。对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。 对于有符号的整数，32 位中的 前 31 位用于表示整数的值 。第 32 位用于表示数值的符号 ：0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31 位中的每一位都表示 2 的幂。第一位（叫做位 0）表示 2 0 ，第二位表示 2 1 ，以此类 推 。 没 有 用 到 的 位 以 0 填 充 ， 即 忽 略 不 计 。 例 如 ， 数 值 18 的 二 进 制 表 示 是00000000000000000000000000010010，或者更简洁的 10010。这是 5 个有效位，这 5 位本身就决定了实际的值（如下图所示）。 负数同样以二进制码存储，但使用的格式是 二进制补码 。计算一个数值的二进制补码，需要经过下列 3 个步骤： 求这个数值绝对值的二进制码（例如，要求-18 的二进制补码，先求 18 的二进制码）； 求二进制反码，即将 0 替换为 1，将 1 替换为 0； 得到的二进制反码加 1。 要根据这 3 个步骤求得-18 的二进制码，首先就要求得 18 的二进制码，即： 10000 0000 0000 0000 0000 0000 0001 0010 然后，求其二进制反码，即 0 和 1 互换： 11111 1111 1111 1111 1111 1111 1110 1101 最后，二进制反码加 1： 12341111 1111 1111 1111 1111 1111 1110 11011---------------------------------------1111 1111 1111 1111 1111 1111 1110 1110 这样，就求得了18 的二进制表示，即 11111111111111111111111111101110。要注意的是，在处理有符号整数时，是不能访问位 31 的。 ECMAScript 会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示： 12var num = -18;alert(num.toString(2)); // "-10010" 要把数值-18 转换成二进制字符串时，得到的结果是 “-10010” 。这说明转换过程理解了二进制补码并将其以更合乎逻辑的形式展示了出来。 默认情况下，ECMAScript 中的所有整数都是有符号整数。不过，当然也存在无符号整数。对于无符号整数来说，第 32 位不再表示符号，因为无符号整数只能是正数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示数值。 在 ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成 32 位数值，然后执行位操作，最后再将 32 位的结果转换回 64 位数值。这样，表面上看起来就好像是在操作 32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。 如果对非数值应用位操作符，会先使用 Number() 函数将该值转换为一个数值（自动完成），然后再应用位操作。得到的结果将是一个数值。 按位非（NOT）按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。按位非是 ECMAScript 操作符中少数几个与二进制计算有关的操作符之一。下面看一个例子： 123var num1 = 25; // 二进制 00000000000000000000000000011001var num2 = ~num1; // 二进制 11111111111111111111111111100110alert(num2); // -26 这里，对 25 执行按位非操作，结果得到了-26。这也验证了按位非操作的本质：操作数的负值减 1。因此，下面的代码也能得到相同的结果： 123var num1 = 25;var num2 = -num1 - 1;alert(num2); // "-26" 虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底层执行操作，因此速度更快。 按位与（AND）按位与操作符由一个和号字符（ &amp; ）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行 AND 操作： 简而言之，按位与操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。 下面看一个对 25 和 3 执行按位与操作的例子： 12var result = 25 &amp; 3;alert(result); //1 可见，对 25 和 3 执行按位与操作的结果是 1。为什么呢？请看其底层操作： 123425 = 0000 0000 0000 0000 0000 0000 0001 10013 = 0000 0000 0000 0000 0000 0000 0000 0011---------------------------------------------AND = 0000 0000 0000 0000 0000 0000 0000 0001 原来，25 和 3 的二进制码对应位上只有一位同时是 1，而其他位的结果自然都是 0，因此最终结果等于 1。 按位或（OR）按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或操作遵循下面这个真值表。 由此可见，按位或操作在有一个位是 1的情况下就返回 1，而只有在两个位都是 0的情况下才返回 0。如果在前面按位与的例子中对 25 和 3 执行按位或操作，则代码如下所示： 12var result = 25 | 3;alert(result); //27 25 与 3 按位或的结果是 27： 123425 = 0000 0000 0000 0000 0000 0000 0001 10013 = 0000 0000 0000 0000 0000 0000 0000 0011--------------------------------------------OR = 0000 0000 0000 0000 0000 0000 0001 1011 这两个数值的都包含 4个 1，因此可以把每个 1直接放到结果中。二进制码 11011等于十进制值 27。 按位异或（XOR）按位异或操作符由一个插入符号（^）表示，也有两个操作数。以下是按位异或的真值表。 按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。 对 25 和 3 执行按位异或操作的代码如下所示： 12var result = 25 ^ 3;alert(result); //26 25 与 3 按位异或的结果是 26，其底层操作如下所示： 123425 = 0000 0000 0000 0000 0000 0000 0001 10013 = 0000 0000 0000 0000 0000 0000 0000 0011---------------------------------------------XOR = 0000 0000 0000 0000 0000 0000 0001 1010 这两个数值都包含 4 个 1，但第一位上则都是 1，因此结果的第一位变成了 0。而其他位上的 1 在另一个数值中都没有对应的 1，可以直接放到结果中。二进制码 11010 等于十进制值 26（注意这个结果比执行按位或时小 1）。 左移左移操作符由两个小于号（&lt;&lt;）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，如果将数值 2（二进制码为 10）向左移动 5 位，结果就是 64（二进制码为 1000000），代码如下所示： 12var oldValue = 2; // 等于二进制的 10var newValue = oldValue &lt;&lt; 5; // 等于二进制的 1000000，十进制的 64 注意，在向左移位后，原数值的右侧多出了 5 个空位。左移操作会以 0 来填充这些空位，以便得到的结果是一个完整的 32 位二进制数（见下图）。 注意，左移不会影响操作数的符号位。换句话说，如果将2向左移动 5位，结果将是-64，而非 64。 有符号的右移有符号的右移操作符由两个大于号（&gt;&gt;）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将 64 向右移动 5 位，结果将变回 2： 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧（下图）。而此时 ECMAScript 会用符号位的值来填充所有空位，以便得到一个完整的值。 无符号右移无符号右移操作符由 3 个大于号（&gt;&gt;&gt;）表示，这个操作符会将数值的所有 32 位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将 64 无符号右移 5 位，结果仍然还是 2： 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 但是对负数来说，情况就不一样了。首先，无符号右移是以 0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示： 12var oldValue = -64; // 等于二进制的 11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于十进制的 134217726 这里，当对64 执行无符号右移 5 位的操作后，得到的结果是 134217726。之所以结果如此之大，是因为-64 的二进制码为 11111111111111111111111111000000，而且无符号右移操作会把这个二进制码当成正数的二进制码，换算成十进制就是 4294967232。如果把这个值右移 5 位，结果就变成了 00000111111111111111111111111110，即十进制的 134217726。 布尔操作符在一门编程语言中，布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力，那么诸如 if…else 和循环之类的语句就不会有用武之地了。布尔操作符一共有 3 个：非（NOT）、与（AND）和或（OR）。 逻辑非逻辑非操作符由一个叹号（！）表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。也就是说，逻辑非操作符遵循下列规则： 如果操作数是一个对象，返回 false ； 如果操作数是一个空字符串，返回 true ；- 如果操作数是一个非空字符串，返回 false ； 如果操作数是数值 0，返回 true ； 如果操作数是任意非 0 数值（包括 Infinity ），返回 false ； 如果操作数是 null ，返回 true ； 如果操作数是 NaN ，返回 true ； 如果操作数是 undefined ，返回 true 。 下面几个例子展示了应用上述规则的结果： 123456alert(!false); // truealert(!"blue"); // falsealert(!0); // truealert(!NaN); // truealert(!""); // truealert(!12345); // false 逻辑非操作符也可以用于将一个值转换为与其对应的布尔值 。而 同时使用两个逻辑非操作符 ，实际上就会模拟 Boolean() 转型函数 的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 Boolean() 函数相同，如下面的例子所示： 12345alert(!!&quot;blue&quot;); //truealert(!!0); //falsealert(!!NaN); //falsealert(!!&quot;&quot;); //falsealert(!!12345); //true 逻辑与逻辑与操作符由两个和号（ &amp;&amp; ）表示，有两个操作数，如下面的例子所示： 1var result = true &amp;&amp; false; 逻辑与的真值表如下： 逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第二个操作数； 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象； 如果两个操作数都是对象，则返回第二个操作数； 如果有一个操作数是 null ，则返回 null ； 如果有一个操作数是 NaN ，则返回 NaN ； 如果有一个操作数是 undefined ，则返回 undefined 。 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 对于逻辑与操作而言，如果第一个操作数是 false ，则无论第二个操作数是什么值，结果都不再可能是 true 了。来看下面的例子： 123var found = true;var result = (found &amp;&amp; someUndefinedVariable); // 这里会发生错误alert(result); // 这一行不会执行 在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 someUndefinedVariable 没有声明。由于变量 found 的值是 true ，所以逻辑与操作符会继续对变量 someUndefinedVariable 求值。 但 someUndefinedVariable 尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义的值。如果像下面这个例中一样，将 found 的值设置为 false ，就不会发生错误了： 123var found = false;var result = (found &amp;&amp; someUndefinedVariable); // 不会发生错误alert(result); // 会执行（&quot;false&quot;） 在这个例子中，警告框会显示出来。无论变量 someUndefinedVariable 有没有定义，也永远不会对它求值，因为第一个操作数的值是 false 。而这也就意味着逻辑与操作的结果必定是 false ，根本用不着再对 &amp;&amp; 右侧的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。 逻辑或逻辑或操作符由两个竖线符号（ || ）表示，有两个操作数，如下面的例子所示： 1var result = true || false; 逻辑或的真值表如下： 与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第一个操作数； 如果第一个操作数的求值结果为 false ，则返回第二个操作数； 如果两个操作数都是对象，则返回第一个操作数； 如果两个操作数都是 null ，则返回 null ； 如果两个操作数都是 NaN ，则返回 NaN ； 如果两个操作数都是 undefined ，则返回 undefined 。 与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为 true ，就不会对第二个操作数求值了。下面看一个例子： 123var found = true;var result = (found || someUndefinedVariable); // 不会发生错误alert(result); // 会执行（"true"） 这个例子跟前面的例子一样，变量 someUndefinedVariable 也没有定义。但是，由于变量 found 的值是 true ，而变量 someUndefinedVariable 永远不会被求值，因此结果就会输出 “true” 。如果像下面这个例子一样，把 found 的值改为 false ，就会导致错误： 123var found = false;var result = (found || someUndefinedVariable); // 这里会发生错误alert(result); // 这一行不会执行 我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。例如： 1var myObject = preferredObject || backupObject; 在这个例子中，变量 myObject 将被赋予等号后面两个值中的一个。变量 preferredObject 中包含优先赋给变量 myObject 的值，变量 backupObject 负责在 preferredObject 中不包含有效值的情况下提供后备值。如果 preferredObject 的值是 null ，那么它的值将被赋给 myObject ；如果是 null ，则将 backupObject 的值赋给 myObject 。ECMAScript 程序的赋值语句经常会使用这种模式，本书也将采用这种模式。 乘性操作符ECMAScript 定义了 3 个乘性操作符：乘法、除法和求模。这些操作符与 Java、C 或者 Perl 中的相应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。 乘法乘法操作符由一个星号（ * ）表示，用于计算两个数值的乘积。其语法类似于 C，如下面的例子所示： 1var result = 34 * 56; 在处理特殊值的情况下，乘法操作符遵循下列特殊的规则： 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或 -Infinity ；- 如果有一个操作数是 NaN ，则结果是 NaN ； 如果是 Infinity 与 0 相乘，则结果是 NaN ； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity ； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 除法除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算，如下面的例子所示： 1var result = 66 / 11; 与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下： 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或 -Infinity ； 如果有一个操作数是 NaN ，则结果是 NaN ； 如果是 Infinity 被 Infinity 除，则结果是 NaN ； 如果是零被零除，则结果是 NaN ； 如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号； 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 求模求模（余数）操作符由一个百分号（ % ）表示，用法如下： 1var result = 26 % 5; // 等于 1 与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值： 如果操作数都是数值，执行常规的除法计算，返回除得的余数； 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN ； 如果被除数是有限大的数值而除数是零，则结果是 NaN ； 如果是 Infinity 被 Infinity 除，则结果是 NaN ； 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 如果被除数是零，则结果是零； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 加性操作符加法和减法这两个加性操作符应该说是编程语言中最简单的算术操作符了。但是在 ECMAScript 中，这两个操作符却都有一系列的特殊行为。与乘性操作符类似，加性操作符也会在后台转换不同的数据类型。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。 加法加法操作符（+）的用法如下所示： 1var result = 1 + 2; 如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN ，则结果是 NaN ； 如果是 Infinity 加 Infinity ，则结果是 Infinity ； 如果是 -Infinity 加 -Infinity ，则结果是 -Infinity ； 如果是 Infinity 加 -Infinity ，则结果是 NaN ； 如果是+0 加+0，则结果是+0； 如果是0 加0，则结果是0； 如果是+0 加0，则结果是+0。 不过，如果有一个操作数是字符串，那么就要应用如下规则： 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null ，则分别调用 String() 函数并取得字符串 “undefined” 和 “null” 。 下面来举几个例子： 1234var result1 = 5 + 5; // 两个数值相加alert(result1); // 10var result2 = 5 + &quot;5&quot;; // 一个数值和一个字符串相加alert(result2); // &quot;55&quot; 以上代码演示了加法操作符在两种模式下的差别。第一行代码演示了正常的情况，即 5+5 等于 10（数值）。但是，如果将一个操作数改为字符串 “5” ，结果就变成了 “55” （字符串值），因为第一个操作数也被转换成了 “5” 。 忽视加法操作中的数据类型是 ECMAScript 编程中最常见的一个错误。再来看一个例子： 1234var num1 = 5;var num2 = 10;var message = "The sum of 5 and 10 is " + num1 + num2;alert(message); // "The sum of 5 and 10 is 510" 在这个例子中，变量 message 的值是执行两个加法操作之后的结果。有人可能以为最后得到的字符串是 “The sum of 5 and 10 is 15” ，但实际的结果却是 “The sum of 5 and 10 is 510” 。 之所以会这样，是因为每个加法操作是独立执行的。第一个加法操作将一个字符串和一个数值（5）拼接了起来，结果是一个字符串。而第二个加法操作又用这个字符串去加另一个数值（10），当然也会得到一个字符串。如果想先对数值执行算术计算，然后再将结果与字符串拼接起来，应该像下面这样使用圆括号： 1234var num1 = 5;var num2 = 10;var message = &quot;The sum of 5 and 10 is &quot; + (num1 + num2);alert(message); //&quot;The sum of 5 and 10 is 15&quot; 在这个例子中，一对圆括号把两个数值变量括在了一起，这样就会告诉解析器先计算其结果，然后再将结果与字符串拼接起来。因此，就得到了结果 “The sum of 5 and 10 is 15” 。 减法减法操作符（-）是另一个极为常用的操作符，其用法如下所示： 1var result = 2 - 1; 与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则，如下所示： 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果； 如果有一个操作数是 NaN ，则结果是 NaN ； 如果是 Infinity 减 Infinity ，则结果是 NaN ； 如果是 -Infinity 减 -Infinity ，则结果是 NaN ； 如果是 Infinity 减 -Infinity ，则结果是 Infinity ； 如果是 -Infinity 减 Infinity ，则结果是 -Infinity ； 如果是+0 减+0，则结果是+0； 如果是+0 减0，则结果是0； 如果是0 减0，则结果是+0； 如果有一个操作数是字符串、布尔值、 null 或 undefined ，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN ，则减法的结果就是 NaN ； 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN ，则减法的结果就是 NaN 。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。 下面几个例子展示了上面的规则： 123456var result1 = 5 - true; // 4，因为 true 被转换成了 1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - ""; // 5，因为"" 被转换成了 0var result5 = 5 - "2"; // 3，因为"2"被转换成了 2var result6 = 5 - null; // 5，因为 null 被转换成了 0 关系操作符小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）这几个关系操作符用于对两个值进行比较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值，如下面的例子所示： 12var result1 = 5 &gt; 3; //truevar result2 = 5 &lt; 3; //false 与 ECMAScript中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。 如果两个操作数都是数值，则执行数值比较。 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前面的规则执行比较。 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。 在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。很多人都会认为，在比较字符串值时，小于的意思是“在字母表中的位置靠前”，而大于则意味着“在字母表中的位置靠后”，但实际上完全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。经过这么一番比较之后，再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码，因此我们就会看到如下所示的奇怪现象： 1var result = "Brick" &lt; "alphabet"; //true 在这个例子中，字符串 “Brick” 被认为小于字符串 “alphabet” 。原因是字母 B 的字符编码为 66，而字母 a 的字符编码是 97。如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式（全部大写或全部小写），然后再执行比较，如下所示： 1var result = "Brick".toLowerCase() &lt; "alphabet".toLowerCase(); //false 通过将两个操作数都转换为小写形式，就可以得出 “alphabet” 按字母表顺序排在 “Brick” 之前的正确判断了。 另一种奇怪的现象发生在比较两个数字字符串的情况下，比如下面这个例子： 1var result = "23" &lt; "3"; //true 确实，当比较字符串 “23” 是否小于 “3” 时，结果居然是 true 。这是因为两个操作数都是字符串，而字符串比较的是字符编码（ “2” 的字符编码是 50，而 “3” 的字符编码是 51）。不过，如果像下面例子中一样，将一个操作数改为数值，比较的结果就正常了： 1var result = "23" &lt; 3; //false 此时，字符串 “23” 会被转换成数值 23，然后再与 3 进行比较，因此就会得到合理的结果。在比较数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。当然，这个规则对前面的例子是适用的。可是，如果那个字符串不能被转换成一个合理的数值呢？比如： 1var result = "a" &lt; 3; // false，因为"a"被转换成了 NaN 由于字母 “a” 不能转换成合理的数值，因此就被转换成了 NaN 。根据规则，任何操作数与 NaN 进行关系比较，结果都是 false 。于是，就出现了下面这个有意思的现象： 12var result1 = NaN &lt; 3; //falsevar result2 = NaN &gt;= 3; //false 按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在与 NaN 进行比较时，这两个比较操作的结果都返回了 false 。 相等操作符确定两个变量是否相等是编程中的一个非常重要的操作。在比较字符串、数值和布尔值的相等性时，问题还比较简单。但在涉及到对象的比较时，问题就变得复杂了。最早的 ECMAScript 中的相等和不等操作符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后，ECMAScript 的解决方案就是提供两组操作符：相等和不相等——先转换再比较，全等和不全等——仅比较而不转换。 相等和不相等ECMAScript 中的相等操作符由两个等于号（ == ）表示，如果两个操作数相等，则返回 true 。而不相等操作符由叹号后跟等于号（ != ）表示，如果两个操作数不相等，则返回 true 。这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。 在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—— false 转换为 0，而true 转换为 1； 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；这两个操作符在进行比较时则要遵循下列规则。 null 和 undefined 是相等的。 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 如果有一个操作数是 NaN ，则相等操作符返回 false ，而不相等操作符返回 true 。重要提示：即使两个操作数都是 NaN ，相等操作符也返回 false ；因为按照规则， NaN 不等于 NaN 。 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true ；否则，返回 false 。 下表列出了一些特殊情况及比较结果： 全等和不全等除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由 3 个等于号（ === ）表示，它只在两个操作数未经转换就相等的情况下返回 true ，如下面的例子所示： 12var result1 = ("55" == 55); //true，因为转换后相等var result2 = ("55" === 55); //false，因为不同的数据类型不相等 在这个例子中，第一个比较使用的是相等操作符比较字符串 “55” 和数值 55，结果返回了 true 。如前所述，这是因为字符串 “55” 先被转换成了数值 55，然后再与另一个数值 55 进行比较。第二个比较使用了全等操作符以不转换数值的方式比较同样的字符串和值。在不转换的情况下，字符串当然不等于数值，因此结果就是 false 。 不全等操作符由一个叹号后跟两个等于号（ !== ）表示，它在两个操作数未经转换就不相等的情况下返回 true 。例如： 12var result1 = ("55" != 55); //false，因为转换后相等var result2 = ("55" !== 55); //true，因为不同的数据类型不相等 在这个例子中，第一个比较使用了不相等操作符，而该操作符会将字符串 “55” 转换成 55，结果就与第二个操作数（也是 55）相等了。而由于这两个操作数被认为相等，因此就返回了 false 。第二个比较使用了不全等操作符。假如我们这样想：字符串 55 与数值 55 不相同吗？，那么答案一定是：是的（ true ）。 记住： null == undefined 会返回 true ，因为它们是类似的值；但 null === undefined 会返回 false ，因为它们是不同类型的值。 由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。 条件操作符条件操作符应该算是 ECMAScript 中最灵活的一种操作符了，而且它遵循与 Java 中的条件操作符相同的语法形式，如下面的例子所示： 1variable = boolean_expression ? true_value : false_value; 本质上，这行代码的含义就是基于对 boolean_expression 求值的结果，决定给变量 variable 赋什么值。如果求值结果为 true ，则给变量 variable 赋 true_value 值；如果求值结果为 false ，则给变量 variable 赋 false_value 值。再看一个例子： 1var max = (num1 &gt; num2) ? num1 : num2; 在这个例子中， max 中将会保存一个最大的值。这个表达式的意思是：如果 num1 大于 num2 （关系表达式返回 true ），则将 num1 的值赋给 max ；如果 num1 小于或等于 num2 （关系表达式返回 false ），则将 num2 的值赋给 max 。 赋值操作符简单的赋值操作符由等于号（ = ）表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示： 1var num = 10; 如果在等于号（ = ）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。 这种复合赋值操作相当于是对下面常规表达式的简写形式： 12var num = 10;num = num + 10; 其中的第二行代码可以用一个复合赋值来代替： 12var num = 10;num += 10; 每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示： 乘/赋值（ *= ）； 除/赋值（ /= ）； 模/赋值（ %= ）； 加/赋值（ += ）； 减/赋值（ = ）； 左移/赋值（ &lt;&lt;= ）； 有符号右移/赋值（ &gt;&gt;= ）； 无符号右移/赋值（ &gt;&gt;&gt;= ）。 设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。 逗号操作符使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示： 1var num1=1, num2=2, num3=3; 逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示： 1var num = (5, 1, 4, 8, 0); // num 的值为 0 由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。 语句ECMA-262 规定了一组语句（也称为流控制语句）。从本质上看，语句定义了 ECMAScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。 if 语句大多数编程语言中最为常用的一个语句就是 if 语句。以下是 if 语句的语法： 1if (condition) statement1 else statement2 其中的 condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值。如果对 condition 求值的结果是 true ，则执行statement1 （语句1），如果对condition求值的结果是 false ，则执行statement2 （语句 2）。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。 请看下面的例子。 12345if (i &gt; 25) alert("Greater than 25."); // 单行语句else &#123; alert("Less than or equal to 25."); // 代码块中的语句&#125; 不过，业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。 另外，也可以像下面这样把整个 if 语句写在一行代码中： 1if (condition1) statement1 else if (condition2) statement2 else statement3 但我们推荐的做法则是像下面这样： 1234567if (i &gt; 25) &#123; alert("Greater than 25.");&#125; else if (i &lt; 0) &#123; alert("Less than 0.");&#125; else &#123; alert("Between 0 and 25, inclusive.");&#125; do-while 语句do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的语法： 123do &#123; statement&#125; while (expression); 下面是一个示例： 12345var i = 0;do &#123; i += 2;&#125; while (i &lt; 10);alert(i); 在这个例子中，只要变量 i 的值小于 10，循环就会一直继续下去。而且变量 i 的值最初为 0，每次循环都会递增 2。 像 do-while 这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。 while 语句while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法： 1while(expression) statement 下面是一个示例： 1234var i = 0;while (i &lt; 10) &#123; i += 2;&#125; 在这个例子中，变量 i 开始时的值为 0，每次循环都会递增 2。而只要 i 的值小于 10，循环就会继续下去。 for 语句for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是 for 语句的语法： 1for (initialization; expression; post-loop-expression) statement 下面是一个示例： 1234var count = 10;for (var i = 0; i &lt; count; i++)&#123; alert(i);&#125; 以上代码定义了变量 i 的初始值为 0。只有当条件表达式（ i&lt;count ）返回 true 的情况下才会进入 for 循环，因此也有可能不会执行循环体中的代码。如果执行了循环体中的代码，则一定会对循环后的表达式（ i++ ）求值，即递增 i 的值。这个 for 循环语句与下面的 while 语句的功能相同： 123456var count = 10;var i = 0;while (i &lt; count)&#123; alert(i); i++;&#125; 使用 while 循环做不到的，使用 for 循环同样也做不到。也就是说， for 循环只是把与循环有关的代码集中在了一个位置。 有必要指出的是，在 for 循环的变量初始化表达式中，也可以不使用 var 关键字。该变量的初始化可以在外部执行，例如： 12345var count = 10;var i;for (i = 0; i &lt; count; i++)&#123; alert(i);&#125; 以上代码与在循环初始化表达式中声明变量的效果是一样的。由于 ECMAScript 中不存在块级作用域（第 4 章将进一步讨论这一点），因此在循环内部定义的变量也可以在外部访问到。例如： 12345var count = 10;for (var i = 0; i &lt; count; i++)&#123; alert(i);&#125;alert(i); //10 在这个例子中，会有一个警告框显示循环完成后变量 i 的值，这个值是 10。这是因为，即使 i 是在循环内部定义的一个变量，但在循环外部仍然可以访问到它。此外， for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环，例如： 123for (;;) &#123; // 无限循环 doSomething();&#125; 而只给出控制表达式实际上就把 for 循环转换成了 while 循环，例如： 123456var count = 10;var i = 0;for (; i &lt; count; )&#123; alert(i); i++;&#125; 由于 for 语句存在极大的灵活性，因此它也是 ECMAScript 中最常用的一个语句。 for-in 语句for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法： 1for (property in expression) statement 下面是一个示例： 123for (var propName in window) &#123; document.write(propName);&#125; 在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName 。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。 ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。 具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。但是，如果表示要迭代的对象的变量值为 null 或 undefined ， for-in 语句会抛出错误。 ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined 。 Safari 3 以前版本的 for-in 语句中存在一个 bug，该 bug 会导致某些属性被返回两次。 label 语句使用 label 语句可以在代码中添加标签，以便将来使用。以下是 label 语句的语法： 1label: statement 下面是一个示例： 123start: for (var i=0; i &lt; count; i++) &#123;alert(i);&#125; 这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。加标签的语句一般都要与 for 语句等循环语句配合使用。 break 和 continue 语句break 和 continue 语句用于在循环中精确地控制代码的执行。其中， break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子： 12345678var num = 0;for (var i=1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break; &#125; num++;&#125;alert(num); //4 这个例子中的 for 循环会将变量 i 由 1 递增至 10。在循环体内，有一个 if 语句检查 i 的值是否可以被 5 整除（使用求模操作符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开始，用于记录循环执行的次数。在执行 break 语句之后，要执行的下一行代码是 alert() 函数，结果显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在 num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果： 12345678var num = 0;for (var i=1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; continue; &#125; num++;&#125;alert(num); //8 例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前退出，但接下来执行的是下一次循环，即 i 的值等于 6 的循环。于是，循环又继续执行，直到 i 等于 10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。 break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示： 1234567891011var num = 0;outermost:for (var i=0; i &lt; 10; i++) &#123; for (var j=0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; num++; &#125;&#125;alert(num); //55 在这个例子中， outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++ 语句就会正常执行 100 次。换句话说，如果两个循环都自然结束， num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时， num 的值正好是 55。同样， continue 语句也可以像这样与 label 语句联用，如下面的例子所示： 1234567891011var num = 0;outermost:for (var i=0; i &lt; 10; i++) &#123; for (var j=0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; num++; &#125;&#125;alert(num); //95 在这种情况下， continue 语句会强制继续执行循环——退出内部循环，执行外部循环。当 j 是 5 时， continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。 虽然联用 break 、 continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。 with 语句with 语句的作用是将代码的作用域设置到一个特定的对象中。 with 语句的语法如下： 1with (expression) statement; 定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示： 123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示： 12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询 location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。 严格模式下不允许使用 with 语句，否则将视为语法错误。 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。 switch 语句switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。ECMAScript 中 switch 语句的语法与其他基于 C 的语言非常接近，如下所示： 1234567891011switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; switch 语句中的每一种情形（case）的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码（因此，也相当于一个 else 语句）。 从根本上讲， switch 语句就是为了让开发人员免于编写像下面这样的代码： 123456789if (i == 25)&#123; alert("25");&#125; else if (i == 35) &#123; alert("35");&#125; else if (i == 45) &#123; alert("45");&#125; else &#123; alert("Other");&#125; 而与此等价的 switch 语句如下所示： 12345678910111213switch (i) &#123; case 25: alert(&quot;25&quot;); break; case 35: alert(&quot;35&quot;); break; case 45: alert(&quot;45&quot;); break; default: alert(&quot;Other&quot;);&#125; 通过为每个 case 后面都添加一个 break 语句，就可以避免同时执行多个 case代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了 break 关键字，如下所示： 123456789101112switch (i) &#123; case 25: /* 合并两种情形 */ case 35: alert(&quot;25 or 35&quot;); break; case 45: alert(&quot;45&quot;); break; default: alert(&quot;Other&quot;);&#125; 虽然 ECMAScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这个例子： 12345678910switch ("hello world") &#123; case "hello" + " world": alert("Greeting was found."); break; case "goodbye": alert("Closing was found."); break; default: alert("Unexpected message was found.");&#125; 在这个例子中， switch 语句使用的就是字符串。其中，第一种情形实际上是一个对字符串拼接操作求值的表达式。由于这个字符串拼接表达式的结果与 switch 的参数相等，因此结果就会显示 “Greeting was found.” 。而且，使用表达式作为 case 值还可以实现下列操作： 1234567891011121314var num = 25;switch (true) &#123; case num &lt; 0: alert("Less than 0."); break; case num &gt;= 0 &amp;&amp; num &lt;= 10: alert("Between 0 and 10."); break; case num &gt; 10 &amp;&amp; num &lt;= 20: alert("Between 10 and 20."); break; default: alert("More than 20.");&#125; 这个例子首先在 switch 语句外面声明了变量 num 。而之所以给 switch 语句传递表达式 true ，是因为每个 case 值都可以返回一个布尔值。这样，每个 case 按照顺序被求值，直到找到匹配的值或者遇到 default 语句为止（这正是这个例子的最终结果）。 switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串 “10” 不等于数值 10）。 函数函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。 函数的基本语法如下所示： 123function functionName(arg0, arg1,...,argN) &#123; statements&#125; 以下是一个函数示例： 123function sayHi(name, message) &#123; alert("Hello " + name + "," + message);&#125; 这个函数可以通过其函数名来调用，后面还要加上一对圆括号和参数（圆括号中的参数如果有多个，可以用逗号隔开）。调用 sayHi() 函数的代码如下所示： 1sayHi("Nicholas", "how are you today?"); 这个函数的输出结果是 “Hello Nicholas,how are you today?” 。函数中定义中的命名参数 name 和 message 被用作了字符串拼接的两个操作数，而结果最终通过警告框显示了出来。 ECMAScript 中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过 return 语句后跟要返回的值来实现返回值。请看下面的例子： 123function sum(num1, num2) &#123; return num1 + num2;&#125; 这个 sum() 函数的作用是把两个值加起来返回一个结果。我们注意到，除了 return 语句之外，没有任何声明表示该函数会返回一个值。调用这个函数的示例代码如下： 1var result = sum(5, 10); 这个函数会在执行完 return 语句之后停止并立即退出。因此，位于 return 语句之后的任何代码都永远不会执行。例如： 1234function sum(num1, num2) &#123; return num1 + num2; alert("Hello world"); // 永远不会执行&#125; 在这个例子中，由于调用 alert() 函数的语句位于 return 语句之后，因此永远不会显示警告框。当然，一个函数中也可以包含多个 return 语句，如下面这个例子中所示： 1234567function diff(num1, num2) &#123; if (num1 &lt; num2) &#123; return num2 - num1; &#125; else &#123; return num1 - num2; &#125;&#125; 这个例子中定义的 diff() 函数用于计算两个数值的差。如果第一个数比第二个小，则用第二个数减第一个数；否则，用第一个数减第二个数。代码中的两个分支都具有自己的 return 语句，分别用于执行正确的计算。 另外， return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 undefined 值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。比如在下面这个例子中，就不会显示警告框： 1234function sayHi(name, message) &#123; return; alert("Hello " + name + "," + message); //永远不会调用&#125; 推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。 严格模式对函数有一些限制： 不能把函数命名为 eval 或 arguments ； 不能把参数命名为 eval 或 arguments ； 不能出现两个命名参数同名的情况。 如果发生以上情况，就会导致语法错误，代码无法执行。 理解参数ECMAScript 函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。 其实， arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是 arguments[0] ，第二个元素是 argumetns[1] ，以此类推），使用 length 属性来确定传递进来多少个参数。在前面的例子中， sayHi() 函数的第一个参数的名字叫 name ，而该参数的值也可以通过访问 arguments[0] 来获取。因此，那个函数也可以像下面这样重写，即不显式地使用命名参数： 123function sayHi() &#123; alert("Hello " + arguments[0] + "," + arguments[1]);&#125; 这个重写后的函数中不包含命名的参数。虽然没有使用 name 和 message 标识符，但函数的功能依旧。这个事实说明了 ECMAScript 函数的一个重要特点：命名的参数只提供便利，但不是必需的。另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在 ECMAScript 中，没有这些条条框框，解析器不会验证命名参数。 通过访问 arguments 对象的 length 属性可以获知有多少个参数传递给了函数。下面这个函数会在每次被调用时，输出传入其中的参数个数： 123456function howManyArgs() &#123; alert(arguments.length);&#125;howManyArgs("string", 45); //2howManyArgs(); //0howManyArgs(12); //1 执行以上代码会依次出现 3 个警告框，分别显示 2、0 和 1。由此可见，开发人员可以利用这一点让函数能够接收任意个参数并分别实现适当的功能。请看下面的例子： 123456789function doAdd() &#123; if(arguments.length == 1) &#123; alert(arguments[0] + 10); &#125; else if (arguments.length == 2) &#123; alert(arguments[0] + arguments[1]); &#125;&#125;doAdd(10); //20doAdd(30, 20); //50 函数 doAdd() 会在只有一个参数的情况下给该参数加上 10；如果是两个参数，则将那个参数简单相加并返回结果。因此， doAdd(10) 会返回 20，而 doAdd(30,20) 则返回 50。虽然这个特性算不上完美的重载，但也足够弥补 ECMAScript 的这一缺憾了。 另一个与参数相关的重要方面，就是 arguments 对象可以与命名参数一起使用，如下面的例子所示： 1234567function doAdd(num1, num2) &#123; if(arguments.length == 1) &#123; alert(num1 + 10); &#125; else if (arguments.length == 2) &#123; alert(arguments[0] + num2); &#125;&#125; 在重写后的这个 doAdd() 函数中，两个命名参数都与 arguments 对象一起使用。由于 num1 的值与 arguments[0] 的值相同，因此它们可以互换使用（当然， num2 和 arguments[1] 也是如此）。 关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。例如： 1234function doAdd(num1, num2) &#123; arguments[1] = 10; alert(arguments[0] + num2);&#125; 每次执行这个 doAdd() 函数都会重写第二个参数，将第二个参数的值修改为 10。因为 arguments 对象中的值会自动反映到对应的命名参数，所以修改 arguments[1] ，也就修改了 num2 ，结果它们的值都会变成 10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。另外还要记住，如果只传入了一个参数，那么为 arguments[1] 设置的值不会反应到命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。 关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了变量但又没有初始化一样。例如，如果只给 doAdd() 函数传递了一个参数，则 num2 中就会保存 undefined 值。 严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把 arguments[1] 设置为 10 ， num2 的值仍然还是 undefined 。其次，重写 arguments 的值会导致语法错误（代码将不会执行）。 ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。 没有重载ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt 函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。 如果在 ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。请看下面的例子： 1234567function addSomeNumber(num)&#123; return num + 100;&#125;function addSomeNumber(num) &#123; return num + 200;&#125;var result = addSomeNumber(100); //300 在此，函数 addSomeNumber() 被定义了两次。第一个版本给参数加 100，而第二个版本给参数加 200。由于后定义的函数覆盖了先定义的函数，因此当在最后一行代码中调用这个函数时，返回的结果就是 300。 如前所述，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。 小结JavaScript 的核心语言特性在 ECMA-262 中是以名为 ECMAScript 的伪语言的形式来定义的。ECMAScript 中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但没有对取得输入和产生输出的机制作出规定。理解 ECMAScript 及其纷繁复杂的各种细节，是理解其在 Web 浏览器中的实现——JavaScript 的关键。目前大多数实现所遵循的都是 ECMA-262 第 3 版，但很多也已经着手开始实现第 5 版了。以下简要总结了 ECMAScript 中基本的要素。 ECMAScript 中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 和 String 。 与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型， Number 类型可用于表示所有数值。 ECMAScript 中也有一种复杂的数据类型，即 Object 类型，该类型是这门语言中所有对象的基础类型。 严格模式为这门语言中容易出错的地方施加了限制。 ECMAScript 提供了很多与 C 及其他类 C 语言中相同的基本操作符，包括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。 ECMAScript 从其他语言中借鉴了很多流控制语句，例如 if 语句、 for 语句和 switch 语句等。ECMAScript 中的函数与其他语言中的函数有诸多不同之处。 无须指定函数的返回值，因为任何 ECMAScript 函数都可以在任何时候返回任何值。 实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。 ECMAScript 中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。 可以向 ECMAScript 函数传递任意数量的参数，并且可以通过 arguments 对象来访问这些参数。 由于不存在函数签名的特性，ECMAScript 函数不能重载。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记- 在HTML中使用JavaScript]]></title>
    <url>%2F2018%2F08%2F30%2FJavaScript-HTML%2F</url>
    <content type="text"><![CDATA[在HTML中使用JavaScript只要一提到把 JavaScript 放到网页中，就不得不涉及 Web 的核心语言——HTML。在当初开发 JavaScript 的时候，Netscape 要解决的一个重要问题就是如何做到让 JavaScript 既能与 HTML页面共存，又不影响那些页面在其他浏览器中的呈现效果。经过尝试、纠错和争论，最终的决定就是为 Web 增加统一的脚本支持。而 Web 诞生早期的很多做法也都保留了下来，并被正式纳入 HTML 规范当中。 &lt;script&gt; 元素向 HTML 页面中插入 JavaScript 的主要方法，就是 使用 &lt;script&gt; 元素 。这个元素由 Netscape 创造并在 Netscape Navigator 2中首先实现。后来，这个元素被加入到正式的 HTML 规范中。HTML 4.01 为 &lt;script&gt; 定义了下列 6 个属性。 async ：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。 charset ：可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。 defer ：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。 language ：已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript 、 JavaScript1.2 或 VBScript ）。大多数浏览器会忽略这个属性，因此也没有必要再用了。 src ：可选。表示包含要执行代码的外部文件。 type ：可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text/javascript 和 text/ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是 text/javascript 。实际上，服务器在传送 JavaScript 文件时使用的MIME 类型通常是 application/x–javascript ，但在 type 中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值： application/javascript 和 application/ecmascript 。考虑到约定俗成和最大限度的浏览器兼容性，目前 type 属性的值依旧还是 text/javascript 。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为 text/javascript 。 使用 &lt;script&gt; 元素的方式有两种：直接在页面中嵌入 JavaScript 代码 和 包含外部 JavaScript 文件 。 在使用 &lt;script&gt; 元素嵌入 JavaScript 代码时，只须为 &lt;script&gt; 指定 type 属性。然后，像下面这样把 JavaScript 代码直接放在元素内部即可： 12345&lt;script type="text/javascript"&gt; function sayHi()&#123; alert("Hi!"); &#125;&lt;/script&gt; 包含在 &lt;script&gt; 元素内部的 JavaScript 代码将被从上至下依次解释。就拿前面这个例子来说，解释器会解释一个函数的定义，然后将该定义保存在自己的环境当中。在解释器对 &lt;script&gt; 元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。 在使用 &lt;script&gt; 嵌入 JavaScript 代码时，记住不要在代码中的任何地方出现 “&lt;/script&gt;“ 字符串。例如，浏览器在加载下面所示的代码时就会产生一个错误： 12345&lt;script type="text/javascript"&gt; function sayScript()&#123; alert("&lt;/script&gt;"); &#125;&lt;/script&gt; 因为按照解析嵌入式代码的规则，当浏览器遇到字符串 “&lt;/script&gt;“ 时，就会认为那是结束的 &lt;/script&gt; 标签。而通过转义字符“/”可以解决这个问题，例如： 12345&lt;script type="text/javascript"&gt; function sayScript()&#123; alert("&lt;\/script&gt;"); &#125;&lt;/script&gt; 这样写代码浏览器可以接受，因而也就不会导致错误了。 如果要通过 &lt;script&gt; 元素来包含外部 JavaScript 文件，那么 src 属性就是必需的。这个属性的值是一个指向外部 JavaScript 文件的链接，例如： 1&lt;script type="text/javascript" src="example.js"&gt;&lt;/script&gt; 在这个例子中，外部文件 example.js 将被加载到当前页面中。外部文件只须包含通常要放在开始的 &lt;script&gt; 和结束的 &lt;/script&gt; 之间的那些 JavaScript 代码即可。与解析嵌入式 JavaScript 代码一样，在解析外部 JavaScript 文件（包括下载该文件）时，页面的处理也会暂时停止。如果是在 XHTML 文档中，也可以省略前面示例代码中结束的 &lt;/script&gt; 标签，例如： 1&lt;script type="text/javascript" src="example.js" /&gt; 但是，不能在 HTML 文档使用这种语法。原因是这种语法不符合 HTML 规范，而且也得不到某些浏览器（尤其是 IE）的正确解析。 按照惯例，外部 JavaScript 文件带有.js扩展名。但这个扩展名不是必需的，因为浏览器不会检查包含 JavaScript 的文件的扩展名。这样一来，使用 JSP、PHP 或其他服务器端语言动态生成 JavaScript 代码也就成为了可能。但是，服务器通常还是需要看扩展名决定为响应应用哪种 MIME 类型。如果不使用.js 扩展名，请确保服务器能返回正确的 MIME 类型。 需要注意的是，带有 src 属性的 &lt;script&gt; 元素不应该在其 &lt;script&gt; 和 &lt;/script&gt; 标签之间再包含额外的 JavaScript 代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。 另外，通过 &lt;script&gt; 元素的 src 属性还可以包含来自外部域的 JavaScript 文件。这一点既让 &lt;script&gt; 元素倍显强大，又让它备受争议。在这一点上， &lt;script&gt; 与 &lt;img&gt; 元素非常相似，即它的 src 属性可以是指向当前 HTML 页面所在域之外的某个域中的完整 URL，例如： 1&lt;script type="text/javascript" src="http://www.somewhere.com/afile.js"&gt;&lt;/script&gt; 这样，位于外部域中的代码也会被加载和解析，就像这些代码位于加载它们的页面中一样。利用这一点就可以在必要时通过不同的域来提供 JavaScript 文件。不过，在访问自己不能控制的服务器上的 JavaScript 文件时则要多加小心。如果不幸遇到了怀有恶意的程序员，那他们随时都可能替换该文件中的代码。因此，如果想包含来自不同域的代码，则要么你是那个域的所有者，要么那个域的所有者值得信赖。 无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照 &lt;script&gt; 元素在页面中出现的先后顺序对它们依次进行解析。换句话说，在第一个 &lt;script&gt; 元素包含的代码解析完成后，第二个 &lt;script&gt; 包含的代码才会被解析，然后才是第三个、第四个…… 标签的位置按照传统的做法，所有 &lt;script&gt; 元素都应该放在页面的 &lt;head&gt; 元素中，例如： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里放内容 --&gt; &lt;/body&gt;&lt;/html&gt; 这种做法的目的就是把所有外部文件（包括 CSS 文件和 JavaScript 文件）的引用都放在相同的地方。可是，在文档的 &lt;head&gt; 元素中包含所有 JavaScript 文件，意味着 必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容 （浏览器在遇到 &lt;body&gt; 标签时才开始呈现内容）。对于那些需要很多 JavaScript 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。为了避免这个问题，现代 Web 应用程序一般都 把全部 JavaScript 引用放在 &lt;body&gt; 元素中页面内容的后面 ，如下例所示： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里放内容 --&gt; &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样，在解析包含的 JavaScript 代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。 延迟脚本HTML 4.01 为 &lt;script&gt; 标签定义了 defer 属性。这个属性的用途是 表明脚本在执行时不会影响页面的构造 。也就是说，脚本会被延迟到整个页面都解析完毕后再运行 。因此，在 &lt;script&gt; 元素中设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type="text/javascript" defer="defer" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" defer="defer" src="example2.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里放内容 --&gt; &lt;/body&gt;&lt;/html&gt; 在这个例子中，虽然我们把 &lt;script&gt; 元素放在了文档的 &lt;head&gt; 元素中，但其中包含的脚本将延迟到浏览器遇到 &lt;/html&gt; 标签后再执行。HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件（详见第 13 章）执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。 前面提到过， defer 属性只适用于外部脚本文件。这一点在 HTML5 中已经明确规定，因此支持 HTML5 的实现会忽略给嵌入脚本设置的 defer 属性。IE4～IE7 还支持对嵌入脚本的 defer 属性，但 IE8 及之后版本则完全支持 HTML5 规定的行为。IE4、Firefox 3.5、Safari 5 和 Chrome 是最早支持 defer 属性的浏览器。其他浏览器会忽略这个属性，像平常一样处理脚本。为此，把延迟脚本放在页面底部仍然是最佳选择。 在 XHTML 文档中，要把 defer 属性设置为 defer=”defer” 。 异步脚本HTML5 为 &lt;script&gt; 元素定义了 async 属性。这个属性与 defer 属性类似，都用于 改变处理脚本的行为 。同样与 defer 类似， async 只适用于外部脚本文件，并告诉浏览器立即下载文件 。但与 defer 不同的是，标记为 async 的脚本并不保证按照指定它们的先后顺序执行。例如： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type="text/javascript" async src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" async src="example2.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里放内容 --&gt; &lt;/body&gt;&lt;/html&gt; 在以上代码中，第二个脚本文件可能会在第一个脚本文件之前执行。因此，确保两者之间互不依赖非常重要。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改 DOM。 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。支持异步脚本的浏览器有 Firefox 3.6、Safari 5 和 Chrome。 在 XHTML 文档中，要把 async 属性设置为 async=”async” 。 在XHTML中的用法（HTML5 正快速地被前端开发人员采用，建议读者在学习和开发中遵循 HTML5 标准，本节内容可以跳过。）可扩展超文本标记语言，即 XHTML（Extensible HyperText Markup Language），是将 HTML 作为 XML 的应用而重新定义的一个标准。编写 XHTML 代码的规则要比编写 HTML 严格得多，而且直接影响能否在嵌入 JavaScript 代码时使用 &lt;script/&gt; 标签。以下面的代码块为例，虽然它们在 HTML 中是有效的，但在 XHTML 中则是无效的。 1234567891011&lt;script type="text/javascript"&gt; function compare(a, b) &#123; if (a &lt; b) &#123; alert("A is less than B"); &#125; else if (a &gt; b) &#123; alert("A is greater than B"); &#125; else &#123; alert("A is equal to B"); &#125; &#125;&lt;/script&gt; 在 HTML 中，有特殊的规则用以确定 &lt;script&gt; 元素中的哪些内容可以被解析，但这些特殊的规则在 XHTML 中不适用。这里比较语句 a &lt; b 中的小于号（&lt;）在 XHTML 中将被当作开始一个新标签来解析。但是作为标签来讲，小于号后面不能跟空格，因此就会导致语法错误。 避免在 XHTML 中出现类似语法错误的方法有两个。一是 用相应的 HTML 实体（ &lt; ）替换代码中所有的小于号（&lt;） ，替换后的代码类似如下所示： 1234567891011&lt;script type="text/javascript"&gt; function compare(a, b) &#123; if (a &amp;lt; b) &#123; alert("A is less than B"); &#125; else if (a &gt; b) &#123; alert("A is greater than B"); &#125; else &#123; alert("A is equal to B"); &#125; &#125;&lt;/script&gt; 虽然这样可以让代码在 XHTML 中正常运行，但却导致代码不好理解了。为此，我们可以考虑采用另一个方法。 保证让相同代码在 XHTML 中正常运行的第二个方法，就是用一个 CData 片段来包含 JavaScript 代码。在 XHTML（XML）中，CData 片段是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。因此，在 CData 片段中就可以使用任意字符——小于号当然也没有问题，而且不会导致语法错误。引入 CData 片段后的 JavaScript 代码块如下所示： 1234567891011&lt;script type="text/javascript"&gt;&lt;![CDATA[ function compare(a, b) &#123; if (a &lt; b) &#123; alert("A is less than B"); &#125; else if (a &gt; b) &#123; alert("A is greater than B"); &#125; else &#123; alert("A is equal to B"); &#125; &#125;]]&gt;&lt;/script&gt; 在兼容 XHTML 的浏览器中，这个方法可以解决问题。但实际上，还有不少浏览器不兼容 XHTML，因而不支持 CData 片段。怎么办呢？再使用 JavaScript 注释将 CData 标记注释掉就可以了： 12345678910111213&lt;script type="text/javascript"&gt;//&lt;![CDATA[ function compare(a, b) &#123; if (a &lt; b) &#123; alert("A is less than B"); &#125; else if (a &gt; b) &#123; alert("A is greater than B"); &#125; else &#123; alert("A is equal to B"); &#125; &#125;//]]&gt;&lt;/script&gt; 这种格式在所有现代浏览器中都可以正常使用。虽然有几分 hack 的味道，但它能通过 XHTML 验证，而且对 XHTML 之前的浏览器也会平稳退化。 在将页面的 MIME 类型指定为 “application/xhtml+xml” 的情况下会触发 XHTML 模式。并不是所有浏览器都支持以这种方式提供 XHTML 文档。 不推荐使用的语法在最早引入 &lt;script&gt; 元素的时候，该元素与传统 HTML 的解析规则是有冲突的。由于要对这个元素应用特殊的解析规则，因此在那些不支持 JavaScript 的浏览器（最典型的是 Mosaic）中就会导致问题。具体来说，不支持 JavaScript 的浏览器会把 &lt;script&gt; 元素的内容直接输出到页面中，因而会破坏页面的布局和外观。 Netscape 与 Mosaic 协商并提出了一个解决方案，让不支持 &lt;script&gt; 元素的浏览器能够隐藏嵌入的 JavaScript 代码。这个方案就是把 JavaScript 代码包含在一个 HTML 注释中，像下面这样： 12345&lt;script&gt;&lt;!--function sayHi()&#123;alert("Hi!");&#125;//--&gt;&lt;/script&gt; 给脚本加上 HTML 注释后，Mosaic 等浏览器就会忽略 &lt;script&gt; 标签中的内容；而那些支持JavaScript 的浏览器在遇到这种情况时，则必须进一步确认其中是否包含需要解析的 JavaScript 代码。 虽然这种注释 JavaScript 代码的格式得到了所有浏览器的认可，也能被正确解释，但由于所有浏览器都已经支持 JavaScript，因此也就没有必要再使用这种格式了。在 XHTML 模式下，因为脚本包含在 XML 注释中，所以脚本会被忽略。 嵌入代码与外部文件在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强调如下优点。 可维护性：遍及不同 HTML 页面的 JavaScript 会造成维护问题。但把所有 JavaScript 文件都放在一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及 HTML 标记的情况下，集中精力编辑 JavaScript 代码。 可缓存：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。 适应未来：通过外部文件来包含 JavaScript 无须使用前面提到 XHTML 或注释 hack。HTML 和 XHTML 包含外部文件的语法是相同的。 文档模式IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。最初的两种文档模式是：混杂模式（quirks mode,这里 quirks mode 的译法源自 Firefox 3.5.5中文版。）和标准模式（standards mode）。混杂模式会让 IE 的行为与（包含非标准特性的）IE5 相同，而标准模式则让 IE 的行为更接近标准行为。虽然这两种模式主要影响 CSS内容的呈现，但在某些情况下也会影响到 JavaScript 的解释执行。本书将在必要时再讨论这些因文档模式而影响 JavaScript 执行的情况。 在 IE 引入文档模式的概念后，其他浏览器也纷纷效仿。在此之后，IE 又提出一种所谓的准标准模式（almost standards mode）。这种模式下的浏览器特性有很多都是符合标准的，但也不尽然。不标准的地方主要体现在处理图片间隙的时候（在表格中使用图片时问题最明显）。 如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。 对于标准模式，可以通过使用下面任何一种文档类型来开启： 1234567891011&lt;!-- HTML 4.01 严格型 --&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd"&gt;&lt;!-- XHTML 1.0 严格型 --&gt;&lt;!DOCTYPE html PUBLIC"-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt; 而对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发，如下所示： 12345678910111213141516171819&lt;!-- HTML 4.01 过渡型 --&gt;&lt;!DOCTYPE HTML PUBLIC"-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;!-- HTML 4.01 框架集型 --&gt;&lt;!DOCTYPE HTML PUBLIC"-//W3C//DTD HTML 4.01 Frameset//EN""http://www.w3.org/TR/html4/frameset.dtd"&gt;&lt;!-- XHTML 1.0 过渡型 --&gt;&lt;!DOCTYPE html PUBLIC"-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;!-- XHTML 1.0 框架集型 --&gt;&lt;!DOCTYPE html PUBLIC"-//W3C//DTD XHTML 1.0 Frameset//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt; 准标准模式与标准模式非常接近，它们的差异几乎可以忽略不计。因此，当有人提到“标准模式”时，有可能是指这两种模式中的任何一种。而且，检测文档模式（本书后面将会讨论）时也不会发现什么不同。本书后面提到标准模式时，指的是除混杂模式之外的其他模式。 &lt;noscript&gt; 元素早期浏览器都面临一个特殊的问题，即当浏览器不支持 JavaScript 时如何让页面平稳地退化。对这个问题的最终解决方案就是创造一个 &lt;noscript&gt; 元素，用以在不支持 JavaScript 的浏览器中显示替代的内容 。这个元素可以包含能够出现在文档 &lt;body&gt; 中的任何 HTML 元素—— &lt;script&gt; 元素除外。包含在 &lt;noscript&gt; 元素中的内容只有在下列情况下才会显示出来： 浏览器不支持脚本； 浏览器支持脚本，但脚本被禁用。 符合上述任何一个条件，浏览器都会显示 &lt;noscript&gt; 中的内容。而在除此之外的其他情况下，浏览器不会呈现 &lt;noscript&gt; 中的内容。 请看下面这个简单的例子： 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type="text/javascript" defer="defer" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" defer="defer" src="example2.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;p&gt; 本页面需要浏览器支持（启用）JavaScript 。 &lt;/noscript&gt; &lt;/body&gt;&lt;/html&gt; 这个页面会在脚本无效的情况下向用户显示一条消息。而在启用了脚本的浏览器中，用户永远也不会看到它——尽管它是页面的一部分。 小结把 JavaScript 插入到 HTML 页面中要使用 &lt;script&gt; 元素。使用这个元素可以把 JavaScript 嵌入到 HTML页面中，让脚本与标记混合在一起；也可以包含外部的 JavaScript文件。而我们需要注意的地方有： 在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。 所有 &lt;script&gt; 元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和 async 属性的情况下，只有在解析完前面 &lt;script&gt; 元素中的代码之后，才会开始解析后面 &lt;script&gt; 元素中的代码。 由于浏览器会先解析完不使用 defer 属性的 &lt;script&gt; 元素中的代码，然后再解析后面的内容，所以一般应该把 &lt;script&gt; 元素放在页面最后，即主要内容后面， &lt;/body&gt; 标签前面。 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。 使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。 另外，使用 &lt;noscript&gt; 元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示 &lt;noscript&gt; 元素中的任何内容。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记- JavaScript简介]]></title>
    <url>%2F2018%2F08%2F30%2FJavaScript-brief%2F</url>
    <content type="text"><![CDATA[JavaScript 简介JavaScript 诞生于 1995 年。当时，它的主要目的是处理以前由服务器端语言（如 Perl）负责的一些输入验证操作。在 JavaScript 问世之前，必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填域，是否输入了无效的值。Netscape Navigator 希望通过 JavaScript 来解决这个问题。在人们普遍使用电话拔号上网的年代，能够在客户端完成一些基本的验证任务绝对是令人兴奋的。毕竟，拨号上网的速度之慢，导致了与服务器的每一次数据交换事实上都成了对人们耐心的一次考验。 自此以后，JavaScript 逐渐成为市面上常见浏览器必备的一项特色功能。如今，JavaScript 的用途早已不再局限于简单的数据验证，而是具备了与浏览器窗口及其内容等几乎所有方面交互的能力。今天的 JavaScript 已经成为一门功能全面的编程语言，能够处理复杂的计算和交互，拥有了闭包、匿名（lamda，拉姆达）函数，甚至元编程等特性。作为 Web 的一个重要组成部分，JavaScript 的重要性是不言而喻的，就连手机浏览器，甚至那些专为残障人士设计的浏览器等非常规浏览器都支持它。当然，微软的例子更为典型。虽然有自己的客户端脚本语言 VBScript，但微软仍然在 Internet Explorer 的早期版本中加入了自己的 JavaScript 实现（对 IE 而言，当我们提到 JavaScript时，实际上就是指 IE 对 JavaScript （ECMAScript）的实现——JScript。最早的 JScript基于 Netscape JavaScript 1.0 开发，于 1996 年 8月随同 Internet Explorer 3.0 发布。）。 JavaScript 从一个简单的输入验证器发展成为一门强大的编程语言，完全出乎人们的意料。应该说，它既是一门非常简单的语言，又是一门非常复杂的语言 。说它简单，是因为学会使用它只需片刻功夫；而说它复杂，是因为要真正掌握它则需要数年时间 。要想全面理解和掌握 JavaScript，关键在于弄清楚它的本质、历史和局限性。 JavaScript 简史在 Web 日益流行的同时，人们对客户端脚本语言的需求也越来越强烈。那个时候，绝大多数因特网用户都使用速度仅为 28.8kbit/s 的“猫”（调制解调器）上网，但网页的大小和复杂性却不断增加。为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担。想象一下：用户填写完一个表单，单击“提交”按钮，然后等待 30 秒钟，最终服务器返回消息说有一个必填字段没有填好……当时走在技术革新最前沿的 Netscape 公司，决定着手开发一种客户端语言，用来处理这种简单的验证。 当时就职于 Netscape 公司的布兰登·艾奇（Brendan Eich），开始着手为计划于 1995 年 2 月发布的 Netscape Navigator 2 开发一种名为 LiveScript 的脚本语言——该语言将同时在浏览器和服务器中使用（它在服务器上的名字叫 LiveWire）。为了赶在发布日期前完成 LiveScript 的开发，Netscape 与 Sun 公司建立了一个开发联盟。在 Netscape Navigator 2 正式发布前夕，Netscape 为了搭上媒体热炒 Java 的顺风车，临时把 LiveScript 改名为 JavaScript。 由于 JavaScript 1.0 获得了巨大成功，Netscape 随即在 Netscape Navigator 3 中又发布了 JavaScript 1.1。Web 虽然羽翼未丰，但用户关注度却屡创新高。在这样的背景下，Netscape 把自己定位为市场领袖型公司。与此同时，微软决定向与 Navigator 竞争的自家产品 Internet Explorer 浏览器投入更多资源。Netscape Navigator 3发布后不久，微软就在其 Internet Explorer 3中加入了名为 JScript 的 JavaScript 实现（命名为 JScript 是为了避开与 Netscape 有关的授权问题）。以现在的眼光来看，微软 1996 年 8 月为进入 Web 浏览器领域而实施的这个重大举措，是导致 Netscape 日后蒙羞的一个标志性事件。然而，这个重大举措同时也标志着 JavaScript 作为一门语言，其开发向前迈进了一大步。 微软推出其 JavaScript 实现意味着有了两个不同的 JavaScript 版本：Netscape Navigator 中的 JavaScript、Internet Explorer 中的 JScript。与 C 及其他编程语言不同，当时还没有标准规定 JavaScript 的语法和特性，两个不同版本并存的局面已经完全暴露了这个问题。随着业界担心的日益加剧，JavaScript 的标准化问题被提上了议事日程。 1997 年，以 JavaScript 1.1 为蓝本的建议被提交给了欧洲计算机制造商协会（ECMA，European Computer Manufacturers Association）。该协会指定 39 号技术委员会（TC39，Technical Committee #39）负责“标准化一种通用、跨平台、供应商中立的脚本语言的语法和语义”（ http://www.ecmainternational.org/memento/TC39.htm ）。TC39 由来自 Netscape、Sun、微软、Borland 及其他关注脚本语言发展的公司的程序员组成，他们经过数月的努力完成了 ECMA-262——定义一种名为 ECMAScript（发音为“ek-ma-script”）的新脚本语言的标准。 第二年，ISO/IEC（International Organization for Standardization and International Electrotechnical Commission，国标标准化组织和国际电工委员会）也采用了 ECMAScript 作为标准（即 ISO/IEC-16262）。自此以后，浏览器开发商就开始致力于将 ECMAScript 作为各自 JavaScript 实现的基础，也在不同程度上取得了成功。 JavaScript 实现虽然 JavaScript 和 ECMAScript 通常都被人们用来表达相同的含义，但 JavaScript 的含义却比 ECMA-262 中规定的要多得多。没错，一个完整的 JavaScript 实现应该由下列三个不同的部分组成（见下图）。 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） ECMAScript由 ECMA-262 定义的 ECMAScript 与 Web浏览器没有依赖关系。实际上，这门语言本身并不包含输入和输出定义。ECMA-262 定义的只是这门语言的基础，而在此基础之上可以构建更完善的脚本语言。我们常见的 Web 浏览器只是 ECMAScript 实现可能的宿主环境之一。宿主环境不仅提供基本的 ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。而这些扩展——如 DOM，则利用 ECMAScript 的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。其他宿主环境包括 Node（一种服务端 JavaScript 平台）和 Adobe Flash。 既然 ECMA-262 标准没有参照 Web 浏览器，那它都规定了些什么内容呢？大致说来，它规定了这门语言的下列组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述。JavaScript 实现了 ECMAScript，Adobe ActionScript 同样也实现了 ECMAScript。 ECMAScript 的版本ECMAScript 的不同版本又称为版次，以第 x 版表示（意即描述特定实现的 ECMA-262 规范的第 x 个版本）。ECMA-262 的最近一版是第 5 版，发布于 2009 年。而 ECMA-262 的第 1 版本质上与 Netscape 的 JavaScript 1.1 相同——只不过删除了所有针对浏览器的代码并作了一些较小的改动：ECMA-262 要求支持 Unicode 标准（从而支持多语言开发），而且对象也变成了平台无关的（Netscape JavaScript 1.1 的对象在不同平台中的实现不一样，例如 Date 对象）。这也是 JavaScript 1.1 和 1.2 与 ECMA-262 第 1 版不一致的主要原因。 ECMA-262 第 2 版主要是编辑加工的结果。这一版中内容的更新是为了与 ISO/IEC-16262 保持严格一致，没有作任何新增、修改或删节处理。因此，一般不使用第 2 版来衡量 ECMAScript 实现的兼容性。 ECMA-262 第 3 版才是对该标准第一次真正的修改。修改的内容涉及字符串处理、错误定义和数值输出。这一版还新增了对正则表达式、新控制语句、 try-catch 异常处理的支持，并围绕标准的国际化做出了一些小的修改。从各方面综合来看，第 3 版标志着 ECMAScript 成为了一门真正的编程语言。 ECMA-262 第 4 版对这门语言进行了一次全面的检核修订。由于 JavaScript在 Web上日益流行，开发人员纷纷建议修订 ECMAScript，以使其能够满足不断增长的 Web 开发需求。作为回应，ECMA TC39重新召集相关人员共同谋划这门语言的未来。结果，出台后的标准几乎在第 3 版基础上完全定义了一门新语言。第 4 版不仅包含了强类型变量、新语句和新数据结构、真正的类和经典继承，还定义了与数据交互的新方式。 与此同时，TC39 下属的一个小组也提出了一个名为 ECMAScript 3.1 的替代性建议，该建议只对这门语言进行了较少的改进。这个小组认为第 4 版给这门语言带来的跨越太大了。因此，该小组建议对这门语言进行小幅修订，能够在现有 JavaScript 引擎基础上实现。最终，ES3.1 附属委员会获得的支持超过了 TC39，ECMA-262 第 4 版在正式发布前被放弃。 ECMAScript 3.1 成为 ECMA-262 第 5 版，并于 2009 年 12 月 3 日正式发布。第 5 版力求澄清第 3 版中已知的歧义并增添了新的功能。新功能包括原生 JSON 对象（用于解析和序列化 JSON 数据）、继承的方法和高级属性定义，另外还包含一种严格模式，对 ECMAScript 引擎解释和执行代码进行了补充说明。 什么是 ECMAScript 兼容ECMA-262 给出了 ECMAScript 兼容的定义。要想成为 ECMAScript 的实现，则该实现必须做到： 支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序句法和语义”（ECMA-262第 1 页）； 支持 Unicode 字符标准。此外，兼容的实现还可以进行下列扩展。 添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”。ECMA-262 所说的这些新增特性，主要是指该标准中没有规定的新对象和对象的新属性。 支持 ECMA-262 没有定义的“程序和正则表达式语法”。（也就是说，可以修改和扩展内置的正则表达式语法。） 上述要求为兼容实现的开发人员基于 ECMAScript 开发一门新语言提供了广阔的空间和极大的灵活性，这也从另一个侧面说明了 ECMAScript 受开发人员欢迎的原因。 Web 浏览器对 ECMAScript 的支持1996 年，Netscape Navigator 3 捆绑发布了 JavaScript 1.1。而相同的 JavaScript 1.1 设计规范随后作为对新标准（ECMA-262）的建议被提交给 Ecma。伴随着 JavaScript 的迅速走红，Netscape 豪情满怀地着手开发 JavaScript 1.2。然而，问题是 Ecma 当时还没有接受 Netscape 的建议。 Netscape Navigator 3发布后不久，微软也推出了 Internet Explorer 3。微软在 IE 的这一版中捆绑了 JScript 1.0，很多人都认为 JScript 1.0 与 JavaScript 1.1 应该是一样的。但是，由于没有文档依据，加之不适当的特性模仿，JScript 1.0 还是很难与 JavaScript 1.1相提并论。 1997 年，内置 JavaScript 1.2 的 Netscape Navigator 4 发布；而到这一年年底，ECMA-262第 1版也被接受并实现了标准化。结果，虽然 ECMAScript 被认为是基于 JavaScript 1.1 制定的，但 JavaScript 1.2 与 ECMAScript 的第 1 版并不兼容。 JScript 的升级版是 Internet Explorer 4 中内置的 JScript 3.0（随同微软 IIS 3.0 发布的 JScript 2.0 从来也没有移植到浏览器中）。微软通过媒体大肆宣传 JScript 3.0 是世界上第一个 ECMA 兼容的脚本语言，但当时的 ECMA-262 尚未定稿。于是，JScript 3.0 与 JavaScript 1.2 都遭遇了相同的尴尬局面——谁都没有按照最终的 ECMAScript 标准来实现。 Netscape 决定更新其 JavaScript 实现，即在 Netscape Navigator 4.06中发布 JavaScript 1.3，从而做到了与 ECMA-262 的第一个版本完全兼容。在 JavaScript 1.3中，Netscape 增加了对 Unicode 标准的支持，并在保留 JavaScript 1.2 新增特性的同时实现了所有对象的平台中立化。 在 Netscape 以 Mozilla 项目的名义开放其源代码时，预期 JavaScript 1.4将随同 Netscape Navigator 5 一道发布。然而，一个激进的决定，彻底重新设计 Netscape 代码，打乱了原有计划。后来，JavaScript 1.4 只发布了针对 Netscape Enterprise Server的服务器版，而没有内置于 Web 浏览器中。 到了 2008 年，五大主流 Web 浏览器（IE、Firefox、Safari、Chrome 和 Opera）全部做到了与 ECMA-262 兼容。IE8 是第一个着手实现 ECMA-262 第 5 版的浏览器，并在 IE9 中提供了完整的支持。Firefox 4也紧随其后做到兼容。下表列出了 ECMAScript 受主流 Web 浏览器支持的情况。 文档对象模型（DOM）文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于 HTML 的应用程序编程接口（API，Application Programming Interface）。DOM 把整个页面映射为一个多层节点结构。HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。看下面这个 HTML 页面： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 在 DOM 中，这个页面可以通过图 1-2 所示的分层节点图表示。 通过 DOM 创建的这个表示文档的树形图，开发人员获得了控制页面内容和结构的主动权。借助 DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点。 为什么要使用 DOM在 Internet Explorer 4 和 Netscape Navigator 4 分别支持的不同形式的 DHTML（Dynamic HTML）基础上，开发人员首次无需重新加载网页，就可以修改其外观和内容了。然而，DHTML 在给 Web技术发展带来巨大进步的同时，也带来了巨大的问题。由于 Netscape 和微软在开发 DHTML 方面各持己见，过去那个只编写一个 HTML 页面就能够在任何浏览器中运行的时代结束了。 对开发人员而言，如果想继续保持 Web 跨平台的天性，就必须额外多做一些工作。而人们真正担心的是，如果不对 Netscape 和微软加以控制，Web 开发领域就会出现技术上两强割据，浏览器互不兼容的局面。此时，负责制定 Web 通信标准的 W3C（World Wide Web Consortium，万维网联盟）开始着手规划 DOM。 DOM 级别DOM1 级（DOM Level 1）于 1998 年 10 月成为 W3C 的推荐标准。DOM1 级由两个模块组成：DOM核心（DOM Core）和 DOM HTML。其中，DOM 核心规定的是如何映射基于 XML 的 文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在 DOM 核心的基础上加以扩展，添加了针对 HTML 的对象和方法。 请读者注意，DOM 并不只是针对 JavaScript 的，很多别的语言也都实现了 DOM。不过，在 Web 浏览器中，基于 ECMAScript 实现的 DOM 的确已经成为 JavaScript 这门语言的一个重要组成部分。 如果说 DOM1 级的目标主要是映射文档的结构，那么 DOM2 级的目标就要宽泛多了。DOM2 级在原来 DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 文档的方法）等细分模块，而且通过对象接口增加了对 CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1 级中的 DOM 核心模块也经过扩展开始支持 XML 命名空间。 DOM2 级引入了下列新模块，也给出了众多新类型和新接口的定义。 DOM 视图（DOM Views）：定义了跟踪不同文档（例如，应用 CSS 之前和之后的文档）视图的接口； DOM 事件（DOM Events）：定义了事件和事件处理的接口； DOM 样式（DOM Style）：定义了基于 CSS 为元素应用样式的接口； DOM 遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口。 DOM3 级则进一步扩展了 DOM，引入了以统一方式加载和保存文档的方法——在 DOM 加载和保存（DOM Load and Save）模块中定义；新增了验证文档的方法——在 DOM 验证（DOM Validation）模块中定义。DOM3 级也对 DOM 核心进行了扩展，开始支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base。 在阅读 DOM ，DOM0 级指的是 Internet Explorer 4.0 和 Netscape Navigator 4.0最标准的时候，读者可能会看到 DOM0 级（DOM Level 0）的字眼。实际上，DOM0 级标准是不存在的；所谓 DOM0 级只是 DOM 历史坐标中的一个参照点而已。具体说来初支持的 DHTML。 其他 DOM 标准除了 DOM 核心和 DOM HTML 接口之外，另外几种语言还发布了只针对自己的 DOM 标准。下面列出的语言都是基于 XML 的，每种语言的 DOM 标准都添加了与特定语言相关的新方法和新接口： SVG（Scalable Vector Graphic，可伸缩矢量图）1.0； MathML（Mathematical Markup Language，数学标记语言）1.0； SMIL（Synchronized Multimedia Integration Language，同步多媒体集成语言）。 还有一些语言也开发了自己的 DOM 实现，例如 Mozilla 的 XUL（XML User Interface Language，XML用户界面语言）。但是，只有上面列出的几种语言是 W3C 的推荐标准。 Web 浏览器对 DOM 的支持在 DOM 标准出现了一段时间之后，Web 浏览器才开始实现它。微软在 IE5 中首次尝试实现 DOM，但直到 IE5.5 才算是真正支持 DOM1 级。在随后的 IE6 和 IE7 中，微软都没有引入新的 DOM 功能，而到了 IE8 才对以前 DOM 实现中的 bug 进行了修复。 Netscape直到 Netscape 6（Mozilla 0.6.0）才开始支持 DOM。在 Netscape 7之后，Mozilla把开发重心转向了 Firefox浏览器。Firefox 3完全支持 DOM1级，几乎完全支持 DOM2级，甚至还支持 DOM3级的一部分。（Mozilla开发团队的目标是构建与标准 100%兼容的浏览器，而他们的努力也得到了回报。） 目前，支持 DOM已经成为浏览器开发商的首要目标，主流浏览器每次发布新版本都会改进对 DOM的支持。下表列出了主流浏览器对 DOM 标准的支持情况。 浏览器对象模型（BOM）Internet Explorer 3 和 Netscape Navigator 3 有一个共同的特色，那就是支持可以访问和操作浏览器窗口的浏览器对象模型（BOM，Browser Object Model）。开发人员使用 BOM 可以控制浏览器显示的页面以外的部分。而 BOM 真正与众不同的地方（也是经常会导致问题的地方），还是它作为 JavaScript 实现的一部分但却没有相关的标准。这个问题在 HTML5 中得到了解决，HTML5 致力于把很多 BOM功能写入正式规范。HTML5 发布后，很多关于 BOM 的困惑烟消云散。 从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的 JavaScript 扩展算作 BOM的一部分。下面就是一些这样的扩展： 弹出新浏览器窗口的功能； 移动、缩放和关闭浏览器窗口的功能； 提供浏览器详细信息的 navigator 对象； 提供浏览器所加载页面的详细信息的 location 对象； 提供用户显示器分辨率详细信息的 screen 对象； 对 cookies 的支持； 像 XMLHttpRequest 和 IE的 ActiveXObject 这样的自定义对象。 由于没有 BOM标准可以遵循，因此每个浏览器都有自己的实现。虽然也存在一些事实标准，例如要有 window 对象和 navigator 对象等，但每个浏览器都会为这两个对象乃至其他对象定义自己的属性和方法。现在有了 HTML5，BOM 实现的细节有望朝着兼容性越来越高的方向发展。第 8 章将深入讨论 BOM。 JavaScript 版本作为 Netscape“继承人”的 Mozilla 公司，是目前唯一还在沿用最初的 JavaScript 版本编号序列的浏览器开发商。在 Netscape 将源代码提交给开源的 Mozilla 项目的时候，JavaScript 在浏览器中的最后一个版本号是 1.3。（如前所述，1.4版是只针对服务器的实现。）后来，随着 Mozilla基金会继续开发 JavaScript，添加新的特性、关键字和语法，JavaScript 的版本号继续递增。下表列出了 Netscape/Mozilla 浏览器中 JavaScript 版本号的递增过程： 实际上，上表中的编号方案源自 Firefox 4 将内置 JavaScript 2.0 这一共识。因此，2.0 版之前每个递增的版本号，表示的是相应实现与 JavaScript 2.0 开发目标还有多大的距离。虽然原计划是这样，但 JavaScript 的这种发展速度让这个计划不再可行。目前，JavaScript 2.0还没有目标实现。 请注意，只有 Netscape/Mozilla浏览器才遵循这种编号模式。例如，IE 的 JScript 就采用了另一种版本命名方案。换句话说，JScript 的版本号与上表中 JavaScript 的版本号之间不存在任何对应关系。而且，大多数浏览器在提及对 JavaScript 的支持情况时，一般都以 ECMAScript 兼容性和对 DOM的支持情况为准。 小结JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成： ECMAScript，由 ECMA-262 定义，提供核心语言功能； 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM），提供与浏览器交互的方法和接口。 JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中都得到了不同程度的支持。其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对 ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单导航]]></title>
    <url>%2F2018%2F08%2F29%2Fnav%2F</url>
    <content type="text"><![CDATA[垂直导航HTML 结构1234567&lt;ul&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;首 页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻快讯&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;产品展示&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;售后服务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;联系我们&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; CSS 样式 1234567891011121314151617181920212223242526/* reset */* &#123; margin: 0; padding: 0; font-size: 14px;&#125;/* reset */ul &#123; list-style: none; /* 清除列表元素样式 */ width: 100px;&#125;a &#123; text-decoration: none; /* 去掉 a 标签下划线 */ display: block; /* 将 a 标签变成块级元素 */ height: 30px; line-height: 30px; width: 100px; background-color: #ccc; margin-bottom: 1px; /* padding-left: 10px; */ text-indent: 10px; /* 文本缩略 与 padding 等价但总体少了 10px*/&#125;a:hover &#123; background-color: #f60; color: fff;&#125; 上面代码，首先将元素样式 reset, 然后清除 ul 元素的默认样式并设置宽度为 100px，紧接着设置 a 标签的下划线去掉，并将 a 标签变成块级元素，这样就可以为 a 标签设置高度和宽度了，然后使用 padding-left 或 text-indent 为文本设置居左的距离，但是由于 padding-left 会增加元素整体的宽度，因此 text-indent 属性来缩进文本更合适。最后再为 a 标签添加上 hover 效果就大功告成了。 水平导航HTML 结构 水平导航和垂直导航的 HTML 结构是完全一致的，只需要对 CSS 样式进行调整。 CSS 样式12345678910111213141516171819202122232425262728/* reset */* &#123; margin: 0; padding: 0; font-size: 14px;&#125;/* reset */ul &#123; list-style: none; /* 清除列表元素样式 *//* width: 100px; */ /* 去掉 */&#125;li &#123; float: left; /* 添加浮动 */&#125;a &#123; text-decoration: none; /* 去掉 a 标签下划线 */ display: block; /* 将 a 标签变成块级元素 */ height: 30px; line-height: 30px; width: 100px; background-color: #ccc; margin-bottom: 1px; text-align: center; /* 文本水平居中对齐 */&#125;a:hover &#123; background-color: #f60; color: fff;&#125; 上面代码是在垂直导航的样式上，首先将 li 元素设置为浮动，然后将 ul 元素的宽度去掉，刷新页面导航就水平了。接着将 a 元素的 text-indent 属性去掉，并使用 text-align 属性将文字设置为水平居中。 写在后面效果展示 参考地址]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[经典算法]]></title>
    <url>%2F2018%2F08%2F29%2FClassical-algorithm%2F</url>
    <content type="text"><![CDATA[动态规划问题 由交叠子问题构成的问题。 动态规划不仅是用来解决某类最优问题的重要工具，而且也被当做一种通用的算法设计技术来使用。 思想 动态规划法建议，与其对交叠的子问题一次又一次地求解，还不如对每个较小的子问题只求解一次并把结果记录在表中，这样就可以从表中得出原始问题的解。 虽然动态规划的直接应用也可以解释成一种特殊类型的空间换时间权衡的技术，但有时候一个动态归还算法经过改进可以避免使用额外的空间。 求解 无论我们使用动态规划的经典的从底至上版本还是它基于记忆功能的从顶至下版本，设计这样的一种算法的关键步骤还是相同的，即 导出一个问题实例的递推关系，该递推关系包含该问题的更小（并且是交叠的）子实例的解 。 最优化法则：该法则认为最优化问题任一实例的最优解，都是其子实例的最优解构成的 。最优化法则在大多数情况下是成立的，尽管也有少数情况例外（图中找最长简单路径）。 典型例子 币值最大化问题 问题描述 求解思路 算法实现]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记- Ajax 与 Comet]]></title>
    <url>%2F2018%2F08%2F28%2FJavaScript-Ajax-and-Comet%2F</url>
    <content type="text"><![CDATA[Ajax 与 Comet2005 年，Jesse James Garrett 发表了一篇在线文章，题为“Ajax: A new Approach to Web Applications”（ http://www.adaptivepath.com/ideas/essays/archives/000385.php ）。他在这篇文章里介绍了一种技术，用他的话说，就叫 Ajax，是对 Asynchronous JavaScript + XML 的简写 。这一技术能够向服务器请求额外的数据而无须卸载页面 ，会带来更好的用户体验 。Garrett 还解释了怎样使用这一技术改变自从 Web 诞生以来就一直沿用的“单击，等待”的交互模式。 Ajax 技术的核心 是 XMLHttpRequest 对象（简称 XHR），这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。在 XHR 出现之前，Ajax 式的通信必须借助一些 hack 手段来实现，大多数是使用隐藏的框架或内嵌框架 。XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口 。能够以异步方式从服务器取得更多信息，意味着 用户单击后 ，可以不必刷新页面也能取得新数据 。也就是说，可以使用 XHR 对象取得新数据 ，然后 再通过 DOM 将新数据插入到页面中 。另外，虽然名字中包含 XML 的成分，但 Ajax 通信与数据格式无关 ；这种技术就是 无须刷新页面即可从服务器取得数据 ，但不一定是 XML 数据。 实际上，Garrett 提到的这种技术已经存在很长时间了。在 Garrett 撰写那篇文章之前，人们通常将这种技术叫做 远程脚本（remote scripting），而且早在 1998 年就有人采用不同的手段实现了这种浏览器与服务器的通信。再往前推，JavaScript 需要通过 Java applet 或 Flash 电影等中间层向服务器发送请求 。而 XHR 则将浏览器原生的通信能力提供给了开发人员 ，简化了实现同样操作的任务 。 在重命名为 Ajax 之后，大约是 2005 年底 2006 年初，这种浏览器与服务器的通信技术可谓红极一时。人们对 JavaScript 和 Web 的全新认识，催生了很多使用原有特性的新技术和新模式。就目前来说，熟练使用 XHR 对象已经成为所有 Web 开发人员必须掌握的一种技能。 XMLHttpRequest 对象IE5 是第一款引入 XHR 对象的浏览器。在 IE5 中，XHR 对象是通过 MSXML 库中的一个 ActiveX 对象实现的。因此，在 IE 中可能会遇到三种不同版本的 XHR 对象，即 MSXML2.XMLHttp 、MSXML2.XMLHttp.3.0 和 MXSML2.XMLHttp.6.0 。要使用 MSXML 库中的 XHR 对象，需要像第 18 章讨论创建 XML 文档时一样，编写一个函数，例如： 12345678910111213141516171819//适用于 IE7 之前的版本function createXHR()&#123; if (typeof arguments.callee.activeXString != "string")&#123; var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"], i, len; for (i=0,len=versions.length; i &lt; len; i++)&#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex)&#123; //跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString);&#125; 这个函数会尽力根据 IE 中可用的 MSXML 库的情况创建最新版本的 XHR 对象。 IE7+、Firefox、Opera、Chrome 和 Safari 都支持原生的 XHR 对象，在这些浏览器中 创建 XHR 对象 要像下面这样 使用 XMLHttpRequest 构造函数 。 1var xhr = new XMLHttpRequest(); 假如你只想支持 IE7 及更高版本，那么大可丢掉前面定义的那个函数，而只用原生的 XHR 实现。 但是，如果你必须还要支持 IE 的早期版本，那么则可以在这个 createXHR() 函数中加入对原生 XHR 对象的支持。 1234567891011121314151617181920212223function createXHR()&#123; if (typeof XMLHttpRequest != "undefined")&#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != "undefined")&#123; if (typeof arguments.callee.activeXString != "string")&#123; var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"], i, len; for (i=0,len=versions.length; i &lt; len; i++)&#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex)&#123; //跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error("No XHR object available."); &#125;&#125; 这个函数中新增的代码首先 检测原生 XHR 对象是否存在 ，如果存在则返回它的新实例。如果原生对象不存在，则 检测 ActiveX对象 。如果这两种对象都不存在，就抛出一个错误。然后，就可以使用下面的代码在所有浏览器中 创建 XHR 对象 了。 1var xhr = createXHR(); 由于其他浏览器中对 XHR 的实现与 IE 最早的实现是兼容的，因此就可以在 所有浏览器中都以相同方式使用上面创建的 xhr 对象 。 XHR 的用法在 使用 XHR 对象 时，要调用的第一个方法是 open() ，它接受 3 个参数：要发送的请求的类型（ “get” 、 “post” 等）、请求的 URL 和 表示是否异步发送请求的布尔值 。下面就是调用这个方法的例子。 1xhr.open("get", "example.php", false); 这行代码会启动一个针对 example.php 的 GET 请求。有关这行代码，需要说明两点：一是 URL 相对于执行代码的当前页面 （当然也可以使用绝对路径）；二是 调用 open() 方法并不会真正发送请求 ，而 只是启动一个请求以备发送 。 只能向同一个域中使用相同端口和协议的 URL 发送请求 。如果 URL 与启动请求页面有任何差别，都会引发安全错误。 要 发送特定的请求 ，必须像下面这样调用 send() 方法 ： 12xhr.open("get", "example.txt", false);xhr.send(null); 这里的 send() 方法 接收一个参数，即 要作为请求主体发送的数据 。如果不需要通过请求主体发送数据 ，则 必须传入 null ，因为 这个参数对有些浏览器来说是必需的 。调用 send() 之后，请求就会被分派到服务器 。 由于这次 请求是同步的 ，JavaScript 代码会等到服务器响应之后再继续执行 。在收到响应后，响应的数据会自动填充 XHR 对象的属性 ，相关的属性简介如下。 responseText ：作为响应主体被返回的文本。 responseXML ：如果响应的内容类型是 “text/xml” 或 “application/xml” ，这个属性中将保存包含着响应数据的 XML DOM 文档。 status ：响应的 HTTP 状态。 statusText ：HTTP 状态的说明。 在接收到响应后，第一步是 检查 status 属性 ，以确定响应已经成功返回。一般来说，可以将 HTTP 状态代码为 200 作为成功的标志 。此时， responseText 属性的内容已经就绪，而且在内容类型正确的情况下， responseXML 也应该能够访问了。此外，状态代码为 304 表示请求的资源并没有被修改 ，可以直接使用浏览器中缓存的版本 ；当然，也意味着响应是有效的 。为确保接收到适当的响应，应该像下面这样检查上述这两种状态代码 ： 12345678xhr.open("get", "example.txt", false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText);&#125; else &#123; alert("Request was unsuccessful: " + xhr.status);&#125; 根据返回的状态代码，这个例子可能会显示由服务器返回的内容，也可能会显示一条错误消息。我们建议读者要通过检测 status 来决定下一步的操作，不要依赖 statusText ，因为后者在跨浏览器使用时不太可靠。另外，无论内容类型是什么，响应主体的内容都会保存到 responseText 属性中 ；而 对于非 XML 数据而言 ， responseXML 属性的值将为 null 。 有的浏览器会错误地报告 204 状态代码。IE 中 XHR 的 ActiveX 版本会将 204 设置为 1223，而 IE 中原生的 XHR 则会将 204 规范化为 200。Opera 会在取得 204 时报告 status 的值为 0。 像前面这样发送同步请求当然没有问题，但多数情况下，我们还是要发送异步请求，才能让 JavaScript 继续执行而不必等待响应。此时，可以检测 XHR 对象的 readyState 属性，该属性表示请求响应过程的当前活动阶段 。这个属性可取的值如下。 0 ：未初始化。尚未调用 open() 方法。 1 ：启动。已经调用 open() 方法，但尚未调用 send() 方法。 2 ：发送。已经调用 send() 方法，但尚未接收到响应。 3 ：接收。已经接收到部分响应数据。 4 ：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 只要 readyState 属性的值由一个值变成另一个值，都会触发一次 readystatechange 事件 。可以利用这个事件来检测每次状态变化后 readyState 的值。通常，我们只对 readyState 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用 open() 之前指定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性 。下面来看一个例子。 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("get", "example.txt", true);xhr.send(null); 以上代码利用 DOM 0级方法为 XHR 对象添加了事件处理程序，原因是并非所有浏览器都支持 DOM 2 级方法。与其他事件处理程序不同，这里没有向 onreadystatechange 事件处理程序中传递 event 对象 ；必须通过 XHR 对象本身来确定下一步该怎么做 。 这个例子 在 onreadystatechange 事件处理程序中使用了 xhr 对象 ，没有使用 this 对象 ，原因是 onreadystatechange 事件处理程序的作用域问题 。如果使用 this 对象，在有的浏览器中会导致函数执行失败，或者导致错误发生。因此，使用实际的 XHR 对象实例变量是较为可靠的一种方式 。 另外，在接收到响应之前还可以调用 abort() 方法来取消异步请求 ，如下所示： 1xhr.abort(); 调用这个方法后，XHR 对象会停止触发事件 ，而且 也不再允许访问任何与响应有关的对象属性 。在终止请求之后，还应该对 XHR 对象进行解引用操作 。由于内存原因，不建议重用 XHR 对象。 HTTP头部信息每个 HTTP 请求和响应都会带有相应的头部信息 ，其中有的对开发人员有用，有的也没有什么用。XHR 对象也提供了操作这两种头部（即请求头部和响应头部）信息的方法 。 默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。 Accept ：浏览器能够处理的内容类型。 Accept-Charset ：浏览器能够显示的字符集。 Accept-Encoding ：浏览器能够处理的压缩编码。 Accept-Language ：浏览器当前设置的语言。 Connection ：浏览器与服务器之间连接的类型。 Cookie ：当前页面设置的任何 Cookie。 Host ：发出请求的页面所在的域 。 Referer ：发出请求的页面的 URI。注意，HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。（这个英文单词的正确拼法应该是 referrer。） User-Agent ：浏览器的用户代理字符串。 虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。使用 setRequestHeader() 方法 可以 设置自定义的请求头部信息 。这个方法接受两个参数：头部字段的名称 和 头部字段的值 。要成功发送请求头部信息，必须在调用 open() 方法之后且调用 send() 方法之前调用 setRequestHeader() ，如下面的例子所示。 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("get", "example.php", true);xhr.setRequestHeader("MyHeader", "MyValue");xhr.send(null); 服务器在接收到这种自定义的头部信息之后，可以执行相应的后续操作 。我们 建议读者使用自定义的头部字段名称 ，不要使用浏览器正常发送的字段名称 ，否则有可能会影响服务器的响应 。有的浏览器允许开发人员重写默认的头部信息，但有的浏览器则不允许这样做。 调用 XHR 对象的 getResponseHeader() 方法并传入头部字段名称 ，可以 取得相应的响应头部信息 。而 调用 getAllResponseHeaders() 方法 则可以 取得一个包含所有头部信息的长字符串 。来看下面的例子。 12var myHeader = xhr.getResponseHeader("MyHeader");var allHeaders = xhr.getAllResponseHeaders(); 在服务器端，也可以 利用头部信息向浏览器发送额外的、结构化的数据 。在没有自定义信息的情况下， getAllResponseHeaders() 方法通常会返回如下所示的多行文本内容 ： 123456Date: Sun, 14 Nov 2004 18:04:03 GMTServer: Apache/1.3.29 (Unix)Vary: AcceptX-Powered-By: PHP/4.3.8Connection: closeContent-Type: text/html; charset=iso-8859-1 这种格式化的输出可以方便我们 检查响应中所有头部字段的名称 ，而不必一个一个地检查某个字段是否存在。 GET 请求GET 是最常见的请求类型 ，最常用于向服务器查询某些信息 。必要时，可以将查询字符串参数追加到 URL 的末尾 ，以便将信息发送给服务器 。对 XHR 而言，位于传入 open() 方法的 URL 末尾的查询字符串必须经过正确的编码才行 。 使用 GET 请求经常会发生的一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用 encodeURIComponent() 进行编码 ，然后才能放到 URL 的末尾 ；而且 所有名-值对儿都必须由和号（&amp;）分隔 ，如下面的例子所示。 1xhr.open("get", "example.php?name1=value1&amp;name2=value2", true); 下面这个函数 可以辅助向现有 URL 的末尾添加查询字符串参数： 12345function addURLParam(url, name, value) &#123; url += (url.indexOf("?") == -1 ? "?" : "&amp;"); url += encodeURIComponent(name) + "=" + encodeURIComponent(value); return url;&#125; 这个 addURLParam() 函数接受三个参数：要添加参数的 URLv 、参数的名称 和参数的值 。这个函数首先 检查 URL 是否包含问号（以确定是否已经有参数存在）。如果没有 ，就添加一个问号 ；否则 ，就添加一个和号 。然后，将参数名称和值进行编码 ，再添加到 URL 的末尾 。最后返回添加参数之后的 URL 。 下面是使用这个函数来 构建请求 URL 的示例。 12345678var url = "example.php";//添加参数url = addURLParam(url, "name", "Nicholas");url = addURLParam(url, "book", "Professional JavaScript");//初始化请求xhr.open("get", url, false); 在这里 使用 addURLParam() 函数可以确保查询字符串的格式良好 ，并可靠地用于 XHR 对象 。 POST 请求使用频率仅次于 GET 的是 POST 请求 ，通常用于向服务器发送应该被保存的数据 。 POST 请求应该把数据作为请求的主体提交 ，而 GET 请求传统上不是这样 。 POST 请求的主体可以包含非常多的数据 ，而且 格式不限 。在 open() 方法 第一个参数的位置 传入 “post” ，就可以初始化一个 POST 请求 ，如下面的例子所示。 1xhr.open("post", "example.php", true); 发送 POST 请求 的第二步就是 向 send() 方法中传入某些数据 。由于 XHR 最初的设计主要是为了处理 XML，因此可以在此传入 XML DOM 文档，传入的文档经序列化之后将作为请求主体被提交到服务器 。当然，也可以在此传入任何想发送到服务器的字符串 。 默认情况下，服务器对 POST 请求和提交 Web 表单的请求并不会一视同仁 。因此，服务器端必须有程序来读取发送过来的原始数据 ，并从中解析出有用的部分 。不过，我们 可以使用 XHR 来模仿表单提交 ：首先 将 Content-Type 头部信息设置为 application/x-www-form-urlencoded ，也就是 表单提交时的内容类型 ，其次 是以适当的格式创建一个字符串 。第 14 章曾经讨论过， POST 数据的格式与查询字符串格式相同 。如果需要将页面中表单的数据进行序列化，然后再通过 XHR 发送到服务器 ，那么就可以使用第 14 章介绍的 serialize() 函数来创建这个字符串 ： 1234567891011121314151617function submitData()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("post", "postexample.php", true);xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");var form = document.getElementById("user-info");xhr.send(serialize(form));&#125; 这个函数可以将 ID 为 “user-info” 的表单中的数据序列化之后发送给服务器。而下面的示例 PHP文件 postexample.php 就可以通过 $_POST 取得提交的数据了： 1234567&lt;?php header("Content-Type: text/plain"); echo &lt;&lt;&lt;EOFName: &#123;$_POST[‘user-name’]&#125;Email: &#123;$_POST[‘user-email’]&#125;EOF;?&gt; 如果不设置 Content-Type 头部信息，那么发送给服务器的数据就不会出现在 $_POST 超级全局变量中 。这时候，要访问同样的数据 ，就必须借助 $HTTP_RAW_POST_DATA 。 与 GET 请求相比， POST 请求消耗的资源会更多一些。从性能角度来看，以发送相同的数据计， GET 请求的速度最多可达到 POST 请求的两倍 。 XMLHttpRequest 2 级鉴于 XHR 已经得到广泛接受，成为了事实标准，W3C 也着手制定相应的标准以规范其行为。 XMLHttpRequest 1 级只是把已有的 XHR 对象的实现细节描述了出来。而 XMLHttpRequest 2 级则进一步发展了 XHR。并非所有浏览器都完整地实现了 XMLHttpRequest 2 级规范，但 所有浏览器 都实现了它规定的 部分内容 。 FormData现代 Web 应用中频繁使用的一项功能就是 表单数据的序列化 ，XMLHttpRequest 2 级为此定义了 FormData 类型 。 FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利 。下面的代码 创建了一个 FormData 对象 ，并 向其中添加了一些数据 。 12var data = new FormData();data.append("name", "Nicholas"); 这个 append() 方法 接收两个参数：键 和 值 ，分别 对应表单字段的名字 和 字段中包含的值 。可以像这样添加任意多个键值对儿 。而 通过向 FormData 构造函数中传入表单元素，也可以用表单元素的数据预先向其中填入键值对儿 ： 1var data = new FormData(document.forms[0]); 创建了 FormData 的实例后，可以将它直接传给 XHR 的 send() 方法 ，如下所示： 1234567891011121314var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("post","postexample.php", true);var form = document.getElementById("user-info");xhr.send(new FormData(form)); 使用 FormData 的方便之处体现在 不必明确地在 XHR 对象上设置请求头部 。 XHR 对象能够识别传入的数据类型是 FormData 的实例 ，并配置适当的头部信息 。 支持 FormData 的浏览器有 Firefox 4+、Safari 5+、Chrome 和 Android 3+版 WebKit。 超时设定IE8 为 XHR 对象添加了一个 timeout 属性 ，表示 请求在等待响应多少毫秒之后就终止 。在给 timeout 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应 ，那么就会 触发 timeout 事件 ，进而会 调用 ontimeout 事件处理程序 。这项功能后来也被收入了 XMLHttpRequest 2 级规范中。来看下面的例子。 123456789101112131415161718192021var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; try &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125; catch (ex)&#123; //假设由 ontimeout 事件处理程序处理 &#125; &#125;&#125;;xhr.open("get", "timeout.php", true);xhr.timeout = 1000; // 将超时设置为 1 秒钟（仅适用于 IE8+ ）xhr.ontimeout = function()&#123; alert("Request did not return in a second.");&#125;;xhr.send(null); 这个例子示范了如何使用 timeout 属性。将这个属性设置为 1000 毫秒，意味着如果请求在 1 秒钟内还没有返回，就会自动终止。请求终止时，会调用 ontimeout 事件处理程序。但此时 readyState 可能已经改变为 4 了，这意味着会调用 onreadystatechange 事件处理程序。可是，如果在超时终止请求之后再访问 status 属性 ，就会导致错误 。为避免浏览器报告错误，可以将检查 status 属性的语句封装在一个 try-catch 语句当中 。 在写作本书时，IE 8+仍然是唯一支持超时设定的浏览器。 overrideMimeType() 方法Firefox 最早引入了 overrideMimeType() 方法 ，用于重写 XHR 响应的 MIME 类型 。这个方法后来也被纳入了 XMLHttpRequest 2 级规范。因为 返回响应的 MIME 类型决定了 XHR 对象如何处理它 ，所以 提供一种方法能够重写服务器返回的 MIME 类型是很有用的 。 比如，服务器返回的 MIME 类型是 text/plain ，但 数据中实际包含的是 XML 。根据 MIME 类型，即使数据是 XML ， responseXML 属性中仍然是 null 。通过调用 overrideMimeType() 方法 ，可以保证把响应当作 XML 而非纯文本来处理 。 1234var xhr = createXHR();xhr.open("get", "text.php", true);xhr.overrideMimeType("text/xml");xhr.send(null); 这个例子强迫 XHR 对象将响应当作 XML 而非纯文本来处理。调用 overrideMimeType() 必须在 send() 方法之前，才能保证重写响应的 MIME 类型 。 支持 overrideMimeType() 方法的浏览器有 Firefox、Safari 4+、Opera 10.5 和 Chrome。 进度事件Progress Events 规范是 W3C 的一个工作草案，定义了与客户端服务器通信有关的事件。这些事件最早其实只针对 XHR 操作，但目前也被其他 API 借鉴。有以下 6 个进度事件。 loadstart ：在接收到响应数据的第一个字节时触发。 progress ：在接收响应期间持续不断地触发。 error ：在请求发生错误时触发。 abort ：在因为调用 abort() 方法而终止连接时触发。 load ：在接收到完整的响应数据时触发。 loadend ：在通信完成或者触发 error 、 abort 或 load 事件后触发。 每个请求 都从 触发 loadstart 事件 开始 ，接下来是 一或多个 progress 事件 ，然后 触发 error 、abort 或 load 事件中的一个 ，最后以 触发 loadend 事件结束 。 支持前 5 个事件的浏览器有 Firefox 3.5+、Safari 4+、Chrome、iOS 版 Safari 和 Android 版 WebKit。Opera（从第 11 版开始）、IE 8+只支持 load 事件。目前还没有浏览器支持 loadend 事件。 这些事件大都很直观，但其中两个事件有一些细节需要注意。 load 事件Firefox 在实现 XHR 对象的某个版本时，曾致力于简化异步交互模型。最终，Firefox 实现中 引入了 load 事件 ，用以 替代 readystatechange 事件 。响应接收完毕后将触发 load 事件 ，因此也就 没有必要去检查 readyState 属性 了。而 onload 事件处理程序会接收到一个 event 对象 ，其 target 属性就指向 XHR 对象实例 ，因而 可以访问到 XHR 对象的所有方法和属性 。然而，并非所有浏览器都为这个事件实现了适当的事件对象。结果，开发人员还是要像下面这样被迫使用 XHR 对象变量。 12345678910var xhr = createXHR();xhr.onload = function()&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125;&#125;;xhr.open("get", "altevents.php", true);xhr.send(null); 只要浏览器接收到服务器的响应，不管其状态如何，都会触发 load 事件 。而这意味着你 必须要检查 status 属性 ，才能确定数据是否真的已经可用了 。 Firefox、Opera、Chrome 和 Safari 都支持 load 事件。 progress 事件Mozilla 对 XHR 的另一个革新是添加了 progress 事件 ，这个事件会 在浏览器接收新数据期间周期性地触发 。而 onprogress 事件处理程序会接收到一个 event 对象 ，其 target 属性是 XHR 对象 ，但包含着三个额外的属性： lengthComputable 、 position 和 totalSize 。其中， lengthComputable 是一个 表示进度信息是否可用的布尔值 ， position 表示已经接收的字节数 ， totalSize 表示根据 Content-Length 响应头部确定的预期字节数 。有了这些信息，我们就 可以为用户创建一个进度指示器了 。下面展示了为用户创建进度指示器的一个示例。 123456789101112131415161718var xhr = createXHR();xhr.onload = function(event)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125;&#125;;xhr.onprogress = function(event)&#123; var divStatus = document.getElementById("status"); if (event.lengthComputable)&#123; divStatus.innerHTML = "Received " + event.position + " of " + event.totalSize +" bytes"; &#125;&#125;;xhr.open("get", "altevents.php", true);xhr.send(null); 为确保正常执行 ，必须在 调用 open() 方法之前添加 onprogress 事件处理程序 。在前面的例子中，每次触发 progress 事件，都会以新的状态信息更新 HTML 元素的内容 。如果 响应头部中包含 Content-Length 字段 ，那么 也可以利用此信息来计算从响应中已经接收到的数据的百分比 。 跨源资源共享通过 XHR 实现 Ajax 通信的一个主要限制 ，来源于 跨域安全策略 。默认情况 下，XHR 对象只能访问与包含它的页面位于同一个域中的资源 。这种安全策略可以预防某些恶意行为 。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的 。 CORS（Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了 在必须访问跨源资源时 ，浏览器与服务器应该如何沟通 。CORS 背后的基本思想 ，就是 使用自定义的 HTTP 头部让浏览器与服务器进行沟通 ，从而 决定请求或响应是应该成功 ，还是 应该失败 。 比如一个 简单的使用 GET 或 POST 发送的请求 ，它 没有自定义的头部 ，而 主体内容是 text/plain 。在 发送该请求 时，需要给它附加一个额外的 Origin 头部 ，其中 包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应 。下面是 Origin 头部的一个示例： 1Origin: http://www.nczonline.net 如果 服务器认为这个请求可以接受 ，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 “*” ）。例如： 1Access-Control-Allow-Origin: http://www.nczonline.net 如果没有这个头部 ，或者 有这个头部但源信息不匹配 ，浏览器就会驳回请求 。正常情况下，浏览器会处理请求 。注意，请求和响应都不包含 cookie 信息。 IE对CORS的实现微软在 IE8 中引入了 XDR（ XDomainRequest ）类型 。这个对象与 XHR 类似，但能实现安全可靠的跨域通信。XDR 对象的安全机制部分实现了 W3C 的 CORS 规范。以下是 XDR 与 XHR 的一些不同之处。 cookie 不会随请求发送，也不会随响应返回。 只能设置请求头部信息中的 Content-Type 字段。 不能访问响应头部信息。 只支持 GET 和 POST 请求。 这些变化使 CSRF（Cross-Site Request Forgery，跨站点请求伪造）和 XSS（Cross-Site Scripting，跨站点脚本）的问题得到了缓解。被请求的资源可以根据它认为合适的任意数据（用户代理、来源页面等）来决定是否设置 Access-Control- Allow-Origin 头部。作为请求的一部分， Origin 头部的值表示请求的来源域，以便远程资源明确地识别 XDR 请求。 XDR对象的使用方法与 XHR对象非常相似 。也是创建一个 XDomainRequest 的实例，调用 open() 方法，再调用 send() 方法。但与 XHR 对象的 open() 方法不同， XDR 对象的 open() 方法 只接收两个参数：请求的类型 和 URL 。 所有 XDR 请求都是异步执行的 ，不能用它来创建同步请求 。请求返回之后，会触发 load 事件，响应的数据也会保存在 responseText 属性 中，如下所示。 123456var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.open("get", "http://www.somewhere-else.com/page/");xdr.send(null); 在接收到响应后，你只能访问响应的原始文本；没有办法确定响应的状态代码。而且，只要 响应有效 就会 触发 load 事件 ，如果 失败 （包括响应中缺少 Access-Control-Allow-Origin 头部）就会触发 error 事件 。遗憾的是，除了错误本身之外，没有其他信息可用，因此唯一能够确定的就只有请求未成功了。要检测错误，可以像下面这样指定一个 onerror 事件处理程序。 123456789var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert("An error occurred.");&#125;;xdr.open("get", "http://www.somewhere-else.com/page/");xdr.send(null); 鉴于导致 XDR 请求失败的因素很多，因此建议你不要忘记通过 onerror 事件处理程序来捕获该事件；否则，即使请求失败也不会有任何提示。 在请求返回前调用 abort() 方法可以终止请求 ： 1xdr.abort(); //终止请求 与 XHR 一样，XDR 对象也 支持 timeout 属性以及 ontimeout 事件处理程序 。下面是一个例子。 12345678910111213var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert("An error occurred.");&#125;;xdr.timeout = 1000;xdr.ontimeout = function()&#123; alert("Request took too long.");&#125;;xdr.open("get", "http://www.somewhere-else.com/page/");xdr.send(null); 这个例子会在运行 1 秒钟后超时，并随即调用 ontimeout 事件处理程序。 为支持 POST 请求，XDR 对象提供了 contentType 属性 ，用来 表示发送数据的格式 ，如下面的例子所示。 12345678910var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert("An error occurred.");&#125;;xdr.open("post", "http://www.somewhere-else.com/page/");xdr.contentType = "application/x-www-form-urlencoded";xdr.send("name1=value1&amp;name2=value2"); 这个属性是 通过 XDR 对象影响头部信息的唯一方式 。 其他浏览器对CORS的实现Firefox 3.5+、Safari 4+、Chrome、iOS版 Safari和 Android平台中的 WebKit都通过 XMLHttpRequest 对象实现了对 CORS 的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的 XHR对象并在 open() 方法中传入绝对 URL即可，例如： 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("get", "http://www.somewhere-else.com/page/", true);xhr.send(null); 与 IE 中的 XDR 对象不同，通过跨域 XHR 对象可以访问 status 和 statusText 属性，而且还支持同步请求。跨域 XHR 对象也有一些限制，但为了安全这些限制是必需的。以下就是这些限制。 不能使用 setRequestHeader() 设置自定义头部。 不能发送和接收 cookie。 调用 getAllResponseHeaders() 方法总会返回空字符串。 由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用 相对 URL ，在访问远程资源时再使用 绝对 URL 。这样做能消除歧义，避免出现限制访问头部或本地 cookie 信息等问题。 Preflighted ReqeustsCORS 通过一种叫做 Preflighted Requests 的透明服务器验证机制支持开发人员使用自定义的头部、GET 或 POST之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会向服务器发送一个 Preflight 请求。这种请求使用 OPTIONS 方法，发送下列头部。 Origin ：与简单的请求相同。 Access-Control-Request-Method ：请求自身使用的方法。 Access-Control-Request-Headers ：（可选）自定义的头部信息，多个头部以逗号分隔。 以下是一个带有自定义头部 NCZ 的使用 POST 方法发送的请求。 123Origin: http://www.nczonline.netAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求 。服务器通过在响应中发送如下头部与浏览器进行沟通。 Access-Control-Allow-Origin ：与简单的请求相同。 Access-Control-Allow-Methods ：允许的方法，多个方法以逗号分隔。 Access-Control-Allow-Headers ：允许的头部，多个头部以逗号分隔。 Access-Control-Max-Age ：应该将这个 Preflight 请求缓存多长时间（以秒表示）。 例如： 1234Access-Control-Allow-Origin: http://www.nczonline.netAccess-Control-Allow-Methods: POST, GETAccess-Control-Allow-Headers: NCZAccess-Control-Max-Age: 1728000 Preflight 请求结束后，结果将按照响应中指定的时间缓存起来。而为此付出的代价只是第一次发送这种请求时会多一次 HTTP 请求。 支持 Preflight 请求的浏览器包括 Firefox 3.5+、Safari 4+和 Chrome。IE 10 及更早版本都不支持。 带凭据的请求默认情况下，跨源请求不提供凭据（cookie、HTTP 认证及客户端 SSL 证明等）。通过将 withCredentials 属性设置为 true ，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的 HTTP 头部来响应。 1Access-Control-Allow-Credentials: true 如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript（于是， responseText 中将是空字符串， status 的值为 0，而且会调用 onerror() 事件处理程序）。另外，服务器还可以在 Preflight 响应中发送这个 HTTP 头部，表示允许源发送带凭据的请求。 支持 withCredentials 属性的浏览器有 Firefox 3.5+、Safari 4+和 Chrome。IE 10 及更早版本都不支持。 跨浏览器的CORS即使浏览器对 CORS 的支持程度并不都一样，但 所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求 ，因此 有必要实现一个跨浏览器的方案 。检测 XHR 是否支持 CORS 的最简单方式，就是检查是否存在 withCredentials 属性。再结合检测 XDomainRequest 对象是否存在，就可以兼顾所有浏览器了。 1234567891011121314151617181920function createCORSRequest(method, url)&#123; var xhr = new XMLHttpRequest(); if (&quot;withCredentials&quot; in xhr)&#123; xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != &quot;undefined&quot;)&#123; vxhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;);if (request)&#123; request.onload = function()&#123; //对 request.responseText 进行处理 &#125;; request.send();&#125; Firefox、Safari 和 Chrome 中的 XMLHttpRequest 对象与 IE 中的 XDomainRequest 对象类似，都提供了够用的接口，因此以上模式还是相当有用的。这两个对象共同的属性/方法如下。 abort() ：用于停止正在进行的请求。 onerror ：用于替代 onreadystatechange 检测错误。 onload ：用于替代 onreadystatechange 检测成功。 responseText ：用于取得响应内容。 send() ：用于发送请求。 以上成员都包含在 createCORSRequest() 函数返回的对象中，在所有浏览器中都能正常使用。 其他跨域技术在 CORS 出现以前，要实现跨域 Ajax 通信颇费一些周折。开发人员想出了一些办法，利用 DOM 中能够执行跨域请求的功能，在不依赖 XHR 对象的情况下也能发送某种请求。虽然 CORS 技术已经无处不在，但开发人员自己发明的这些技术仍然被广泛使用，毕竟这样 不需要修改服务器端代码 。 图像Ping上述第一种跨域请求技术是 使用 &lt;img&gt; 标签 。我们知道，一个网页可以从任何网页中加载图像 ，不用担心跨域不跨域 。这也是在线广告跟踪浏览量的主要方式。正如第 13 章讨论过的，也可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。 动态创建图像经常用于图像 Ping 。图像 Ping 是 与服务器进行简单、单向的跨域通信的一种方式 。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。通过图像 Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时候接收到的。来看下面的例子。 12345var img = new Image();img.onload = img.onerror = function()&#123; alert("Done!");&#125;;img.src = "http://www.example.com/test?name=Nicholas"; 这里创建了一个 Image 的实例，然后将 onload 和 onerror 事件处理程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。请求从设置 src 属性那一刻开始，而这个例子在请求中发送了一个 name 参数。 图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数。图像 Ping 有两个主要的缺点，一是 只能发送 GET 请求 ，二是 无法访问服务器的响应文本 。因此，图像 Ping 只能用于浏览器与服务器间的单向通信 。 JSONPJSONP 是 JSON with padding（填充式 JSON 或 参数式 JSON ）的简写，是 应用 JSON 的一种新方法 ，在后来的 Web 服务中非常流行。JSONP 看起来与 JSON 差不多 ，只不过是被包含在函数调用中的 JSON ，就像下面这样。 1callback(&#123; "name": "Nicholas" &#125;); JSONP 由两部分组成：回调函数 和 数据 。回调函数 是 当响应到来时应该在页面中调用的函数 。回调函数的名字一般是在请求中指定的。而 数据 就是 传入回调函数中的JSON数据 。下面是一个典型的JSONP请求。 1http://freegeoip.net/json/?callback=handleResponse 这个 URL 是在请求一个 JSONP 地理定位服务。通过查询字符串来指定 JSONP 服务的回调参数是很常见的，就像上面的 URL 所示，这里指定的回调函数的名字叫 handleResponse() 。 JSONP 是 通过动态 &lt;script&gt; 元素（要了解详细信息，请参考第 13 章）来使用的 ，使用时 可以为 src 属性指定一个跨域 URL 。这里的 &lt;script&gt; 元素与 &lt;img&gt; 元素类似 ，都有能力不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript 代码，所以在请求完成后，即在 JSONP 响应加载到页面中以后，就会立即执行。来看一个例子。 1234567function handleResponse(response)&#123; alert("You’re at IP address " + response.ip + ", which is in " + response.city + ", " + response.region_name);&#125;var script = document.createElement("script");script.src = "http://freegeoip.net/json/?callback=handleResponse";document.body.insertBefore(script, document.body.firstChild); 这个例子通过查询地理定位服务来显示你的 IP 地址和位置信息。 JSONP 之所以在开发人员中极为流行，主要原因是它非常简单易用。与图像 Ping 相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP 也有两点不足。 首先，JSONP 是从其他域中加载代码执行 。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃 JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的 Web 服务时，一定得保证它安全可靠。 其次，要确定 JSONP 请求是否失败并不容易 。虽然 HTML5 给 &lt;script&gt; 元素新增了一个 onerror 事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和带宽都一样。 CometComet 是 Alex Russell（Alex Russell 是著名 JavaScript 框架 Dojo的创始人。） 发明的一个词儿，指的是 一种更高级的 Ajax 技术（经常也有人称为“服务器推送”）。Ajax 是一种 从页面向服务器请求数据的技术 ，而 Comet 则是一种 服务器向页面推送数据的技术 。Comet 能够让信息近乎实时地被推送到页面上 ，非常适合处理 体育比赛的分数 和 股票报价 。 有两种实现 Comet 的方式：长轮询 和 流 。长轮询 是 传统轮询（也称为短轮询）的一个翻版 ，即 浏览器定时向服务器发送请求，看有没有更新的数据 。下图展示的是 短轮询 的时间线。 长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求 ，然后 服务器一直保持连接打开，直到有数据可发送 。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。下图展示了 长轮询 的时间线。 无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接 。两者最大的区别在于服务器如何发送数据。短轮询 是 服务器立即发送响应，无论数据是否有效 ，而 长轮询 是 等待发送响应 。轮询的优势是所有浏览器都支持，因为使用 XHR 对象和 setTimeout() 就能实现。而你要做的就是决定什么时候发送请求。 第二种流行的 Comet 实现是 HTTP 流 。流不同于上述两种轮询，因为它 在页面的整个生命周期内只使用一个 HTTP 连接 。具体来说，就是 浏览器向服务器发送一个请求 ，而 服务器保持连接打开 ，然后 周期性地向浏览器发送数据 。比如，下面这段 PHP 脚本就是采用流实现的服务器中常见的形式。 123456789101112&lt;?php $i = 0; while(true)&#123; //输出一些数据，然后立即刷新输出缓存 echo "Number is $i"; flush(); //等几秒钟 sleep(10); $i++; &#125; 所有服务器端语言都支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客户端）的功能 。而这正是实现 HTTP 流的关键所在。 在 Firefox、Safari、Opera 和 Chrome 中，通过侦听 readystatechange 事件及检测 readyState 的值是否为 3，就可以利用 XHR 对象实现 HTTP 流。在上述这些浏览器中，随着不断从服务器接收数据， readyState 的值会周期性地变为 3。当 readyState 值变为 3 时， responseText 属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用 XHR 对象实现 HTTP 流的典型代码如下所示。 1234567891011121314151617181920212223242526function createStreamingClient(url, progress, finished)&#123; var xhr = new XMLHttpRequest(), received = 0; xhr.open("get", url, true); xhr.onreadystatechange = function()&#123; var result; if (xhr.readyState == 3)&#123; //只取得最新数据并调整计数器 result = xhr.responseText.substring(received); received += result.length; //调用 progress 回调函数 progress(result); &#125; else if (xhr.readyState == 4)&#123; finished(xhr.responseText); &#125; &#125;; xhr.send(null); return xhr;&#125;var client = createStreamingClient("streaming.php", function(data)&#123; alert("Received: " + data);&#125;, function(data)&#123; alert("Done!");&#125;); 这个 createStreamingClient() 函数接收三个参数：要连接的 URL、在接收到数据时调用的函数以及关闭连接时调用的函数。有时候，当连接关闭时，很可能还需要重新建立，所以关注连接什么时候关闭还是有必要的。 只要 readystatechange 事件发生，而且 readyState 值为 3，就对 responseText 进行分割以取得最新数据。这里的 received 变量用于记录已经处理了多少个字符，每次 readyState 值为 3 时都递增。然后，通过 progress 回调函数来处理传入的新数据。而当 readyState 值为 4 时，则执行 finished 回调函数，传入响应返回的全部内容。虽然这个例子比较简单，而且也能在大多数浏览器中正常运行（IE 除外），但管理 Comet 的连接是很容易出错的，需要时间不断改进才能达到完美。浏览器社区认为 Comet 是未来 Web 的一个重要组成部分，为了简化这一技术，又为 Comet 创建了两个新的接口。 服务器发送事件SSE（Server-Sent Events，服务器发送事件）是 围绕只读 Comet 交互推出的 API 或者模式 。SSE API 用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME 类型必须是 text/event-stream ，而且是浏览器中的 JavaScript API 能解析格式输出。SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。有了这么简单实用的 API，再实现 Comet 就容易多了。 支持 SSE 的浏览器有 Firefox 6+、Safari 5+、Opera 11+、Chrome 和 iOS 4+版 Safari。 SSE APISSE 的 JavaScript API 与其他传递消息的 JavaScript API 很相似。要预订新的事件流，首先要创建一个新的 EventSource 对象，并传进一个入口点： 1var source = new EventSource("myevents.php"); 注意，传入的 URL 必须与创建对象的页面同源（相同的 URL 模式、域及端口）。 EventSource 的实例有一个 readyState 属性，值为 0 表示正连接到服务器，值为 1 表示打开了连接，值为 2 表示关闭了连接。 另外，还有以下三个事件。 open ：在建立连接时触发。 message ：在从服务器接收到新事件时触发。 error ：在无法建立连接时触发。 就一般的用法而言， onmessage 事件处理程序也没有什么特别的。 1234source.onmessage = function(event)&#123;var data = event.data; //处理数据&#125;; 服务器发回的数据以字符串形式保存在 event.data 中。 默认情况下， EventSource 对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着 SSE 适合长轮询和 HTTP 流 。如果想强制立即断开连接并且不再重新连接，可以调用 close() 方法。 1source.close(); 事件流所谓的服务器事件会通过一个持久的 HTTP 响应发送，这个响应的 MIME 类型为 text/event-stream 。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀 data: ，例如： 1234data: foodata: bardata: foodata: bar 对以上响应而言，事件流中的第一个 message 事件返回的 event.data 值为 “foo” ，第二个 message 事件返回的 event.data 值为 “bar” ，第三个 message 事件返回的 event.data 值为 “foo\nbar” （注意中间的换行符）。对于多个连续的以 data: 开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有在包含 data: 的数据行后面有空行时，才会触发 message 事件，因此在服务器上生成事件流时不能忘了多添加这一行。 通过 id: 前缀可以给特定的事件指定一个关联的 ID，这个 ID 行位于 data: 行前面或后面皆可： 12data: fooid: 1 设置了 ID 后， EventSource 对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为 Last-Event-ID 的特殊 HTTP 头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。 Web Sockets要说最令人津津乐道的新浏览器 API，就得数 Web Sockets了。Web Sockets 的目标是 在一个单独的持久连接上提供全双工、双向通信 。在 JavaScript 中创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 Web Socket 协议 。也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持这种协议的专门服务器才能正常工作。 由于 Web Sockets 使用了自定义的协议，所以 URL 模式也略有不同。未加密的连接不再是 http:// ，而是 ws:// ；加密的连接也不是 https:// ，而是 wss:// 。在使用 Web Socket URL 时，必须带着这个模式，因为将来还有可能支持其他模式。 使用自定义协议而非 HTTP 协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心 HTTP 那样字节级的开销 。由于传递的数据包很小，因此 Web Sockets 非常适合移动应用 。毕竟对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，制定协议的时间比制定 JavaScript API 的时间还要长 。Web Sockets曾几度搁浅，就因为不断有人发现这个新协议存在一致性和安全性的问题。Firefox 4 和 Opera 11 都曾默认启用 Web Sockets，但在发布前夕又禁用了，因为又发现了安全隐患。目前支持 Web Sockets 的浏览器有 Firefox 6+、Safari 5+、Chrome 和 iOS 4+版 Safari。 Web Sockets API要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL： 1var socket = new WebSocket("ws://www.example.com/server.php"); 注意，必须给 WebSocket 构造函数传入 绝对 URL 。同源策略对 Web Sockets 不适用 ，因此 可以通过它打开到任何站点的连接 。至于是否会与某个域中的页面通信，则完全取决于服务器 。（通过握手信息就可以知道请求来自何方。） 实例化了 WebSocket 对象后，浏览器就会马上尝试创建连接。与 XHR 类似， WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示。 WebSocket.OPENING (0)：正在建立连接。 WebSocket.OPEN (1)：已经建立连接。 WebSocket.CLOSING (2)：正在关闭连接。 WebSocket.CLOSE (3)：已经关闭连接。 WebSocket 没有 readystatechange 事件；不过，它有其他事件，对应着不同的状态。 readyState 的值永远从 0 开始。 要 关闭 Web Socket 连接 ，可以在任何时候调用 close() 方法。 1socket.close(); 调用了 close() 之后， readyState 的值立即变为 2（正在关闭），而在关闭连接后就会变成 3。 发送和接收数据Web Socket 打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用 send() 方法并传入任意字符串，例如： 12var socket = new WebSocket("ws://www.example.com/server.php");socket.send("Hello world!"); 因为 Web Sockets 只能通过连接发送纯文本数据 ，所以 对于复杂的数据结构 ，在通过连接发送之前，必须进行序列化 。下面的例子展示了先将数据序列化为一个 JSON 字符串，然后再发送到服务器： 1234567var message = &#123; time: new Date(), text: "Hello world!", clientId: "asdfp8734rew"&#125;;socket.send(JSON.stringify(message)); 接下来，服务器要读取其中的数据，就要解析接收到的 JSON 字符串。 当服务器向客户端发来消息时， WebSocket 对象就会触发 message 事件。这个 message 事件与其他传递消息的协议类似，也是把返回的数据保存在 event.data 属性 中。 1234socket.onmessage = function(event)&#123;var data = event.data; //处理数据&#125;; 与通过 send() 发送到服务器的数据一样， event.data 中返回的数据也是字符串。如果你想得到其他格式的数据，必须手工解析这些数据。 其他事件WebSocket 对象还有其他三个事件，在连接生命周期的不同阶段触发。 open ：在成功建立连接时触发。 error ：在发生错误时触发，连接不能持续。 close ：在连接关闭时触发。 WebSocket 对象不支持 DOM 2 级事件侦听器，因此必须使用 DOM 0 级语法分别定义每个事件处理程序。 123456789101112var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);socket.onopen = function()&#123; alert(&quot;Connection established.&quot;);&#125;;socket.onerror = function()&#123; alert(&quot;Connection error.&quot;);&#125;;socket.onclose = function()&#123; alert(&quot;Connection closed.&quot;);&#125;; 在这三个事件中，只有 close 事件的 event 对象有额外的信息。这个事件的事件对象有三个额外的属性： wasClean 、 code 和 reason 。其中， wasClean 是一个布尔值，表示连接是否已经明确地关闭； code 是服务器返回的数值状态码；而 reason 是一个字符串，包含服务器发回的消息。可以把这些信息显示给用户，也可以记录到日志中以便将来分析。 123socket.onclose = function(event)&#123; console.log("Was clean? " + event.wasClean + " Code=" + event.code + " Reason=" + event.reason);&#125;; SSE与Web Sockets面对某个具体的用例，在考虑是使用 SSE 还是使用 Web Sockets 时，可以考虑如下几个因素。首先，你是否有自由度建立和维护 Web Sockets服务器？ 因为 Web Socket 协议不同于 HTTP，所以 现有服务器不能用于 Web Socket 通信 。SSE 倒是通过常规 HTTP 通信，因此现有服务器就可以满足需求。 第二个要考虑的问题是 到底需不需要双向通信 。如果用例只需读取服务器数据（如比赛成绩），那么 SSE 比较容易实现。如果用例必须 双向通信 （如聊天室），那么 Web Sockets 显然更好 。别忘了，在不能选择 Web Sockets 的情况下，组合 XHR 和 SSE 也是能实现双向通信的 。 安全讨论 Ajax 和 Comet 安全的文章可谓连篇累牍，而相关主题的书也已经出了很多本了。大型 Ajax 应用程序的安全问题涉及面非常之广，但我们可以从普遍意义上探讨一些基本的问题。 首先，可以 通过 XHR 访问的任何 URL 也可以 通过浏览器或服务器来访问 。下面的 URL 就是一个例子。 1/getuserinfo.php?id=23 如果是向这个 URL 发送请求，可以想象结果会返回 ID 为 23 的用户的某些数据。谁也无法保证别人不会将这个 URL 的用户 ID 修改为 24、56 或其他值。因此， getuserinfo.php 文件必须知道请求者是否真的有权限访问要请求的数据；否则，你的服务器就会门户大开，任何人的数据都可能被泄漏出去。 对于未被授权系统有权访问某个资源的情况，我们称之为 CSRF（Cross-Site Request Forgery，跨站点请求伪造）。未被授权系统会伪装自己，让处理请求的服务器认为它是合法的。受到 CSRF 攻击的 Ajax程序有大有小，攻击行为既有旨在 揭示系统漏洞的恶作剧 ，也有 恶意的数据窃取或数据销毁 。 为确保通过 XHR 访问的 URL 安全，通行的做法就是 验证发送请求者是否有权限访问相应的资源 。 有下列几种方式可供选择。 要求以 SSL 连接来访问可以通过 XHR 请求的资源。 要求每一次请求都要附带经过相应算法计算得到的验证码。 请注意，下列措施对防范 CSRF 攻击不起作用。 要求发送 POST 而不是 GET 请求——很容易改变。 检查来源 URL 以确定是否可信——来源记录很容易伪造。 基于 cookie 信息进行验证——同样很容易伪造。 XHR 对象也提供了一些安全机制，虽然表面上看可以保证安全，但实际上却相当不可靠。实际上，前面介绍的 open() 方法还能再接收两个参数：要随请求一起发送的用户名和密码。带有这两个参数的请求可以通过 SSL 发送给服务器上的页面，如下面的例子所示。 1xhr.open("get", "example.php", true, "username", "password"); //不要这样做！！ 即便可以考虑这种安全机制，但还是尽量不要这样做。把用户名和密码保存在 JavaScript 代码中本身就是极为不安全的。任何人，只要他会使用 JavaScript 调试器，就可以通过查看相应的变量发现纯文本形式的用户名和密码。 小结Ajax 是 无需刷新页面就能够从服务器取得数据的一种方法 。关于 Ajax，可以从以下几方面来总结一下。 负责 Ajax 运作的核心对象是 XMLHttpRequest （XHR）对象。 XHR 对象由微软最早在 IE5 中引入，用于通过 JavaScript 从服务器取得 XML 数据。 在此之后，Firefox、Safari、Chrome 和 Opera 都实现了相同的特性，使 XHR 成为了 Web 的一个事实标准。 虽然实现之间存在差异，但 XHR 对象的基本用法在不同浏览器间还是相对规范的，因此可以放心地用在 Web 开发当中。 同源策略是对 XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。这个解决方案叫做 CORS（Cross-Origin Resource Sharing，跨源资源共享），IE8 通过 XDomainRequest 对象支持CORS，其他浏览器通过 XHR 对象原生支持 CORS。图像 Ping 和 JSONP 是另外两种跨域通信的技术，但不如 CORS 稳妥。 Comet 是 对 Ajax 的进一步扩展 ，让服务器几乎能够实时地向客户端推送数据 。实现 Comet 的手段主要有两个：长轮询 和 HTTP 流 。所有浏览器都支持长轮询，而只有部分浏览器原生支持 HTTP 流。SSE（Server-Sent Events，服务器发送事件）是一种实现 Comet 交互的浏览器 API，既支持长轮询，也支持 HTTP 流。 Web Sockets 是 一种与服务器进行全双工、双向通信的信道 。与其他方案不同，Web Sockets 不使用 HTTP 协议，而使用一种自定义的协议。这种协议专门为快速传输小数据设计。虽然要求使用不同的 Web 服务器，但却具有速度上的优势。 各方面对 Ajax 和 Comet 的鼓吹吸引了越来越多的开发人员学习 JavaScript，人们对 Web 开发的关注也再度升温。与 Ajax 有关的概念都还相对比较新，这些概念会随着时间推移继续发展。 Ajax 是一个非常庞大的主题，完整地讨论这个主题超出了本书的范围。要想了解有关 Ajax 的更多信息，请读者参考 《Ajax 高级程序设计（第 2 版）》。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-JSON]]></title>
    <url>%2F2018%2F08%2F28%2FJavaScript-JSON%2F</url>
    <content type="text"><![CDATA[JSON曾经有一段时间，XML 是互联网上传输结构化数据的事实标准 。Web 服务的第一次浪潮很大程度上都是建立在 XML 之上的，突出的特点是服务器与服务器间通信 。然而，业界一直不乏质疑 XML 的声音。不少人认为 XML 过于烦琐、冗长。为解决这个问题，也涌现了一些方案。不过，Web 的发展方向已经改变了。 2006 年，Douglas Crockford 把 JSON（JavaScript Object Notation，JavaScript 对象表示法 ）作为 IETF RFC 4627 提交给 IETF，而 JSON 的应用早在 2001 年就已经开始了。JSON 是 JavaScript 的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据 。Crockford 认为与 XML 相比，JSON是在JavaScript 中读写结构化数据的更好的方式 。因为可以把 JSON 直接传给 eval() ，而且不必创建 DOM 对象 。 关于 JSON，最重要的是要理解它是 一种数据格式 ，不是一种编程语言 。虽然具有相同的语法形式，但 JSON 并不从属于 JavaScript 。而且，并不是只有 JavaScript 才使用 JSON ，毕竟 JSON 只是一种数据格式 。很多编程语言都有针对 JSON 的解析器和序列化器 。 语法JSON 的语法可以表示以下三种类型的值。 简单值 ：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null 。但 JSON 不支持 JavaScript 中的特殊值 undefined 。 对象 ：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。 数组 ：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。 JSON 不支持变量、函数或对象实例 ，它就是一种表示结构化数据的格式 ，虽然与 JavaScript 中表示数据的某些语法相同 ，但它并不局限于 JavaScript 的范畴 。 简单值最简单的 JSON 数据形式就是简单值 。例如，下面这个值是有效的 JSON 数据： 15 这是 JSON 表示数值 5 的方式。类似地，下面是 JSON 表示字符串的方式 ： 1"Hello world!" JavaScript 字符串与 JSON 字符串的最大区别在于，JSON 字符串必须使用双引号（单引号会导致语法错误）。 布尔值和 null 也是有效的 JSON 形式 。但是，在实际应用中，JSON 更多地用来表示更复杂的数据结构，而简单值只是整个数据结构中的一部分 。 对象JSON 中的对象与 JavaScript 字面量稍微有一些不同 。下面是一个 JavaScript 中的对象字面量： 1234var person = &#123; name: "Nicholas", age: 29&#125;; 这虽然是开发人员在 JavaScript 中创建对象字面量的标准方式，但 JSON 中的对象要求给属性加引号 。实际上，在 JavaScript 中，前面的对象字面量完全可以写成下面这样 ： 1234var object = &#123; "name": "Nicholas", "age": 29&#125;; JSON 表示上述对象的方式 如下： 1234&#123; "name": "Nicholas", "age": 29&#125; 与 JavaScript 的对象字面量相比，JSON 对象有两个地方不一样。首先，没有声明变量（JSON 中没有变量的概念）。其次，没有末尾的分号（因为这不是 JavaScript 语句，所以不需要分号）。再说一遍，对象的属性必须加双引号 ，这在 JSON 中是必需的。属性的值可以是简单值 ，也可以是复杂类型值 ，因此可以像下面这样在对象中嵌入对象： 12345678&#123; "name": "Nicholas", "age": 29, "school": &#123; "name": "Merrimack College", "location": "North Andover, MA" &#125;&#125; 这个例子在顶级对象中嵌入了学校（ “school” ）信息。虽然有两个 “name” 属性 ，但 由于它们分别属于不同的对象 ，因此这样完全没有问题 。不过，同一个对象中绝对不应该出现两个同名属性 。 与 JavaScript 不同，JSON 中对象的属性名任何时候都必须加双引号 。手工编写 JSON 时，忘了给对象属性名加双引号 或者 把双引号写成单引号 都是 常见的错误 。 数组JSON 中的第二种复杂数据类型是数组。JSON 数组采用的就是 JavaScript 中的数组字面量形式 。例如，下面是 JavaScript 中的数组字面量： 1var values = [25, "hi", true]; 在 JSON 中，可以采用同样的语法表示同一个数组 ： 1[25, "hi", true] 同样要注意，JSON 数组也没有变量和分号 。把数组和对象结合起来，可以构成更复杂的数据集合 ，例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[ &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], "edition": 3, "year": 2011 &#125;, &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], "edition": 2, "year": 2009 &#125;, &#123; "title": "Professional Ajax", "authors": [ "Nicholas C. Zakas", "Jeremy McPeak", "Joe Fawcett" ], "edition": 2, "year": 2008 &#125;, &#123; "title": "Professional Ajax", "authors": [ "Nicholas C. Zakas", "Jeremy McPeak", "Joe Fawcett" ], "edition": 1, "year": 2007 &#125;, &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], "edition": 1, "year": 2006 &#125;] 这个数组中包含一些表示图书的对象。每个对象都有几个属性，其中一个属性是 “authors” ，这个属性的值又是一个数组。对象和数组通常是 JSON 数据结构的最外层形式（当然，这不是强制规定的），利用它们能够创造出各种各样的数据结构。 解析与序列化JSON 之所以流行，拥有与 JavaScript 类似的语法并不是全部原因。更重要的一个原因是，可以把 JSON 数据结构解析为有用的 JavaScript 对象 。与 XML 数据结构要解析成 DOM 文档而且从中提取数据极为麻烦相比 ，JSON 可以解析为 JavaScript 对象的优势极其明显 。就以上一节中包含一组图书的 JSON 数据结构为例，在解析为 JavaScript 对象后，只需要下面一行简单的代码就可以取得第三本书的书名： 1books[2].title 当然，这里是假设把解析 JSON 数据结构后得到的对象保存到了变量 books 中。再看看下面在 DOM 结构中查找数据的代码： 1doc.getElementsByTagName("book")[2].getAttribute("title") 看看这些多余的方法调用，就不难理解为什么 JSON 能得到 JavaScript 开发人员的热烈欢迎了。从此以后，JSON 就成了 Web 服务开发中交换数据的事实标准 。 JSON对象早期的 JSON 解析器基本上就是使用 JavaScript 的 eval() 函数 。由于 JSON 是 JavaScript 语法的子集 ，因此 eval() 函数可以解析、解释并返回 JavaScript 对象和数组 。ECMAScript 5 对解析 JSON 的行为进行规范，定义了全局对象 JSON 。支持这个对象的浏览器有 IE 8+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10.5+。对于较早版本的浏览器，可以使用一个 shim：https://github.com/douglascrockford/JSON-js 。在旧版本的浏览器中，使用 eval() 对 JSON 数据结构求值存在风险，因为可能会执行一些恶意代码 。对于不能原生支持 JSON 解析的浏览器，使用这个 shim 是最佳选择 。 JSON 对象 有两个方法： stringify() 和 parse() 。在最简单的情况下，这两个方法分别用于 把 JavaScript 对象序列化为 JSON 字符串 和 把 JSON 字符串解析为原生 JavaScript 值 。例如： 12345678910var book = &#123; title: &quot;Professional JavaScript&quot;, authors: [ &quot;Nicholas C. Zakas&quot; ], edition: 3, year: 2011&#125;; var jsonText = JSON.stringify(book); 这个例子使用 JSON.stringify() 把一个 JavaScript 对象序列化为一个 JSON 字符串 ，然后 将它保存在变量 jsonText 中 。默认情况下， JSON.stringify() 输出的 JSON 字符串不包含任何空格字符或缩进 ，因此 保存在 jsonText 中的字符串如下所示 ： 1&#123;"title":"Professional JavaScript","authors":["Nicholas C. Zakas"],"edition":3, "year":2011&#125; 在序列化 JavaScript 对象时，所有函数及原型成员都会被有意忽略，不体现在结果中 。此外，值为 undefined 的任何属性也都会被跳过 。结果中最终都是值为有效 JSON 数据类型的实例属性 。 将 JSON 字符串直接传递给 JSON.parse() 就可以得到相应的 JavaScript 值 。例如，使用下列代码就可以创建与 book 类似的对象： 1var bookCopy = JSON.parse(jsonText); 注意，虽然 book 与 bookCopy 具有相同的属性，但它们是两个独立的、没有任何关系的对象。 如果传给 JSON.parse() 的字符串不是有效的 JSON，该方法会抛出错误 。 序列化选项实际上，JSON.stringify() 除了要序列化的 JavaScript 对象外 ，还可以 接收另外两个参数 ，这两个参数 用于指定以不同的方式序列化 JavaScript 对象 。第一个参数是个 过滤器 ，可以是一个数组 ，也 可以是一个函数 ；第二个参数是一个 选项 ，表示 是否在 JSON 字符串中保留缩进 。单独或组合使用这两个参数，可以更全面深入地控制 JSON 的序列化。 过滤结果如果过滤器参数是数组，那么 JSON.stringify() 的结果中将只包含数组中列出的属性。来看下面的例子。 12345678910var book = &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, ["title", "edition"]); JSON.stringify() 的第二个参数是一个数组，其中包含两个字符串： “title” 和 “edition” 。这两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符串中，就只会包含这两个属性： 1&#123;"title":"Professional JavaScript","edition":3&#125; 如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性（键）名和属性值。根据属性（键）名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非键值对儿结构的值时，键名可以是空字符串。 为了改变序列化对象的结果，函数返回的值就是相应键的值。不过要注意，如果函数返回了undefined ，那么相应的属性会被忽略。还是看一个例子吧。 123456789101112131415161718192021222324var book = &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, function(key, value)&#123; switch(key)&#123; case "authors": return value.join(",") case "year": return 5000; case "edition": return undefined; default: return value; &#125;&#125;); 这里，函数过滤器根据传入的键来决定结果。如果键为 “authors” ，就将数组连接为一个字符串；如果键为 “year” ，则将其值设置为 5000 ；如果键为 “edition” ，通过返回 undefined 删除该属性。最后，一定要提供 default 项，此时返回传入的值，以便其他值都能正常出现在结果中。实际上，第一次调用这个函数过滤器，传入的键是一个空字符串，而值就是 book 对象。序列化后的 JSON 字符串如下所示： 1&#123;"title":"Professional JavaScript","authors":"Nicholas C. Zakas","year":5000&#125; 要序列化的对象中的每一个对象都要经过过滤器，因此数组中的每个带有这些属性的对象经过过滤之后，每个对象都只会包含 “title” 、 “authors” 和 “year” 属性。 Firefox 3.5 和 3.6 对 JSON.stringify() 的实现有一个 bug，在将函数作为该方法的第二个参数时这个 bug 就会出现，即这个函数只能作为过滤器：返回 undefined 意味着要跳过某个属性，而返回其他任何值都会在结果中包含相应的属性。Firefox 4 修复了这个 bug。 字符串缩进JSON.stringify() 方法的第三个参数用于控制结果中的缩进和空白符 。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数 。例如，要在每个级别缩进 4 个空格，可以这样写代码： 12345678910var book = &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, null, 4); 保存在 jsonText 中的字符串如下所示： 12345678&#123; &quot;title&quot;: &quot;Professional JavaScript&quot;, &quot;authors&quot;: [ &quot;Nicholas C. Zakas&quot; ], &quot;edition&quot;: 3, &quot;year&quot;: 2011&#125; 不知道读者注意到没有，JSON.stringify() 也在结果字符串中插入了换行符以提高可读性 。只要传入有效的控制缩进的参数值，结果字符串就会包含换行符 。（只缩进而不换行意义不大。）最大缩进空格数为 10 ，所有 大于 10 的值都会自动转换为 10 。如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON 字符串中被用作缩进字符（不再使用空格）。在使用字符串的情况下，可以将缩进字符设置为制表符，或者两个短划线之类的任意字符 。 1var jsonText = JSON.stringify(book, null, " - -"); 这样， jsonText 中的字符串将变成如下所示： 12345678&#123;--"title": "Professional JavaScript",--"authors": [----"Nicholas C. Zakas"--],--"edition": 3,--"year": 2011&#125; 缩进字符串最长不能超过 10 个字符长 。如果 字符串长度超过了 10 个 ，结果中将只出现前 10 个字符 。 toJSON() 方法有时候， JSON.stringify() 还是不能满足对某些对象进行自定义序列化的需求。在这些情况下，可以给对象定义 toJSON() 方法 ，返回其自身的 JSON 数据格式 。原生 Date 对象有一个 toJSON() 方法 ，能够将JavaScript的 Date 对象自动转换成ISO 8601日期字符串（与在 Date 对象上调用 toISOString() 的结果完全一样）。 可以为任何对象添加 toJSON() 方法 ，比如： 12345678910111213var book = &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011, toJSON: function()&#123; return this.title; &#125;&#125;;var jsonText = JSON.stringify(book); 以上代码在 book 对象上定义了一个 toJSON() 方法，该方法返回图书的书名。与 Date 对象类似，这个对象也将被序列化为一个简单的字符串而非对象。可以让 toJSON() 方法返回任何值，它都能正常工作。比如，可以让这个方法返回 undefined ，此时如果包含它的对象嵌入在另一个对象中，会导致它的值变成 null ，而如果它是顶级对象，结果就是 undefined 。 toJSON() 可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要。假设 把一个对象传入 JSON.stringify() ，序列化该对象的顺序如下 。 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第 1 步返回的值。 对第 2 步返回的每个值进行相应的序列化。 如果提供了第三个参数，执行相应的格式化。 无论是考虑定义 toJSON() 方法，还是考虑使用函数过滤器，亦或需要同时使用两者，理解这个顺序都是至关重要的。 解析选项JSON.parse() 方法也可以接收另一个参数，该参数是一个函数，将在每个键值对儿上调用。为了区别 JSON.stringify() 接收的替换（过滤）函数（replacer），这个函数被称为还原函数（reviver），但实际上这两个函数的签名是相同的——它们都接收两个参数，一个键和一个值，而且都需要返回一个值。 如果还原函数返回 undefined ，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。在将日期字符串转换为 Date 对象时，经常要用到还原函数。例如： 123456789101112131415161718192021var book = &#123; &quot;title&quot;: &quot;Professional JavaScript&quot;, &quot;authors&quot;: [ &quot;Nicholas C. Zakas&quot; ], edition: 3, year: 2011, releaseDate: new Date(2011, 11, 1)&#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function(key, value)&#123; if (key == &quot;releaseDate&quot;)&#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);alert(bookCopy.releaseDate.getFullYear()); 以上代码先是为 book 对象新增了一个 releaseDate 属性，该属性保存着一个 Date 对象。这个对象在经过序列化之后变成了有效的 JSON 字符串，然后经过解析又在 bookCopy 中还原为一个 Date 对象。还原函数在遇到 “releaseDate” 键时，会基于相应的值创建一个新的 Date 对象。结果就是 bookCopy.releaseDate 属性中会保存一个 Date 对象。正因为如此，才能基于这个对象调用 getFullYear() 方法。 小结JSON 是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量 。JSON 使用 JavaScript 语法的子集表示 对象、数组 、字符串 、数值、布尔值 和 null 。即使 XML 也能表示同样复杂的数据结果，但 JSON 没有那么烦琐，而且在 JavaScript 中使用更便利。 ECMAScript 5 定义了一个原生的 JSON 对象 ，可以用来将对象序列化为 JSON 字符串或者将 JSON 数据解析为 JavaScript 对象 。 JSON.stringify() 和 JSON.parse() 方法分别用来实现上述两项功能。这两个方法都有一些选项，通过它们可以改变过滤的方式，或者改变序列化的过程。 原生的 JSON 对象也得到了很多浏览器的支持，比如 IE8+、Firefox 3.5+、Safari 4+、Opera 10.5 和 Chrome。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-HTML5 脚本编程]]></title>
    <url>%2F2018%2F08%2F28%2FJavaScript-HTML5-script-programming%2F</url>
    <content type="text"><![CDATA[HTML5 脚本编程本书前面讨论过，HTML5 规范定义了很多新 HTML 标记。为了配合这些标记的变化，HTML5 规范也用显著篇幅定义了很多 JavaScript API 。定义这些 API 的用意就是 简化此前实现起来困难重重的任务 ，最终简化创建动态 Web 界面的工作 。 跨文档消息传递跨文档消息传送（cross-document messaging），有时候简称为 XDM ，指的是 在来自不同域的页面间传递消息 。例如，www.wrox.com 域中的页面与位于一个内嵌框架中的 p2p.wrox.com 域中的页面通信 。在 XDM 机制出现之前，要稳妥地实现这种通信需要花很多工夫。XDM 把这种机制规范化，让我们能既稳妥又简单地实现跨文档通信。 XDM 的核心是 postMessage() 方法 。在 HTML5 规范中，除了 XDM部分之外的其他部分也会提到这个方法名，但都是为了同一个目的：向另一个地方传递数据 。对于 XDM 而言，“另一个地方”指的是包含在当前页面中的 &lt;iframe&gt; 元素 ，或者 由当前页面弹出的窗口 。 postMessage() 方法 接收两个参数：一条消息 和 一个表示消息接收方来自哪个域的字符串 。第二个参数对保障安全通信非常重要 ，可以防止浏览器把消息发送到不安全的地方 。来看下面的例子。 123//注意：所有支持 XDM 的浏览器也支持 iframe 的 contentWindow 属性var iframeWindow = document.getElementById("myframe").contentWindow;iframeWindow.postMessage("A secret", "http://www.wrox.com"); 最后一行代码尝试向内嵌框架中发送一条消息，并指定框架中的文档必须来源于 “http://www.wrox.com “ 域。如果来源匹配，消息会传递到内嵌框架中 ；否则， postMessage() 什么也不做 。这一限制可以避免窗口中的位置在你不知情的情况下发生改变。如果传给 postMessage() 的第二个参数是 “*” ，则表示可以把消息发送给来自任何域的文档，但我们不推荐这样做 。 接收到 XDM 消息时，会触发 window 对象的 message 事件 。这个事件是以异步形式触发的，因此从发送消息到接收消息（触发接收窗口的 message 事件）可能要经过一段时间的延迟。触发 message 事件后，传递给 onmessage 处理程序的事件对象包含以下三方面的重要信息。 data ：作为 postMessage() 第一个参数传入的字符串数据。 origin ：发送消息的文档所在的域，例如 “http://www.wrox.com “ 。 source ：发送消息的文档的 window 对象的代理。这个代理对象主要用于在发送上一条消息的窗口中调用 postMessage() 方法。如果发送消息的窗口来自同一个域，那这个对象就是 window 。 接收到消息后验证发送窗口的来源是至关重要的 。就像给 postMessage() 方法指定第二个参数，以确保浏览器不会把消息发送给未知页面一样，在 onmessage 处理程序中检测消息来源可以确保传入的消息来自已知的页面 。基本的检测模式如下。 123456789101112EventUtil.addHandler(window, "message", function(event)&#123; //确保发送消息的域是已知的域 if (event.origin == "http://www.wrox.com")&#123; //处理接收到的数据 processMessage(event.data); //可选：向来源窗口发送回执 event.source.postMessage("Received!", "http://p2p.wrox.com"); &#125;&#125;); 还是要提醒大家，event.source 大多数情况下只是 window 对象的代理，并非实际的 window 对象 。换句话说，不能通过这个代理对象访问 window 对象的其他任何信息 。记住，只通过这个代理调用 postMessage() 就好，这个方法永远存在，永远可以调用。 XDM 还有一些怪异之处。首先， postMessage() 的第一个参数最早是作为“永远都是字符串”来实现的。但后来这个参数的定义改了，改成允许传入任何数据结构。可是，并非所有浏览器都实现了这一变化。为保险起见，使用 postMessage() 时，最好还是只传字符串 。如果你想传入结构化的数据，最佳选择是先在要传入的数据上调用 JSON.stringify() ，通过 postMessage() 传入得到的字符串，然后再在 onmessage 事件处理程序中调用 JSON.parse() 。 在通过内嵌框架加载其他域的内容时，使用 XDM 是非常方便的 。因此，在混搭（mashup）和社交网络应用中，这种传递消息的方法极为常用。有了 XDM，包含 &lt;iframe&gt; 的页面可以确保自身不受恶意内容的侵扰，因为它只通过 XDM 与嵌入的框架通信 。而 XDM 也可以在来自相同域的页面间使用 。 支持 XDM 的浏览器有 IE8+、Firefox 3.5+、Safari 4+、Opera、Chrome、iOS 版 Safari 及 Android 版 WebKit。XDM 已经作为一个规范独立出来，现在它的名字叫 Web Messaging，官方页面是 http://dev.w3.org/html5/postmsg/ 。 原生拖放最早在网页中引入 JavaScript 拖放功能的是 IE4。当时，网页中只有两种对象可以拖放：图像和某些文本 。拖动图像时，把鼠标放在图像上，按住鼠标不放就可以拖动它。拖动文本时，要先选中文本，然后可以像拖动图像一样拖动被选中的文本。在 IE 4 中，唯一有效的放置目标是文本框。到了 IE5，拖放功能得到扩展，添加了新的事件，而且几乎网页中的任何元素都可以作为放置目标。IE5.5 更进一步，让网页中的任何元素都可以拖放。（IE6 同样也支持这些功能。）HTML5 以 IE 的实例为基础制定了拖放规范。Firefox 3.5、Safari 3+和 Chrome 也根据 HTML5 规范实现了原生拖放功能。 说到拖放，最有意思的恐怕就是能够在框架间、窗口间 ，甚至在应用间拖放网页元素了 。浏览器对拖放的支持为实现这些功能提供了便利。 拖放事件通过拖放事件，可以控制拖放相关的各个方面。其中 最关键的地方在于确定哪里发生了拖放事件 ，有些事件是在被拖动的元素上触发的 ，而有些事件是在放置目标上触发的 。拖动某元素时 ，将依次触发下列事件： 123(1) dragstart(2) drag(3) dragend 按下鼠标键并开始移动鼠标 时，会在被拖放的元素上触发 dragstart 事件 。此时光标变成“不能放”符号（圆环中有一条反斜线），表示不能把元素放到自己上面。拖动开始 时，可以通过 ondragstart 事件处理程序来运行 JavaScript 代码 。 触发 dragstart 事件后，随即会 触发 drag 事件 ，而且 在元素被拖动期间会持续触发该事件 。这个事件 与 mousemove 事件相似 ，在鼠标移动过程中， mousemove 事件也会持续发生。当拖动停止时（无论是把元素放到了有效的放置目标，还是放到了无效的放置目标上），会触发 dragend 事件 。 上述三个事件的目标都是被拖动的元素 。默认情况下，浏览器不会在拖动期间改变被拖动元素的外观，但你可以自己修改 。不过，大多数浏览器会为正被拖动的元素创建一个半透明的副本，这个副本始终跟随着光标移动 。 当某个元素被拖动到一个有效的放置目标上时 ，下列事件会依次发生： 123(1) dragenter(2) dragover(3) dragleave 或 drop 只要有元素被拖动到放置目标上 ，就会 触发 dragenter 事件（类似于 mouseover 事件）。紧随其后的是 dragover 事件 ，而且 在被拖动的元素还在放置目标的范围内移动时 ，就会持续触发该事件 。如果元素被拖出了放置目标， dragover 事件不再发生 ，但会 触发 dragleave 事件 （类似于 mouseout 事件）。如果元素被放到了放置目标中 ，则会 触发 drop 事件 而不是 dragleave 事件。上述三个事件的目标都是作为放置目标的元素 。 自定义放置目标在拖动元素经过某些无效放置目标时 ，可以看到一种特殊的光标（圆环中有一条反斜线），表示不能放置 。虽然 所有元素都支持放置目标事件 ，但 这些元素默认是不允许放置的 。如果拖动元素经过不允许放置的元素 ，无论用户如何操作 ，都不会发生 drop 事件 。不过，你可以把任何元素变成有效的放置目标 ，方法是重写 dragenter 和 dragover 事件的默认行为 。例如，假设有一个 ID 为 “droptarget”的 &lt;div&gt; 元素，可以用如下代码将它变成一个放置目标。 12345678var droptarget = document.getElementById("droptarget");EventUtil.addHandler(droptarget, "dragover", function(event)&#123; EventUtil.preventDefault(event);&#125;);EventUtil.addHandler(droptarget, "dragenter", function(event)&#123; EventUtil.preventDefault(event);&#125;); 以上代码执行后，你就会发现 当拖动着元素移动到放置目标上时 ，光标变成了允许放置的符号 。当然，释放鼠标也会触发 drop 事件 。 在 Firefox 3.5+中，放置事件的默认行为是打开被放到放置目标上的 URL。换句话说，如果是把图像拖放到放置目标上，页面就会转向图像文件 ；而 如果是把文本拖放到放置目标上，则会导致无效 URL 错误 。因此，为了让 Firefox 支持正常的拖放，还要取消 drop 事件的默认行为，阻止它打开 URL： 123EventUtil.addHandler(droptarget, "drop", function(event)&#123; EventUtil.preventDefault(event);&#125;); dataTransfer 对象只有简单的拖放而没有数据变化是没有什么用的 。为了在拖放操作时实现数据交换 ，IE 5 引入了 dataTransfer 对象 ，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据 。 因为它是事件对象的属性，所以 只能在拖放事件的事件处理程序中访问 dataTransfer 对象 。在事件处理程序中，可以使用这个对象的属性和方法来完善拖放功能 。目前，HTML5 规范草案也收入了 dataTransfer 对象。 dataTransfer 对象 有两个主要方法：getData() 和 setData() 。不难想象， getData() 可以取得由 setData() 保存的值。 setData() 方法的第一个参数，也是 getData() 方法唯一的一个参数，是一个字符串，表示保存的数据类型 ，取值为 “text“ 或 “URL“ ，如下所示： 1234567//设置和接收文本数据event.dataTransfer.setData("text", "some text");var text = event.dataTransfer.getData("text");//设置和接收 URLevent.dataTransfer.setData("URL", "http://www.wrox.com/");var url = event.dataTransfer.getData("URL"); IE只定义了 “text” 和 “URL” 两种有效的数据类型，而 HTML5 则对此加以扩展，允许指定各种 MIME 类型 。考虑到向后兼容，HTML5 也支持 “text” 和 “URL” ，但这两种类型会被映射为 “text/plain” 和 “text/uri-list” 。 实际上， dataTransfer 对象可以为每种 MIME 类型都保存一个值 。换句话说，同时在这个对象中保存一段文本和一个 URL 不会有任何问题 。不过，保存在 dataTransfer 对象中的数据只能在 drop 事件处理程序中读取 。如果在 ondrop 处理程序中没有读到数据，那就是 dataTransfer 对象已经被销毁，数据也丢失了 。 在 拖动文本框中的文本 时，浏览器会调用 setData() 方法，将拖动的文本以 “text” 格式保存在 dataTransfer 对象中 。类似地，在 拖放链接或图像 时，会调用 setData() 方法并保存 URL 。然后，在这些元素被拖放到放置目标时，就可以通过 getData() 读到这些数据 。当然，作为开发人员，你也 可以在 dragstart 事件处理程序中调用 setData() ，手工保存自己要传输的数据 ，以便将来使用 。 将数据保存为文本和保存为 URL 是有区别的 。如果 将数据保存为文本格式 ，那么 数据不会得到任何特殊处理 。而如果 将数据保存为 URL ，浏览器会将其当成网页中的链接 。换句话说，如果你把它放置到另一个浏览器窗口中，浏览器就会打开该 URL 。 Firefox 在其第 5 个版本之前不能正确地将 “url” 和 “text” 映射为 “text/uri-list” 和 “text/plain” 。但是却能把 “Text” （T 大写）映射为 “text/plain” 。为了更好地在跨浏览器的情况下从 dataTransfer 对象取得数据 ，最好在取得 URL 数据时检测两个值，而在取得文本数据时使用 “Text” 。 1234567var dataTransfer = event.dataTransfer;//读取 URLvar url = dataTransfer.getData("url") ||dataTransfer.getData("text/uri-list");//读取文本var text = dataTransfer.getData("Text"); 注意，一定要把短数据类型放在前面，因为 IE 10 及之前的版本仍然不支持扩展的 MIME 类型名，而它们在遇到无法识别的数据类型时，会抛出错误。 dropEffect 与 effectAllowed利用 dataTransfer 对象 ，可 不光是能够传输数据 ，还能 通过它来确定被拖动的元素以及作为放置目标的元素能够接收什么操作 。为此，需要访问 dataTransfer 对象的两个属性： dropEffect 和 effectAllowed 。 其中，通过 dropEffect 属性可以知道被拖动的元素能够执行哪种放置行为 。这个属性有下列 4 个可能的值。 “none” ：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。 “move” ：应该把拖动的元素移动到放置目标。 “copy” ：应该把拖动的元素复制到放置目标。 “link” ：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有 URL）。 在把元素拖动到放置目标上时，以上每一个值都会导致光标显示为不同的符号。然而，要怎样实现光标所指示的动作完全取决于你。换句话说，如果你不介入，没有什么会自动地移动、复制，也不会打开链接。总之，浏览器只能帮你改变光标的样式，而其他的都要靠你自己来实现 。要使用 dropEffect 属性，必须在 ondragenter 事件处理程序中针对放置目标来设置它 。 dropEffect 属性只有搭配 effectAllowed 属性才有用 。 effectAllowed 属性表示允许拖动元素的哪种 dropEffect ， effectAllowed 属性 可能的值如下。 “uninitialized” ：没有给被拖动的元素设置任何放置行为。 “none” ：被拖动的元素不能有任何行为。 “copy” ：只允许值为 “copy” 的 dropEffect 。 “link” ：只允许值为 “link” 的 dropEffect 。 “move” ：只允许值为 “move” 的 dropEffect 。 “copyLink” ：允许值为 “copy” 和 “link” 的 dropEffect 。 “copyMove” ：允许值为 “copy” 和 “move” 的 dropEffect 。 “linkMove” ：允许值为 “link” 和 “move” 的 dropEffect 。 “all” ：允许任意 dropEffect 。 必须在 ondragstart 事件处理程序中设置 effectAllowed 属性 。 假设你想允许用户把文本框中的文本拖放到一个 &lt;div&gt; 元素中。首先，必须将 dropEffect 和 effectAllowed 设置为 “move” 。但是，由于 &lt;div&gt; 元素的放置事件的默认行为是什么也不做，所以文本不可能自动移动。重写这个默认行为，就能从文本框中移走文本 。然后 你就可以自己编写代码将文本插入到 &lt;div&gt; 中，这样整个拖放操作就完成了 。如果你将 dropEffect 和 effectAllowed 的值设置为 “copy” ，那就不会自动移走文本框中的文本 。 Firefox 5 及之前的版本在处理 effectAllowed 属性时有一个问题，即如果你在代码中设置了这个属性的值，那不一定会触发 drop 事件。 可拖动默认情况下，图像、链接和文本是可以拖动的 ，也就是说，不用额外编写代码，用户就可以拖动它们 。文本只有在被选中的情况下才能拖动 ，而 图像和链接在任何时候都可以拖动 。 让其他元素可以拖动也是可能的 。HTML5 为所有 HTML 元素规定了一个 draggable 属性 ，表示元素是否可以拖动 。图像和链接的 draggable 属性自动被设置成了 true ，而 其他元素这个属性的默认值都是 false 。要想让其他元素可拖动，或者让图像或链接不能拖动，都可以设置这个属性。例如： 12345&lt;!-- 让这个图像不可以拖动 --&gt;&lt;img src="smile.gif" draggable="false" alt="Smiley face"&gt;&lt;!-- 让这个元素可以拖动 --&gt;&lt;div draggable="true"&gt;...&lt;/div&gt; 支持 draggable 属性的浏览器有 IE 10+、Firefox 4+、Safari 5+和 Chrome。Opera11.5 及之前的版本都不支持 HTML5 的拖放功能。另外，为了让 Firefox 支持可拖动属性，还必须添加一个 ondragstart 事件处理程序，并在 dataTransfer 对象中保存一些信息。 在 IE9 及更早版本中，通过 mousedown 事件处理程序调用 dragDrop() 能够让任何元素可拖动。而在 Safari 4 及之前版本中，必须额外给相应元素设置 CSS 样式–khtml-user-drag: element 。 其他成员HTML5 规范规定 dataTransfer 对象还应该包含下列方法和属性。 addElement(element) ：为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖动源而响应回调的对象），不会影响拖动操作时页面元素的外观。在写作本书时，只有 Firefox 3.5+ 实现了这个方法。 clearData(format) ：清除以特定格式保存的数据。实现这个方法的浏览器有 IE、Fireforx 3.5+、Chrome 和 Safari 4+。 setDragImage(element, x, y) ：指定一幅图像，当拖动发生时，显示在光标下方。这个方法接收的三个参数分别是要显示的 HTML 元素和光标在图像中的 x、y 坐标。其中，HTML 元素可以是一幅图像，也可以是其他元素。是图像则显示图像，是其他元素则显示渲染后的元素。实现这个方法的浏览器有 Firefox 3.5+、Safari 4+和 Chrome。 types ：当前保存的数据类型。这是一个类似数组的集合，以 “text” 这样的字符串形式保存着数据类型。实现这个属性的浏览器有 IE10+、Firefox 3.5+和 Chrome。 媒体元素随着音频和视频在 Web 上的迅速流行，大多数提供富媒体内容的站点为了保证跨浏览器兼容性，不得不选择使用 Flash。HTML5 新增了两个与媒体相关的标签 ，开发人员不必依赖任何插件就能在网页中嵌入跨浏览器的音频和视频内容 。这两个标签就是 &lt;audio&gt; 和 &lt;video&gt; 。 这两个标签 除了能让开发人员方便地嵌入媒体文件之外 ，都提供了用于实现常用功能的 JavaScript API ，允许为媒体创建自定义的控件 。这两个元素的用法如下。 12345&lt;!-- 嵌入视频 --&gt;&lt;video src="conference.mpg" id="myVideo"&gt;Video player not available.&lt;/video&gt;&lt;!-- 嵌入音频 --&gt;&lt;audio src="song.mp3" id="myAudio"&gt;Audio player not available.&lt;/audio&gt; 使用这两个元素时，至少要在标签中包含 src 属性，指向要加载的媒体文件 。还可以设置 width 和 height 属性以指定视频播放器的大小，而为 poster 属性指定图像的 URI 可以在加载视频内容期间显示一幅图像 。另外，如果标签中有 controls 属性，则意味着浏览器应该显示 UI 控件，以便用户直接操作媒体 。位于开始和结束标签之间的任何内容都将作为后备内容 ，在浏览器不支持这两个媒体元素的情况下显示 。 因为 并非所有浏览器都支持所有媒体格式 ，所以 可以指定多个不同的媒体来源 。为此，不用在标签中指定 src 属性，而是要像下面这样使用一或多个 &lt;source&gt; 元素 。 1234567891011121314&lt;!-- 嵌入视频 --&gt;&lt;video id="myVideo"&gt; &lt;source src="conference.webm" type="video/webm; codecs='vp8, vorbis'"&gt; &lt;source src="conference.ogv" type="video/ogg; codecs='theora, vorbis'"&gt; &lt;source src="conference.mpg"&gt; Video player not available.&lt;/video&gt;&lt;!-- 嵌入音频 --&gt;&lt;audio id="myAudio"&gt; &lt;source src="song.ogg" type="audio/ogg"&gt; &lt;source src="song.mp3" type="audio/mpeg"&gt; Audio player not available.&lt;/audio&gt; 关于视频和音频编解码器的内容超出了本书讨论的范围。作者在此只想告诉大家，不同的浏览器支持不同的编解码器 ，因此一般来说指定多种格式的媒体来源是必需的 。支持这两个媒体元素的浏览器有 IE9+、Firefox 3.5+、Safari 4+、Opera 10.5+、Chrome、iOS 版 Safari 和 Android 版 WebKit。 &lt;video&gt; 和 &lt;audio&gt; 元素都提供了完善的 JavaScript 接口 。下表列出了这两个元素共有的属性，通过这些属性可以知道媒体的当前状态 。 其中很多属性也可以直接在 &lt;audio&gt; 和 &lt;video&gt; 元素中设置。 事件除了大量属性之外，这两个媒体元素还可以触发很多事件 。这些事件监控着不同的属性的变化，这些变化可能是媒体播放的结果，也可能是用户操作播放器的结果 。下表列出了媒体元素相关的事件。 这些事件之所以如此具体，就是 为了让开发人员只使用少量 HTML 和 JavaScript（与创建 Flash 影片相比）即可编写出自定义的音频/视频播放器 。 自定义媒体播放器使用 &lt;audio&gt; 和 &lt;video&gt; 元素的 play() 和 pause() 方法 ，可以手工控制媒体文件的播放 。组合使用属性、事件和这两个方法，很容易创建一个自定义的媒体播放器，如下面的例子所示。 1234567891011&lt;div class="mediaplayer"&gt; &lt;div class="video"&gt; &lt;video id="player" src="movie.mov" poster="mymovie.jpg" width="300" height="200"&gt; Video player not available. &lt;/video&gt; &lt;/div&gt; &lt;div class="controls"&gt; &lt;input type="button" value="Play" id="video-btn"&gt; &lt;span id="curtime"&gt;0&lt;/span&gt;/&lt;span id="duration"&gt;0&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 以上基本的 HTML 再加上一些 JavaScript 就可以变成一个简单的视频播放器。以下就是 JavaScript 代码。 123456789101112131415161718192021222324//取得元素的引用var player = document.getElementById("player"), btn = document.getElementById("video-btn"), curtime = document.getElementById("curtime"), duration = document.getElementById("duration");//更新播放时间duration.innerHTML = player.duration;//为按钮添加事件处理程序EventUtil.addHandler(btn, "click", function(event)&#123; if (player.paused)&#123; player.play(); btn.value = "Pause"; &#125; else &#123; player.pause(); btn.value = "Play"; &#125;&#125;);//定时更新当前时间setInterval(function()&#123; curtime.innerHTML = player.currentTime;&#125;, 250); 以上 JavaScript 代码给按钮添加了一个事件处理程序，单击它能让视频在暂停时播放，在播放时暂停 。通过 &lt;video&gt; 元素的 load 事件处理程序，设置了加载完视频后显示播放时间 。最后，设置了一个计时器，以更新当前显示的时间 。你可以进一步扩展这个视频播放器，监听更多事件，利用更多属性。而同样的代码也可以用于 &lt;audio&gt; 元素，以创建自定义的音频播放器。 检测编解码器的支持情况如前所述，并非所有浏览器都支持 &lt;video&gt; 和 &lt;audio&gt; 的所有编解码器 ，而这基本上就意味着 你必须提供多个媒体来源 。不过，也有一个 JavaScript API 能够检测浏览器是否支持某种格式和编解码器 。这两个媒体元素都有一个 canPlayType() 方法 ，该方法 接收一种格式/编解码器字符串 ，返回 “probably” 、 “maybe” 或 “” （ 空字符串） 。空字符串是假值，因此可以像下面这样在 if 语句中使用 canPlayType() ： 123if (audio.canPlayType("audio/mpeg"))&#123; //进一步处理&#125; 而 “probably” 和 “maybe” 都是真值，因此在 if 语句的条件测试中可以转换成 true 。 如果给 canPlayType() 传入了一种 MIME 类型，则返回值很可能是 “maybe” 或空字符串 。这是因为 媒体文件本身只不过是音频或视频的一个容器 ，而 真正决定文件能否播放的还是编码的格式 。在同时传入 MIME 类型和编解码器的情况下，可能性就会增加，返回的字符串会变成 “probably” 。下面来看几个例子。 1234567891011var audio = document.getElementById("audio-player");//很可能"maybe"if (audio.canPlayType("audio/mpeg"))&#123; //进一步处理&#125;//可能是"probably"if (audio.canPlayType("audio/ogg; codecs=\"vorbis\""))&#123; //进一步处理&#125; 注意，编解码器必须用引号引起来才行 。下表列出了已知的已得到支持的音频格式和编解码器。 当然，也可以使用 canPlayType() 来检测视频格式。下表列出了已知的已得到支持的视频格式和编解码器。 Audio 类型&lt;audio&gt; 元素还有一个原生的 JavaScript 构造函数 Audio ，可以在任何时候播放音频 。从同为 DOM 元素的角度看，Audio 与 Image 很相似 ，但 Audio 不用像 Image 那样必须插入到文档中 。只要创建一个新实例，并传入音频源文件即可 。 1234var audio = new Audio("sound.mp3");EventUtil.addHandler(audio, "canplaythrough", function(event)&#123; audio.play();&#125;); 创建新的 Audio 实例即可开始下载指定的文件 。下载完成后，调用 play() 就可以播放音频 。在 iOS 中，调用 play() 时会弹出一个对话框，得到用户的许可后才能播放声音。如果想在一段音频播放后再播放另一段音频，必须在 onfinish 事件处理程序中调用 play() 方法 。 历史状态管理历史状态管理是现代 Web 应用开发中的一个难点。在现代 Web 应用中，用户的每次操作不一定会打开一个全新的页面，因此“后退”和“前进”按钮也就失去了作用，导致用户很难在不同状态间切换 。要解决这个问题，首选 使用 hashchange 事件（第 13 章曾讨论过）。HTML5 通过更新 history 对象为管理历史状态提供了方便 。 通过 hashchange 事件，可以知道 URL 的参数什么时候发生了变化，即什么时候该有所反应 。而 通过状态管理 API，能够在不加载新页面的情况下改变浏览器的 URL 。为此，需要使用 history.pushState() 方法 ，该方法可以接收三个参数：状态对象 、新状态的标题 和 可选的相对 URL 。例如： 1history.pushState(&#123;name:"Nicholas"&#125;, "Nicholas' page", "nicholas.html"); 执行 pushState() 方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对 URL 。但是，浏览器并不会真的向服务器发送请求，即使状态改变之后查询 location.href 也会返回与地址栏中相同的地址 。另外，第二个参数目前还没有浏览器实现，因此完全可以只传入一个空字符串，或者一个短标题也可以。而 第一个参数则应该尽可能提供初始化页面状态所需的各种信息 。 因为 pushState() 会创建新的历史状态 ，所以 你会发现“后退”按钮也能使用了 。按下“后退”按钮，会触发 window 对象的 popstate 事件（popstate 事件发生后，事件对象中的状态对象（event.state）是当前状态。） 。 popstate 事件的事件对象有一个 state 属性 ，这个属性就包含着当初以第一个参数传递给 pushState() 的状态对象 。 123456EventUtil.addHandler(window, "popstate", function(event)&#123; var state = event.state; if (state)&#123; //第一个页面加载时 state 为空 processState(state); &#125;&#125;); 得到这个状态对象后，必须把页面重置为状态对象中的数据表示的状态（因为浏览器不会自动为你做这些）。记住，浏览器加载的第一个页面没有状态，因此单击“后退”按钮返回浏览器加载的第一个页面时， event.state 值为 null 。 要更新当前状态，可以调用 replaceState() ，传入的参数与 pushState() 的前两个参数相同 。调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态 。 1history.replaceState(&#123;name:"Greg"&#125;, "Greg's page"); 支持 HTML5 历史状态管理的浏览器有 Firefox 4+、Safari 5+、Opera 11.5+和 Chrome。在 Safari和 Chrome 中，传递给 pushState() 或 replaceState() 的状态对象中不能包含 DOM 元素。而 Firefox 支持在状态对象中包含 DOM 元素。Opera 还支持一个 history.state 属性，它返回当前状态的状态对象。 在使用 HTML5 的状态管理机制时，请确保使用 pushState() 创造的每一个“假” URL ，在 Web 服务器上都有一个真的、实际存在的 URL 与之对应 。否则，单击“刷新”按钮会导致 404 错误 。 小结HTML5 除了定义了新的标记规则，还定义了一些 JavaScript API。这些 API 是为了让开发人员创建出更好的、能够与桌面应用媲美的用户界面而设计的。本章讨论了如下 API。 跨文档消息传递 API 能够让我们在不降低同源策略安全性的前提下，在来自不同域的文档间传递消息。 原生拖放功能让我们可以方便地指定某个元素可拖动，并在操作系统要放置时做出响应。还可以创建自定义的可拖动元素及放置目标。 新的媒体元素 &lt;audio&gt; 和 &lt;video&gt; 拥有自己的与音频和视频交互的 API。并非所有浏览器支持所有的媒体格式，因此应该使用 canPlayType() 检查浏览器是否支持特定的格式。 历史状态管理让我们不必卸载当前页面即可修改浏览器的历史状态栈。有了这种机制，用户就可以通过“后退”和“前进”按钮在页面状态间切换，而这些状态完全由 JavaScript 进行控制。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-使用 Canvas 绘图]]></title>
    <url>%2F2018%2F08%2F27%2FJavaScript-canvas-drawing%2F</url>
    <content type="text"><![CDATA[使用 Canvas 绘图不用说，HTML5 添加的最受欢迎的功能就是 &lt;canvas&gt; 元素 。这个元素负责在页面中设定一个区域 ，然后就可以通过 JavaScript 动态地在这个区域中绘制图形 。 &lt;canvas&gt; 元素最早是由苹果公司推出的，当时主要用在其 Dashboard 微件中。很快，HTML5 加入了这个元素，主流浏览器也迅速开始支持它。IE9+、Firefox 1.5+、Safari 2+、Opera 9+、Chrome、iOS 版 Safari 以及 Android 版 WebKit 都在某种程度上支持 &lt;canvas&gt; 。 与浏览器环境中的其他组件类似， &lt;canvas&gt; 由几组 API 构成 ，但 并非所有浏览器都支持所有这些 API 。除了具备基本绘图能力的 2D 上下文 ， &lt;canvas&gt; 还建议了一个名为 WebGL 的 3D 上下文 。目前，支持该元素的浏览器都支持 2D 上下文及文本 API ，但 对 WebGL 的支持还不够好 。由于 WebGL还是实验性的，因此要得到所有浏览器支持还需要很长一段时间。Firefox 4+和 Chrome 支持 WebGL 规范的早期版本，但一些老版本的操作系统，比如 Windows XP，由于缺少必要的绘图驱动程序，即便安装了这两款浏览器也无济于事。 基本用法要使用 &lt;canvas&gt; 元素，必须先设置其 width 和 height 属性 ，指定可以绘图的区域大小 。出现在开始和结束标签中的内容是后备信息 ，如果浏览器不支持 &lt;canvas&gt; 元素 ，就会显示这些信息 。下面就是 &lt;canvas&gt; 元素的例子。 1&lt;canvas id="drawing" width=" 200" height="200"&gt;A drawing of something &lt;/canvas&gt; 与其他元素一样， &lt;canvas&gt; 元素对应的 DOM 元素对象也有 width 和 height 属性 ，可以随意修改 。而且，也能通过 CSS 为该元素添加样式 ，如果不添加任何样式或者不绘制任何图形，在页面中是看不到该元素的 。 要在这块画布（canvas）上绘图，需要取得绘图上下文 。而 取得绘图上下文对象的引用 ，需要调用 getContext() 方法 并传入 上下文的名字 。传入 “2d” ，就可以 取得 2D 上下文对象 。 1234567var drawing = document.getElementById("drawing");//确定浏览器支持 &lt;canvas&gt; 元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"); //更多代码&#125; 在使用 &lt;canvas&gt; 元素之前，首先 要检测 getContext() 方法是否存在 ，这一步非常重要。有些浏览器会为 HTML 规范之外的元素创建默认的 HTML 元素对象（假设你想在 Firefox 3 中使用 &lt;canvas&gt; 元素。虽然浏览器会为该标签创建一个 DOM 对象，而且也可以引用它，但这个对象中并没有 getContext()方法。） 。在这种情况下，即使 drawing 变量中保存着一个有效的元素引用，也检测不到 getContext() 方法。 使用 toDataURL() 方法，可以导出在 &lt;canvas&gt; 元素上绘制的图像 。这个方法接受一个参数，即 图像的 MIME 类型格式 ，而且 适合用于创建图像的任何上下文 。比如，要取得画布中的一幅 PNG 格式的图像 ，可以使用以下代码。 123456789101112var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; // 取得图像的数据 URI var imgURI = drawing.toDataURL("image/png"); // 显示图像 var image = document.createElement("img"); image.src = imgURI; document.body.appendChild(image);&#125; 默认情况下，浏览器会将图像编码为 PNG 格式（除非另行指定）。Firefox 和 Opera 也支持基于 “image/jpeg” 参数的 JPEG 编码格式。由于这个方法是后来才追加的，所以支持 &lt;canvas&gt; 的浏览器也是在较新的版本中才加入了对它的支持，比如 IE9、Firefox 3.5 和 Opera 10。 如果绘制到画布上的图像源自不同的域 ， toDataURL() 方法会抛出错误 。本章后面还将介绍更多相关内容。 2D 上下文使用 2D 绘图上下文提供的方法 ，可以绘制简单的 2D 图形 ，比如矩形、弧线和路径。2D 上下文的坐标开始于 &lt;canvas&gt; 元素的左上角 ，原点坐标是(0,0) 。所有坐标值都基于这个原点计算 ，x 值越大表示越靠右 ，y 值越大表示越靠下 。默认情况下， width 和 height 表示水平和垂直两个方向上可用的像素数目 。 填充和描边2D 上下文的两种基本绘图操作是填充和描边 。填充 ，就是 用指定的样式（颜色、渐变或图像）填充图形 ；描边 ，就是 只在图形的边缘画线 。大多数 2D 上下文操作都会细分为填充和描边两个操作，而操作的结果取决于两个属性： fillStyle 和 strokeStyle 。 这两个属性的值可以是字符串、渐变对象或模式对象 ，而且 它们的默认值都是 “#000000” 。如果为它们指定表示颜色的字符串值，可以 使用 CSS 中指定颜色值的任何格式 ，包括 颜色名 、十六进制码 、rgb 、 rgba 、 hsl 或 hsla 。举个例子： 123456789var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"); context.strokeStyle = "red"; context.fillStyle = "#0000ff";&#125; 以上代码将 strokeStyle 设置为 red（CSS 中的颜色名），将 fillStyle 设置为#0000ff（蓝色）。然后，所有涉及描边和填充的操作都将使用这两个样式 ，直至重新设置这两个值 。如前所述，这两个属性的值也可以是渐变对象或模式对象 。本章后面会讨论这两种对象。 绘制矩形矩形是唯一一种可以直接在 2D 上下文中绘制的形状 。与矩形有关的方法包括 fillRect() 、strokeRect() 和 clearRect() 。这三个方法都能接收 4 个参数：矩形的 x 坐标 、矩形的 y 坐标 、矩形宽度 和 矩形高度 这些参数的单位都是像素。 首先，fillRect() 方法在画布上绘制的矩形会填充指定的颜色 。填充的颜色通过 fillStyle 属性指定 ，比如： 1234567891011121314151617181920var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"); /* * 根据 Mozilla 的文档 * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage */ // 绘制红色矩形 context.fillStyle = "#ff0000"; context.fillRect(10, 10, 50, 50); // 绘制半透明的蓝色矩形 context.fillStyle = "rgba(0,0,255,0.5)"; context.fillRect(30, 30, 50, 50);&#125; 以上代码首先将 fillStyle 设置为红色，然后从(10,10)处开始绘制矩形，矩形的宽和高均为 50 像素。然后，通过 rgba() 格式再将 fillStyle 设置为半透明的蓝色，在第一个矩形上面绘制第二个矩形。结果就是可以透过蓝色的矩形看到红色的矩形（见下图）。 strokeRect() 方法在画布上绘制的矩形会使用指定的颜色描边 。 描边颜色通过 strokeStyle 属性指定 。比如： 1234567891011121314151617181920var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"); /* * 根据 Mozilla 的文档 * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage */ // 绘制红色描边矩形 context.strokeStyle = "#ff0000"; context.strokeRect(10, 10, 50, 50); // 绘制半透明的蓝色描边矩形 context.strokeStyle = "rgba(0,0,255,0.5)"; context.strokeRect(30, 30, 50, 50);&#125; 以上代码绘制了两个重叠的矩形。不过，这两个矩形都只有框线，内部并没有填充颜色（见下图）。 描边线条的宽度由 lineWidth 属性控制，该属性的值可以是任意整数。另外，通过 lineCap 属性可以控制线条末端的形状是平头、圆头还是方头（ “butt” 、”round” 或 “square” ），通过 lineJoin 属性可以控制线条相交的方式是圆交、斜交还是斜接（ “round” 、 “bevel” 或 “miter” ）。 最后，clearRect() 方法用于清除画布上的矩形区域 。本质上，这个方法 可以把绘制上下文中的某一矩形区域变透明 。通过绘制形状然后再清除指定区域 ，就可以生成有意思的效果 ，例如把某个形状切掉一块。下面看一个例子。 1234567891011121314151617181920212223var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"); /* * 根据 Mozilla 的文档 * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage */ //绘制红色矩形 context.fillStyle = "#ff0000"; context.fillRect(10, 10, 50, 50); //绘制半透明的蓝色矩形 context.fillStyle = "rgba(0,0,255,0.5)"; context.fillRect(30, 30, 50, 50); // 在两个矩形重叠的地方清除一个小矩形 context.clearRect(40, 40, 10, 10);&#125; 如下图所示，两个填充矩形重叠在一起，而重叠的地方又被清除了一个小矩形区域。 绘制路径2D 绘制上下文支持很多在画布上绘制路径的方法 。通过路径可以创造出复杂的形状和线条 。要绘制路径，首先必须调用 beginPath() 方法 ，表示要开始绘制新路径 。然后，再通过调用下列方法来实际地绘制路径 。 arc(x, y, radius, startAngle, endAngle, counterclockwise) ：以 (x,y) 为圆心绘制一条弧线，弧线半径为 radius ，起始和结束角度（用弧度表示）分别为 startAngle 和 endAngle 。最后一个参数表示 startAngle 和 endAngle 是否按逆时针方向计算，值为 false 表示按顺时针方向计算。 arcTo(x1, y1, x2, y2, radius) ：从上一点开始绘制一条弧线，到 (x2,y2) 为止，并且以给定的半径 radius 穿过 (x1,y1) 。 bezierCurveTo(c1x, c1y, c2x, c2y, x, y) ：从上一点开始绘制一条曲线，到 (x,y) 为止，并且以 (c1x,c1y) 和 (c2x,c2y) 为控制点。 lineTo(x, y) ：从上一点开始绘制一条直线，到 (x,y) 为止。 moveTo(x, y) ：将绘图游标移动到 (x,y) ，不画线。 quadraticCurveTo(cx, cy, x, y) ：从上一点开始绘制一条二次曲线，到 (x,y) 为止，并且以 (cx,cy) 作为控制点。 rect(x, y, width, height) ：从点 (x,y) 开始绘制一个矩形，宽度和高度分别由 width 和 height 指定。这个方法绘制的是矩形路径，而不是 strokeRect() 和 fillRect() 所绘制的独立的形状。 创建了路径后，接下来有几种可能的选择。如果想绘制一条连接到路径起点的线条 ，可以调用 closePath() 。如果路径已经完成 ，你想用 fillStyle 填充 它，可以 调用 fill() 方法 。另外，还可以 调用 stroke() 方法对路径描边 ，描边使用的是 strokeStyle 。最后还可以 调用 clip() ，这个方法 可以在路径上创建一个剪切区域v 。 下面看一个例子，即绘制一个不带数字的时钟表盘。 123456789101112131415161718192021222324252627var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"); // 开始路径 context.beginPath(); // 绘制外圆 context.arc(100, 100, 99, 0, 2 * Math.PI, false); // 绘制内圆 context.moveTo(194, 100); context.arc(100, 100, 94, 0, 2 * Math.PI, false); // 绘制分针 context.moveTo(100, 100); context.lineTo(100, 15); // 绘制时针 context.moveTo(100, 100); context.lineTo(35, 100); // 描边路径 context.stroke();&#125; 这个例子使用 arc() 方法绘制了两个圆形：一个外圆和一个内圆，构成了表盘的边框。外圆的半径是 99 像素，圆心位于点(100,100)，也是画布的中心点。为了绘制一个完整的圆形，我们从 0 弧度开始，绘制 2π 弧度（通过 Math.PI 来计算）。在绘制内圆之前，必须把路径移动到内圆上的某一点，以避免绘制出多余的线条。第二次调用 arc() 使用了小一点的半径，以便创造边框的效果。然后，组合使用 moveTo() 和 lineTo() 方法来绘制时针和分针。最后一步是调用 stroke() 方法，这样才能把图形绘制到画布上，如下图所示。 在 2D 绘图上下文中，路径是一种主要的绘图方式，因为路径能为要绘制的图形提供更多控制 。由于路径的使用很频繁，所以就有了一个名为 isPointInPath() 的方法 。这个方法 接收 x 和 y 坐标作为参数 ，用于在路径被关闭之前确定画布上的某一点是否位于路径上 ，例如： 123if (context.isPointInPath(100, 100))&#123; alert("Point (100, 100) is in the path.");&#125; 2D 上下文中的路径 API 已经非常稳定 ，可以利用它们结合不同的填充和描边样式 ，绘制出非常复杂的图形来 。 绘制文本文本与图形总是如影随形 。为此，2D 绘图上下文也提供了绘制文本的方法。 绘制文本 主要有两个方法： fillText() 和 strokeText() 。这两个方法都可以接收 4 个参数：要绘制的文本字符串 、x 坐标 、y 坐标 和 可选的最大像素宽度 。而且，这两个方法都以下列 3 个属性为基础。 font ：表示文本样式、大小及字体，用 CSS 中指定字体的格式来指定，例如 “10px Arial” 。 textAlign ：表示文本对齐方式。可能的值有 “start” 、 “end” 、 “left” 、 “right” 和 “center” 。建议使用 “start” 和 “end” ，不要使用 “left” 和 “right” ，因为前两者的意思更稳妥，能同时适合从左到右和从右到左显示（阅读）的语言。 textBaseline ：表示文本的基线。可能的值有 “top” 、 “hanging” 、 “middle” 、 “alphabetic” 、”ideographic” 和 “bottom” 。 这几个属性都有默认值 ，因此没有必要每次使用它们都重新设置一遍值。 fillText() 方法使用 fillStyle 属性绘制文本 ，而 strokeText() 方法使用 strokeStyle 属性为文本描边 。相对来说，还是 使用 fillText() 的时候更多 ，因为 该方法模仿了在网页中正常显示文本 。例如，下面的代码在前一节创建的表盘上方绘制了数字 12： 1234context.font = "bold 14px Arial";context.textAlign = "center";context.textBaseline = "middle";context.fillText("12", 100, 20); 结果如下图所示。 因为这里把 textAlign 设置为 “center” ，把 textBaseline 设置为 “middle” ，所以坐标(100,20) 表示的是文本水平和垂直中点的坐标。如果将 textAlign 设置为 “start” ，则 x 坐标表示的是文本左端的位置（从左到右阅读的语言）；设置为 “end” ，则 x 坐标表示的是文本右端的位置（从左到右阅读的语言）。例如： 12345678910111213//正常context.font = "bold 14px Arial";context.textAlign = "center";context.textBaseline = "middle";context.fillText("12", 100, 20);// 起点对齐context.textAlign = "start";context.fi llText("12", 100, 40);// 终点对齐context.textAlign = "end";context.fi llText("12", 100, 60); 这一回绘制了三个字符串 “12” ，每个字符串的 x 坐标值相同，但 textAlign 值不同。另外，后两个字符串的 y 坐标依次增大，以避免相互重叠。结果如下图所示。 表盘中的分针恰好位于正中间，因此文本的水平对齐方式如何变化也能够一目了然 。类似地，修改 textBaseline 属性的值可以调整文本的垂直对齐方式：值为 “top” ，y 坐标表示文本顶端；值为 “bottom” ，y 坐标表示文本底端；值为 “hanging” 、 “alphabetic” 和 “ideographic” ，则 y 坐标分别指向字体的特定基线坐标。 由于绘制文本比较复杂，特别是需要把文本控制在某一区域中的时候，2D 上下文提供了辅助确定文本大小的方法 measureText() 。这个方法接收一个参数，即 要绘制的文本 ；返回一个 TextMetrics对象 。返回的对象目前只有一个 width 属性 ，但将来还会增加更多度量属性。 measureText() 方法利用 font 、 textAlign 和 textBaseline 的当前值计算指定文本的大小 。比如，假设你想在一个 140 像素宽的矩形区域中绘制文本 Hello world!，下面的代码从 100 像素的字体大小开始递减，最终会找到合适的字体大小。 12345678910var fontSize = 100;context.font = fontSize + "px Arial";while(context.measureText("Hello world!").width &gt; 140)&#123; fontSize--; context.font = fontSize + "px Arial";&#125;context.fillText("Hello world!", 10, 10);context.fillText("Font size is " + fontSize + "px", 10, 50); 前面提到过， fillText 和 strokeText() 方法 都可以接收第四个参数，也就是 文本的最大像素宽度 。不过，这个可选的参数尚未得到所有浏览器支持（最早支持它的是 Firefox 4）。提供这个参数后，调用 fillText() 或 strokeText() 时如果传入的字符串大于最大宽度，则绘制的文本字符的高度正确，但宽度会收缩以适应最大宽度。下图展示了这个效果。 绘制文本还是相对比较复杂的操作，因此支持 &lt;canvas&gt; 元素的浏览器也并未完全实现所有与绘制文本相关的 API。 变换通过上下文的变换，可以把处理后的图像绘制到画布上 。2D 绘制上下文支持各种基本的绘制变换 。创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下 ，所有处理都按描述直接绘制 。为绘制上下文应用变换 ，会导致使用不同的变换矩阵应用处理 ，从而产生不同的结果 。可以通过如下方法来修改变换矩阵。 rotate(angle) ：围绕原点旋转图像 angle 弧度。 scale(scaleX, scaleY) ：缩放图像，在 x 方向乘以 scaleX ，在 y 方向乘以 scaleY 。 scaleX和 scaleY 的默认值都是 1.0。 translate(x, y) ：将坐标原点移动到 (x,y) 。执行这个变换之后，坐标(0,0)会变成之前由 (x,y)表示的点。 transform(m1_1, m1_2, m2_1, m2_2, dx, dy) ：直接修改变换矩阵，方式是乘以如下矩阵。 123m1_1 m1_2 dxm2_1 m2_2 dy0 0 1 setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy) ：将变换矩阵重置为默认状态，然后再调用 transform() 。 变换有可能很简单，但也可能很复杂，这都要视情况而定。比如，就拿前面例子中绘制表针来说，如果把原点变换到表盘的中心，然后再绘制表针就容易多了。请看下面的例子。 123456789101112131415161718192021222324252627282930var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"); //开始路径 context.beginPath(); //绘制外圆 context.arc(100, 100, 99, 0, 2 * Math.PI, false); //绘制内圆 context.moveTo(194, 100); context.arc(100, 100, 94, 0, 2 * Math.PI, false); // 变换原点 context.translate(100, 100); // 绘制分针 context.moveTo(0,0); context.lineTo(0, -85); // 绘制时针 context.moveTo(0, 0); context.lineTo(-65, 0); //描边路径 context.stroke();&#125; 把原点变换到时钟表盘的中心点(100,100)后，在同一方向上绘制线条就变成了简单的数学问题了。所有数学计算都基于(0,0)，而不是(100,100)。还可以更进一步，像下面这样 使用 rotate() 方法旋转时钟的表针 。 12345678910111213141516171819202122232425262728293031323334var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"); //开始路径 context.beginPath(); //绘制外圆 context.arc(100, 100, 99, 0, 2 * Math.PI, false); //绘制内圆 context.moveTo(194, 100); context.arc(100, 100, 94, 0, 2 * Math.PI, false); //变换原点 context.translate(100, 100); // 旋转表针 context.rotate(1); //绘制分针 context.moveTo(0,0); context.lineTo(0, -85); //绘制时针 context.moveTo(0, 0); context.lineTo(-65, 0); //描边路径 context.stroke();&#125; 因为原点已经变换到了时钟表盘的中心点，所以旋转也是以该点为圆心的 。结果就像是表针真地被固定在表盘中心一样，然后向右旋转了一定角度。结果如下图所示。 无论是刚才执行的变换 ，还是 fillStyle 、 strokeStyle 等属性 ，都会在当前上下文中一直有效 ，除非再对上下文进行什么修改 。虽然没有什么办法把上下文中的一切都重置回默认值，但有两个方法可以跟踪上下文的状态变化。如果你知道将来还要返回某组属性与变换的组合，可以 调用 save() 方法 。调用这个方法后，当时的所有设置都会进入一个栈结构 ，得以妥善保管 。然后 可以对上下文进行其他修改 。等想要 回到之前保存的设置 时，可以 调用 restore() 方法 ，在保存设置的栈结构中向前返回一级 ，恢复之前的状态 。连续调用 save() 可以把更多设置保存到栈结构中 ，之后再连续调用 restore() 则可以一级一级返回 。下面来看一个例子。 123456789101112131415context.fillStyle = "#ff0000";context.save();context.fillStyle = "#00ff00";context.translate(100, 100);context.save();context.fillStyle = "#0000ff";context.fillRect(0, 0, 100, 200); //从点(100,100)开始绘制蓝色矩形context.restore();context.fillRect(10, 10, 100, 200); //从点(110,110)开始绘制绿色矩形context.restore();context.fillRect(0, 0, 100, 200); //从点(0,0)开始绘制红色矩形 首先，将 fillStyle 设置为红色，并调用 save() 保存上下文状态。接下来，把 fillStyle 修改为绿色，把坐标原点变换到(100,100)，再调用 save() 保存上下文状态。然后，把 fillStyle 修改为蓝色并绘制蓝色的矩形。因为此时的坐标原点已经变了，所以矩形的左上角坐标实际上是(100,100)。然后调用 restore() ，之后 fillStyle 变回了绿色，因而第二个矩形就是绿色。之所以第二个矩形的起点坐标是(110,110)，是因为坐标位置的变换仍然起作用。再调用一次 restore() ，变换就被取消了，而 fillStyle 也返回了红色。所以最后一个矩形是红色的，而且绘制的起点是(0,0)。需要注意的是， save() 方法保存的只是对绘图上下文的设置和变换 ，不会保存绘图上下文的内容 。 绘制图像2D 绘图上下文内置了对图像的支持 。如果你想把一幅图像绘制到画布上 ，可以使用 drawImage() 方法 。根据期望的最终结果不同，调用这个方法时，可以使用三种不同的参数组合。最简单的调用方式是 传入一个 HTML &lt;img&gt; 元素 ，以及 绘制该图像的起点的 x 和 y 坐标 。例如： 12var image = document.images[0];context.drawImage(image, 10, 10); 这两行代码 取得了文档中的第一幅图像 ，然后 将它绘制到上下文中 ，起点为(10,10)。绘制到画布上的图像大小与原始大小一样。如果你想 改变绘制后图像的大小 ，可以再多传入两个参数，分别表示 目标宽度 和 目标高度 。通过这种方式来 缩放图像并不影响上下文的变换矩阵 。例如： 1context.drawImage(image, 50, 10, 20, 30); 执行代码后，绘制出来的图像大小会变成 20×30 像素。 除了上述两种方式，还可以 选择把图像中的某个区域绘制到上下文中 。 drawImage() 方法的这种调用方式总共需要传入 9 个参数：要绘制的图像 、源图像的 x 坐标 、源图像的 y 坐标 、源图像的宽度 、源图像的高度 、目标图像的 x 坐标 、目标图像的 y 坐标 、目标图像的宽度 、目标图像的高度 。这样调用 drawImage() 方法可以获得最多的控制。例如： 1context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60); 这行代码只会把原始图像的一部分绘制到画布上。原始图像的这一部分的起点为(0,10)，宽和高都是 50 像素。最终绘制到上下文中的图像的起点是(0,100)，而大小变成了 40×60 像素。这种调用方式可以创造出很有意思的效果，如下图所示。 除了给 drawImage() 方法传入 HTML &lt;img&gt; 元素外，还 可以传入另一个 &lt;canvas&gt; 元素作为其第一个参数 。这样，就 可以把另一个画布内容绘制到当前画布上 。 结合使用 drawImage() 和其他方法，可以对图像进行各种基本操作。而 操作的结果可以通过 toDataURL() 方法获得 （请读者注意，虽然本章至今一直在讨论 2D 绘图上下文，但 toDataURL()是 Canvas 对象的方法，不是上下文对象的方法。）。不过，有一个例外，即 图像不能来自其他域 。如果图像来自其他域，调用 toDataURL() 会抛出一个错误 。打个比方，假如位于 www.example.com 上的页面绘制的图像来自于 www.wrox.com ，那当前上下文就会被认为“不干净”，因而会抛出错误。 阴影2D 上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影 。 shadowColor ：用 CSS 颜色格式表示的阴影颜色，默认为黑色。 shadowOffsetX ：形状或路径 x 轴方向的阴影偏移量，默认为 0。 shadowOffsetY ：形状或路径 y 轴方向的阴影偏移量，默认为 0。 shadowBlur ：模糊的像素数，默认 0，即不模糊。 这些属性都可以 通过 context 对象来修改 。只要在绘制前为它们设置适当的值，就能自动产生阴影 。例如： 123456789101112131415var context = drawing.getContext("2d");// 设置阴影context.shadowOffsetX = 5;context.shadowOffsetY = 5;context.shadowBlur = 4;context.shadowColor = "rgba(0, 0, 0, 0.5)";//绘制红色矩形context.fillStyle = "#ff0000";context.fillRect(10, 10, 50, 50);//绘制蓝色矩形context.fillStyle = gradient;llStyle = "rgba(0,0,255,1)";context.ficontext.fillRect(30, 30, 50, 50); 两个矩形的阴影样式相同，结果如下图所示。 不同浏览器对阴影的支持有一些差异 。IE9、Firefox 4 和 Opera 11 的行为最为规范，其他浏览器多多少少会有一些奇怪的现象，甚至根本不支持阴影。Chrome（直至第 10 版）不能正确地为描边的形状应用实心阴影。Chrome 和 Safari（直至第 5 版）在为带透明像素的图像应用阴影时也会有问题：不透明部分的下方本来是该有阴影的，但此时则一概不见了。Safari 也不能给渐变图形应用阴影，其他浏览器都可以。 渐变渐变由 CanvasGradient 实例表示 ，很容易 通过 2D 上下文来创建和修改 。要创建一个新的线性渐变，可以 调用 createLinearGradient() 方法 。这个方法接收 4 个参数：起点的 x 坐标 、起点的 y 坐标 、终点的 x 坐标 、终点的 y 坐标 。调用这个方法后，它就会 创建一个指定大小的渐变 ，并 返回 CanvasGradient 对象的实例 。 创建了渐变对象后，下一步就是使用 addColorStop() 方法来指定色标 。这个方法接收两个参数：色标位置 和 CSS 颜色值 。色标位置是一个 0（开始的颜色）到 1（结束的颜色）之间的数字 。例如： 1234var gradient = context.createLinearGradient(30, 30, 70, 70);gradient.addColorStop(0, "white");gradient.addColorStop(1, "black"); 此时， gradient 对象表示的是一个从画布上点(30,30)到点(70,70)的渐变。起点的色标是白色，终点的色标是黑色。然后就 可以把 fillStyle 或 strokeStyle 设置为这个对象 ，从而使用渐变来绘制形状或描边 ： 1234567//绘制红色矩形context.fillStyle = "#ff0000";context.fillRect(10, 10, 50, 50);//绘制渐变矩形context.fillStyle = gradient;context.fillRect(30, 30, 50, 50); 为了让渐变覆盖整个矩形 ，而不是仅应用到矩形的一部分，矩形和渐变对象的坐标必须匹配才行 。以上代码会得到如下图所示的结果。 如果没有把矩形绘制到恰当的位置，那可能就只会显示部分渐变效果。例如： 12context.fillStyle = gradient;context.fillRect(50, 50, 50, 50); 这两行代码执行后得到的矩形只有左上角稍微有一点白色。这主要是因为矩形的起点位于渐变的中间位置，而此时渐变差不多已经结束了。由于渐变不重复，所以矩形的大部分区域都是黑色。确保渐变与形状对齐非常重要 ，有时候可以考虑使用函数来确保坐标合适 。例如： 123function createRectLinearGradient(context, x, y, width, height)&#123; return context.createLinearGradient(x, y, x+width, y+height);&#125; 这个函数 基于起点的x和y坐标以及宽度和高度值来创建渐变对象 ，从而 让我们可以在 fillRect() 中使用相同的值 。 1234567var gradient = createRectLinearGradient(context, 30, 30, 50, 50);gradient.addColorStop(0, "white");gradient.addColorStop(1, "black");//绘制渐变矩形context.fi llStyle = gradient;context.fillRect(30, 30, 50, 50); 使用画布的时候，确保坐标匹配很重要，也需要一些技巧。类似 createRectLinearGradient() 这样的辅助方法可以让控制坐标更容易一些。要创建径向渐变（或放射渐变），可以使用 createRadialGradient() 方法 。这个方法接收 6 个参数，对应着两个圆的圆心和半径 。前三个参数指定的是起点圆的原心（x 和 y）及半径，后三个参数指定的是终点圆的原心（x 和 y）及半径。可以把径向渐变想象成一个长圆桶，而这 6 个参数定义的正是这个桶的两个圆形开口的位置。如果把一个圆形开口定义得比另一个小一些，那这个圆桶就变成了圆锥体，而通过移动每个圆形开口的位置，就可达到像旋转这个圆锥体一样的效果。 如果想从某个形状的中心点开始创建一个向外扩散的径向渐变效果 ，就要 将两个圆定义为同心圆 。比如，就拿前面创建的矩形来说，径向渐变的两个圆的圆心都应该在(55,55)，因为矩形的区域是从(30,30) 到(80,80)。请看代码： 1234567891011var gradient = context.createRadialGradient(55, 55, 10, 55, 55, 30);gradient.addColorStop(0, "white");gradient.addColorStop(1, "black");//绘制红色矩形context.fillStyle = "#ff0000";context.fillRect(10, 10, 50, 50);//绘制渐变矩形context.fillStyle = gradient;context.fillRect(30, 30, 50, 50); 运行代码，会得到如下图所示的结果。 因为创建比较麻烦，所以径向渐变并不那么容易控制。不过，一般来说，让起点圆和终点圆保持为同心圆的情况比较多 ，这时候 只要考虑给两个圆设置不同的半径就好了 。 模式模式其实就是重复的图像 ，可以用来填充或描边图形 。要创建一个新模式，可以调用 createPattern() 方法 并传入两个参数：一个 HTML &lt;img&gt; 元素 和 一个表示如何重复图像的字符串 。其中，第二个参数的值 与 CSS 的 background-repeat 属性值相同 ，包括 “repeat“ 、 “repeat-x“ 、”repeat-y“ 和 “no-repeat“ 。看一个例子。 123456var image = document.images[0],pattern = context.createPattern(image, "repeat");//绘制矩形context.fillStyle = pattern;context.fillRect(10, 10, 150, 150); 需要注意的是，模式与渐变一样，都是从画布的原点(0,0)开始的。将填充样式（ fillStyle ）设置为模式对象，只表示在某个特定的区域内显示重复的图像，而不是要从某个位置开始绘制重复的图像。上面的代码会得到如下图所示的结果。 createPattern() 方法 的第一个参数也 可以是一个 &lt;video&gt; 元素 ，或者 另一个 &lt;canvas&gt; 元素 。 使用图像数据2D 上下文的一个明显的长处就是，可以通过 getImageData() 取得原始图像数据 。这个方法接收 4 个参数：要取得其数据的画面区域的 x 和 y 坐标 以及 该区域的像素宽度和高度 。例如，要取得左上角坐标为(10,5)、大小为 50×50 像素的区域的图像数据，可以使用以下代码： 1var imageData = context.getImageData(10, 5, 50, 50); 这里 返回的对象是 ImageData 的实例 。每个 ImageData 对象都有三个属性： width 、 height 和 data 。其中 data 属性是一个数组 ，保存着图像中每一个像素的数据 。在 data 数组中，每一个像素用 4 个元素来保存，分别表示红、绿、蓝和透明度值 。因此，第一个像素的数据就保存在数组的第 0 到第 3 个元素中，例如： 12345var data = imageData.data, red = data[0], green = data[1], blue = data[2], alpha = data[3]; 数组中每个元素的值都介于 0 到 255 之间（包括 0 和 255）。能够直接访问到原始图像数据，就能够以各种方式来操作这些数据。例如，通过修改图像数据，可以像下面这样创建一个 简单的灰阶过滤器 。 1234567891011121314151617181920212223242526272829303132333435var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext("2d"), image = document.images[0], imageData, data, i, len, average, red, green, blue, alpha; //绘制原始图像 context.drawImage(image, 0, 0); //取得图像数据 imageData = context.getImageData(0, 0, image.width, image.height); data = imageData.data; for (i=0, len=data.length; i &lt; len; i+=4)&#123; red = data[i]; green = data[i+1]; blue = data[i+2]; alpha = data[i+3]; //求得 rgb 平均值 average = Math.floor((red + green + blue) / 3); //设置颜色值，透明度不变 data[i] = average; data[i+1] = average; data[i+2] = average; &#125; //回写图像数据并显示结果 imageData.data = data; context.putImageData(imageData, 0, 0);&#125; 这个例子首先在画面上绘制了一幅图像，然后取得了原始图像数据。其中的 for 循环遍历了图像数据中的每一个像素。这里要注意的是，每次循环控制变量 i 都递增 4。在取得每个像素的红、绿、蓝颜色值后，计算出它们的平均值。再把这个平均值设置为每个颜色的值，结果就是去掉了每个像素的颜色，只保留了亮度接近的灰度值（即彩色变黑白）。在把 data 数组回写到 imageData 对象后，调用 putImageData() 方法把图像数据绘制到画布上。最终得到了图像的黑白版。 当然，通过操作原始像素值不仅能实现灰阶过滤 ，还能实现其他功能 。要了解通过操作原始图像数据实现过滤器的更多信息，请参考 Ilmari Heikkinen 的文章“Making Image Filters with Canvas”（基于Canvas的图像过滤器）：http://www.html5rocks.com/en/tutorials/canvas/imagefilters/ 。 只有在画布“干净”的情况下（即图像并非来自其他域），才可以取得图像数据 。如果画布“不干净”，那么访问图像数据时会导致 JavaScript 错误。 合成还有两个会应用到 2D 上下文中所有绘制操作的属性 ： globalAlpha 和 globalCompositionOperation 。其中，globalAlpha 是一个介于 0 和 1 之间的值（包括 0和 1），用于指定所有绘制的透明度 。默认值为 0 。如果所有后续操作都要基于相同的透明度 ，就可以先把 globalAlpha 设置为适当值，然后绘制，最后再把它设置回默认值 0 。下面来看一个例子。 12345678910111213//绘制红色矩形context.fillStyle = "#ff0000";context.fillRect(10, 10, 50, 50);//修改全局透明度context.globalAlpha = 0.5;//绘制蓝色矩形context.fillStyle = "rgba(0,0,255,1)";context.fillRect(30, 30, 50, 50);//重置全局透明度context.globalAlpha = 0; 在这个例子中，我们把蓝色矩形绘制到了红色矩形上面。因为在绘制蓝色矩形前， globalAlpha 已经被设置为 0.5，所以蓝色矩形会呈现半透明效果，透过它可以看到下面的红色矩形。 第二个属性 globalCompositionOperation 表示后绘制的图形怎样与先绘制的图形结合 。这个属性的值是字符串，可能的值如下。 source-over （默认值）：后绘制的图形位于先绘制的图形上方。 source-in ：后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明。 source-out ：后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明。 source-atop ：后绘制的图形与先绘制的图形重叠的部分可见，先绘制图形不受影响。 destination-over ：后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见。 destination-in ：后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明。 destination-out ：后绘制的图形擦除与先绘制的图形重叠的部分。 destination-atop ：后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的 lighter ：后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮。 copy ：后绘制的图形完全替代与之重叠的先绘制图形。 xor ：后绘制的图形与先绘制的图形重叠的部分执行“异或”操作。 这个合成操作实际上用语言或者黑白图像是很难说清楚的。要了解每个操作的具体效果，请参见 https://developer.mozilla.org/samples/canvas-tutorial/6_1_canvas_composite.html 。推荐使用 IE9+或 Firefox 4+访问前面的网页，因为这两款浏览器对 Canvas的实现最完善。下面来看一个例子。 12345678910//绘制红色矩形context.fillStyle = "#ff0000";context.fillRect(10, 10, 50, 50);//设置合成操作context.globalCompositeOperation = "destination-over";//绘制蓝色矩形context.fillStyle = "rgba(0,0,255,1)";context.fillRect(30, 30, 50, 50); 如果不修改 globalCompositionOperation ，那么蓝色矩形应该位于红色矩形之上。但把globalCompositionOperation 设置为 “destination-over” 之后，红色矩形跑到了蓝色矩形上面。在使用 globalCompositionOperation 的情况下，一定要多测试一些浏览器。因为不同浏览器对这个属性的实现仍然存在较大的差别。Safari 和 Chrome 在这方面还有问题，至于有什么问题，大家可以比较在打开上述页面的情况下，IE9+和 Firefox 4+与它们有什么差异。 WebGLWebGL 是针对 Canvas 的 3D 上下文 。与其他 Web 技术不同，WebGL 并不是 W3C 制定的标准 ，而是由 Khronos Group 制定的。其官方网站是这样介绍的：“Khronos Group 是一个非盈利的由会员资助的协会，专注于为并行计算以及各种平台和设备上的图形及动态媒体制定无版税的开放标准。” Khronos Group 也设计了其他图形处理 API，比如 OpenGL ES 2.0。浏览器中使用的 WebGL就是基于 OpenGL ES 2.0 制定的。 OpenGL 等 3D 图形语言是非常复杂的，本书不可能介绍其中每一个概念。熟悉 OpenGL ES 2.0 的读者可能会觉得 WebGL 更好理解一些，因为好多概念是相通的。本节将适当地介绍 OpenGL ES 2.0 的一些概念，尽力解释其中的某些部分在 WebGL 中的实现。要全面了解 OpenGL，请访问 www.opengl.org 。要全面学习 WebGL，请参考 www.learningwebgl.com ，其中包含非常棒的系列教程（中文翻译版请参考 http://www.hiwebgl.com/?p=42 。） 。 类型化数组WebGL 涉及的复杂计算需要提前知道数值的精度 ，而 标准的 JavaScript 数值无法满足需要 。为此，WebGL 引入了一个概念 ，叫 类型化数组 （typed arrays）。类型化数组也是数组 ，只不过其元素被设置为特定类型的值 。 类型化数组的核心就是一个名为 ArrayBuffer 的类型 。每个 ArrayBuffer 对象表示的只是内存中指定的字节数 ，但 不会指定这些字节用于保存什么类型的数据 。通过 ArrayBuffer 所能做的，就是为了将来使用而分配一定数量的字节 。例如，下面这行代码会在内存中分配 20B。 1var buffer = new ArrayBuffer(20); 创建了 ArrayBuffer 对象后，能够通过该对象获得的信息只有它包含的字节数 ，方法是 访问其 byteLength 属性 ： 1var bytes = buffer.byteLength; 虽然 ArrayBuffer 对象本身没有多少可说的，但对 WebGL 而言，使用它是极其重要的。而且，在涉及视图的时候，你才会发现它原来还是很有意思的。 视图使用 ArrayBuffer （数组缓冲器类型）的一种特别的方式就是用它来创建数组缓冲器视图 。其中，最常见的视图是 DataView ，通过它可以选择 ArrayBuffer 中一小段字节 。为此，可以在 创建 DataView 实例 的时候传入 一个 ArrayBuffer 、一个可选的字节偏移量（从该字节开始选择）和 v一个可选的要选择的字节数** 。例如： 123456789//基于整个缓冲器创建一个新视图var view = new DataView(buffer);//创建一个开始于字节 9 的新视图var view = new DataView(buffer, 9);//创建一个从字节 9 开始到字节 18 的新视图var view = new DataView(buffer, 9, 10);` 实例化之后， DataView 对象会把字节偏移量以及字节长度信息分别保存在 byteOffset 和 byteLength 属性中 。 12alert(view.byteOffset);alert(view.byteLength); 通过这两个属性可以在以后方便地 了解视图的状态 。另外，通过其 buffer 属性也可以取得数组缓冲器 。 读取和写入 DataView 的时候，要根据实际操作的数据类型，选择相应的 getter 和 setter 方法。下表列出了 DataView 支持的数据类型以及相应的读写方法 。 所有 这些方法的第一个参数 都是一个 字节偏移量 ，表示要从哪个字节开始读取或写入 。不要忘了，要保存有些数据类型的数据 ，可能需要不止 1B 。比如，无符号 8 位整数要用 1B，而 32 位浮点数则要用 4B。使用 DataView ，就需要你自己来管理这些细节 ，即 要明确知道自己的数据需要多少字节 ，并选择正确的读写方法 。例如： 1234567var buffer = new ArrayBuffer(20), view = new DataView(buffer), value;view.setUint16(0, 25);view.setUint16(2, 50); //不能从字节 1 开始，因为 16 位整数要用 2Bvalue = view.getUint16(0); 以上代码把两个无符号 16 位整数保存到了数组缓冲器中。因为每个 16 位整数要用 2B，所以保存第一个数的字节偏移量为 0，而保存第二个数的字节偏移量为 2。 用于读写 16 位或更大数值的方法都有一个可选的参数 littleEndian 。这个参数是一个 布尔值 ，表示读写数值时是否采用小端字节序 （即将数据的最低有效位保存在低内存地址中），而不是大端字节序（即将数据的最低有效位保存在高内存地址中）。 如果你也不确定应该使用哪种字节序，那不用管它，就采用默认的大端字节序方式保存即可 。 因为在这里使用的是字节偏移量，而非数组元素数，所以可以通过几种不同的方式来 访问同一字节 。例如： 12345678var buffer = new ArrayBuffer(20), view = new DataView(buffer), value;view.setUint16(0, 25);value = view.getInt8(0);alert(value); //0 在这个例子中，数值 25 以 16 位无符号整数的形式被写入，字节偏移量为 0。然后，再以 8 位有符号整数的方式读取该数据，得到的结果是 0。这是因为 25 的二进制形式的前 8 位（第一个字节）全部是 0，如下图所示。 可见，虽然 DataView 能让我们在字节级别上读写数组缓冲器中的数据 ，但 我们必须自己记住要将数据保存到哪里，需要占用多少字节 。这样一来，就会带来很多工作量，因此类型化视图也就应运而生。 类型化视图类型化视图一般也被称为类型化数组 ，因为它们 除了元素必须是某种特定的数据类型外 ，与常规的数组无异 。类型化视图也分几种，而且 它们都继承了 DataView 。 Int8Array ：表示 8 位二补整数。 Uint8Array ：表示 8 位无符号整数。 Int16Array ：表示 16 位二补整数。 Uint16Array ：表示 16 位无符号整数。 Int32Array ：表示 32 位二补整数。 Uint32Array ：表示 32 位无符号整数。 Float32Array ：表示 32 位 IEEE 浮点值。 Float64Array ：表示 64 位 IEEE 浮点值。 每种视图类型都以不同的方式表示数据 ，而 同一数据视选择的类型不同有可能占用一或多字节 。例如，20B 的 ArrayBuffer 可以保存 20 个 Int8Array 或 Uint8Array ，或者 10 个 Int16Array 或 Uint16Array ，或者 5 个 Int32Array 、 Uint32Array 或 Float32Array ，或者 2 个 Float64Array 。 由于 这些视图都继承自 DataView ，因而 可以使用相同的构造函数参数来实例化 。第一个参数是要使用 ArrayBuffer 对象 ，第二个参数是 作为起点的字节偏移量 （默认为 0），第三个参数是 要包含的字节数 。三个参数中 只有第一个是必需的 。下面来看几个例子。 12345678//创建一个新数组，使用整个缓冲器var int8s = new Int8Array(buffer);//只使用从字节 9 开始的缓冲器var int16s = new Int16Array(buffer, 9);//只使用从字节 9 到字节 18 的缓冲器var uint16s = new Uint16Array(buffer, 9, 10); 能够指定缓冲器中可用的字节段 ，意味着 能在同一个缓冲器中保存不同类型的数值 。比如，下面的代码就是在缓冲器的开头保存 8 位整数，而在其他字节中保存 16 位整数。 123//使用缓冲器的一部分保存 8 位整数，另一部分保存 16 位整数var int8s = new Int8Array(buffer, 0, 10);var uint16s = new Uint16Array(buffer, 11, 10); 每个视图构造函数都有一个名为 BYTES_PER_ELEMENT 的属性 ，表示类型化数组的每个元素需要多少字节 。因此， Uint8Array.BYTES_PER_ELEMENT 就是 1 ，而 Float32Array.BYTES_PER_ELEMENT 则为 4 。可以利用这个属性来辅助初始化 。 12345//需要 10 个元素空间var int8s = new Int8Array(buffer, 0, 10 * Int8Array.BYTES_PER_ELEMENT);//需要 5 个元素空间var uint16s = new Uint16Array(buffer, int8s.byteOffset + int8s.byteLength, 5 * Uint16Array.BYTES_PER_ELEMENT); 以上代码基于同一个数组缓冲器创建了两个视图。缓冲器的前 10B 用于保存 8 位整数，而其他字节用于保存无符号 16 位整数。在初始化 Uint16Array 的时候，使用了 Int8Array 的 byteOffset 和 byteLength 属性，以确保 uint16s 开始于 8 位数据之后。 如前所述，类型化视图的目的在于简化对二进制数据的操作 。除了前面看到的优点之外，创建类型化视图还可以不用首先创建 ArrayBuffer 对象。只要传入希望数组保存的元素数，相应的构造函数就可以自动创建一个包含足够字节数的 ArrayBuffer 对象 ，例如： 12345//创建一个数组保存 10 个 8 位整数（10 字节）var int8s = new Int8Array(10);//创建一个数组保存 10 个 16 位整数（20 字节）var int16s = new Int16Array(10); 另外，也 可以把常规数组转换为类型化视图 ，只要把常规数组传入类型化视图的构造函数即可 ： 12//创建一个数组保存 5 个 8 位整数（10 字节）var int8s = new Int8Array([10, 20, 30, 40, 50]); 这是 用默认值来初始化类型化视图的最佳方式，也是 WebGL 项目中最常用的方式 。 以这种方式来使用类型化视图，可以让它们看起来更像 Array 对象 ，同时 也能确保在读写信息的时候使用正确的数据类型 。 使用类型化视图 时，可以 通过方括号语法访问每一个数据成员 ，可以 通过 length 属性确定数组中有多少元素 。这样，对类型化视图的迭代与对 Array 对象的迭代就是一样的了 。 123for (var i=0, len=int8s.length; i &lt; len; i++)&#123; console.log("Value at position " + i + " is " + int8s[i]);&#125; 当然，也可以 使用方括号语法为类型化视图的元素赋值 。如果为相应元素指定的字节数放不下相应的值，则实际保存的值是最大可能值的模 。例如，无符号 16 位整数所能表示的最大数值是 65535，如果你想保存 65536，那实际保存的值是 0；如果你想保存 65537，那实际保存的值是 1，依此类推。 123var uint16s = new Uint16Array(10);uint16s[0] = 65537;alert(uint16s[0]); //1 数据类型不匹配时不会抛出错误，所以你必须自己保证所赋的值不会超过相应元素的字节限制。 类型化视图 还有一个方法，即 subarray() ，使用 这个方法可以基于底层数组缓冲器的子集创建一个新视图 。这个方法接收两个参数：开始元素的索引 和 可选的结束元素的索引 。返回的类型与调用该方法的视图类型相同 。例如： 12var uint16s = new Uint16Array(10),sub = uint16s.subarray(2, 5); 在以上代码中， sub 也是 Uint16Array 的一个实例，而且底层与 uint16s 都基于同一个 ArrayBuffer 。通过大视图创建小视图的主要好处就是，在操作大数组中的一部分元素时，无需担心意外修改了其他元素 。 类型化数组是 WebGL 项目中执行各种操作的重要基础。 WebGL上下文目前，在支持的浏览器中，WebGL 的名字叫 “experimental-webgl” ，这是因为 WebGL 规范仍然未制定完成。制定完成后，这个上下文的名字就会变成简单的 “webgl” 。如果浏览器不支持 WebGL，那么取得该上下文时会返回 null 。 在使用 WebGL 上下文时，务必先检测一下返回值 。 12345678910var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var gl = drawing.getContext("experimental-webgl"); if (gl)&#123; // 使用 WebGL &#125;&#125; 一般都把WebGL上下文对象命名为 gl 。大多数WebGL应用和示例都遵守这一约定，因为 OpenGL ES 2.0 规定的方法和值通常都以 “gl” 开头 。这样做也可以保证 JavaScript 代码与 OpenGL 程序更相近。 取得了 WebGL 上下文之后，就可以开始 3D 绘图了 。如前所述，WebGL 是 OpenGL ES 2.0的 Web版，因此本节讨论的概念实际上就是 OpenGL 概念在 JavaScript 中的实现。 通过给 getContext() 传递第二个参数，可以为 WebGL 上下文设置一些选项 。这个参数本身是一个对象，可以包含下列属性。 alpha ：值为 true ，表示为上下文创建一个 Alpha 通道缓冲区；默认值为 true 。 depth ：值为 true ，表示可以使用 16 位深缓冲区；默认值为 true 。 stencil ：值为 true ，表示可以使用 8 位模板缓冲区；默认值为 false 。 antialias ：值为 true ，表示将使用默认机制执行抗锯齿操作；默认值为 true 。 premultipliedAlpha ：值为 true ，表示绘图缓冲区有预乘 Alpha 值；默认值为 true 。 preserveDrawingBuffer ：值为 true ，表示在绘图完成后保留绘图缓冲区；默认值为 false 。 建议确实有必要的情况下再开启这个值 ，因为 可能影响性能 。传递这个选项对象的方式如下： 12345678910var drawing = document.getElementById("drawing");//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var gl = drawing.getContext("experimental-webgl", &#123; alpha: false&#125;); if (gl)&#123; // 使用 WebGL &#125;&#125; 大多数上下文选项只在高级技巧中使用。很多时候，各个选项的默认值就能满足我们的要求。 如果 getContext() 无法创建 WebGL 上下文，有的浏览器会抛出错误 。为此，最好 把调用封装到 一个 try-catch 块中 。 123456789101112131415Insert IconMargin [download]var drawing = document.getElementById("drawing"), gl;//确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; try &#123; gl = drawing.getContext("experimental-webgl"); &#125; catch (ex) &#123; // 什么也不做 &#125; if (gl)&#123; //使用 WebGL &#125; else &#123; alert("WebGL context could not be created."); &#125;&#125; 常量如果你熟悉 OpenGL，那肯定会对各种操作中使用非常多的常量印象深刻。 这些常量在 OpenGL 中都带前缀 GL_ 。在 WebGL 中， 保存在上下文对象中的这些常量都没有 GL_ 前缀 。比如说，GL_COLOR_BUFFER_BIT 常量在 WebGL上下文中就是 gl.COLOR_BUFFER_BIT 。WebGL 以这种方式支持大多数 OpenGL 常量（有一部分常量是不支持的）。 方法命名OpenGL（以及 WebGL）中的很多方法都试图通过名字传达有关数据类型的信息 。如果某方法可以接收不同类型及不同数量的参数，看方法名的后缀就可以知道。方法名的后缀会包含参数个数（1 到 4）和接收的数据类型（ f 表示浮点数， i 表示整数）。例如， gl.uniform4f() 意味着要接收 4 个浮点数，而 gl.uniform3i() 则表示要接收 3 个整数。 也有很多方法接收数组参数而非一个个单独的参数。这样的方法其名字中会包含字母 v（即 vector，矢量）。因此， gl.uniform3iv() 可以接收一个包含 3 个值的整数数组。请大家记住以上命名约定，这样对理解后面关于 WebGL的讨论很有帮助。 准备绘图在实际操作 WebGL 上下文之前， 一般都要使用某种实色清除 &lt;canvas&gt; ，为绘图做好准备。为此，首先必须使用 clearColor() 方法 来 指定要使用的颜色值 ，该方法接收 4 个参数：红、绿 、蓝 和 透明度 。每个参数必须是一个 0 到 1 之间的数值 ，表示 每种分量在最终颜色中的强度 。来看下面的例子。 12gl.clearColor(0,0,0,1); //blackgl.clear(gl.COLOR_BUFFER_BIT); 以上代码 把清理颜色缓冲区的值设置为黑色 ，然后调用了 clear() 方法 ，这个方法 与 OpenGL 中的 glClear() 等价 。传入的参数 gl.COLOR_BUFFER_BIT 告诉 WebGL使用之前定义的颜色来填充相应区域。一般来说，都要先清理缓冲区 ，然后 再执行其他绘图操作 。 视口与坐标开始绘图之前，通常要先 定义 WebGL 的视口（viewport）。默认情况下，视口可以使用整个 &lt;canvas&gt; 区域。要改变视口大小 ，可以调用 viewport() 方法 并传入 4 个参数：（视口相对于 &lt;canvas&gt; 元素的） x 坐标 、y 坐标 、宽度 和 高度 。例如，下面的调用就使用了 &lt;canvas&gt; 元素： 1gl.viewport(0, 0, drawing.width, drawing.height); 视口坐标与我们通常熟悉的网页坐标不一样。视口坐标的原点(0,0)在 &lt;canvas&gt; 元素的左下角 ，x 轴和 y 轴的正方向分别是向右和向上 ，可以定义为(width-1, height-1)，如下图所示。 知道怎么定义视口大小，就可以只在 &lt;canvas&gt; 元素的部分区域中绘图 。来看下面的例子。 12345678//视口是&lt;canvas&gt;左下角的四分之一区域gl.viewport(0, 0, drawing.width/2, drawing.height/2);//视口是&lt;canvas&gt;左上角的四分之一区域gl.viewport(0, drawing.height/2, drawing.width/2, drawing.height/2);//视口是&lt;canvas&gt;右下角的四分之一区域gl.viewport(drawing.width/2, 0, drawing.width/2, drawing.height/2); 另外，视口内部的坐标系与定义视口的坐标系也不一样 。在视口内部，坐标原点(0,0)是视口的中心点 ，因此 视口左下角坐标为(-1,-1) ，而 右上角坐标为(1,1) ，如下图所示。 如果在视口内部绘图时使用视口外部的坐标，结果可能会被视口剪切 。比如，要绘制的形状有一个顶点在(1,2)，那么该形状在视口右侧的部分会被剪切掉。 缓冲区顶点信息保存在 JavaScript 的类型化数组中 ，使用之前必须转换到 WebGL 的缓冲区 。要创建缓冲区，可以调用 gl.createBuffer() ，然后 使用 gl.bindBuffer() 绑定到 WebGL 上下文 。这两步做完之后，就可以 用数据来填充缓冲区 了。例如： 123var buffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0.5, 1]), gl.STATIC_DRAW); 调用 gl.bindBuffer() 可以将 buffer 设置为上下文的当前缓冲区 。此后，所有缓冲区操作都直接在 buffer 中执行。因此，调用 gl.bufferData() 时不需要明确传入 buffer 也没有问题。最后一行代码使用 Float32Array 中的数据初始化了 buffer （一般都是用 Float32Array 来保存顶点信息）。如果想使用 drawElements() 输出缓冲区的内容，也可以传入 gl.ELEMENT_ARRAY_BUFFER 。 gl.bufferData() 的最后一个参数用于 指定使用缓冲区的方式 ，取值范围是如下几个常量。 gl.STATIC_DRAW ：数据只加载一次，在多次绘图中使用。 gl.STREAM_DRAW ：数据只加载一次，在几次绘图中使用。 gl.DYNAMIC_DRAW ：数据动态改变，在多次绘图中使用。 如果不是非常有经验的 OpenGL 程序员，多数情况下将缓冲区使用方式设置为 gl.STATIC_DRAW 即可 。 在包含缓冲区的页面重载之前，缓冲区始终保留在内存中。如果你不想要某个缓冲区了，可以直接调用 gl.deleteBuffer() 释放内存 ： 1gl.deleteBuffer(buffer); 错误JavaScript 与 WebGL 之间的一个最大的区别在于 ，WebGL 操作一般不会抛出错误v 。为了知道是否有错误发生 ，必须 在调用某个可能出错的方法后 ，手工调用 gl.getError() 方法 。这个方法 v返回一个表示错误类型的常量** 。可能的错误常量如下。 gl.NO_ERROR ：上一次操作没有发生错误（值为 0）。 gl.INVALID_ENUM ：应该给方法传入 WebGL 常量，但却传错了参数。 gl.INVALID_VALUE ：在需要无符号数的地方传入了负值。 gl.INVALID_OPERATION ：在当前状态下不能完成操作。 gl.OUT_OF_MEMORY ：没有足够的内存完成操作。 gl.CONTEXT_LOST_WEBGL ：由于外部事件（如设备断电）干扰丢失了当前 WebGL 上下文。 每次调用 gl.getError() 方法返回一个错误值。第一次调用后，后续对 gl.getError() 的调用可能会返回另一个错误值。如果发生了多个错误，需要反复调用 gl.getError() 直至它返回 gl.NO_ERROR 。在执行了很多操作的情况下，最好通过一个循环来调用 getError() ，如下所示： 12345var errorCode = gl.getError();while(errorCode)&#123; console.log("Error occurred: " + errorCode); errorCode = gl.getError();&#125; 如果 WebGL脚本输出不正确，那在脚本中放几行 gl.getError() 有助于找出问题所在。 着色器着色器（shader）是 OpenGL 中的另一个概念。WebGL 中有两种着色器：顶点着色器 和 片段（或像素）着色器 。顶点着色器用于将 3D 顶点转换为需要渲染的 2D 点 。片段着色器用于准确计算要绘制的每个像素的颜色 。WebGL 着色器的独特之处也是其难点在于，它们并不是用 JavaScript 写的。这些着色器是使用 GLSL（OpenGL Shading Language，OpenGL 着色语言）写的 ，GLSL 是一种与 C 和 JavaScript 完全不同的语言 。 编写着色器GLSL 是一种类 C 语言，专门用于编写 OpenGL 着色器 。因为 WebGL 是 OpenGL ES 2.0 的实现，所以 OpenGL 中使用的着色器可以直接在 WebGL 中使用 。这样就方便了将桌面图形应用移植到浏览器中。 每个着色器都有一个 main() 方法，该方法在绘图期间会重复执行。为着色器传递数据的方式有两种：Attribute 和 Uniform。通过 Attribute 可以向顶点着色器中传入顶点信息，通过 Uniform 可以向任何着色器传入常量值。Attribute 和 Uniform 在 main() 方法外部定义，分别使用关键字 attribute 和 uniform 。在这两个值类型关键字之后，是数据类型和变量名。下面是一个简单的顶点着色器的例子。 12345678//OpenGL 着色语言//着色器，作者 Bartek Drozdz，摘自他的文章//http://www.netmagazine.com/tutorials/get-started-webgl-draw-squareattribute vec2 aVertexPosition;void main() &#123; gl_Position = vec4(aVertexPosition, 0.0, 1.0);&#125; 这个顶点着色器定义了一个名为 aVertexPosition 的 Attribute，这个 Attribute 是一个数组，包含两个元素（数据类型为 vec2 ），表示 x 和 y 坐标。即使只接收到两个坐标，顶点着色器也必须把一个包含四方面信息的顶点赋值给特殊变量 gl_Position 。这里的着色器创建了一个新的包含四个元素的数组（ vec4 ），填补缺失的坐标，结果是把 2D 坐标转换成了 3D 坐标。 除了只能通过 Uniform传入数据外，片段着色器与顶点着色器类似。以下是片段着色器的例子。 12345678//OpenGL 着色语言//着色器，作者 Bartek Drozdz，摘自他的文章//http://www.netmagazine.com/tutorials/get-started-webgl-draw-squareuniform vec4 uColor;void main() &#123; gl_FragColor = uColor;&#125; 片段着色器必须返回一个值，赋给变量 gl_FragColor ，表示绘图时使用的颜色。这个着色器定义了一个包含四方面信息（ vec4 ）的统一的颜色 uColor 。从以上代码看，这个着色器除了把传入的值赋给 gl_FragColor 什么也没做。 uColor 的值在这个着色器内部不能改变。 OpenGL 着色语言比这里看到的还要复杂。专门讲解这门语言的书有很多，本节只是从辅助使用 WebGL 的角度简要介绍一下该语言。要了解更多信息，请参考 RandiJ. Rost 编著的 OpenGL Shading Language（Addison-Wesley,2006）。 编写着色器程序浏览器不能理解 GLSL 程序，因此必须准备好字符串形式的 GLSL 程序，以便编译并链接到着色器程序。为便于使用，通常是把着色器包含在页面的 &lt;script&gt; 标签内，并为该标签指定一个自定义的 type 属性。由于无法识别 type 属性值，浏览器不会解析 &lt;script&gt; 标签中的内容，但这不影响你读写其中的代码。例如： 1234567891011121314&lt;script type="x-webgl/x-vertex-shader" id="vertexShader"&gt;attribute vec2 aVertexPosition;void main() &#123; gl_Position = vec4(aVertexPosition, 0.0, 1.0);&#125;&lt;/script&gt;&lt;script type="x-webgl/x-fragment-shader" id="fragmentShader"&gt;uniform vec4 uColor;void main() &#123; gl_FragColor = uColor;&#125;&lt;/script&gt; 然后，可以 通过 text 属性提取出 &lt;script&gt; 元素的内容 ： 12var vertexGlsl = document.getElementById("vertexShader").text,fragmentGlsl = document.getElementById("fragmentShader").text; 复杂一些的 WebGL 应用可能会通过 Ajax（详见第 21 章）动态加载着色器。而使用着色器的关键是要有字符串形式的 GLSL 程序。 取得了 GLSL 字符串之后，接下来就是创建着色器对象。要创建着色器对象，可以调用 gl.createShader() 方法 并传入 要创建的着色器类型（ gl.VERTEX_SHADER 或 gl.FRAGMENT_SHADER ）。编译着色器使用的是 gl.compileShader() 。请看下面的例子。 1234567var vertexShader = gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vertexShader, vertexGlsl);gl.compileShader(vertexShader);var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fragmentShader, fragmentGlsl);gl.compileShader(fragmentShader); 以上代码创建了两个着色器，并将它们分别保存在 vertexShader 和 fragmentShader 中。而使用下列代码，可以把这两个对象链接到着色器程序中。 1234var program = gl.createProgram();gl.attachShader(program, vertexShader);gl.attachShader(program, fragmentShader);gl.linkProgram(program); 第一行代码创建了程序，然后调用 attachShader() 方法又包含了两个着色器。最后调用 gl.linkProgram() 则把两个着色器封装到了变量 program 中。链接完程序之后，就可以通过 gl.useProgram() 方法通知 WebGL 使用这个程序了。 1gl.useProgram(program); 调用 gl.useProgram() 方法后，所有后续的绘图操作都将使用这个程序。 为着色器传入值前面定义的着色器都必须接收一个值才能工作。为了给着色器传入这个值，必须先找到要接收这个值的变量。对于 Uniform变量，可以使用 gl.getUniformLocation() ，这个方法返回一个对象，表示 Uniform变量在内存中的位置。然后可以基于变量的位置来赋值。例如： 12var uColor = gl.getUniformLocation(program, "uColor");gl.uniform4fv(uColor, [0, 0, 0, 1]); 第一行代码从 program 中找到 Uniform变量 uColor ，返回了它在内存中的位置。第二行代码使用 gl.uniform4fv() 给 uColor 赋值。 对于顶点着色器中的 Attribute 变量，也是差不多的赋值过程。要找到 Attribute 变量在内存中的位置，可以调用 gl.getAttribLocation() 。取得了位置之后，就可以像下面这样赋值了： 123var aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");gl.enableVertexAttribArray(aVertexPosition);gl.vertexAttribPointer(aVertexPosition, itemSize, gl.FLOAT, false, 0, 0); 在此，我们取得了 aVertexPosition 的位置，然后又通过gl.enableVertexAttribArray() 启用它。最后一行创建了指针，指向由 gl.bindBuffer() 指定的缓冲区，并将其保存在 aVertexPosition 中，以便顶点着色器使用。 调试着色器和程序与 WebGL 中的其他操作一样，着色器操作也可能会失败，而且也是静默失败。如果你想知道着色器或程序执行中是否发生了错误，必须亲自询问 WebGL 上下文。 对于着色器，可以在操作之后调用 gl.getShaderParameter() ，取得着色器的编译状态 ： 123if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))&#123; alert(gl.getShaderInfoLog(vertexShader));&#125; 这个例子检测了 vertexShader 的编译状态。如果着色器编译成功，调用 gl.getShader-Parameter() 会返回 true 。如果返回的是 false ，说明编译期间发生了错误，此时调用 gl.getShaderInfoLog() 并传入相应的着色器就可以取得错误消息。错误消息就是一个表示问题所在的字符串。无论是顶点着色器，还是片段着色器，都可以使用 gl.getShaderParameter() 和 gl.getShaderInfoLog() 方法。 程序也可能会执行失败，因此也有类似的方法—— gl.getProgramParameter() ，可以用来检测执行状态。最常见的程序失败发生在链接过程中，要检测链接错误，可以使用下列代码。 123if (!gl.getProgramParameter(program, gl.LINK_STATUS))&#123; alert(gl.getProgramInfoLog(program));&#125; 与 gl.getShaderParameter() 类似， gl.getProgramParameter() 返回 true 表示链接成功，返回 false 表示链接失败。同样，也有一个 gl.getProgramInfoLog() 方法，用于捕获程序失败的消息。 以上介绍的这些方法主要在开发过程中用于调试。只要没有依赖外部代码，就可以放心地把它们从产品代码中删除。 绘图WebGL 只能绘制三种形状：点 、线 和 三角 。其他所有形状都是由这三种基本形状合成之后 ，再绘制到三维空间中的 。执行绘图操作要调用 gl.drawArrays() 或 gl.drawElements() 方法，前者用于数组缓冲区 ，后者用于元素数组缓冲区 。 gl.drawArrays() 或 gl.drawElements() 的第一个参数都是一个常量，表示 要绘制的形状 。可取值的常量范围包括以下这些。 gl.POINTS ：将每个顶点当成一个点来绘制。 gl.LINES ：将数组当成一系列顶点，在这些顶点间画线。每个顶点既是起点也是终点，因此数组中必须包含偶数个顶点才能完成绘制。 gl.LINE_LOOP ：将数组当成一系列顶点，在这些顶点间画线。线条从第一个顶点到第二个顶点，再从第二个顶点到第三个顶点，依此类推，直至最后一个顶点。然后再从最后一个顶点到第一个顶点画一条线。结果就是一个形状的轮廓。 gl.LINE_STRIP ：除了不画最后一个顶点与第一个顶点之间的线之外，其他与 gl.LINE_LOOP相同。 gl.TRIANGLES ：将数组当成一系列顶点，在这些顶点间绘制三角形。除非明确指定，每个三角形都单独绘制，不与其他三角形共享顶点。 gl.TRIANGLES_STRIP ：除了将前三个顶点之后的顶点当作第三个顶点与前两个顶点共同构成一个新三角形外，其他都与 gl.TRIANGLES 相同。例如，如果数组中包含 A、B、C、D 四个顶点，则第一个三角形连接 ABC，而第二个三角形连接 BCD。 gl. TRIANGLES_FAN ：除了将前三个顶点之后的顶点当作第三个顶点与前一个顶点及第一个顶点共同构成一个新三角形外，其他都与 gl.TRIANGLES 相同。例如，如果数组中包含 A、B、C、D 四个顶点，则第一个三角形连接 ABC，而第二个三角形连接 ACD。 gl.drawArrays() 方法 接收上面列出的常量中的一个作为第一个参数，接收 数组缓冲区中的起始索引 作为第二个参数，接收数组缓冲区中包含的顶点数（点的集合数）作为第三个参数。下面的代码 使用 gl.drawArrays() 在画布上绘制了一个三角形 。 123456789101112131415161718192021222324//假设已经使用本节前面定义的着色器清除了视口//定义三个顶点以及每个顶点的 x 和 y 坐标var vertices = new Float32Array([ 0, 1, 1, -1, -1, -1 ]), buffer = gl.createBuffer(), vertexSetSize = 2, vertexSetCount = vertices.length/vertexSetSize, uColor, aVertexPosition;//把数据放到缓冲区gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);//为片段着色器传入颜色值uColor = gl.getUniformLocation(program, "uColor");gl.uniform4fv(uColor, [ 0, 0, 0, 1 ]);//为着色器传入顶点信息aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");gl.enableVertexAttribArray(aVertexPosition);gl.vertexAttribPointer(aVertexPosition, vertexSetSize, gl.FLOAT, false, 0, 0);//绘制三角形gl.drawArrays(gl.TRIANGLES, 0, vertexSetCount); 这个例子定义了一个 Float32Array ，包含三组顶点（每个顶点由两点表示）。这里关键是要知道顶点的大小及数量，以便将来计算时使用。把 vertexSetSize 设置为 2 之后，就可以计算出 vertexSetCount 的值。把顶点的信息保存在缓冲区中后，又把颜色信息传给了片段着色器。 接下来，给顶点着色器传入顶点大小以及 gl.FLOAT ，后者表示顶点坐标是浮点数。传入的第四个参数是一个布尔值， false 在此表示坐标不是标准化的。第五个参数是步长值（stride value），表示取得下一个值的时候，要跳过多少个数组元素。除非你真需要跳过数组元素，否则传入 0 即可。最后一个参数是起点偏移量，值为 0 表示从第一个元素开始。 最后一步就是使用 gl.drawArrays() 绘制三角形。传入 gl.TRIANGLES 作为第一个参数，表示在(0,1)、(1,-1)和(-1,-1)点之间绘制三角形，并使用传给片段着色器的颜色来填充它。第二个参数是缓冲区中的起点偏移量，最后一个参数是要读取的顶点总数。这次绘图操作的结果如图 15-17 所示。 通过修改 gl.drawArrays() 的第一个参数，可以修改绘制三角形的方式。图 15-18 展示了传入不同的参数后可能得到的结果。 纹理WebGL 的纹理可以使用 DOM 中的图像 。要 创建一个新纹理 ，可以调用 gl.createTexture() ，然后再 将一幅图像绑定到该纹理 。如果图像尚未加载到内存中，可能需要创建一个 Image 对象的实例，以便动态加载图像 。图像加载完成之前，纹理不会初始化，因此，必须在 load 事件触发后才能设置纹理 。例如： 123456789101112131415var image = new Image(), texture;image.src = "smile.gif";image.onload = function()&#123; texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); //清除当前纹理 gl.bindTexture(gl.TEXTURE_2D, null);&#125; 除了使用 DOM 中的图像之外，以上步骤与在 OpenGL 中创建纹理的步骤相同。最大的差异是使用 gl.pixelStore1() 设置像素存储格式。 gl.UNPACK_FLIP_Y_WEBGL 是 WebGL 独有的常量，在加载 Web 中的图像时，多数情况下都必须使用这个常量。这主要是因为 GIF、JPEG 和 PNG 图像与 WebGL 使用的坐标系不一样，如果没有这个标志，解析图像时就会发生混乱。 用作纹理的图像必须与包含页面来自同一个域 ，或者 是保存在启用了 CORS（Cross-Origin Resource Sharing，跨域资源共享）的服务器上 。第 21 章将讨论 CORS。 图像、加载到 &lt;video&gt; 元素中的视频 ，甚至其他 &lt;canvas&gt; 元素都可以用作纹理 。跨域资源限制同样适用于视频 。 读取像素与 2D 上下文 类似，通过 WebGL 上下文也能读取像素值。读取像素值的方法 readPixels() 与 OpenGL 中的同名方法只有一点不同，即 最后一个参数必须是类型化数组 。像素信息是从帧缓冲区读取的，然后保存在类型化数组中。 readPixels() 方法的参数有：x 、y 、宽度 、高度 、图像格式 、数据类型 和 类型化数组 。前 4 个参数指定读取哪个区域中的像素。图像格式参数几乎总是 gl.RGBA 。数据类型参数用于指定保存在类型化数组中的数据的类型，但有以下限制。 如果类型是 gl.UNSIGNED_BYTE ，则类型化数组必须是 Uint8Array 。 如果类型是 gl.UNSIGNED_SHORT_5_6_5 、 gl.UNSIGNED_SHORT_4_4_4_4 或 gl.UNSIGNED_SHORT_5_5_5_1 ，则类型化数组必须是 Uint16Array 。 下面是一个简单的例子。 12var pixels = new Uint8Array(25*25);gl.readPixels(0, 0, 25, 25, gl.RGBA, gl.UNSIGNED_BYTE, pixels); 以上代码从帧缓冲区中读取了 25×25 像素的区域，将读取到的像素信息保存到了 pixels 数组中。其中，每个像素的颜色由 4 个数组元素表示，分别代表红、绿、蓝和透明度。每个数组元素的值介于 0 到 255 之间（包含 0 和 255）。不要忘了根据返回的数据大小初始化类型化数组。 在浏览器绘制更新的 WebGL 图像之前调用 readPixels() 不会有什么意外。绘制发生后，帧缓冲区会恢复其原始的干净状态，而调用 readPixels() 返回的像素数据反映的就是清除缓冲区后的状态。如果你想在绘制发生后读取像素数据 ，那在初始化 WebGL 上 下文时必须传入适当的 preserveDrawingBuffer 选项（前面讨论过）。 1var gl = drawing.getContext("experimental-webgl", &#123; preserveDrawingBuffer: true; &#125;); 设置这个标志的意思是让帧缓冲区在下一次绘制之前，保留其最后的状态。这个选项会导致性能损失，因此能不用最好不要用。 支持Firefox 4+和 Chrome 都实现了 WebGL API。Safari 5.1 也实现了 WebGL，但默认是禁用的。WebGL比较特别的地方在于，某个浏览器的某个版本实现了它，并不一定意味着就真能使用它。某个浏览器支持 WebGL，至少意味着两件事：首先，浏览器本身必须实现了 WebGL API ；其次，计算机必须升级显示驱动程序 。运行 Windows XP 等操作系统的一些老机器，其驱动程序一般都不是最新的。因此，这些计算机中的浏览器都会禁用 WebGL。从稳妥的角度考虑，在使用 WebGL 之前，最好检测其是否得到了支持，而不是只检测特定的浏览器版本 。 大家别忘了，WebGL 还是一个正在制定和发展中的规范。不管是函数名、函数签名，还是数据类型，都有可能改变。可以说，WebGL 目前只适合实验性地学习，不适合真正开发和应用。 小结HTML5 的 &lt;canvas&gt; 元素提供了一组 JavaScript API，让我们可以动态地创建图形和图像。图形是在一个特定的上下文中创建的，而上下文对象目前有两种。第一种是 2D上下文，可以执行原始的绘图操作 ，比如： 设置填充、描边颜色和模式 绘制矩形 绘制路径 绘制文本 创建渐变和模式 第二种是 3D 上下文，即 WebGL 上下文 。WebGL 是从 OpenGL ES 2.0 移植到浏览器中的，而 OpenGL ES 2.0 是游戏开发人员在创建计算机图形图像时经常使用的一种语言。WebGL 支持比 2D 上下文更丰富和更强大的图形图像处理能力 ，比如： 用 GLSL（OpenGL Shading Language，OpenGL 着色语言）编写的顶点和片段着色器 支持类型化数组，即能够将数组中的数据限定为某种特定的数值类型 创建和操作纹理 目前，主流浏览器的较新版本大都已经支持 &lt;canvas&gt; 标签 。同样地，这些版本的浏览器基本上也都支持 2D 上下文 。但 对于 WebGL 而言，目前还只有 Firefox 4+和 Chrome 支持它 。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-表单脚本]]></title>
    <url>%2F2018%2F08%2F27%2FJavaScript-form-script%2F</url>
    <content type="text"><![CDATA[表单脚本JavaScript 最初的一个应用，就是分担服务器处理表单的责任，打破处处依赖服务器的局面。尽管目前的 Web 和 JavaScript 已经有了长足的发展，但 Web 表单的变化并不明显。由于 Web 表单没有为许多常见任务提供现成的解决手段，很多开发人员不仅会在验证表单时使用 JavaScirpt，而且还增强了一些标准表单控件的默认行为。 表单的基础知识在 HTML 中 ，表单是由 &lt;form&gt; 元素来表示的 ，而 在 JavaScript 中 ，表单对应的则是 HTMLFormElement 类型 。 HTMLFormElement 继承了HTMLElement ，因而与其他 HTML 元素具有相同的默认属性 。不过， HTMLFormElement 也有它自己下列独有的属性和方法。 acceptCharset ：服务器能够处理的字符集；等价于 HTML 中的 accept-charset 特性。 action ：接受请求的 URL；等价于 HTML 中的 action 特性。 elements ：表单中所有控件的集合（ HTMLCollection ）。 enctype ：请求的编码类型；等价于 HTML 中的 enctype 特性。 length ：表单中控件的数量。 method ：要发送的 HTTP 请求类型，通常是 “get” 或 “post” ；等价于 HTML 的 method 特性。 name ：表单的名称；等价于 HTML 的 name 特性。 reset() ：将所有表单域重置为默认值。 submit() ：提交表单。 target ：用于发送请求和接收响应的窗口名称；等价于 HTML 的 target 特性。 取得 &lt;form&gt; 元素引用 的方式有好几种。其中 最常见的方式 就是 将它看成与其他元素一样 ，并为其添加 id 特性 ，然后再像下面这样使用 getElementById() 方法找到它 。 1var form = document.getElementById("form1"); 其次，通过 document.forms 可以取得页面中所有的表单 。在这个集合中，可以通过数值索引或 name 值来取得特定的表单 ，如下面的例子所示。 12var firstForm = document.forms[0]; //取得页面中的第一个表单var myForm = document.forms["form2"]; //取得页面中名称为"form2"的表单 另外，在较早的浏览器或者那些支持向后兼容的浏览器中，也会把每个设置了 name 特性的表单作为属性保存在 document 对象中。例如，通过 document.form2 可以访问到名为 “form2” 的表单 。不过，我们 不推荐使用这种方式 ：一是 容易出错 ，二是 将来的浏览器可能会不支持 。 注意，可以同时为表单指定 id 和 name 属性 ，但 它们的值不一定相同 。 提交表单用户单击提交按钮或图像按钮时，就会提交表单 。使用 &lt;input&gt; 或 &lt;button&gt; 都可以定义提交按钮 ，只要将其 type 特性的值设置为 “submit” 即可 ，而 图像按钮则是通过将 &lt;input&gt; 的 type 特性值设置为 “image” 来定义的 。因此，只要我们单击以下代码生成的按钮，就可以提交表单。 12345678&lt;!-- 通用提交按钮 --&gt;&lt;input type="submit" value="Submit Form"&gt;&lt;!-- 自定义提交按钮 --&gt;&lt;button type="submit"&gt;Submit Form&lt;/button&gt;&lt;!-- 图像按钮 --&gt;&lt;input type="image" src="graphic.gif"&gt; 只要表单中存在上面列出的任何一种按钮，那么在相应表单控件拥有焦点的情况下，按回车键就可以提交该表单。（ textarea 是一个例外，在文本区中回车会换行。）如果表单里没有提交按钮，按回车键不会提交表单 。 以这种方式提交表单时，浏览器会在将请求发送给服务器之前触发 submit 事件 。这样，我们就有机会验证表单数据，并据以决定是否允许表单提交 。阻止这个事件的默认行为就可以取消表单提交 。例如，下列代码会阻止表单提交。 123456789var form = document.getElementById("myForm");EventUtil.addHandler(form, "submit", function(event)&#123; //取得事件对象 event = EventUtil.getEvent(event); //阻止默认事件 EventUtil.preventDefault(event);&#125;); 这里使用了第 13 章定义的 EventUtil 对象，以便跨浏览器处理事件。调用 prevetnDefault() 方法阻止了表单提交 。一般来说，在表单数据无效而不能发送给服务器时，可以使用这一技术 。 在 JavaScript 中，以编程方式调用 submit() 方法也可以提交表单 。而且，这种方式无需表单包含提交按钮 ，任何时候都可以正常提交表单 。来看一个例子。 1234var form = document.getElementById("myForm");// 提交表单form.submit(); 在以调用 submit() 方法的形式提交表单时 ，不会触发 submit 事件 ，因此要记得在调用此方法之前先验证表单数据 。 提交表单时可能出现的最大问题，就是 重复提交表单 。在第一次提交表单后，如果长时间没有反应，用户可能会变得不耐烦。这时候，他们也许会反复单击提交按钮。结果往往很麻烦（因为服务器要处理重复的请求），或者会造成错误（如果用户是下订单，那么可能会多订好几份）。解决这一问题的办法有两个：在第一次提交表单后就禁用提交按钮 ，或者 利用 onsubmit 事件处理程序取消后续的表单提交操作 。 重置表单在用户单击重置按钮时，表单会被重置 。使用 type 特性值为 “reset” 的 &lt;input&gt; 或 &lt;button&gt; 都可以创建重置按钮 ，如下面的例子所示。 12345&lt;!-- 通用重置按钮 --&gt;&lt;input type="reset" value="Reset Form"&gt;&lt;!-- 自定义重置按钮 --&gt;&lt;button type="reset"&gt;Reset Form&lt;/button&gt; 这两个按钮都可以用来重置表单。在重置表单时，所有表单字段都会恢复到页面刚加载完毕时的初始值 。如果某个字段的初始值为空，就会恢复为空；而带有默认值的字段，也会恢复为默认值。 用户单击重置按钮重置表单时，会触发 reset 事件 。利用这个机会，我们可以在必要时取消重置操作 。例如，下面展示了阻止重置表单的代码。 123456789var form = document.getElementById("myForm");EventUtil.addHandler(form, "reset", function(event)&#123; //取得事件对象 event = EventUtil.getEvent(event); //阻止表单重置 EventUtil.preventDefault(event);&#125;); 与提交表单一样，也 可以通过 JavaScript 来重置表单 ，如下面的例子所示。 1234var form = document.getElementById("myForm");// 重置表单form.reset(); 与调用 submit() 方法不同，调用 reset() 方法会像单击重置按钮一样触发 reset 事件 。 在 Web 表单设计中，重置表单通常意味着对已经填写的数据不满意。重置表单经常会导致用户摸不着头脑，如果意外地触发了表单重置事件，那么用户甚至会很恼火。事实上，重置表单的需求是很少见的。更常见的做法是提供一个取消按钮 ，让用户能够回到前一个页面 ，而不是不分青红皂白地重置表单中的所有值 。 表单字段可以像访问页面中的其他元素一样，使用原生 DOM 方法访问表单元素 。此外，每个表单都有elements 属性 ，该属性是 表单中所有表单元素（字段）的集合 。这个elements 集合是一个有序列表 ，其中 包含着表单中的所有字段 ，例如 &lt;input&gt; 、 &lt;textarea&gt; 、 &lt;button&gt; 和 &lt;fieldset&gt; 。每个表单字段在 elements 集合中的顺序 ，与它们出现在标记中的顺序相同 ，可以按照位置和 name 特性来访问它们 。下面来看一个例子。 12345678910var form = document.getElementById("form1");//取得表单中的第一个字段var field1 = form.elements[0];//取得名为"textbox1"的字段var field2 = form.elements["textbox1"];//取得表单中包含的字段的数量var fieldCount = form.elements.length; 如果有多个表单控件都在使用一个 name （如单选按钮），那么就会返回以该 name 命名的一个 NodeList 。例如，以下面的 HTML 代码片段为例。 1234567&lt;form method="post" id="myForm"&gt;&lt;ul&gt;&lt;li&gt;&lt;input type="radio" name="color" value="red"&gt;Red&lt;/li&gt;&lt;li&gt;&lt;input type="radio" name="color" value="green"&gt;Green&lt;/li&gt;&lt;li&gt;&lt;input type="radio" name="color" value="blue"&gt;Blue&lt;/li&gt;&lt;/ul&gt;&lt;/form&gt; 在这个 HTML 表单中，有 3 个单选按钮，它们的 name 都是 “color” ，意味着这 3 个字段是一起的。在访问 elements[“color”] 时，就会返回一个 NodeList ，其中 包含这 3 个元素 ；不过，如果访问 elements[0] ，则只会返回第一个元素。来看下面的例子。 12345678var form = document.getElementById("myForm");var colorFields = form.elements["color"];alert(colorFields.length); //3var firstColorField = colorFields[0];var firstFormField = form.elements[0];alert(firstColorField === firstFormField); //true 以上代码显示，通过 form.elements[0] 访问到的第一个表单字段，与包含在 form.elements[“color”] 中的第一个元素相同。 也可以通过访问表单的属性来访问元素，例如 form[0] 可以取得第一个表单字段，而 form[“color”] 则可以取得第一个命名字段。这些属性与通过 elements 集合访问到的元素是相同的。但是，我们应该尽可能使用 elements ，通过表单属性访问元素只是为了与旧浏览器向后兼容而保留的一种过渡方式。 共有的表单字段属性除了 &lt;fieldset&gt; 元素之外，所有表单字段都拥有相同的一组属性 。由于 &lt;input&gt; 类型可以表示多种表单字段 ，因此 有些属性只适用于某些字段 ，但 还有一些属性是所有字段所共有的 。表单字段共有的属性如下。 disabled ：布尔值，表示当前字段是否被禁用。 form ：指向当前字段所属表单的指针；只读。 name ：当前字段的名称。 readOnly ：布尔值，表示当前字段是否只读。 tabIndex ：表示当前字段的切换（tab）序号。 type ：当前字段的类型，如 “checkbox” 、 “radio” ，等等。 value ：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件在计算机中的路径。 除了 form 属性之外，可以通过 JavaScript 动态修改其他任何属性 。来看下面的例子： 1234567891011121314151617var form = document.getElementById("myForm");var field = form.elements[0];//修改 value 属性field.value = "Another value";//检查 form 属性的值alert(field.form === form); //true//把焦点设置到当前字段field.focus();//禁用当前字段field.disabled = true;//修改 type 属性（不推荐，但对&lt;input&gt;来说是可行的）field.type = "checkbox"; 能够动态修改表单字段属性 ，意味着 我们可以在任何时候 ，以任何方式来动态操作表单 。例如，很多用户可能会重复单击表单的提交按钮。在涉及信用卡消费时，这就是个问题：因为会导致费用翻番。为此，最常见的解决方案，就是在第一次单击后就禁用提交按钮。只要侦听 submit 事件，并在该事件发生时禁用提交按钮即可。以下就是这样一个例子。 1234567891011//避免多次提交表单EventUtil.addHandler(form, "submit", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); //取得提交按钮 var btn = target.elements["submit-btn"]; //禁用它 btn.disabled = true;&#125;); 以上代码为表单的 submit 事件添加了一个事件处理程序 。事件触发后，代码取得了提交按钮并将其 disabled 属性设置为 true 。注意，不能通过 onclick 事件处理程序来实现这个功能，原因是不同浏览器之间存在“时差”：有的浏览器会在触发表单的 submit 事件之前触发 click 事件，而有的浏览器则相反。对于先触发 click 事件的浏览器，意味着会在提交发生之前禁用按钮，结果永远都不会提交表单。因此，最好是通过 submit 事件来禁用提交按钮。不过，这种方式不适合表单中不包含提交按钮的情况；如前所述，只有在包含提交按钮的情况下，才有可能触发表单的 submit 事件。 除了 &lt;fieldset&gt; 之外 ，所有表单字段都有 type 属性 。对于 &lt;input&gt; 元素 ，这个值等于 HTML 特性 type 的值 。对于其他元素，这个 type 属性的值如下表所列。 此外， &lt;input&gt; 和 &lt;button&gt; 元素的 type 属性是可以动态修改的 ，而 &lt;select&gt; 元素的 type 属性则是只读的 。 共有的表单字段方法每个表单字段都有两个方法： focus() 和 blur() 。其中， focus() 方法 用于 将浏览器的焦点设置到表单字段 ，即 激活表单字段 ，使其可以响应键盘事件 。例如，接收到焦点的文本框会显示插入符号，随时可以接收输入。使用 focus() 方法 ，可以将用户的注意力吸引到页面中的某个部位 。例如，在页面加载完毕后，将焦点转移到表单中的第一个字段。为此，可以侦听页面的 load 事件 ，并在该事件发生时在表单的第一个字段上调用 focus() 方法 ，如下面的例子所示。 123EventUtil.addHandler(window, "load", function(event)&#123; document.forms[0].elements[0].focus();&#125;); 要注意的是，如果 第一个表单字段是一个 &lt;input&gt; 元素 ，且其 type 特性的值为 “hidden” ，那么 以上代码会导致错误 。另外，如果使用 CSS 的 display 和 visibility 属性隐藏了该字段 ，同样也会导致错误 。 HTML5 为表单字段 新增了一个 autofocus 属性 。在支持这个属性的浏览器中，只要设置这个属性 ，不用 JavaScript 就能自动把焦点移动到相应字段 。例如： 1&lt;input type="text" autofocus&gt; 为了保证前面的代码在设置 autofocus 的浏览器中正常运行 ，必须 先检测是否设置了该属性 ，如果 设置了 ，就 不用再调用 focus()了 。 123456EventUtil.addHandler(window, "load", function(event)&#123; var element = document.forms[0].elements[0]; if (element.autofocus !== true)&#123; element.focus(); console.log("JS focus"); &#125;&#125;); 因为 autofocus 是一个布尔值属性 ，所以 在支持的浏览器中它的值应该是 true 。（在不支持的浏览器中，它的值将是空字符串。）为此，上面的代码只有在 autofocus 不等于 true 的情况下才会调用 focus() ，从而保证向前兼容 。支持 autofocus 属性的浏览器有 Firefox 4+、Safari 5+、Chrome 和 Opera 9.6。 在默认情况下，只有表单字段可以获得焦点 。对于其他元素而言，如果先将其 tabIndex 属性设置为 -1 ，然后 再调用 focus() 方法 ，也可以让这些元素获得焦点 。只有 Opera 不支持这种技术。 与 focus() 方法相对的是 blur() 方法 ，它的作用是 从元素中移走焦点 。在调用 blur() 方法时，并不会把焦点转移到某个特定的元素上 ；仅仅是将焦点从调用这个方法的元素上面移走而已 。在早期 Web 开发中，那时候的表单字段还没有 readonly 特性，因此就可以使用 blur() 方法来创建只读字段。 现在，虽然需要使用 blur() 的场合不多了，但必要时还可以使用的。用法如下： 1document.forms[0].elements[0].blur(); 共有的表单字段事件 除了支持鼠标、键盘、更改和 HTML 事件之外，所有表单字段都支持下列 3 个事件 。 blur ：当前字段失去焦点时触发。 change ：对于 &lt;input&gt; 和 &lt;textarea&gt; 元素，在它们失去焦点且 value 值改变时触发；对于 &lt;select&gt; 元素，在其选项改变时触发。 focus ：当前字段获得焦点时触发。 当用户改变了当前字段的焦点 ，或者 我们调用了 blur() 或 focus() 方法 时，都可以触发 blur 和 focus 事件 。这两个事件在所有表单字段中都是相同的 。但是，change 事件在不同表单控件中触发的次数会有所不同 。对于 &lt;input&gt; 和 &lt;textarea&gt; 元素 ，当它们从获得焦点到失去焦点且 value 值改变时 ，才会 触发 change 事件 。对于 &lt;select&gt; 元素 ，只要 用户选择了不同的选项 ，就会触发 change 事件 ；换句话说，不失去焦点也会触发 change 事件 。 通常，可以使用 focus 和 blur 事件来以某种方式改变用户界面 ，要么是 向用户给出视觉提示 ，要么是 向界面中添加额外的功能 （例如，为文本框显示一个下拉选项菜单）。而 change 事件则经常用于验证用户在字段中输入的数据 。例如，假设有一个文本框，我们只允许用户输入数值。此时，可以利用 focus 事件修改文本框的背景颜色 ，以便更清楚地表明这个字段获得了焦点 。可以利用 blur 事件恢复文本框的背景颜色 ，利用 change 事件在用户输入了非数值字符时再次修改背景颜色 。下面就给出了实现上述功能的代码。 12345678910111213141516171819202122232425262728var textbox = document.forms[0].elements[0];EventUtil.addHandler(textbox, "focus", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.style.backgroundColor != "red")&#123; target.style.backgroundColor = "yellow"; &#125;&#125;);EventUtil.addHandler(textbox, "blur", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (/[^\d]/.test(target.value))&#123; target.style.backgroundColor = "red"; &#125; else &#123; target.style.backgroundColor = ""; &#125;&#125;);EventUtil.addHandler(textbox, "change", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (/[^\d]/.test(target.value))&#123; target.style.backgroundColor = "red"; &#125; else &#123; target.style.backgroundColor = ""; &#125;&#125;); 在此， onfocus 事件处理程序将文本框的背景颜色修改为黄色，以清楚地表明当前字段已经激活 。随后，onblur 和 onchange 事件处理程序则会在发现非数值字符时，将文本框背景颜色修改为红色 。为了测试用户输入的是不是非数值，这里针对文本框的 value 属性使用了简单的正则表达式。而且，为确保无论文本框的值如何变化，验证规则始终如一， onblur 和 onchange 事件处理程序中使用了相同的正则表达式。 关于 blur 和 change 事件的关系，并没有严格的规定。在某些浏览器中， blur 事件会先于 change 事件发生；而在其他浏览器中，则恰好相反。为此，不能假定这两个事件总会以某种顺序依次触发 ，这一点要特别注意。 文本框脚本在 HTML 中，有两种方式来表现文本框：一种是 使用 &lt;input&gt; 元素的单行文本框 ，另一种是 使用 &lt;textarea&gt; 的多行文本框 。这两个控件非常相似，而且多数时候的行为也差不多。不过，它们之间仍然存在一些重要的区别。 要表现文本框，必须将 &lt;input&gt; 元素的 type 特性设置为 “text” 。而通过 设置 size 特性 ，可以 指定文本框中能够显示的字符数 。通过 value 特性 ，可以 设置文本框的初始值 ，而 maxlength 特性 则用于 指定文本框可以接受的最大字符数 。如果要创建一个文本框，让它能够显示 25 个字符，但输入不能超过 50 个字符，可以使用以下代码： 1&lt;input type="text" size="25" maxlength="50" value="initial value"&gt; 相对而言，&lt;textarea&gt; 元素则始终会呈现为一个多行文本框 。要指定文本框的大小，可以使用 rows 和 cols 特性 。其中， rows 特性 指定的是 文本框的字符行数 ，而 cols 特性 指定的是 文本框的字符列数（类似于 &lt;input&gt; 元素的 size 特性）。与 &lt;input&gt; 元素不同， &lt;textarea&gt; 的初始值必须要放在 &lt;textarea&gt; 和 &lt;/textarea&gt; 之间 ，如下面的例子所示。 1&lt;textarea rows="25" cols="5"&gt;initial value&lt;/textarea&gt; 另一个与 &lt;input&gt; 的区别在于，不能在 HTML 中给 &lt;textarea&gt; 指定最大字符数 。 无论这两种文本框在标记中有什么区别，但 它们都会将用户输入的内容保存在 value 属性中 。可以通过这个属性读取和设置文本框的值 ，如下面的例子所示： 1234var textbox = document.forms[0].elements["textbox1"];alert(textbox.value);textbox.value = "Some new value"; 我们建议读者 像上面这样使用 value 属性读取或设置文本框的值 ，不建议使用标准的 DOM 方法 。换句话说，不要使用 setAttribute() 设置 &lt;input&gt; 元素的 value 特性 ，也 不要去修改 &lt;textarea&gt; 元素的第一个子节点 。原因很简单：对 value 属性所作的修改 ，不一定会反映在 DOM中 。因此，在处理文本框的值时，最好不要使用 DOM 方法。 选择文本上述两种文本框都支持 select() 方法 ，这个方法用于 选择文本框中的所有文本 。在调用 select() 方法时，大多数浏览器（Opera 除外）都会将焦点设置到文本框中。这个方法不接受参数，可以在任何时候被调用。下面来看一个例子。 12var textbox = document.forms[0].elements["textbox1"];textbox.select(); 在文本框获得焦点时选择其所有文本 ，这是一种非常常见的做法，特别是在文本框包含默认值的时候。因为这样做可以让用户不必一个一个地删除文本。下面展示了实现这一操作的代码。 123456EventUtil.addHandler(textbox, "focus", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.select();&#125;); 将上面的代码应用到文本框之后，只要文本框获得焦点 ，就会选择其中所有的文本 。这种技术能够较大幅度地提升表单的易用性。 选择（ select ）事件与 select() 方法对应的，是一个 select 事件 。在选择了文本框中的文本时，就会触发 select 事件 。不过，到底什么时候触发 select 事件，还会因浏览器而异。在 IE9+、Opera、Firefox、Chrome 和 Safari 中，只有用户选择了文本（而且要释放鼠标），才会触发 select 事件。而在 IE8 及更早版本中，只要用户选择了一个字母（不必释放鼠标），就会触发 select 事件。另外，在调用 select() 方法时也会触发 select 事件 。下面是一个简单的例子。 1234var textbox = document.forms[0].elements["textbox1"];EventUtil.addHandler(textbox, "select", function(event)&#123; var alert("Text selected" + textbox.value);&#125;); 取得选择的文本虽然通过 select 事件我们可以知道用户什么时候选择了文本，但仍然不知道用户选择了什么文本。HTML5 通过一些扩展方案解决了这个问题，以便更顺利地取得选择的文本。该规范采取的办法是添加两个属性： selectionStart 和 selectionEnd 。这两个属性中保存的是基于 0 的数值 ，表示所选择文本的范围 （即文本选区开头和结尾的偏移量）。因此，要 取得用户在文本框中选择的文本 ，可以使用如下代码。 123function getSelectedText(textbox)&#123; return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd);&#125; 因为 substring() 方法基于字符串的偏移量执行操作 ，所以 将 selectionStart 和 selectionEnd 直接传给它就可以取得选中的文本 。 IE9+、Firefox、Safari、Chrome 和 Opera 都支持这两个属性。IE8 及之前版本不支持这两个属性，而是提供了另一种方案。 IE8 及更早的版本中有一个 document.selection 对象 ，其中 保存着用户在整个文档范围内选择的文本信息 ；也就是说，无法确定用户选择的是页面中哪个部位的文本。不过，在与 select 事件一起使用的时候，可以假定是用户选择了文本框中的文本，因而触发了该事件。要取得选择的文本 ，首先必须 创建一个范围 （第 12 章讨论过），然后再 将文本从其中提取出来 ，如下面的例子所示。 1234567function getSelectedText(textbox)&#123; if (typeof textbox.selectionStart == "number")&#123; return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd); &#125; else if (document.selection)&#123; return document.selection.createRange().text; &#125;&#125; 这里修改了前面的函数，包括了在 IE 中取得选择文本的代码。注意，调用 document.selection 时，不需要考虑 textbox 参数。 选择部分文本HTML5 也为选择文本框中的部分文本提供了解决方案 ， 即最早由 Firefox 引入的setSelectionRange() 方法 。现在除 select() 方法之外，所有文本框都有一个 setSelectionRange() 方法。这个方法接收两个参数：要选择的第一个字符的索引 和 要选择的最后一个字符之后的字符的索引 （类似于 substring() 方法的两个参数）。来看一个例子。 12345678910textbox.value = "Hello world!"//选择所有文本textbox.setSelectionRange(0, textbox.value.length); //"Hello world!"//选择前 3 个字符textbox.setSelectionRange(0, 3); //"Hel"//选择第 4 到第 6 个字符textbox.setSelectionRange(4, 7); //"o w" 要看到选择的文本，必须在调用 setSelectionRange() 之前或之后立即将焦点设置到文本框。IE9、Firefox、Safari、Chrome和 Opera 支持这种方案。 IE8 及更早版本支持使用范围（第 12 章讨论过）选择部分文本。要选择文本框中的部分文本，必须首先使用 IE 在所有文本框上提供的 createTextRange() 方法创建一个范围 ，并 将其放在恰当的位置上 。然后，再 使用 moveStart() 和 moveEnd() 这两个范围方法将范围移动到位 。不过，在调用这两个方法以前，还 必须使用 collapse() 将范围折叠到文本框的开始位置 。此时， moveStart() 将范围的起点和终点移动到了相同的位置 ，只要再给 moveEnd() 传入要选择的字符总数即可 。最后一步，就是 使用范围的 select() 方法选择文本 ，如下面的例子所示。 123456789101112131415161718192021textbox.value = "Hello world!";var range = textbox.createTextRange();//选择所有文本range.collapse(true);range.moveStart("character", 0);range.moveEnd("character", textbox.value.length); //"Hello world!"range.select();//选择前 3 个字符range.collapse(true);range.moveStart("character", 0);range.moveEnd("character", 3);range.select(); //"Hel"//选择第 4 到第 6 个字符range.collapse(true);range.moveStart("character", 4);range.moveEnd("character", 3);range.select(); //"o w" 与在其他浏览器中一样，要想在文本框中看到文本被选择的效果，必须让文本框获得焦点 。 为了 实现跨浏览器编程 ，可以将上述两种方案组合起来，如下面的例子所示。 123456789101112function selectText(textbox, startIndex, stopIndex)&#123; if (textbox.setSelectionRange)&#123; textbox.setSelectionRange(startIndex, stopIndex); &#125; else if (textbox.createTextRange)&#123; var range = textbox.createTextRange(); range.collapse(true); range.moveStart("character", startIndex); range.moveEnd("character", stopIndex - startIndex); range.select(); &#125; textbox.focus();&#125; 这个 selectText() 函数 接收三个参数：要操作的文本框 、要选择文本中第一个字符的索引 和 要选择文本中最后一个字符之后的索引 。首先，函数测试了文本框是否包含 setSelectionRange() 方法。 如果有，则使用该方法。否则，检测文本框是否支持 createTextRange() 方法。如果支持，则通过创建范围来实现选择。最后一步，就是为文本框设置焦点，以便用户看到文本框中选择的文本。可以像下面这样使用 selectText() 方法。 12345678910textbox.value = "Hello world!"//选择所有文本selectText(textbox, 0, textbox.value.length); //"Hello world!"//选择前 3 个字符selectText(textbox, 0, 3); //"Hel"//选择第 4 到第 6 个字符selectText(textbox, 4, 7); //"o w" 选择部分文本的技术在实现高级文本输入框时很有用 ，例如提供自动完成建议的文本框就可以使用这种技术。 过滤输入我们经常会要求用户在文本框中输入特定的数据 ，或者输入特定格式的数据 。例如，必须包含某些字符，或者必须匹配某种模式。由于文本框在默认情况下没有提供多少验证数据的手段 ，因此必须使用 JavaScript 来完成此类过滤输入的操作 。而综合运用事件和 DOM 手段，就可以 将普通的文本框转换成能够理解用户输入数据的功能型控件 。 屏蔽字符有时候，我们需要用户 输入的文本中包含或不包含某些字符 。例如，电话号码中不能包含非数值字符。如前所述，响应向文本框中插入字符操作的是 keypress 事件 。因此，可以通过阻止这个事件的默认行为来屏蔽此类字符。在极端的情况下，可以通过下列代码 屏蔽所有按键操作 。 1234EventUtil.addHandler(textbox, "keypress", function(event)&#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event);&#125;); 运行以上代码后，由于所有按键操作都将被屏蔽，结果会导致文本框变成只读的。如果 只想屏蔽特定的字符 ，则 需要检测 keypress 事件对应的字符编码 ，然后 再决定如何响应 。例如，下列代码只允许用户输入数值。 123456789EventUtil.addHandler(textbox, "keypress", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\d/.test(String.fromCharCode(charCode)))&#123; EventUtil.preventDefault(event); &#125;&#125;); 在这个例子中，我们 使用 EventUtil.getCharCode() 实现了跨浏览器取得字符编码 。然后，使用 String.fromCharCode() 将字符编码转换成字符串 ，再 使用正则表达式 /\d/ 来测试该字符串 ，从而 确定用户输入的是不是数值 。如果测试失败，那么就使用 EventUtil.preventDefault() 屏蔽按键事件 。结果，文本框就会忽略所有输入的非数值。 虽然理论上只应该在用户按下字符键时才触发 keypress 事件，但有些浏览器也会对其他键触发此事件。Firefox 和 Safari（3.1 版本以前）会对向上键、向下键、退格键和删除键触发 keypress 事件；Safari 3.1 及更新版本则不会对这些键触发 keypress 事件。这意味着，仅考虑到屏蔽不是数值的字符还不够 ，还要避免屏蔽这些极为常用和必要的键 。所幸的是，要检测这些键并不困难。在 Firefox 中，所有由非字符键触发的 keypress 事件对应的字符编码为 0，而在 Safari 3 以前的版本中，对应的字符编码全部为 8。为了让代码更通用，只要不屏蔽那些字符编码小于 10 的键即可 。故而，可以将上面的函数重写成如下所示。 123456789EventUtil.addHandler(textbox, "keypress", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9)&#123; EventUtil.preventDefault(event); &#125;&#125;); 这样，我们的事件处理程序就可以适用所有浏览器了，即可以屏蔽非数值字符 ，但不屏蔽那些也会触发 keypress 事件的基本按键 。 除此之外，还有一个问题需要处理：复制 、粘贴 及 v其他操作还要用到 Ctrl 键 。在除 IE 之外的所有浏览器中，前面的代码也会屏蔽 Ctrl+C、Ctrl+V，以及其他使用 Ctrl 的组合键 。因此，最后还要添加一个检测条件 ，以确保用户没有按下 Ctrl 键** ，如下面的例子所示。 12345678910EventUtil.addHandler(textbox, "keypress", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9 &amp;&amp; !event.ctrlKey)&#123; EventUtil.preventDefault(event); &#125;&#125;); 经过最后一点修改，就可以确保文本框的行为完全正常了。在这个例子的基础上加以修改和调整，就 可以将同样的技术运用于放过和屏蔽任何输入文本框的字符 。 操作剪贴板IE 是第一个支持与剪贴板相关事件，以及通过 JavaScript 访问剪贴板数据的浏览器。IE 的实现成为了事实上的标准，不仅 Safari 2、Chrome 和 Firefox 3 也都支持类似的事件和剪贴板访问（Opera 不支持通过 JavaScript 访问剪贴板），HTML 5 后来也把剪贴板事件纳入了规范 。下列就是 6 个剪贴板事件。 beforecopy ：在发生复制操作前触发。 copy ：在发生复制操作时触发。 beforecut ：在发生剪切操作前触发。 cut ：在发生剪切操作时触发。 beforepaste ：在发生粘贴操作前触发。 paste ：在发生粘贴操作时触发。 由于没有针对剪贴板操作的标准，这些事件及相关对象会因浏览器而异。在 Safari、Chrome 和 Firefox 中， beforecopy 、 beforecut 和 beforepaste 事件只会在显示针对文本框的上下文菜单（预期将发生剪贴板事件）的情况下触发。但是，IE 则会在触发 copy 、 cut 和 paste 事件之前先行触发这些事件。 至于 copy 、 cut 和 paste 事件 ，只要是在上下文菜单中选择了相应选项 ，或者 使用了相应的键盘组合键 ，所有浏览器都会触发它们 。 在实际的事件发生之前，通过 beforecopy 、 beforecut 和 beforepaste 事件可以在向剪贴板发送数据 ，或者 从剪贴板取得数据之前修改数据 。不过，取消这些事件并不会取消对剪贴板的操作 ——只有取消 copy 、 cut 和 paste 事件，才能阻止相应操作发生。 要访问剪贴板中的数据，可以使用 clipboardData 对象：在 IE 中，这个对象是 window 对象的属性；而在 Firefox 4+、Safari 和 Chrome 中，这个对象是相应 event 对象的属性。但是，在 Firefox、Safari 和 Chorme 中，只有在处理剪贴板事件期间 clipboardData 对象才有效，这是为了防止对剪贴板的未授权访问；在 IE 中，则可以随时访问 clipboardData 对象。为了确保跨浏览器兼容性，最好只在发生剪贴板事件期间使用这个对象。 这个 clipboardData 对象 有三个方法： getData() 、 setData() 和 clearData() 。其中， getData() 用于从剪贴板中取得数据 ，它接受一个参数，即 要取得的数据的格式 。在 IE中，有两种数据格式： “text”和 “URL” 。在 Firefox、Safari 和 Chrome 中，这个参数是一种 MIME 类型；不过，可以用 “text” 代表 “text/plain” 。 类似地， setData() 方法 的 第一个参数也是数据类型 ，第二个参数是 要放在剪贴板中的文本 。对于第一个参数，IE 照样支持 “text” 和 “URL” ，而 Safari 和 Chrome 仍然只支持 MIME 类型。但是，与 getData() 方法不同的是，Safari 和 Chrome的 setData() 方法不能识别 “text” 类型。这两个浏览器在成功将文本放到剪贴板中后，都会返回 true ；否则，返回 false 。为了弥合这些差异，我们可以向 EventUtil 中再添加下列方法。 123456789101112131415161718192021var EventUtil = &#123; //省略的代码 getClipboardText: function(event)&#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData("text"); &#125;, //省略的代码 setClipboardText: function(event, value)&#123; if (event.clipboardData)&#123; return event.clipboardData.setData("text/plain", value); &#125; else if (window.clipboardData)&#123; return window.clipboardData.setData("text", value); &#125; &#125;, //省略的代码&#125;; 这里的 getClipboardText() 方法 相对简单；它只要 确定 clipboardData 对象的位置 ，然后再 以 “text” 类型调用 getData() 方法 即可。相应地， setClipboardText() 方法 则要稍微复杂一些。在 取得 clipboardData 对象 之后，需要 根据不同的浏览器实现为 setData() 传入不同的类型 （对于 Safari 和 Chrome，是 “text/plain” ；对于 IE，是 “text” ）。 在需要确保粘贴到文本框中的文本中包含某些字符 ， 或者符合某种格式要求时 ，能够访问剪贴板是非常有用的 。例如，如果一个文本框只接受数值，那么就必须检测粘贴过来的值，以确保有效。在 paste 事件 中，可以确定剪贴板中的值是否有效 ，如果无效 ，就可以像下面示例中那样，取消默认的行为 。 1234567EventUtil.addHandler(textbox, "paste", function(event)&#123; event = EventUtil.getEvent(event); var text = EventUtil.getClipboardText(event); if (!/^\d*$/.test(text))&#123; EventUtil.preventDefault(event); &#125;&#125;); 在这里， onpaste 事件处理程序可以确保只有数值才会被粘贴到文本框中。如果剪贴板的值与正则表达式不匹配，则会取消粘贴操作。Firefox、Safari 和 Chrome 只允许在 onpaste 事件处理程序中访问 getData() 方法。 由于并非所有浏览器都支持访问剪贴板，所以 更简单的做法是屏蔽一或多个剪贴板操作 。在支持 copy 、 cut 和 paste 事件的浏览器中（IE、Safari、Chrome 和 Firefox 3 及更高版本），很容易阻止这些事件的默认行为。在 Opera 中，则需要阻止那些会触发这些事件的按键操作，同时还要阻止在文本框中显示上下文菜单。 自动切换焦点使用 JavaScript 可以从多个方面增强表单字段的易用性。其中，最常见的一种方式就是在用户填写完当前字段时 ，自动将焦点切换到下一个字段 。通常，在自动切换焦点之前，必须知道用户已经输入了既定长度的数据（例如电话号码）。例如，美国的电话号码通常会分为三部分：区号、局号和另外 4 位数字。为取得完整的电话号码，很多网页中都会提供下列 3 个文本框： 123&lt;input type="text" name="tel1" id="txtTel1" maxlength="3"&gt;&lt;input type="text" name="tel2" id="txtTel2" maxlength="3"&gt;&lt;input type="text" name="tel3" id="txtTel3" maxlength="4"&gt; 为增强易用性 ，同时加快数据输入 ，可以在前一个文本框中的字符达到最大数量后 ，自动将焦点切换到下一个文本框 。换句话说，用户在第一个文本框中输入了 3 个数字之后，焦点就会切换到第二个文本框，再输入 3 个数字，焦点又会切换到第三个文本框。这种 “自动切换焦点”的功能 ，可以通过下列代码实现： 12345678910111213141516171819202122232425262728(function()&#123; function tabForward(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.value.length == target.maxLength)&#123; var form = target.form; for (var i=0, len=form.elements.length; i &lt; len; i++) &#123; if (form.elements[i] == target) &#123; if (form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125;&#125;var textbox1 = document.getElementById("txtTel1");var textbox2 = document.getElementById("txtTel2");var textbox3 = document.getElementById("txtTel3");EventUtil.addHandler(textbox1, "keyup", tabForward);EventUtil.addHandler(textbox2, "keyup", tabForward);EventUtil.addHandler(textbox3, "keyup", tabForward);&#125;)(); 开始的 tabForward() 函数 是实现“自动切换焦点”的关键所在。这个函数 通过比较用户输入的值与文本框的 maxlength 特性v，可以确定是否已经达到最大长度 。如果这两个值相等 （因为浏览器最终会强制它们相等，因此用户绝不会多输入字符），则需要查找表单字段集合 ，直至找到下一个文本框 。 找到下一个文本框之后，则将焦点切换到该文本框。然后，我们把这个函数指定为每个文本框的 onkeyup 事件处理程序。由于 keyup 事件会在用户输入了新字符之后触发，所以此时是检测文本框中内容长度的最佳时机。这样一来，用户在填写这个简单的表单时 ，就不必再通过按制表键切换表单字段和提交表单了 。 不过请记住，这些代码 只适用于前面给出的标记 ，而且没有考虑隐藏字段 。 HTML5 约束验证API为了在将表单提交到服务器之前验证数据，HTML5 新增了一些功能。有了这些功能，即便 JavaScript 被禁用或者由于种种原因未能加载 ，也可以确保基本的验证 。换句话说，浏览器自己会根据标记中的规则执行验证 ，然后自己显示适当的错误消息（完全不用 JavaScript 插手）。当然，这个功能只有在支持 HTML5 这部分内容的浏览器中才有效 ，这些浏览器有 Firefox 4+、Safari 5+、Chrome 和 Opera 10+。 只有在某些情况下表单字段才能进行自动验证 。具体来说，就是 要在 HTML 标记中为特定的字段指定一些约束 ，然后 浏览器才会自动执行表单验证。 必填字段第一种情况是在表单字段中指定了 required 属性 ，如下面的例子所示： 1&lt;input type="text" name="username" required&gt; 任何标注有 required 的字段，在提交表单时都不能空着。这个属性适用于 &lt;input&gt; 、 &lt;textarea&gt; 和 &lt;select&gt; 字段（Opera 11 及之前版本还不支持 &lt;select&gt; 的 required 属性）。在 JavaScript 中 ，通过对应的 required 属性，可以检查某个表单字段是否为必填字段 。 1var isUsernameRequired = document.forms[0].elements["username"].required; 另外，使用下面这行代码可以 测试浏览器是否支持 required 属性 。 1var isRequiredSupported = "required" in document.createElement("input"); 以上代码通过特性检测来确定新创建的 &lt;input&gt; 元素中是否存在 required 属性。 对于空着的必填字段，不同浏览器有不同的处理方式。Firefox 4 和 Opera 11 会阻止表单提交并在相应字段下方弹出帮助框，而 Safari（5 之前）和 Chrome（9 之前）则什么也不做，而且也不阻止表单提交。 其他输入类型HTML5 为 &lt;input&gt; 元素的 type 属性又增加了几个值 。这些新的类型不仅能反映数据类型的信息 ，而且 还能提供一些默认的验证功能 。其中， “email” 和 “url” 是两个得到支持最多的类型 ，各浏览器也都为它们增加了定制的验证机制 。例如： 12&lt;input type="email" name ="email"&gt;&lt;input type="url" name="homepage"&gt; 顾名思义， “email” 类型要求输入的文本必须符合电子邮件地址的模式 ，而 “url” 类型要求输入的文本必须符合 URL 的模式 。不过，本节前面提到的浏览器在恰当地匹配模式方面都存在问题。最明显的是 “-@-“ 会被当成一个有效的电子邮件地址。浏览器开发商还在解决这些问题。 要检测浏览器是否支持这些新类型 ，可以在 JavaScript 创建一个 &lt;input&gt; 元素 ，然后 将 type 属性设置为 “email” 或 “url” ，最后 再检测这个属性的值 。不支持它们的旧版本浏览器 会 自动将未知的值设置为 “text” ，而 支持的浏览器 则会 返回正确的值 。例如： 1234var input = document.createElement("input");input.type = "email";var isEmailSupported = (input.type == "email"); 要注意的是，如果不给 &lt;input&gt; 元素设置 required 属性，那么空文本框也会验证通过。另一方面，设置特定的输入类型并不能阻止用户输入无效的值 ，只是应用某些默认的验证而已 。 数值范围除了 “email” 和 “url” ，HTML5 还定义了另外几个输入元素 。这几个元素都要求填写某种基于数字的值： “number” 、 “range” 、 “datetime” 、 “datetime-local” 、 “date” 、 “month” 、 “week” ，还有 “time” 。浏览器对这几个类型的支持情况并不好 ，因此如果真想选用的话，要特别小心。目前，浏览器开发商主要关注更好的跨平台兼容性以及更多的逻辑功能。因此，本节介绍的内容某种程度上有些超前，不一定马上就能在实际开发中使用。 对所有这些数值类型的输入元素 ，可以指定 min 属性（最小的可能值）、 max 属性（最大的可能值）和 step 属性（从 min 到 max 的两个刻度间的差值）。例如，想让用户只能输入 0 到 100的值，而且这个值必须是 5 的倍数，可以这样写代码： 1&lt;input type="number" min="0" max="100" step="5" name="count"&gt; 在不同的浏览器中，可能会也可能不会看到能够自动递增和递减的数值调节按钮（向上和向下按钮）。 以上这些属性 在 JavaScript 中都能通过对应的元素访问（或修改）。此外，还有两个方法： stepUp() 和 stepDown() ，都接收一个可选的参数：要在当前值基础上加上或减去的数值 。（默认是加或减 1。）这两个方法还没有得到任何浏览器支持，但下面的例子演示了它们的用法。 1234input.stepUp(); //加 1input.stepUp(5); //加 5input.stepDown(); //减 1input.stepDown(10); //减 10 输入模式HTML5 为文本字段新增了 pattern 属性 。这个属性的值是一个正则表达式 ，用于 匹配文本框中的值 。例如，如果只想允许在文本字段中输入数值，可以像下面的代码一样应用约束： 1&lt;input type="text" pattern="\d+" name="count"&gt; 注意，模式的开头和末尾不用加^和$符号（假定已经有了）。这两个符号表示输入的值必须从头到尾都与模式匹配 。与其他输入类型相似，指定 pattern 也不能阻止用户输入无效的文本 。这个模式应用给值，浏览器来判断值是有效，还是无效 。在 JavaScript 中可以通过 pattern 属性访问模式 。 1var pattern = document.forms[0].elements["count"].pattern; 使用以下代码可以检测浏览器是否支持 pattern 属性。 1var isPatternSupported = "pattern" in document.createElement("input"); 检测有效性使用 checkValidity() 方法 可以 检测表单中的某个字段是否有效 。所有表单字段都有个方法 ，如果字段的值有效，这个方法返回 true ，否则返回 false 。字段的值是否有效的判断依据是本节前面介绍过的那些约束。换句话说，必填字段中如果没有值就是无效的 ，而 字段中的值与 pattern 属性不匹配也是无效的 。例如： 12345if (document.forms[0].elements[0].checkValidity())&#123; //字段有效，继续&#125; else &#123; //字段无效&#125; 要检测整个表单是否有效，可以在表单自身调用 checkValidity() 方法 。如果所有表单字段都有效 ，这个方法 返回 true ；即使有一个字段无效 ，这个方法也会 返回 false 。 12345if(document.forms[0].checkValidity())&#123; //表单有效，继续&#125; else &#123; //表单无效&#125; 与 checkValidity() 方法简单地告诉你字段是否有效 相比， validity 属性则会告诉你为什么字段有效或无效 。这个对象中包含一系列属性，每个属性会返回一个布尔值 。 customError ：如果设置了 setCustomValidity() ，则为 true ，否则返回 false 。 patternMismatch ：如果值与指定的 pattern 属性不匹配，返回 true 。 rangeOverflow ：如果值比 max 值大，返回 true 。 rangeUnderflow ：如果值比 min 值小，返回 true 。 stepMisMatch ：如果 min 和 max 之间的步长值不合理，返回 true 。 tooLong ：如果值的长度超过了 maxlength 属性指定的长度，返回 true 。有的浏览器（如Firefox 4）会自动约束字符数量，因此这个值可能永远都返回 false 。 typeMismatch ：如果值不是 “mail” 或 “url” 要求的格式，返回 true 。 valid ：如果这里的其他属性都是 false ，返回 true 。 checkValidity() 也要求相同的值。 valueMissing ：如果标注为 required 的字段中没有值，返回 true 。 因此，要想得到更具体的信息 ，就 应该使用 validity 属性来检测表单的有效性 。下面是一个例子。 123456789if (input.validity &amp;&amp; !input.validity.valid)&#123; if (input.validity.valueMissing)&#123; alert("Please specify a value.") &#125; else if (input.validity.typeMismatch)&#123; alert("Please enter an email address."); &#125; else &#123; alert("Value is invalid."); &#125;&#125; 禁用验证通过设置 novalidate 属性，可以告诉表单不进行验证 。 123&lt;form method="post" action="signup.php" novalidate&gt; &lt;!--这里插入表单元素--&gt;&lt;/form&gt; 在 JavaScript 中使用 noValidate 属性可以取得或设置这个值 ，如果这个属性存在 ，值为 true ，如果不存在 ，值为 false 。 1document.forms[0].noValidate = true; //禁用验证 如果一个表单中有多个提交按钮，为了指定点击某个提交按钮不必验证表单 ，可以在相应的按钮上添加 formnovalidate 属性 。 123456&lt;form method="post" action="foo.php"&gt; &lt;!--这里插入表单元素--&gt; &lt;input type="submit" value="Regular Submit"&gt; &lt;input type="submit" formnovalidate name="btnNoValidate" value="Non-validating Submit"&gt;&lt;/form&gt; 在这个例子中，点击第一个提交按钮会像往常一样验证表单，而点击第二个按钮则会不经过验证而提交表单。使用 JavaScript 也可以设置这个属性 。 12//禁用验证document.forms[0].elements["btnNoValidate"].formNoValidate = true; 选择框脚本选择框是通过 &lt;select&gt; 和 &lt;option&gt; 元素创建的 。为了方便与这个控件交互，除了所有表单字段共有的属性和方法外 ， HTMLSelectElement 类型还提供了下列属性和方法。 add(newOption, relOption) ：向控件中插入新 &lt;option&gt; 元素，其位置在相关项（ relOption ）之前。 multiple ：布尔值，表示是否允许多项选择；等价于 HTML 中的 multiple 特性。 options ：控件中所有 &lt;option&gt; 元素的 HTMLCollection 。 remove(index) ：移除给定位置的选项。 selectedIndex ：基于 0 的选中项的索引，如果没有选中项，则值为 -1 。对于支持多选的控件，只保存选中项中第一项的索引。 size ：选择框中可见的行数；等价于 HTML 中的 size 特性。选择框的 type 属性不是 “select-one” ，就是 “select-multiple” ，这取决于 HTML 代码中有没有 multiple 特性。选择框的 value 属性由当前选中项决定，相应规则如下。 如果没有选中的项，则选择框的 value 属性保存空字符串。 如果有一个选中项，而且该项的 value 特性已经在 HTML 中指定，则选择框的 value 属性等于选中项的 value 特性。即使 value 特性的值是空字符串，也同样遵循此条规则。 如果有一个选中项，但该项的 value 特性在 HTML 中未指定，则选择框的 value 属性等于该项的文本。 如果有多个选中项，则选择框的 value 属性将依据前两条规则取得第一个选中项的值。 以下面的选择框为例： 1234567&lt;select name="location" id="selLocation"&gt; &lt;option value="Sunnyvale, CA"&gt;Sunnyvale&lt;/option&gt; &lt;option value="Los Angeles, CA"&gt;Los Angeles&lt;/option&gt; &lt;option value="Mountain View, CA"&gt;Mountain View&lt;/option&gt; &lt;option value=""&gt;China&lt;/option&gt; &lt;option&gt;Australia&lt;/option&gt;&lt;/select&gt; 如果用户选择了其中第一项，则选择框的值就是 “Sunnyvale, CA” 。如果文本为 “China” 的选项被选中，则选择框的值就是一个空字符串，因为其 value 特性是空的。如果选择了最后一项，那么由于 &lt;option&gt; 中没有指定 value 特性，则选择框的值就是 “Australia” 。 在 DOM 中，每个 &lt;option&gt; 元素都有一个 HTMLOptionElement 对象表示。为便于访问数据，HTMLOptionElement 对象添加了下列属性： index ：当前选项在 options 集合中的索引。 label ：当前选项的标签；等价于 HTML 中的 label 特性。 selected ：布尔值，表示当前选项是否被选中。将这个属性设置为 true 可以选中当前选项。 text ：选项的文本。 value ：选项的值（等价于 HTML 中的 value 特性）。 其中大部分属性的目的，都是为了方便对选项数据的访问 。虽然也可以使用 常规的 DOM 功能来访问这些信息 ，但 效率是比较低的 ，如下面的例子所示： 12345var selectbox = document.forms[0].elements["location"];//不推荐var text = selectbox.options[0].firstChild.nodeValue; //选项的文本var value = selectbox.options[0].getAttribute("value"); //选项的值 以上代码使用标准 DOM 方法，取得了选择框中第一项的文本和值。可以与下面使用选项属性的代码作一比较： 12345var selectbox = document.forms[0]. elements["location"];// 推荐var text = selectbox.options[0].text; // 选项的文本var value = selectbox.options[0].value; // 选项的值 在操作选项时，我们建议 最好是使用特定于选项的属性 ，因为 所有浏览器都支持这些属性 。在将表单控件作为 DOM 节点的情况下，实际的交互方式则会因浏览器而异。我们不推荐使用标准 DOM 技术修改 &lt;option&gt; 元素的文本或者值。 最后，我们还想提醒读者注意一点：选择框的 change 事件与其他表单字段的 change 事件触发的条件不一样 。其他表单字段的 change 事件 是在 值被修改且焦点离开当前字段时触发 ，而 选择框的 change 事件 只要 选中了选项就会触发 。 不同浏览器下，选项的 value 属性返回什么值也存在差别。但是，在所有浏览器中， value 属性始终等于 value 特性。在未指定 value 特性的情况下，IE8会返回空字符串，而 IE9+、Safari、Firefox、Chrome 和 Opera 则会返回与 text 特性相同的值。 选择选项对于 只允许选择一项的选择框 ，访问选中项的最简单方式，就是 使用选择框的 selectedIndex 属性 ，如下面的例子所示： 1var selectedOption = selectbox.options[selectbox.selectedIndex]; 取得选中项之后，可以像下面这样显示该选项的信息： 123var selectedIndex = selectbox.selectedIndex;var selectedOption = selectbox.options[selectedIndex];alert("Selected index: " + selectedIndex + "\nSelected text: " + selectedOption.text + "\nSelected value: " + selectedOption.value); 这里，我们通过一个警告框显示了选中项的索引、文本和值。 对于可以选择多项的选择框， selectedfIndex 属性就好像只允许选择一项一样 。设置 selectedIndex 会导致取消以前的所有选项并选择指定的那一项，而读取 selectedIndex 则只会返回选中项中第一项的索引值。 另一种选择选项的方式，就是 取得对某一项的引用 ，然后 将其 selected 属性设置为 true 。例如，下面的代码会选中选择框中的第一项： 1selectbox.options[0].selected = true; 与 selectedIndex 不同，在允许多选的选择框中设置选项的 selected 属性，不会取消对其他选中项的选择，因而可以动态选中任意多个项。但是，如果是在单选选择框中，修改某个选项的 selected 属性则会取消对其他选项的选择。需要注意的是，将 selected 属性设置为 false 对单选选择框没有影响。 实际上，selected 属性的作用主要是确定用户选择了选择框中的哪一项 。要取得所有选中的项，可以循环遍历选项集合，然后测试每个选项的 selected 属性 。来看下面的例子。 12345678910111213function getSelectedOptions(selectbox)&#123; var result = new Array(); var option = null; for (var i=0, len=selectbox.options.length; i &lt; len; i++)&#123; option = selectbox.options[i]; if (option.selected)&#123; result.push(option); &#125; &#125; return result;&#125; 这个函数可以返回给定选择框中选中项的一个数组。首先，创建一个将包含选中项的数组，然后使用 for 循环迭代所有选项，同时检测每一项的 selected 属性。如果有选项被选中，则将其添加到 result 数组中。最后，返回包含选中项的数组。下面是一个 使用 getSelectedOptions() 函数取得选中项 的示例。 12345678var selectbox = document.getElementById("selLocation");var selectedOptions = getSelectedOptions(selectbox);var message = "";for (var i=0, len=selectedOptions.length; i &lt; len; i++)&#123; message += "Selected index: " + selectedOptions[i].index + "\nSelected text: " + selectedOptions[i].text + "\nSelected value: " + selectedOptions[i].value + "\n\n";&#125;alert(message); 在这个例子中，我们首先从一个选择框中取得了选中项。然后，使用 for 循环构建了一条消息，包含所有选中项的信息：每一项的索引、文本和值。这种技术适用于单选和多选选择框。 添加选项可以使用 JavaScript 动态创建选项，并将它们添加到选择框中 。添加选项的方式有很多，第一种方式就是使用如下所示的 DOM方法。 12345var newOption = document.createElement("option");newOption.appendChild(document.createTextNode("Option text"));newOption.setAttribute("value", "Option value");selectbox.appendChild(newOption); 以上代码创建了一个新的 &lt;option&gt; 元素，然后为它添加了一个文本节点，并设置其 value 特性，最后将它添加到了选择框中。添加到选择框之后，用户立即就可以看到新选项。 第二种方式是 使用 Option 构造函数来创建新选项 ，这个构造函数是 DOM 出现之前就有的，一直遗留到现在。 Option 构造函数 接受两个参数：文本（ text ）和 值（ value ）；第二个参数可选 。虽然这个构造函数会创建一个 Object 的实例，但兼容 DOM 的浏览器会返回一个 &lt;option&gt; 元素。换句话说，在这种情况下，我们仍然可以使用 appendChild() 将新选项添加到选择框中 。来看下面的例子。 12var newOption = new Option("Option text", "Option value");selectbox.appendChild(newOption); //在 IE8 及之前版本中有问题 这种方式在除 IE 之外的浏览器中都可以使用。由于存在 bug，IE 在这种方式下不能正确设置新选项的文本。 第三种添加新选项的方式是 使用选择框的 add() 方法 。DOM 规定这个方法接受两个参数：要添加的新选项 和 将位于新选项之后的选项 。如果想在列表的最后添加一个选项，应该将第二个参数设置为 null 。在 IE对 add() 方法的实现中，第二个参数是可选的，而且如果指定，该参数必须是新选项之后选项的索引。兼容 DOM 的浏览器要求必须指定第二个参数，因此要想编写跨浏览器的代码，就不能只传入一个参数。这时候，为第二个参数传入 undefined ，就可以在所有浏览器中都将新选项插入到列表最后了。来看一个例子。 12var newOption = new Option("Option text", "Option value");selectbox.add(newOption, undefined); //最佳方案 在 IE 和兼容 DOM 的浏览器中，上面的代码都可以正常使用。如果你想将新选项添加到其他位置（不是最后一个），就应该使用标准的 DOM 技术和 insertBefore() 方法 。 就和在 HTML 中一样，此时也不一定要为选项指定值。换句话说，只为 Option 构造函数传入一个参数（选项的文本）也没有问题。 移除选项与添加选项类似，移除选项的方式也有很多种。首先，可以使用 DOM 的 removeChild() 方法 ，为其传入要移除的选项 ，如下面的例子所示： 1selectbox.removeChild(selectbox.options[0]); //移除第一个选项 其次，可以使用选择框的 remove() 方法 。这个方法接受一个参数，即 要移除选项的索引 ，如下面的例子所示： 1selectbox.remove(0); //移除第一个选项 最后一种方式，就是将相应选项设置为 null 。这种方式也是 DOM 出现之前浏览器的遗留机制。例如： 1selectbox.options[0] = null; //移除第一个选项 要清除选择框中所有的项，需要迭代所有选项并逐个移除它们 ，如下面的例子所示： 12345function clearSelectbox(selectbox)&#123; for(var i=0, len=selectbox.options.length; i &lt; len; i++)&#123; selectbox.remove(i); &#125;&#125; 这个函数每次只移除选择框中的第一个选项。由于移除第一个选项后，所有后续选项都会自动向上移动一个位置 ，因此重复移除第一个选项就可以移除所有选项了 。 移动和重排选项在 DOM 标准出现之前，将一个选择框中的选项移动到另一个选择框中是非常麻烦的。整个过程要涉及从第一个选择框中移除选项，然后以相同的文本和值创建新选项，最后再将新选项添加到第二个选择框中。而使用 DOM 的 appendChild() 方法，就可以将第一个选择框中的选项直接移动到第二个选择框中。我们知道，如果为 appendChild() 方法传入一个文档中已有的元素，那么就会先从该元素的父节点中移除它，再把它添加到指定的位置。下面的代码展示了 将第一个选择框中的第一个选项移动到第二个选择框中的过程 。 1234var selectbox1 = document.getElementById("selLocations1");var selectbox2 = document.getElementById("selLocations2");selectbox2.appendChild(selectbox1.options[0]); 移动选项与移除选项有一个共同之处 ，即会重置每一个选项的 index 属性 。 重排选项次序的过程也十分类似，最好的方式仍然是使用 DOM 方法。要将选择框中的某一项移动到特定位置，最合适的 DOM 方法就是 insertBefore() ； appendChild() 方法只适用于将选项添加到选择框的最后。要在选择框中向前移动一个选项的位置，可以使用以下代码： 12var optionToMove = selectbox.options[1];selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index-1]); 以上代码首先选择了要移动的选项，然后将其插入到了排在它前面的选项之前。实际上，第二行代码对除第一个选项之外的其他选项是通用的。类似地，可以使用下列代码 将选择框中的选项向后移动一个位置 。 12var optionToMove = selectbox.options[1];selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index+2]); 以上代码适用于选择框中的所有选项，包括最后一个选项。 IE7 存在一个页面重绘问题，有时候会导致使用 DOM 方法重排的选项不能马上正确显示。 表单序列化随着 Ajax 的出现，表单序列化已经成为一种常见需求 （第 21 章将讨论 Ajax）。在 JavaScript 中，可以利用表单字段的 type 属性，连同 name 和 value 属性一起实现对表单的序列化 。在编写代码之前，有必须先搞清楚在表单提交期间，浏览器是怎样将数据发送给服务器的。 对表单字段的名称和值进行 URL 编码，使用和号（&amp;）分隔。 不发送禁用的表单字段。 只发送勾选的复选框和单选按钮。 不发送 type 为 “reset” 和 “button” 的按钮。 多选选择框中的每个选中的值单独一个条目。 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括 type为 “image” 的 &lt;input&gt; 元素。 &lt;select&gt; 元素的值，就是选中的 &lt;option&gt; 元素的 value 特性的值。如果 &lt;option&gt; 元素没有 value 特性，则是 &lt;option&gt; 元素的文本值。 在表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。除此之外的其他上述规则都应该遵循。以下就是 实现表单序列化 的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function serialize(form)&#123; var parts = [], field = null, i, len, j, optLen, option, optValue; for (i=0, len=form.elements.length; i &lt; len; i++)&#123; field = form.elements[i]; switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if (field.name.length)&#123; for (j=0, optLen = field.options.length; j &lt; optLen; j++)&#123; option = field.options[j]; if (option.selected)&#123; optValue = &quot;&quot;; if (option.hasAttribute)&#123; optValue = (option.hasAttribute(&quot;value&quot;) ? option.value : option.text); &#125; else &#123; optValue = (option.attributes[&quot;value&quot;].specified ? option.value : option.text); &#125; parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(optValue)); &#125; &#125; &#125; break; case undefined: //字段集 case &quot;file&quot;: //文件输入 case &quot;submit&quot;: //提交按钮 case &quot;reset&quot;: //重置按钮 case &quot;button&quot;: //自定义按钮 break; case &quot;radio&quot;: //单选按钮 case &quot;checkbox&quot;: //复选框 if (!field.checked)&#123; break; &#125; /* 执行默认操作 */ default: //不包含没有名字的表单字段 if (field.name.length)&#123; parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value)); &#125; &#125; &#125; return parts.join(&quot;&amp;&quot;);&#125; 上面这个 serialize() 函数首先定义了一个名为 parts 的数组，用于保存将要创建的字符串的各个部分。然后，通过 for 循环迭代每个表单字段，并将其保存在 field 变量中。在获得了一个字段的引用之后，使用 switch 语句检测其 type 属性。序列化过程中最麻烦的就是 &lt;select&gt; 元素，它可能是单选框也可能是多选框。为此，需要遍历控件中的每一个选项，并在相应选项被选中的情况下向数组中添加一个值。对于单选框，只可能有一个选中项，而多选框则可能有零或多个选中项。这里的代码适用于这两种选择框，至于可选项的数量则是由浏览器控制的。在找到一个选中项之后，需要确定使用什么值。如果不存在 value 特性，或者虽然存在该特性，但值为空字符串，都要使用选项的文本来代替。为检查这个特性，在 DOM 兼容的浏览器中需要使用 hasAttribute() 方法，而在 IE 中需要使用特性的 specified 属性。 如果表单中包含 &lt;fieldset&gt; 元素，则该元素会出现在元素集合中，但没有 type 属性。因此，如果 type 属性未定义，则不需要对其进行序列化。同样，对于各种按钮以及文件输入字段也是如此（文件输入字段在表单提交过程中包含文件的内容；但是，这个字段是无法模仿的，序列化时一般都要忽略）。对于单选按钮和复选框，要检查其 checked 属性是否被设置为 false ，如果是则退出 switch 语句。如果 checked 属性为 true ，则继续执行 default 语句，即将当前字段的名称和值进行编码，然后添加到 parts 数组中。函数的最后一步，就是使用 join() 格式化整个字符串，也就是用和号来分隔每一个表单字段。 最后， serialize() 函数会以查询字符串的格式输出序列化之后的字符串。当然，要序列化成其他格式，也不是什么困难的事。 富文本编辑富文本编辑，又称为 WYSIWYG（What You See Is What You Get，所见即所得）。在网页中编辑富文本内容，是人们对 Web 应用程序最大的期待之一 。虽然也没有规范，但在 IE 最早引入的这一功能基础上，已经出现了事实标准。而且，Opera、Safari、Chrome 和 Firefox 都已经支持这一功能。这一技术的本质，就是在页面中嵌入一个包含空 HTML 页面的 iframe 。通过设置 designMode 属性，这个空白的 HTML 页面可以被编辑，而编辑对象则是该页面 &lt;body&gt; 元素的 HTML 代码。 designMode 属性有两个可能的值： “off” （默认值）和 “on” 。在设置为 “on” 时，整个文档都会变得可以编辑（显示插入符号），然后就可以像使用字处理软件一样，通过键盘将文本内容加粗、变成斜体，等等。 可以给 iframe 指定一个非常简单的 HTML 页面作为其内容来源 。例如： 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Blank Page for Rich Text Editing&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这个页面在 iframe 中可以像其他页面一样被加载。要让它可以编辑，必须要将 designMode 设置为 “on” ，但 只有在页面完全加载之后才能设置这个属性 。因此，在包含页面中，需要使用 onload 事件处理程序来在恰当的时刻设置 designMode ，如下面的例子所示： 1234567&lt;iframe name="richedit" style="height:100px;width:100px;" src="blank.htm"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt; EventUtil.addHandler(window, "load", function()&#123; frames["richedit"].document.designMode = "on"; &#125;);&lt;/script&gt; 等到以上代码执行之后，你就会在页面中看到一个类似文本框的可编辑区字段。这个区字段具有与其他网页相同的默认样式；不过，通过为空白页面应用 CSS 样式，可以修改可编辑区字段的外观 。 使用 contenteditable 属性另一种编辑富文本内容的方式是使用名为 contenteditable 的特殊属性 ，这个属性也是由 IE 最早实现的。可以把 contenteditable 属性应用给页面中的任何元素，然后用户立即就可以编辑该元素 。 这种方法之所以受到欢迎，是因为它不需要 iframe 、空白页和 JavaScript，只要为元素设置 contenteditable 属性即可。 1&lt;div class="editable" id="richedit" contenteditable&gt;&lt;/div&gt; 这样，元素中包含的任何文本内容就都可以编辑了，就好像这个元素变成了 元素一样。通过在这个元素上设置 contenteditable 属性，也能打开或关闭编辑模式。 12var div = document.getElementById("richedit");div.contentEditable = "true"; contenteditable 属性有三个可能的值： “true” 表示打开 、 “false” 表示关闭 ， “inherit” 表示从父元素那里继承（因为可以在 contenteditable 元素中创建或删除元素）。支持 contenteditable属性的元素有 IE、Firefox、Chrome、Safari 和 Opera。在移动设备上，支持 contenteditable 属性的浏览器有 iOS 5+中的 Safari 和 Android 3+中的 WebKit。 操作富文本与富文本编辑器交互的主要方式，就是使用 document.execCommand() 。这个方法可以对文档执行预定义的命令，而且可以应用大多数格式。可以为 document.execCommand() 方法 传递 3 个参数：要执行的命令名称 、表示浏览器是否应该为当前命令提供用户界面的一个布尔值 和 执行命令必须的一个值 （如果不需要值，则传递 null ）。为了确保跨浏览器的兼容性，第二个参数应该始终设置为 false ，因为 Firefox 会在该参数为 true 时抛出错误。 不同浏览器支持的预定义命令也不一样。下表列出了那些被支持最多的命令。 其中，与剪贴板有关的命令在不同浏览器中的差异极大。Opera 根本没有实现任何剪贴板命令，而 Firefox 在默认情况下会禁用它们（必须修改用户的首选项来启用它们）。Safari 和 Chrome 实现了 cut 和 copy ，但没有实现 paste 。不过，即使不能通过 document.execCommand() 来执行这些命令，但却可以通过相应的快捷键来实现同样的操作。 可以在任何时候使用这些命令来修改富文本区域的外观 ，如下面的例子所示。 1234567891011//转换粗体文本frames["richedit"].document.execCommand("bold", false, null);//转换斜体文本frames["richedit"].document.execCommand("italic", false, null);//创建指向 www.wrox.com 的链接frames["richedit"].document.execCommand("createlink", false, "http://www.wrox.com");//格式化为 1 级标题frames["richedit"].document.execCommand("formatblock", false, "&lt;h1&gt;"); 同样的方法也适用于页面中 contenteditable 属性为 “true” 的区块，只要把对框架的引用替换成当前窗口的 document 对象即可 。 1234567891011//转换粗体文本document.execCommand("bold", false, null);//转换斜体文本document.execCommand("italic", false, null);//创建指向 www.wrox.com 的链接document.execCommand("createlink", false, "http://www.wrox.com");//格式化为 1 级标题document.execCommand("formatblock", false, "&lt;h1&gt;"); 需要注意的是，虽然所有浏览器都支持这些命令，但这些命令所产生的 HTML 仍然有很大不同。例如，执行 bold 命令时，IE 和 Opera 会使用 &lt;strong&gt; 标签包围文本，Safari 和 Chrome 使用 &lt;b&gt; 标签，而 Firefox 则使用 &lt;span&gt; 标签。由于各个浏览器实现命令的方式不同，加上它们通过 innerHTML 实现转换的方式也不一样，因此不能指望富文本编辑器会产生一致的 HTML。 除了命令之外，还有一些与命令相关的方法。第一个方法就是 queryCommandEnabled() ，可以用它来检测是否可以针对当前选择的文本，或者当前插入字符所在位置执行某个命令。这个方法接收一个参数，即要检测的命令。如果当前编辑区域允许执行传入的命令，这个方法返回 true ，否则返回 false 。例如： 1var result = frames["richedit"].document.queryCommandEnabled("bold"); 如果能够对当前选择的文本执行 “bold” 命令，以上代码会返回 true 。需要注意的是， queryCommandEnabled() 方法返回 true ，并不意味着实际上就可以执行相应命令，而只能说明对当前选择的文本执行相应命令是否合适。例如，Firefox 在默认情况下会禁用剪切操作，但执行 queryCommandEnabled(“cut”) 也可能会返回 true 。 另外， queryCommandState() 方法用于确定是否已将指定命令应用到了选择的文本。例如，要确定当前选择的文本是否已经转换成了粗体，可以使用如下代码。 1var isBold = frames["richedit"].document.queryCommandState("bold"); 如果此前已经对选择的文本执行了 “bold” 命令，那么上面的代码会返回 true 。一些功能全面的富文本编辑器，正是利用这个方法来更新粗体、斜体等按钮的状态的。最后一个方法是 queryCommandValue() ，用于取得执行命令时传入的值（即前面例子中传给 document.execCommand() 的第三个参数）。例如，在对一段文本应用 “fontsize” 命令时如果传入了 7 ，那么下面的代码就会返回 “7” ： 1var fontSize = frames["richedit"].document.queryCommandValue("fontsize"); 通过这个方法可以确定某个命令是怎样应用到选择的文本的，可以据以确定再对其应用后续命令是否合适。 富文本选区在富文本编辑器中，使用框架（ iframe ）的 getSelection() 方法，可以确定实际选择的文本。这个方法是 window 对象和 document 对象的属性，调用它会返回一个表示当前选择文本的 Selection 对象。每个 Selection 对象都有下列属性。 anchorNode ：选区起点所在的节点。 anchorOffset ：在到达选区起点位置之前跳过的 anchorNode 中的字符数量。 focusNode ：选区终点所在的节点。 focusOffset ： focusNode 中包含在选区之内的字符数量。 isCollapsed ：布尔值，表示选区的起点和终点是否重合。 rangeCount ：选区中包含的 DOM 范围的数量。 Selection 对象的这些属性并没有包含多少有用的信息。好在，该对象的下列方法提供了更多信息，并且支持对选区的操作。 addRange(range) ：将指定的 DOM 范围添加到选区中。 collapse(node, offset) ：将选区折叠到指定节点中的相应的文本偏移位置。 collapseToEnd() ：将选区折叠到终点位置。 collapseToStart() ：将选区折叠到起点位置。 containsNode(node) ：确定指定的节点是否包含在选区中。 deleteFromDocument() ：从文档中删除选区中的文本，与 document.execCommand(“delete”,false, null) 命令的结果相同。 extend(node, offset) ：通过将 focusNode 和 focusOffset 移动到指定的值来扩展选区。 getRangeAt(index) ：返回索引对应的选区中的 DOM 范围。 removeAllRanges() ：从选区中移除所有 DOM 范围。实际上，这样会移除选区，因为选区中至少要有一个范围。 reomveRange(range) ：从选区中移除指定的 DOM 范围。 selectAllChildren(node) ：清除选区并选择指定节点的所有子节点。 toString() ：返回选区所包含的文本内容。 Selection 对象的这些方法都极为实用，它们利用了（第 12 章讨论过的）DOM 范围来管理选区。由于可以直接操作选择文本的 DOM 表现，因此访问 DOM范围与使用 execCommand() 相比，能够对富文本编辑器进行更加细化的控制。下面来看一个例子。 123456789101112var selection = frames["richedit"].getSelection();//取得选择的文本var selectedText = selection.toString();//取得代表选区的范围var range = selection.getRangeAt(0);//突出显示选择的文本var span = frames["richedit"].document.createElement("span");span.style.backgroundColor = "yellow";range.surroundContents(span); 以上代码会为富文本编辑器中被选择的文本添加黄色的背景。这里使用了默认选区中的 DOM 范围，通过 surroundContents() 方法将选区添加到了带有黄色背景的 元素中。 HTML5 将 getSelection() 方法纳入了标准，而且 IE9、Firefox、Safari、Chrome 和 Opera 8 都实现了它。由于历史原因，在 Firefox 3.6+中调用 document.getSelection() 会返回一个字符串。为此，可以在 Firefox 3.6+中改作调用 window.getSelection() ，从而返回 selection 对象。Firefox 8 修复了 document.getSelection() 的 bug，能返回与 window.getSelection() 相同的值。 IE8 及更早的版本不支持 DOM范围，但我们可以通过它支持的 selection 对象操作选择的文本。IE 中的 selection 对象是 document 的属性，本章前面曾经讨论过。要取得富文本编辑器中选择的文本，首先必须创建一个文本范围（请参考第 12 章中的相关内容），然后再像下面这样访问其 text 属性。 12var range = frames["richedit"].document.selection.createRange();var selectedText = range.text; 虽然使用 IE 的文本范围来执行 HTML 操作并不像使用 DOM 范围那么可靠，但也不失为一种有效的途径。要像前面使用 DOM 范围那样实现相同的文本高亮效果，可以组合使用 htmlText 属性和 pasteHTML() 方法。 12var range = frames["richedit"].document.selection.createRange();range.pasteHTML("&lt;span style=\"background-color:yellow\"&gt; " + range.htmlText + "&lt;/span&gt;"); 以上代码通过 htmlText 取得了当前选区中的 HTML，然后将其放在了一对 标签中，最后又使用 pasteHTML() 将结果重新插入到了选区中。 表单与富文本由于富文本编辑是使用 iframe 而非表单控件实现的，因此从技术上说，富文本编辑器并不属于表单。换句话说，富文本编辑器中的 HTML 不会被自动提交给服务器，而需要我们手工来提取并提交 HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从 iframe 中提取出的 HTML。具体来说，就是在提交表单之前，从 iframe 中提取出 HTML，并将其插入到隐藏的字段中。下面就是通过表单的 onsubmit 事件处理程序实现上述操作的代码。 123456EventUtil.addHandler(form, "submit", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements["comments"].value = frames["richedit"].document.body.innerHTML;&#125;); 在此，我们通过文档主体的 innerHTML 属性取得了 iframe 中的 HTML，然后将其插入到了名为 “comments” 的表单字段中。这样可以确保恰好在提交表单之前填充 “comments” 字段。如果你想在代码中通过 submit() 来手工提交表单，那么一定不要忘记事先执行上面的操作。对于 contenteditable 元素，也可以执行类似操作。 123456EventUtil.addHandler(form, "submit", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements["comments"].value = document.getElementById("richedit").innerHTML;&#125;); 小结虽然 HTML 和 Web 应用自诞生以来已经发生了天翻地覆的变化，但 Web 表单相对却没有什么改变。使用 JavaScript 可以增强已有的表单字段，从而创造出新的功能，或者提升表单的易用性。为此，表单、表单字段都引入了相应的属性和方法，以便 JavaScript 使用。下面是本章介绍的几个概念。 可以使用一些标准或非标准的方法选择文本框中的全部或部分文本。 大多数浏览器都采用了 Firefox 操作选择文本的方式，但 IE 仍然坚持自己的实现。 在文本框的内容变化时，可以通过侦听键盘事件以及检测插入的字符，来允许或禁止用户输入某些字符。除 Opera 之外的所有浏览器都支持剪贴板事件，包括 copy 、 cut 和 paste 。其他浏览器在实现剪贴板事件时也可以分为几种不同的情况。 IE、Firefox、Chrome 和 Safari 允许通过 JavaScript 访问剪贴板中的数据，而 Opera 不允许这种访问方式。 即使是 IE、Chrome 和 Safari，它们各自的实现方式也不相同。 Firefox、Safari 和 Chrome 只允许在 paste 事件发生时读取剪贴板数据，而 IE 没有这个限制。 Firefox、Safari 和 Chrome 只允许在发生剪贴板事件时访问与剪贴板相关的信息，而 IE 允许在任何时候访问相关信息。 在文本框内容必须限制为某些特定字符的情况下，就可以利用剪贴板事件来屏蔽通过粘贴向文本框中插入内容的操作。 选择框也是经常要通过 JavaScript 来控制的一个表单字段。由于有了 DOM，对选择框的操作比以前要方便多了。添加选项、移除选项、将选项从一个选择框移动到另一个选择框，甚至对选项进行排序等操作，都可以使用标准的 DOM技术来实现。 富文本编辑功能是通过一个包含空 HTML 文档的 iframe 元素来实现的。通过将空文档的 designMode 属性设置为 “on” ，就可以将该页面转换为可编辑状态，此时其表现如同字处理软件。另外，也可以将某个元素设置为 contenteditable 。在默认情况下，可以将字体加粗或者将文本转换为斜体，还可以使用剪贴板。JavaScript 通过使用 execCommand() 方法也可以实现相同的一些功能。另外，使用 queryCommandEnabled() 、 queryCommandState() 和 queryCommandValue() 方法则可以取得有关文本选区的信息。由于以这种方式构建的富文本编辑器并不是一个表单字段，因此在将其内容提交给服务器之前，必须将 iframe 或 contenteditable 元素中的 HTML 复制到一个表单字段中。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-事件]]></title>
    <url>%2F2018%2F08%2F26%2FJavaScript-event%2F</url>
    <content type="text"><![CDATA[事件JavaScript 与 HTML 之间的交互是通过事件实现的 。事件 ，就是文档或浏览器窗口中发生的一些特定的交互瞬间 。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码 。这种在传统软件工程中被称为 观察员模式的模型 ，支持页面的行为（JavaScript 代码）与页面的外观（HTML 和 CSS 代码）之间的松散耦合 。 事件最早是在 IE3 和 Netscape Navigator 2中出现的，当时是作为分担服务器运算负载的一种手段。在 IE4 和 Navigator 4发布时，这两种浏览器都提供了相似但不相同的 API，这些 API 并存经过了好几个主要版本。DOM2 级规范开始尝试以一种符合逻辑的方式来标准化 DOM 事件 。IE9、Firefox、Opera、Safari 和 Chrome 全都已经实现了“DOM2 级事件”模块的核心部分。IE8 是最后一个仍然使用其专有事件系统的主要浏览器。 浏览器的事件系统相对比较复杂 。尽管所有主要浏览器已经实现了“DOM2 级事件”，但这个规范本身并没有涵盖所有事件类型。浏览器对象模型（BOM）也支持一些事件，这些事件与文档对象模型（DOM）事件之间的关系并不十分清晰，因为 BOM事件长期没有规范可以遵循（HTML5 后来给出了详细的说明）。随着 DOM3 级的出现，增强后的 DOM 事件 API 变得更加繁琐 。使用事件有时相对简单，有时则非常复杂，难易程度会因你的需求而不同 。不过，有关事件的一些核心概念是一定要理解的。 事件流当浏览器发展到第四代时（IE4 及 Netscape Communicator 4），浏览器开发团队遇到了一个很有意思的问题：页面的哪一部分会拥有某个特定的事件？要明白这个问题问的是什么，可以 想象画在一张纸上的一组同心圆 。如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆 。两家公司的浏览器开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，他们都认为单击事件不仅仅发生在按钮上。 换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面 。 事件流描述的是从页面中接收事件的顺序 。但有意思的是，IE 和 Netscape 开发团队居然提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡流 ，而 Netscape Communicator 的事件流是事件捕获流 。 事件冒泡IE 的事件流叫做事件冒泡（event bubbling），即 事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收 ，然后逐级向上传播到较为不具体的节点 （文档）。以下面的 HTML 页面为例： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;Click Me&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如果你单击了页面中的 &lt;div&gt; 元素，那么这个 click 事件会按照如下顺序传播： 1234(1) &lt;div&gt;(2) &lt;body&gt;(3) &lt;html&gt;(4) document 也就是说， click 事件首先在 &lt;div&gt; 元素上发生，而这个元素就是我们单击的元素。然后， click 事件沿 DOM 树向上传播，在每一级节点上都会发生，直至传播到 document 对象。下图展示了事件冒泡的过程。 所有现代浏览器都支持事件冒泡 ，但在具体实现上还是有一些差别 。IE5.5 及更早版本中的事件冒泡会跳过 &lt;html&gt; 元素（从 &lt;body&gt; 直接跳到 document ）。IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 window 对象。 事件捕获Netscape Communicator团队提出的另一种事件流 叫做 事件捕获 （event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件 ，最具体的节点应该最后接收到事件 。事件捕获的用意在于在事件到达预定目标之前捕获它 。如果仍以前面的 HTML 页面作为演示事件捕获的例子，那么单击 &lt;div&gt; 元素就会以下列顺序触发 click 事件。 1234(1) document(2) &lt;html&gt;(3) &lt;body&gt;(4) &lt;div&gt; 在事件捕获过程中 ，document 对象 首先 接收到 click 事件，然后 事件沿 DOM 树依次向下 ，一直传播到事件的实际目标 ，即 &lt;div&gt; 元素。下图展示了事件捕获的过程。 虽然事件捕获是 Netscape Communicator 唯一支持的事件流模型，但 IE9、Safari、Chrome、Opera和 Firefox 目前也都支持这种事件流模型。尽管“DOM2 级事件”规范要求事件应该从 document 对象开始传播 ，但 这些浏览器都是从 window 对象开始捕获事件的 。 由于老版本的浏览器不支持，因此很少有人使用事件捕获 。我们也建议读者放心地使用事件冒泡，在有特殊需要时再使用事件捕获。 DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段 、处于目标阶段 和事件冒泡阶段 。首先发生的是 事件捕获 ，为截获事件提供了机会 。然后是实际的 目标接收到事件 。最后一个阶段是 冒泡阶段 ，可以在这个阶段对事件做出响应 。以前面简单的 HTML 页面为例，单击 &lt;div&gt; 元素会按照下图所示顺序触发事件。 在 DOM 事件流中，实际的目标（ &lt;div&gt; 元素）在捕获阶段不会接收到事件 。这意味着在 捕获阶段 ，事件从 document 到 &lt;html&gt; 再到 &lt;body&gt; 后就停止了 。下一个阶段是 “处于目标”阶段 ，于是 事件在 &lt;div&gt; 上发生 ，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生 ，事件又传播回文档 。 多数支持 DOM事件流的浏览器都实现了一种特定的行为 ；即使“DOM2 级事件”规范明确要求捕获阶段不会涉及事件目标，但 IE9、Safari、Chrome、Firefox 和 Opera 9.5 及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。 IE9、Opera、Firefox、Chrome 和 Safari 都支持 DOM 事件流；IE8 及更早版本不支持 DOM 事件流。 事件处理程序事件就是用户或浏览器自身执行的某种动作 。诸如 click 、 load 和 mouseover ，都是事件的名字。而响应某个事件的函数就叫做事件处理程序 （或事件侦听器）。事件处理程序的名字以 “on” 开头 ，因此 click 事件的事件处理程序 就是 onclick ， load 事件的事件处理程序就是 onload 。为事件指定处理程序的方式有好几种。 HTML事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的 HTML 特性来指定 。这个特性的值应该是能够执行的 JavaScript 代码 。例如，要在按钮被单击时执行一些 JavaScript，可以像下面这样编写代码： 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&apos;Clicked&apos;)&quot; /&gt; 当单击这个按钮时，就会显示一个警告框。这个操作是通过指定 onclick 特性并将一些 JavaScript代码作为它的值来定义的。由于这个值是 JavaScript ，因此不能在其中使用未经转义的 HTML 语法字符 ，例如和号（&amp;）、双引号（””）、小于号（&lt;）或大于号（&gt;）。为了避免使用 HTML 实体，这里使用了单引号。如果想要使用双引号，那么就要将代码改写成如下所示： 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&amp;quot;Clicked&amp;quot;)&quot; /&gt; 在 HTML 中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本，如下面的例子所示： 123456&lt;script type="text/javascript"&gt; function showMessage()&#123; alert("Hello world!"); &#125;&lt;/script&gt;&lt;input type="button" value="Click Me" onclick="showMessage()" /&gt; 在这个例子中，单击按钮就会调用 showMessage() 函数。这个函数是在一个独立的 &lt;script&gt; 元素中定义的，当然也可以被包含在一个外部文件中。事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码 。 这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数 。这个函数中有一个局部变量 event ，也就是 事件对象 （本章稍后讨论）： 12&lt;!-- 输出 "click" --&gt;&lt;input type="button" value="Click Me" onclick="alert(event.type)"&gt; 通过 event 变量 ，可以直接访问事件对象 ，你不用自己定义它 ，也不用从函数的参数列表中读取 。在这个函数内部， this 值等于事件的目标元素 ，例如： 12&lt;!-- 输出 "Click Me" --&gt;&lt;input type="button" value="Click Me" onclick="alert(this.value)"&gt; 关于这个 动态创建的函数 ，另一个有意思的地方是 它扩展作用域的方式 。在这个函数内部 ，可以像访问局部变量一样访问 document 及该元素本身的成员 。这个函数使用 with 像下面这样扩展作用域 ： 1234567function()&#123; with(document)&#123; with(this)&#123; //元素属性值 &#125; &#125;&#125; 如此一来，事件处理程序要访问自己的属性就简单多了 。下面这行代码与前面的例子效果相同： 12&lt;!-- 输出 "Click Me" --&gt;&lt;input type="button" value="Click Me" onclick="alert(value)"&gt; 如果当前元素是一个表单输入元素 ，则作用域中还会包含访问表单元素（父元素）的入口 ，这个函数就变成了如下所示： 123456789function()&#123; with(document)&#123; with(this.form)&#123; with(this)&#123; //元素属性值 &#125; &#125; &#125;&#125; 实际上，这样 扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单字段 。例如： 1234&lt;form method="post"&gt; &lt;input type="text" name="username" value=""&gt; &lt;input type="button" value="Echo Username" onclick="alert(username.value)"&gt;&lt;/form&gt; 在这个例子中，单击按钮会显示文本框中的文本。值得注意的是，这里直接引用了 username 元素。 不过，在 HTML 中指定事件处理程序有两个缺点。首先，存在一个时差问题 。因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。以前面的例子来说明，假设 showMessage() 函数是在按钮下方、页面的最底部定义的。如果用户在页面解析 showMessage() 函数之前就单击了按钮，就会引发错误。为此，很多 HTML 事件处理程序都会被封装在一个 try-catch 块中，以便错误不会浮出水面 ，如下面的例子所示： 1&lt;input type="button" value="Click Me" onclick="try&#123;showMessage();&#125;catch(ex)&#123;&#125;"&gt; 这样，如果在 showMessage() 函数有定义之前单击了按钮，用户将不会看到 JavaScript 错误，因为在浏览器有机会处理错误之前，错误就被捕获了。 另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果 。不同 JavaScript引擎遵循的标识符解析规则略有差异 ，很可能会在访问非限定对象成员时出错 。 通过 HTML 指定事件处理程序的最后一个缺点是 HTML 与 JavaScript 代码紧密耦合 。如果要更换事件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码。而这正是许多开发人员摒弃 HTML 事件处理程序 ，转而使用 JavaScript 指定事件处理程序的原因所在 。要了解关于 HTML 事件处理程序缺点的更多信息，请参考 Garrett Smith 的文章“Event Handler Scope”（ www.jibbering.com/faq/names/event_handler.html ）。 DOM0 级事件处理程序通过 JavaScript 指定事件处理程序的传统方式 ，就是 将一个函数赋值给一个事件处理程序属性 。这种为事件处理程序赋值的方法是在第四代 Web 浏览器中出现的，而且至今仍然为所有现代浏览器所支持。原因一是 简单 ，二是 具有跨浏览器的优势 。要使用 JavaScript 指定事件处理程序，首先必须取得一个要操作的对象的引用。 每个元素（包括 window 和 document ）都有自己的事件处理程序属性 ，这些属性通常全部小写 ，例如 onclick 。将这种属性的值设置为一个函数，就可以指定事件处理程序 ，如下所示： 1234var btn = document.getElementById("myBtn");btn.onclick = function()&#123; alert("Clicked");&#125;; 在此，我们通过文档对象取得了一个按钮的引用，然后为它指定了 onclick 事件处理程序。但要注意，在这些代码运行以前不会指定事件处理程序 ，因此 如果这些代码在页面中位于按钮后面 ，就有可能在一段时间内怎么单击都没有反应 。 使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行 ；换句话说，程序中的 this 引用当前元素 。来看一个例子。 1234var btn = document.getElementById("myBtn");btn.onclick = function()&#123; alert(this.id); //"myBtn"&#125;; 单击按钮显示的是元素的 ID，这个 ID 是通过 this.id 取得的。不仅仅是 ID，实际上可以在事件处理程序中通过 this 访问元素的任何属性和方法 。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理 。 也 可以删除通过 DOM0 级方法指定的事件处理程序 ，只要像下面这样将事件处理程序属性的值设置为 null 即可 ： 1btn.onclick = null; //删除事件处理程序 将事件处理程序设置为 null 之后 ，再 单击按钮将不会有任何动作发生 。 如果你使用 HTML 指定事件处理程序，那么 onclick 属性的值就是一个包含着在同名 HTML 特性中指定的代码的函数。而将相应的属性设置为 null ，也可以删除以这种方式指定的事件处理程序。 DOM2 级事件处理程序“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作 ： addEventListener() 和 removeEventListener() 。所有 DOM 节点中都包含这两个方法 ，并且它们都接受 3 个参数：要处理的事件名 、作为事件处理程序的函数 和 一个布尔值 。最后这个布尔值参数 如果是 true ，表示在捕获阶段调用事件处理程序 ；如果是 false ，表示在冒泡阶段调用事件处理程序 。 要在按钮上为 click 事件添加事件处理程序，可以使用下列代码： 1234var btn = document.getElementById("myBtn");btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false); 上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发（因为最后一个参数是 false ）。与 DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。使用 DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序 。来看下面的例子。 1234567var btn = document.getElementById("myBtn");btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false);btn.addEventListener("click", function()&#123; alert("Hello world!");&#125;, false); 这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发，因此首先会显示元素的 ID，其次会显示 “Hello world!” 消息。 通过 addEventListener() 添加的事件处理程序只能使用 removeEventListener() 来移除 ；移除时传入的参数与添加处理程序时使用的参数相同 。这也意味着通过 addEventListener() 添加的匿名函数将无法移除 ，如下面的例子所示。 12345678910var btn = document.getElementById("myBtn");btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false);// 这里省略了其他代码btn.removeEventListener("click", function()&#123; // 没有用！ alert(this.id);&#125;, false); 在这个例子中，我们使用 addEventListener() 添加了一个事件处理程序。虽然调用 removeEventListener() 时看似使用了相同的参数，但实际上，第二个参数与传入 addEventListener() 中的那一个是完全不同的函数。而 传入 removeEventListener() 中的事件处理程序函数必须与传入 addEventListener() 中的相同 ，如下面的例子所示。 123456789var btn = document.getElementById("myBtn");var handler = function()&#123; alert(this.id);&#125;;btn.addEventListener("click", handler, false);// 这里省略了其他代码btn.removeEventListener("click", handler, false); // 有效！ 重写后的这个例子没有问题，是因为在 addEventListener() 和 removeEventListener() 中使用了相同的函数。 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段 ，这样可以最大限度地兼容各种浏览器 。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。 IE9、Firefox、Safari、Chrome和 Opera 支持 DOM2 级事件处理程序。 IE事件处理程序IE 实现了与 DOM 中类似的两个方法： attachEvent() 和 detachEvent() 。这两个方法接受相同的两个参数：事件处理程序名称 与 事件处理程序函数 。由于 IE8 及更早版本只支持事件冒泡，所以 通过 attachEvent() 添加的事件处理程序都会被添加到冒泡阶段 。 要使用 attachEvent() 为按钮添加一个事件处理程序，可以使用以下代码。 1234var btn = document.getElementById("myBtn");btn.attachEvent("onclick", function()&#123; alert("Clicked");&#125;); 注意， attachEvent() 的第一个参数是 “onclick “ ，而非 DOM 的 addEventListener() 方法中的 “click” 。 在 IE 中使用 attachEvent() 与使用 DOM0 级方法的主要区别在于 事件处理程序的作用域 。在 使用 DOM0 级方法 的情况下，事件处理程序会在其所属元素的作用域内运行 ；在 使用 attachEvent() 方法 的情况下，事件处理程序会在全局作用域中运行 ，因此 this 等于 window 。来看下面的例子。 1234var btn = document.getElementById("myBtn");btn.attachEvent("onclick", function()&#123; alert(this === window); //true&#125;); 在编写跨浏览器的代码时，牢记这一区别非常重要。 与 addEventListener() 类似， attachEvent() 方法也可以用来为一个元素添加多个事件处理程序 。来看下面的例子。 1234567var btn = document.getElementById("myBtn");btn.attachEvent("onclick", function()&#123; alert("Clicked");&#125;);btn.attachEvent("onclick", function()&#123; alert("Hello world!");&#125;); 这里调用了两次 attachEvent() ，为同一个按钮添加了两个不同的事件处理程序。不过，与 DOM 方法不同的是 ，这些事件处理程序不是以添加它们的顺序执行 ，而是以相反的顺序被触发 。单击这个例子中的按钮，首先看到的是 “Hello world!” ，然后才是 “Clicked” 。 使用 attachEvent() 添加的事件可以通过 detachEvent() 来移除 ，条件是必须提供相同的参数 。与 DOM 方法一样，这也意味着添加的匿名函数将不能被移除 。不过，只要能够将对相同函数的引用传给 detachEvent() ，就可以移除相应的事件处理程序 。例如： 123456789var btn = document.getElementById("myBtn");var handler = function()&#123; alert("Clicked");&#125;;btn.attachEvent("onclick", handler);// 这里省略了其他代码btn.detachEvent("onclick", handler); 这个例子将保存在变量 handler 中的函数作为事件处理程序。因此，后面的 detachEvent() 可以使用相同的函数来移除事件处理程序 。 支持 IE 事件处理程序的浏览器有 IE 和 Opera。 跨浏览器的事件处理程序为了以跨浏览器的方式处理事件，不少开发人员会使用能够隔离浏览器差异的 JavaScript 库 ，还有一些开发人员会自己开发最合适的事件处理的方法。自己编写代码其实也不难，只要恰当地使用能力检测即可（能力检测在第 9 章介绍过）。要保证处理事件的代码能在大多数浏览器下一致地运行，只需关注冒泡阶段 。 第一个要创建的方法是 addHandler() ，它的职责是 视情况分别使用 DOM0 级方法、DOM2 级方法或 IE 方法来添加事件 。这个方法属于一个名叫 EventUtil 的对象，本书将使用这个对象来处理浏览器间的差异。 addHandler() 方法接受 3 个参数：要操作的元素 、事件名称 和 事件处理程序函数 。 v与 addHandler() 对应的方法是 removeHandler() ，它也 接受相同的参数 。这个方法的职责是 移除之前添加的事件处理程序 —— 无论该事件处理程序是采取什么方式添加到元素中的 ，如果其他方法无效 ，默认采用 DOM0 级方法** 。 EventUtil 的用法如下所示。 123456789101112131415161718192021var EventUtil = &#123; addHandler: function(element, type, handler)&#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = handler; &#125; &#125;, removeHandler: function(element, type, handler)&#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent)&#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;&#125;; 这两个方法首先都会 检测传入的元素中是否存在 DOM2 级方法 。如果 存在 DOM2 级方法 ，则使用该方法：传入事件类型 、事件处理程序函数 和 第三个参数 false （表示冒泡阶段）。如果 存在的是 IE 的方法 ，则 采取第二种方案 。注意，为了在 IE8 及更早版本中运行，此时的事件类型必须加上 “on” 前缀。最后一种可能就是使用 DOM0 级方法（在现代浏览器中，应该不会执行这里的代码）。此时，我们使用的是方括号语法来将属性名指定为事件处理程序，或者将属性设置为 null 。 可以像下面这样使用 EventUtil 对象： 123456789var btn = document.getElementById("myBtn");var handler = function()&#123; alert("Clicked");&#125;;EventUtil.addHandler(btn, "click", handler);// 这里省略了其他代码EventUtil.removeHandler(btn, "click", handler); addHandler() 和 removeHandler() 没有考虑到所有的浏览器问题 ，例如在 IE 中的作用域问题。不过，使用它们添加和移除事件处理程序还是足够了 。此外还要注意，DOM0 级对每个事件只支持一个事件处理程序 。好在，只支持 DOM0 级的浏览器已经没有那么多了，因此这对你而言应该不是什么问题。 事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中 包含着所有与事件有关的信息 。包括 导致事件的元素、事件的类型 以及 其他与特定事件相关的信息 。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持 event 对象，但支持方式不同。 DOM中的事件对象兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级），都会传入 event 对象。来看下面的例子。 1234567var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123; alert(event.type); //"click"&#125;;btn.addEventListener("click", function(event)&#123; alert(event.type); //"click"&#125;, false); 这个例子中的两个事件处理程序都会弹出一个警告框，显示由 event.type 属性表示的事件类型。这个属性始终都会包含被触发的事件类型，例如 “click” （与传入 addEventListener() 和 removeEventListener() 中的事件类型一致）。 在通过 HTML 特性指定事件处理程序时，变量 event 中保存着 event 对象 。请看下面的例子。 1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;/&gt; 以这种方式提供 event 对象，可以让 HTML 特性事件处理程序与 JavaScript 函数执行相同的操作 。event 对象包含与创建它的特定事件有关的属性和方法 。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都会有下表列出的成员。 在事件处理程序内部，对象 this 始终等于 currentTarget 的值 ，而 target 则只包含事件的实际目标 。如果直接将事件处理程序指定给了目标元素 ，则 this 、 currentTarget 和 target 包含相同的值 。来看下面的例子。 12345var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123; alert(event.currentTarget === this); //true alert(event.target === this); //true&#125;; 这个例子检测了 currentTarget 和 target 与 this 的值。由于 click 事件的目标是按钮，因此这三个值是相等的。如果事件处理程序存在于按钮的父节点中（例如 document.body ），那么这些值是不相同的。再看下面的例子。 12345document.body.onclick = function(event)&#123; alert(event.currentTarget === document.body); //true alert(this === document.body); //true alert(event.target === document.getElementById("myBtn")); //true&#125;; 当单击这个例子中的按钮时， this 和 currentTarget 都等于 document.body ，因为事件处理程序是注册到这个元素上的。然而， target 元素却等于按钮元素，因为它是 click 事件真正的目标。由于按钮上并没有注册事件处理程序，结果 click 事件就冒泡到了 document.body ，在那里事件才得到了处理。在需要通过一个函数处理多个事件时，可以使用 type 属性 。例如： 1234567891011121314151617181920var btn = document.getElementById("myBtn");var handler = function(event)&#123; switch(event.type)&#123; case "click": alert("Clicked"); break; case "mouseover": event.target.style.backgroundColor = "red"; break; case "mouseout": event.target.style.backgroundColor = ""; break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn.onmouseout = handler; 这个例子定义了一个名为 handler 的函数，用于处理 3 种事件： click 、 mouseover 和 mouseout 。当单击按钮时，会出现一个与前面例子中一样的警告框。当按钮移动到按钮上面时，背景颜色应该会变成红色，而当鼠标移动出按钮的范围时，背景颜色应该会恢复为默认值。这里通过检测 event.type 属性，让函数能够确定发生了什么事件，并执行相应的操作 。 要阻止特定事件的默认行为，可以使用 preventDefault() 方法 。例如，链接的默认行为就是在被单击时会导航到其 href 特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的 onclick 事件处理程序可以取消它 ，如下面的例子所示。 1234var link = document.getElementById("myLink");link.onclick = function(event)&#123; event.preventDefault();&#125;; 只有 cancelable 属性设置为 true 的事件 ，才可以使用 preventDefault() 来取消其默认行为 。 另外， stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播 ，即 取消进一步的事件捕获或冒泡 。例如，直接添加到一个按钮的事件处理程序可以调用 stopPropagation() ，从而 避免触发注册在 document.body 上面的事件处理程序 ，如下面的例子所示。 12345678var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123; alert("Clicked"); event.stopPropagation();&#125;;document.body.onclick = function(event)&#123; alert("Body clicked");&#125;; 对于这个例子而言，如果不调用 stopPropagation() ，就会在单击按钮时出现两个警告框。可是，由于 click 事件根本不会传播到 document.body ，因此就不会触发注册在这个元素上的 onclick 事件处理程序。 事件对象的 eventPhase 属性 ，可以 用来确定事件当前正位于事件流的哪个阶段 。如果是在捕获阶段调用的 事件处理程序 ，那么 eventPhase 等于 1 ；如果事件处理程序 处于目标对象 上，则 eventPhase 等于 2 ；如果是在 冒泡阶段 调用的事件处理程序， eventPhase 等于 3 。这里要注意的是，尽管“处于目标”发生在冒泡阶段，但 eventPhase 仍然一直等于 2 。来看下面的例子。 123456789101112var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123; alert(event.eventPhase); //2&#125;;document.body.addEventListener("click", function(event)&#123; alert(event.eventPhase); //1&#125;, true);document.body.onclick = function(event)&#123; alert(event.eventPhase); //3&#125;; 当单击这个例子中的按钮时，首先执行的事件处理程序是在捕获阶段触发的添加到 document.body 中的那一个，结果会弹出一个警告框显示表示 eventPhase 的 1 。接着，会触发在按钮上注册的事件处理程序，此时的 eventPhase 值为 2 。最后一个被触发的事件处理程序，是在冒泡阶段执行的添加到 document.body 上的那一个，显示 eventPhase 的值为 3 。而 当 eventPhase 等于 2 时， this 、 target 和 currentTarget 始终都是相等的 。 只有在事件处理程序执行期间， event 对象才会存在 ；一旦事件处理程序执行完成， event 对象就会被销毁 。 IE中的事件对象与访问 DOM 中的 event 对象不同，要 访问 IE 中的 event 对象有几种不同的方式 ，取决于 指定事件处理程序的方法 。在使用 DOM0 级方法添加事件处理程序时， event 对象作为 window 对象的一个属性存在 。来看下面的例子。 12345var btn = document.getElementById("myBtn");btn.onclick = function()&#123; var event = window.event; alert(event.type); //"click"&#125;; 在此，我们 通过 window.event 取得了 event 对象 ，并 检测了被触发事件的类型 （IE 中的 type 属性与 DOM 中的 type 属性是相同的）。可是，如果 事件处理程序是使用 attachEvent() 添加的 ，那么 就会有一个 event 对象作为参数被传入事件处理程序函数中 ，如下所示。 1234var btn = document.getElementById("myBtn");btn.attachEvent("onclick", function(event)&#123; alert(event.type); //"click"&#125;); 在像这样使用 attachEvent() 的情况下，也可以 通过 window 对象来访问 event 对象 ，就像使用 DOM0 级方法时一样。不过为方便起见，同一个对象也会作为参数传递 。 如果是通过HTML特性指定的事件处理程序 ，那么 还可以通过一个名叫 event 的变量来访问 event 对象（与 DOM中的事件模型相同）。再看一个例子。 1&lt;input type="button" value="Click Me" onclick="alert(event.type)"&gt; IE 的 event 对象同样也包含与创建它的事件相关的属性和方法 。其中很多属性和方法都有对应的或者相关的 DOM属性和方法。与 DOM 的 event 对象一样，这些属性和方法也会因为事件类型的不同而不同 ，但 所有事件对象都会包含下表所列的属性和方法 。 因为 事件处理程序的作用域是根据指定它的方式来确定的 ，所以 不能认为 this 会始终等于事件目标 。故而，最好还是使用 event.srcElement 比较保险 。例如： 1234567var btn = document.getElementById("myBtn");btn.onclick = function()&#123; alert(window.event.srcElement === this); //true&#125;;btn.attachEvent("onclick", function(event)&#123; alert(event.srcElement === this); //false&#125;); 在第一个事件处理程序中（使用 DOM0 级方法指定的）， srcElement 属性等于 this ，但在第二个事件处理程序中，这两者的值不相同。 如前所述，returnValue 属性相当于 DOM中的 preventDefault() 方法 ，它们的作用都是 取消给定事件的默认行为 。只要将 returnValue 设置为 false ，就可以阻止默认行为 。来看下面的例子。 1234var link = document.getElementById("myLink");link.onclick = function()&#123; window.event.returnValue = false;&#125;; 这个例子在 onclick 事件处理程序中使用 returnValue 达到了阻止链接默认行为的目的。与 DOM 不同的是，在此没有办法确定事件是否能被取消 。 相应地，cancelBubble 属性与 DOM 中的 stopPropagation() 方法作用相同 ，都是 用来停止事件冒泡的 。由于 IE 不支持事件捕获，因而只能取消事件冒泡 ；但 stopPropagatioin() 可以同时取消事件捕获和冒泡 。例如： 123456789var btn = document.getElementById("myBtn");btn.onclick = function()&#123; alert("Clicked"); window.event.cancelBubble = true;&#125;;document.body.onclick = function()&#123; alert("Body clicked");&#125;; 通过在 onclick 事件处理程序中将 cancelBubble 设置为 true ，就可阻止事件通过冒泡而触发 document.body 中注册的事件处理程序。结果，在单击按钮之后，只会显示一个警告框。 跨浏览器的事件对象虽然 DOM 和 IE 中的 event 对象不同，但基于它们之间的相似性依旧可以拿出跨浏览器的方案来 。IE 中 event 对象的全部信息和方法 DOM 对象中都有，只不过实现方式不一样。不过，这种对应关系让实现两种事件模型之间的映射非常容易。可以对前面介绍的 EventUtil 对象加以增强，添加如下方法以求同存异。 12345678910111213141516171819202122232425262728293031323334var EventUtil = &#123; addHandler: function(element, type, handler)&#123; //省略的代码 &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, preventDefault: function(event)&#123; if (event.preventDefault)&#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function(element, type, handler)&#123; //省略的代码 &#125;, stopPropagation: function(event)&#123; if (event.stopPropagation)&#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;; 以上代码显示，我们为 EventUtil 添加了 4 个新方法。第一个是 getEvent() ，它返回对 event 对象的引用。考虑到 IE 中事件对象的位置不同，可以使用这个方法来取得 event 对象，而不必担心指定事件处理程序的方式。在使用这个方法时，必须假设有一个事件对象传入到事件处理程序中，而且要把该变量传给这个方法，如下所示。 123btn.onclick = function(event)&#123; event = EventUtil.getEvent(event);&#125;; 在兼容 DOM 的浏览器中， event 变量只是简单地传入和返回 。而 在 IE 中， event 参数是未定义的（undefined），因此就会返回 window.event 。将这一行代码添加到事件处理程序的开头，就可以确保随时都能使用 event 对象，而不必担心用户使用的是什么浏览器。 第二个方法是 getTarget() ，它返回事件的目标。在这个方法内部，会检测 event 对象的 target 属性，如果存在则返回该属性的值；否则，返回 srcElement 属性的值。可以像下面这样使用这个方法。 1234btn.onclick = function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);&#125;; 第三个方法是 preventDefault() ，用于取消事件的默认行为。在传入 event 对象后，这个方法会检查是否存在 preventDefault() 方法，如果存在则调用该方法。如果 preventDefault() 方法不存在，则将 returnValue 设置为 false 。下面是使用这个方法的例子。 12345var link = document.getElementById("myLink");link.onclick = function(event)&#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event);&#125;; 以上代码可以确保在所有浏览器中单击该链接都不会打开另一个页面。首先，使用 EventUtil.getEvent() 取得 event 对象，然后将其传入到 EventUtil.preventDefault() 以取消默认行为。 第四个方法是 stopPropagation() ，其实现方式类似。首先尝试使用 DOM 方法阻止事件流，否则就使用 cancelBubble 属性。下面看一个例子。 123456789var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123; alert("Clicked"); event = EventUtil.getEvent(event); EventUtil.stopPropagation(event);&#125;;document.body.onclick = function(event)&#123; alert("Body clicked");&#125;; 在此，首先使用 EventUtil.getEvent() 取得了 event 对象，然后又将其传入到 EventUtil.stopPropagation() 。别忘了由于 IE 不支持事件捕获，因此 这个方法在跨浏览器的情况下，也只能用来阻止事件冒泡 。 事件类型Web 浏览器中可能发生的事件有很多类型。如前所述，不同的事件类型具有不同的信息，而“DOM3 级事件”规定了以下几类事件。 UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层 DOM 结构发生变化时触发。 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们，因此本章不做介绍。 除了这几类事件之外，HTML5 也定义了一组事件，而有些浏览器还会在 DOM 和 BOM 中实现其他专有事件。这些专有的事件一般都是根据开发人员需求定制的，没有什么规范，因此不同浏览器的实现有可能不一致。 DOM3 级事件模块在 DOM2 级事件模块基础上重新定义了这些事件，也添加了一些新事件。包括IE9 在内的所有主流浏览器都支持 DOM2 级事件。IE9 也支持 DOM3 级事件。 UI事件UI 事件指的是那些不一定与用户操作有关的事件 。这些事件在 DOM 规范出现之前，都是以这种或那种形式存在的，而在 DOM规范中保留是为了向后兼容。现有的 UI 事件如下。 DOMActivate ：表示元素已经被用户操作（通过鼠标或键盘）激活。这个事件在 DOM3 级事件中被废弃，但 Firefox 2+和 Chrome 支持它。考虑到不同浏览器实现的差异，不建议使用这个事件。 load ：当页面完全加载后在 window 上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在 &lt;img&gt; 元素上面触发，或者当嵌入的内容加载完毕时在 &lt;object&gt;元素上面触发。 unload ：当页面完全卸载后在 window 上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在 &lt;object&gt; 元素上面触发。 abort ：在用户停止下载过程时，如果嵌入的内容没有加载完，则在 &lt;object&gt;元素上面触发。 error ：当发生 JavaScript 错误时在 window 上面触发，当无法加载图像时在 &lt;img&gt; 元素上面触发，当无法加载嵌入内容时在 &lt;object&gt; 元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。第 17 章将继续讨论这个事件。 select ：当用户选择文本框（&lt;input&gt; 或 &lt;texterea&gt; ）中的一或多个字符时触发。第 14 章将继续讨论这个事件。 resize ：当窗口或框架的大小变化时在 window 或框架上面触发。 scroll ：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。&lt;body&gt; 元素中包含所加载页面的滚动条。多数这些事件都与 window 对象或表单控件相关。 除了 DOMActivate 之外，其他事件在 DOM2级事件中都归为 HTML 事件（ DOMActivate 在 DOM2 级中仍然属于 UI 事件）。要确定浏览器是否支持 DOM2 级事件规定的 HTML 事件 ，可以使用如下代码： 1var isSupported = document.implementation.hasFeature("HTMLEvents", "2.0"); 注意，只有根据“DOM2 级事件”实现这些事件的浏览器才会返回 true 。而 以非标准方式支持这些事件的浏览器则会返回 false 。要确定浏览器是否支持“DOM3 级事件”定义的事件 ，可以使用如下代码： 1var isSupported = document.implementation.hasFeature("UIEvent", "3.0"); load 事件JavaScript 中最常用的一个事件就是 load 。当页面完全加载后（包括所有图像、JavaScript 文件、CSS 文件等外部资源），就会触发 window 上面的 load 事件 。有两种定义 onload 事件处理程序的方式 。第一种方式是使用如下所示的 JavaScript 代码： 123EventUtil.addHandler(window, "load", function(event)&#123; alert("Loaded!");&#125;); 这是 通过 JavaScript 来指定事件处理程序的方式 ，使用了本章前面定义的跨浏览器的 EventUtil对象 。与添加其他事件一样，这里也给事件处理程序传入了一个 event 对象。这个 event 对象中不包含有关这个事件的任何附加信息，但在兼容 DOM 的浏览器中， event.target 属性的值会被设置为 document ，而 IE 并不会为这个事件设置 srcElement 属性 。 第二种指定 onload 事件处理程序的方式是 为 &lt;body&gt; 元素添加一个 onload 特性 ，如下面的例子所示： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Load Event Example&lt;/title&gt; &lt;/head&gt; &lt;body onload="alert('Loaded!')"&gt; &lt;/body&gt;&lt;/html&gt; 一般来说，在 window 上面发生的任何事件都可以在 &lt;body&gt; 元素中通过相应的特性来指定 ，因为 在 HTML 中无法访问 window 元素 。实际上，这只是为了保证向后兼容的一种权宜之计 ，但 所有浏览器都能很好地支持这种方式 。我们建议读者 尽可能使用 JavaScript 方式 。 根据“DOM2 级事件”规范，应该在 document 而非 window 上面触发 load 事件 。但是，所有浏览器都在 window 上面实现了该事件，以确保向后兼容。 图像上面也可以触发 load 事件 ，无论是在 DOM 中的图像元素还是 HTML 中的图像元素 。因此，可以在 HTML 中为任何图像指定 onload 事件处理程序，例如： 1&lt;img src="smile.gif" onload="alert('Image loaded.')"&gt; 这样，当例子中的图像加载完毕后就会显示一个警告框。同样的功能也可以 使用 JavaScript 来实现 ，例如： 12345var image = document.getElementById("myImage");EventUtil.addHandler(image, "load", function(event)&#123; event = EventUtil.getEvent(event); alert(EventUtil.getTarget(event).src);&#125;); 这里，使用 JavaScript 指定了 onload 事件处理程序。同时也传入了 event 对象，尽管它也不包含什么有用的信息。不过，事件的目标是 &lt;img&gt; 元素，因此可以通过 src 属性访问并显示该信息。 在创建新的 &lt;img&gt; 元素时，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，最重要的是要在指定 src 属性之前先指定事件 ，如下面的例子所示。 123456789EventUtil.addHandler(window, "load", function()&#123; var image = document.createElement("img"); EventUtil.addHandler(image, "load", function(event)&#123; event = EventUtil.getEvent(event); alert(EventUtil.getTarget(event).src); &#125;); document.body.appendChild(image); image.src = "smile.gif";&#125;); 在这个例子中，首先为 window 指定了 onload 事件处理程序。原因在于，我们是想向 DOM中添加一个新元素，所以必须确定页面已经加载完毕——如果在页面加载前操作 document.body 会导致错误。然后，创建了一个新的图像元素，并设置了其 onload 事件处理程序。最后又将这个图像添加到页面中，还设置了它的 src 属性。这里有一点需要格外注意：新图像元素不一定要从添加到文档后才开始下载，只要设置了 src 属性就会开始下载。 同样的功能也可以通过 使用 DOM0 级的 Image 对象实现 。在 DOM 出现之前，开发人员经常使用Image 对象在客户端预先加载图像。可以像使用 &lt;img&gt; 元素一样使用 Image 对象，只不过无法将其添加到 DOM 树中。下面来看一个例子。 1234567EventUtil.addHandler(window, "load", function()&#123; var image = new Image(); EventUtil.addHandler(image, "load", function(event)&#123; alert("Image loaded!"); &#125;); image.src = "smile.gif";&#125;); 在此，我们使用 Image 构造函数创建了一个新图像的实例，然后又为它指定了事件处理程序。有的浏览器将 Image 对象实现为 &lt;img&gt; 元素，但并非所有浏览器都如此，所以最好将它们区别对待。 在不属于 DOM文档的图像（包括未添加到文档的 &lt;img&gt; 元素和 Image 对象）上触发 load 事件时，IE8 及之前版本不会生成 event 对象。IE9 修复了这个问题。 还有一些元素也以非标准的方式支持 load 事件。在 IE9+、Firefox、Opera、Chrome和 Safari 3+及更高版本中， &lt;script&gt; 元素也会触发 load 事件，以便开发人员确定动态加载的 JavaScript 文件是否加载完毕。与图像不同，只有在设置了 &lt;script&gt; 元素的 src 属性并将该元素添加到文档后，才会开始下载 JavaScript 文件。换句话说，对于 &lt;script&gt; 元素而言，指定 src 属性和指定事件处理程序的先后顺序就不重要了 。以下代码展示了怎样为 &lt;script&gt; 元素指定事件处理程序。 12345678EventUtil.addHandler(window, "load", function()&#123; var script = document.createElement("script"); EventUtil.addHandler(script, "load", function(event)&#123; alert("Loaded"); &#125;); script.src = "example.js"; document.body.appendChild(script);&#125;); 这个例子使用了跨浏览器的 EventUtil 对象为新创建的 &lt;script&gt; 元素指定了 onload 事件处理程序。此时，大多数浏览器中 event 对象的 target 属性引用的都是 &lt;script&gt; 节点，而在 Firefox 3 之前的版本中，引用的则是 document 。IE8 及更早版本不支持 &lt;script&gt; 元素上的 load 事件。 IE 和 Opera 还支持 &lt;link&gt; 元素上的 load 事件，以便开发人员确定样式表是否加载完毕。例如： 12345678910EventUtil.addHandler(window, "load", function()&#123; var link = document.createElement("link"); link.type = "text/css"; link.rel= "stylesheet"; EventUtil.addHandler(link, "load", function(event)&#123; alert("css loaded"); &#125;); link.href = "example.css"; document.getElementsByTagName("head")[0].appendChild(link);&#125;); 与 &lt;script&gt; 节点类似，在未指定 href 属性并将 &lt;link&gt; 元素添加到文档之前也不会开始下载样式表 。 unload 事件与 load 事件对应的是 unload 事件 ，这个事件在文档被完全卸载后触发 。只要用户从一个页面切换到另一个页面，就会发生 unload 事件 。而 利用这个事件最多的情况是清除引用 ，以避免内存泄漏 。 与 load 事件类似，也有两种指定 onunload 事件处理程序的方式。第一种方式是 使用 JavaScript ，如下所示： 123EventUtil.addHandler(window, "unload", function(event)&#123; alert("Unloaded");&#125;); 此时生成的 event 对象在兼容 DOM 的浏览器中只包含 target 属性（值为 document ）。IE8 及前版本则为这个事件对象提供了 srcElement 属性。指定事件处理程序的第二种方式，也是 为 &lt;body&gt; 元素添加一个特性（与 load 事件相似），如下面的例子所示： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Unload Event Example&lt;/title&gt; &lt;/head&gt; &lt;body onunload="alert('Unloaded!')"&gt; &lt;/body&gt;&lt;/html&gt; 无论使用哪种方式，都要小心编写 onunload 事件处理程序中的代码 。既然 unload 事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。此时，操作 DOM节点或者元素的样式就会导致错误。 根据“DOM2 级事件”，应该在 &lt;body&gt; 元素而非 window 对象上面触发 unload 事件。不过，所有浏览器都在 window 上实现了 unload 事件，以确保向后兼容。 resize 事件当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件 。这个事件在 window （窗口）上面触发 ，因此 可以通过 JavaScript 或者 &lt;body&gt; 元素中的 onresize 特性 来 指定事件处理程序 。如前所述，我们还是推荐使用如下所示的 JavaScript 方式 ： 123EventUtil.addHandler(window, "resize", function(event)&#123; alert("Resized");&#125;); 与其他发生在 window 上的事件类似，在兼容 DOM 的浏览器中，传入事件处理程序中的 event 对象有一个 target 属性，值为 document ；而 IE8 及之前版本则未提供任何属性。 关于何时会触发 resize 事件，不同浏览器有不同的机制。IE、Safari、Chrome 和 Opera 会在浏览器窗口变化了 1 像素时就触发 resize 事件，然后 随着变化不断重复触发 。Firefox 则只会在用户停止调整窗口大小时才会触发 resize 事件 。由于存在这个差别，应该 注意不要在这个事件的处理程序中加入大计算量的代码 ，因为这些代码有可能被频繁执行，从而导致浏览器反应明显变慢。 浏览器窗口最小化或最大化时也会触发 resize 事件 。 scroll 事件虽然 scroll 事件是在 window 对象上发生的 ，但它实际表示的则是页面中相应元素的变化 。在 混杂模式 下，可以 通过 &lt;body&gt; 元素的 scrollLeft 和 scrollTop 来监控到这一变化 ；而在 标准模式 下，除 Safari 之外的所有浏览器都会通过 &lt;html&gt; 元素来反映这一变化（Safari 仍然基于 跟踪滚动位置），如下面的例子所示： 1234567EventUtil.addHandler(window, "scroll", function(event)&#123; if (document.compatMode == "CSS1Compat")&#123; alert(document.documentElement.scrollTop); &#125; else &#123; alert(document.body.scrollTop); &#125;&#125;); 以上代码指定的事件处理程序会输出页面的垂直滚动位置——根据呈现模式不同使用了不同的元素。由于 Safari 3.1 之前的版本不支持 document.compatMode ，因此旧版本的浏览器就会满足第二个条件。与 resize 事件类似， scroll 事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件处理程序的代码简单。 焦点事件焦点事件会在页面元素获得或失去焦点时触发 。利用这些事件并与 document.hasFocus() 方法及 document.activeElement 属性配合 ，可以知晓用户在页面上的行踪 。有以下 6 个焦点事件。 blur ：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 DOMFocusIn ：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。只有Opera 支持这个事件。DOM3 级事件废弃了 DOMFocusIn ，选择了 focusin 。 DOMFocusOut ：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版本。只有 Opera支持这个事件。DOM3 级事件废弃了 DOMFocusOut ，选择了 focusout 。 focus ：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 focusin ：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。支持这个事件的浏览器有 IE5.5+、Safari 5.1+、Opera 11.5+和 Chrome。 focusout ：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版本。支持这个事件的浏览器有 IE5.5+、Safari 5.1+、Opera 11.5+和 Chrome。 这一类事件中最主要的两个是 focus 和 blur ，它们都是 JavaScript 早期就得到所有浏览器支持的事件。这些事件的最大问题是它们不冒泡 。因此，IE 的 focusin 和 focusout 与 Opera 的 DOMFocusIn 和 DOMFocusOut 才会发生重叠。IE 的方式最后被 DOM3 级事件采纳为标准方式。 当焦点从页面中的一个元素移动到另一个元素 ，会 依次触发下列事件 ： focusout 在失去焦点的元素上触发； focusin 在获得焦点的元素上触发； blur 在失去焦点的元素上触发； DOMFocusOut 在失去焦点的元素上触发； focus 在获得焦点的元素上触发； DOMFocusIn 在获得焦点的元素上触发。 其中， blur 、 DOMFocusOut 和 focusout 的事件目标是失去焦点的元素；而 focus 、 DOMFocusIn 和 focusin 的事件目标是获得焦点的元素。 要 确定浏览器是否支持这些事件 ，可以使用如下代码： 1var isSupported = document.implementation.hasFeature("FocusEvent", "3.0"); 即使 focus 和 blur 不冒泡，也可以在捕获阶段侦听到它们。Peter-Paul Koch就此写过一篇非常棒的文章：www.quirksmode.org/blog/archives/2008/04/delegating_the.html。 鼠标与滚轮事件鼠标事件是 Web 开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。DOM3 级事件中定义了 9 个鼠标事件，简介如下。 click ：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保易访问性很重要，意味着 onclick 事件处理程序既可以通过键盘也可以通过鼠标执行。 dblclick ：在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不是 DOM2 级事件规范中规定的，但鉴于它得到了广泛支持，所以 DOM3 级事件将其纳入了标准。 mousedown ：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。 mouseenter ：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它纳入了规范。IE、Firefox 9+和 Opera 支持这个事件。 mouseleave ：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它纳入了规范。IE、Firefox 9+和 Opera 支持这个事件。 mousemove ：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。 mouseout ：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。 mouseover ：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。 mouseup ：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。 页面上的所有元素都支持鼠标事件 。除了 mouseenter 和 mouseleave ，所有鼠标事件都会冒泡 ，可以被取消 ，而取消鼠标事件将会影响浏览器的默认行为 。取消鼠标事件的默认行为还会影响其他事件 ，因为 鼠标事件与其他事件是密不可分的关系 。 只有在同一个元素上相继触发 mousedown 和 mouseup 事件，才会触发 click 事件 ；如果 mousedown 或 mouseup 中的一个被取消，就不会触发 click 事件 。类似地，只有触发两次 click 事件 ，才会触发一次 dblclick 事件 。如果 有代码阻止了连续两次触发 click 事件 （可能是直接取消 click 事件，也可能通过取消 mousedown 或 mouseup 间接实现），那么 就不会触发 dblclick 事件了 。这 4 个事件触发的顺序始终如下： 1234567(1) mousedown(2) mouseup(3) click(4) mousedown(5) mouseup(6) click(7) dblclick 显然， click 和 dblclick 事件都会依赖于其他先行事件的触发；而 mousedown 和 mouseup 则不受其他事件的影响。 IE8 及之前版本中的实现有一个小 bug，因此在双击事件中，会跳过第二个 mousedown 和 click事件，其顺序如下： 12345(1) mousedown(2) mouseup(3) click(4) mouseup(5) dblclick IE9 修复了这个 bug，之后顺序就正确了。 使用以下代码可以 检测浏览器是否支持以上 DOM2 级事件（除 dbclick 、 mouseenter 和 mouseleave 之外）： 1var isSupported = document.implementation.hasFeature("MouseEvents", "2.0"); 要检测浏览器是否支持上面的所有事件 ，可以使用以下代码： 1var isSupported = document.implementation.hasFeature("MouseEvent", "3.0") 注意，DOM3 级事件的 feature 名是 “MouseEvent” ，而非 “MouseEvents” 。 鼠标事件中还有一类滚轮事件 。而说是一类事件，其实就是一个 mousewheel 事件 。这个事件跟踪鼠标滚轮，类似于 Mac 的触控板。 客户区坐标位置鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的 clientX 和 clientY 属性中。所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。下图展示了视口中客户区坐标位置的含义。 可以使用类似下列代码 取得鼠标事件的客户端坐标信息 ： 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event)&#123; event = EventUtil.getEvent(event); alert("Client coordinates: " + event.clientX + "," + event.clientY);&#125;); 这里为一个 &lt;div&gt; 元素指定了 onclick 事件处理程序。当用户单击这个元素时，就会看到事件的客户端坐标信息。注意，这些值中不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。 页面坐标位置通过客户区坐标能够知道鼠标是在视口中什么位置发生的 ，而 页面坐标通过事件对象的 pageX 和 pageY 属性 ，能告诉你事件是在页面中的什么位置发生的 。换句话说， 这两个属性表示鼠标光标在页面中的位置 ，因此 坐标是从页面本身而非视口的左边和顶边计算的 。 以下代码可以 取得鼠标事件在页面中的坐标 ： 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event)&#123; event = EventUtil.getEvent(event); alert("Page coordinates: " + event.pageX + "," + event.pageY);&#125;); 在页面没有滚动的情况下 ，pageX 和 pageY 的值与 clientX 和 clientY 的值相等。 IE8 及更早版本不支持事件对象上的页面坐标 ，不过使用客户区坐标和滚动信息可以计算出来 。这时候 需要用到 document.body （混杂模式）或 document.documentElement （标准模式）中的 scrollLeft 和 scrollTop 属性 。计算过程如下所示： 123456789101112131415161718var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event)&#123; event = EventUtil.getEvent(event); var pageX = event.pageX, pageY = event.pageY; if (pageX === undefined)&#123; pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft); &#125; if (pageY === undefined)&#123; pageY = event.clientY + (document.body.scrollTop || document.documentElement.scrollTop); &#125; alert("Page coordinates: " + pageX + "," + pageY);&#125;); 屏幕坐标位置 鼠标事件发生时 ，不仅 会有相对于浏览器窗口的位置 ，还有 一个相对于整个电脑屏幕的位置 。而 通过 screenX 和 screenY 属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息 。下图展示了浏览器中屏幕坐标的含义。 可以使用类似下面的代码 取得鼠标事件的屏幕坐标 ： 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event)&#123; event = EventUtil.getEvent(event); alert("Screen coordinates: " + event.screenX + "," + event.screenY);&#125;); 与前一个例子类似，这里也是为 &lt;div&gt; 元素指定了一个 onclick 事件处理程序。当这个元素被单击时，就会显示出事件的屏幕坐标信息了。 修改键虽然 鼠标事件主要是使用鼠标来触发的 ，但 在按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作 。这些修改键就是 Shift、Ctrl、Alt 和 Meta（在 Windows键盘中是 Windows键，在苹果机中是 Cmd 键），它们经常被用来修改鼠标事件的行为。DOM 为此规定了 4 个属性，表示这些修改键的状态：shiftKey 、 ctrlKey 、 altKe 和 metaKey 。这些属性中包含的都是布尔值，如果相应的键被按下了 ，则 值为 true ，否则 值为 false 。当某个鼠标事件发生时 ，通过检测这几个属性就可以确定用户是否同时按下了其中的键 。来看下面的例子。 1234567891011121314151617181920212223var div = document.getElementById("myDiv");EventUtil.addHandler(div, "click", function(event)&#123; event = EventUtil.getEvent(event); var keys = new Array(); if (event.shiftKey)&#123; keys.push("shift"); &#125; if (event.ctrlKey)&#123; keys.push("ctrl"); &#125; if (event.altKey)&#123; keys.push("alt"); &#125; if (event.metaKey)&#123; keys.push("meta"); &#125; alert("Keys: " + keys.join(","));&#125;); 在这个例子中，我们通过一个 onclick 事件处理程序检测了不同修改键的状态。数组 keys 中包含着被按下的修改键的名称。换句话说，如果有属性值为 true ，就会将对应修改键的名称添加到 keys数组中。在事件处理程序的最后，有一个警告框将检测到的键的信息显示给用户。 IE9、Firefox、Safari、Chrome和 Opera 都支持这 4 个键。IE8 及之前版本不支持 metaKey 属性。 相关元素在发生 mouseover 和 mouserout 事件时，还会涉及更多的元素 。这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。对 mouseover 事件 而言，事件的主目标是 获得光标的元素 ，而 相关元素就是那个失去光标的元素 。类似地，对 mouseout 事件 而言，事件的主目标是 失去光标的元素 ，而 相关元素则是获得光标的元素** 。来看下面的例子。 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Related Elements Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv" style="background-color:red;height:100px;width:100px;" &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这个例子会在页面上显示一个 &lt;div&gt; 元素。如果鼠标指针一开始位于这个 &lt;div&gt; 元素上，然后移出了这个元素，那么就会在 &lt;div&gt; 元素上触发 mouseout 事件，相关元素就是 &lt;body&gt; 元素。与此同时，&lt;body&gt; 元素上面会触发 mouseover 事件，而相关元素变成了 &lt;div&gt; 。 DOM 通过 event 对象的 relatedTarget 属性提供了相关元素的信息 。这个属性只对于 mouseover 和 mouseout 事件才包含值 ；对于其他事件，这个属性的值是 null 。IE8及之前版本不支持 relatedTarget 属性，但提供了保存着同样信息的不同属性。在 mouseover 事件触发时，IE的 fromElement 属性中保存了相关元素；在 mouseout 事件触发时，IE的 toElement 属性中保存着相关元素。（IE9支持所有这些属性。）可以把下面这个跨浏览器取得相关元素的方法添加到 EventUtil 对象中。 12345678910111213141516171819var EventUtil = &#123; //省略了其他代码 getRelatedTarget: function(event)&#123; if (event.relatedTarget)&#123; return event.relatedTarget; &#125; else if (event.toElement)&#123; return event.toElement; &#125; else if (event.fromElement)&#123; return event.fromElement; &#125; else &#123; return null; &#125; &#125;, //省略了其他代码&#125;; 与以前添加的跨浏览器方法一样，这个方法也使用了特性检测来确定返回哪个值 。可以像下面这样使用 EventUtil.getRelatedTarget() 方法： 1234567var div = document.getElementById("myDiv");EventUtil.addHandler(div, "mouseout", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var relatedTarget = EventUtil.getRelatedTarget(event); alert("Moused out of " + target.tagName + " to " + relatedTarget.tagName);&#125;); 这个例子为 &lt;div&gt; 元素的 mouseout 事件注册了一个事件处理程序。当事件触发时，会有一个警告框显示鼠标移出和移入的元素信息。 鼠标按钮只有在主鼠标按钮被单击（或键盘回车键被按下）时才会触发 click 事件 ，因此检测按钮的信息并不是必要的。但 对于 mousedown 和 mouseup 事件来说，则在其 event 对象存在一个 button 属性 ，表示 按下或释放的按钮 。DOM 的 button 属性可能有如下 3 个值： 0 表示主鼠标按钮 ， 1 表示中间的鼠标按钮（鼠标滚轮按钮）， 2 表示次鼠标按钮 。在常规的设置中，主鼠标按钮就是鼠标左键 ，而 次鼠标按钮就是鼠标右键 。 IE8 及之前版本也提供了 button 属性，但这个属性的值与 DOM 的 button 属性有很大差异。 0 ：表示没有按下按钮。 1 ：表示按下了主鼠标按钮。 2 ：表示按下了次鼠标按钮。 3 ：表示同时按下了主、次鼠标按钮。 4 ：表示按下了中间的鼠标按钮。 5 ：表示同时按下了主鼠标按钮和中间的鼠标按钮。 6 ：表示同时按下了次鼠标按钮和中间的鼠标按钮。 7 ：表示同时按下了三个鼠标按钮。 不难想见，DOM模型下的 button 属性比 IE 模型下的 button 属性更简单也更为实用，因为同时按下多个鼠标按钮的情形十分罕见。最常见的做法就是将 IE 模型规范化为 DOM 方式，毕竟除 IE8 及更早版本之外的其他浏览器都原生支持 DOM模型。而对主、中、次按钮的映射并不困难，只要将 IE 的其他选项分别转换成如同按下这三个按键中的一个即可（同时将主按钮作为优先选取的对象）。换句话说，IE 中返回的 5 和 7 会被转换成 DOM 模型中的 0 。 由于单独使用能力检测无法确定差异（两种模型有同名的 button 属性），因此必须另辟蹊径。我们知道，支持 DOM 版鼠标事件的浏览器可以通过 hasFearture() 方法来检测 ，所以可以再为 EventUtil 对象添加如下 getButton() 方法。 123456789101112131415161718192021222324252627var EventUtil = &#123; //省略了其他代码 getButton: function(event)&#123; if (document.implementation.hasFeature("MouseEvents", "2.0"))&#123; return event.button; &#125; else &#123; switch(event.button)&#123; case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1; &#125; &#125; &#125;, //省略了其他代码&#125;; 通过检测 “MouseEvents” 这个特性，就可以确定 event 对象中存在的 button 属性中是否包含正确的值。如果测试失败，说明是 IE，就必须对相应的值进行规范化。以下是使用该方法的示例。 12345var div = document.getElementById("myDiv");EventUtil.addHandler(div, "mousedown", function(event)&#123; event = EventUtil.getEvent(event); alert(EventUtil.getButton(event));&#125;); 在这个例子中，我们为一个 &lt;div&gt; 元素添加了一个 onmousedown 事件处理程序。当在这个元素上按下鼠标按钮时，会有警告框显示按钮的代码。 在使用 onmouseup 事件处理程序时， button 的值表示释放的是哪个按钮 。此外，如果不是按下或释放了主鼠标按钮，Opera 不会触发 mouseup 或 mousedown 事件。 更多的事件信息“DOM2 级事件”规范在 event 对象中还提供了 detail 属性 ，用于 给出有关事件的更多信息 。对于鼠标事件来说， detail 中包含了一个数值 ，表示 在给定位置上发生了多少次单击 。在同一个元素上相继地发生一次 mousedown 和一次 mouseup 事件算作一次单击。 detail 属性从 1 开始计数，每次单击发生后都会递增。如果鼠标在 mousedown 和 mouseup 之间移动了位置，则 detail 会被重置为 0 。 IE 也通过下列属性为鼠标事件提供了更多信息。 altLeft ：布尔值，表示是否按下了 Alt键。如果 altLeft 的值为 true ，则 altKey 的值也为 true 。 ctrlLeft ：布尔值，表示是否按下了 Ctrl 键。如果 ctrlLeft 的值为 true ，则 ctrlKey 的值也为 true 。 offsetX ：光标相对于目标元素边界的 x 坐标。 offsetY ：光标相对于目标元素边界的 y 坐标。 shiftLeft ：布尔值，表示是否按下了 Shift 键。如果 shiftLeft 的值为 true ，则 shiftKey的值也为 true 。 这些属性的用处并不大，原因一方面是只有 IE 支持它们，另一方是它们提供的信息要么没有什么价值，要么可以通过其他方式计算得来。 鼠标滚轮事件IE 6.0 首先实现了 mousewheel 事件 。此后，Opera、Chrome 和 Safari 也都实现了这个事件。当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel 事件 。这个事件可以在任何元素上面触发，最终会冒泡到 document （IE8）或 window （IE9、Opera、Chrome 及 Safari）对象。与 mousewheel 事件对应的 event 对象除包含鼠标事件的所有标准信息外，还包含一个特殊的 wheelDelta 属性。当用户向前滚动鼠标滚轮时， wheelDelta 是 120 的倍数；当用户向后滚动鼠标滚轮时， wheelDelta 是 -120 的倍数。下图展示了这个属性。 将 mousewheel 事件处理程序指定给页面中的任何元素或 document 对象，即可处理鼠标滚轮的交互操作。来看下面的例子。 1234EventUtil.addHandler(document, "mousewheel", function(event)&#123; event = EventUtil.getEvent(event); alert(event.wheelDelta);&#125;); 这个例子会在发生 mousewheel 事件时显示 wheelDelta 的值。多数情况下，只要知道鼠标滚轮滚动的方向就够了 ，而 这通过检测 wheelDelta 的正负号就可以确定 。 有一点要注意：在 Opera 9.5 之前的版本中， wheelDelta 值的正负号是颠倒的。如果你打算支持早期的 Opera 版本，就需要使用浏览器检测技术来确定实际的值，如下面的例子所示。 12345EventUtil.addHandler(document, "mousewheel", function(event)&#123; event = EventUtil.getEvent(event); var delta = (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); alert(delta);&#125;); 以上代码使用第 9 章创建的 client 对象检测了浏览器是不是早期版本的 Opera。 由于 mousewheel 事件非常流行，而且所有浏览器都支持它，所以 HTML 5 也加入了该事件。 Firefox 支持一个名为 DOMMouseScroll 的类似事件，也是在鼠标滚轮滚动时触发。与 mousewheel 事件一样， DOMMouseScroll 也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。而有关鼠标滚 轮的信息则保存在 detail 属性中，当向前滚动鼠标滚轮时，这个属性的值是 -3 的倍数，当向后滚动鼠标滚轮时，这个属性的值是 3 的倍数。x下图展示了这个属性。 可以将 DOMMouseScroll 事件添加到页面中的任何元素 ，而且 该事件会冒泡到 window 对象 。因此，可以像下面这样针对这个事件来添加事件处理程序。 1234EventUtil.addHandler(window, "DOMMouseScroll", function(event)&#123; event = EventUtil.getEvent(event); alert(event.detail);&#125;); 这个简单的事件处理程序会在 鼠标滚轮滚动时显示 detail 属性的值 。 若要给出跨浏览器环境下的解决方案，第一步就是创建一个能够取得鼠标滚轮增量值（delta）的方法。下面是我们添加到 EventUtil 对象中的这个方法。 1234567891011121314var EventUtil = &#123; //省略了其他代码 getWheelDelta: function(event)&#123; if (event.wheelDelta)&#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail * 40; &#125; &#125;, //省略了其他代码&#125;; 这里， getWheelDelta() 方法首先检测了事件对象是否包含 wheelDelta 属性，如果是则通过浏览器检测代码确定正确的值。如果 wheelDelta 不存在，则假设相应的值保存在 detail 属性中。由于 Firefox 的值有所不同，因此首先要将这个值的符号反向，然后再乘以 40，就可以保证与其他浏览器的值相同了。有了这个方法之后，就可以将相同的事件处理程序指定给 mousewheel 和 DOMMouseScroll 事件了，例如： 1234567891011(function()&#123; function handleMouseWheel(event)&#123; event = EventUtil.getEvent(event); var delta = EventUtil.getWheelDelta(event); alert(delta); &#125; EventUtil.addHandler(document, "mousewheel", handleMouseWheel); EventUtil.addHandler(document, "DOMMouseScroll", handleMouseWheel);&#125;)(); 我们将相关代码放在了一个私有作用域中，从而不会让新定义的函数干扰全局作用域。这里定义的 handleMouseWheel() 函数可以用作两个事件的处理程序（如果指定的事件不存在，则为该事件指定处理程序的代码就会静默地失败）。由于使用了 EventUtil.getWheelDelta() 方法，我们定义的这个事件处理程序函数可以适用于任何一种情况。 触摸设备iOS 和 Android 设备的实现非常特别，因为这些设备没有鼠标 。在面向 iPhone 和 iPod 中的 Safari 开发时，要记住以下几点。 不支持 dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。 轻击可单击元素会触发 mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生 mousedown 、 mouseup 和 click 事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了 onclick 事件处理程序的元素。 mousemove 事件也会触发 mouseover 和 mouseout 事件。 两个手指放在屏幕上且页面随手指移动而滚动时会触发 mousewheel 和 scroll 事件。 无障碍性问题如果你的 Web 应用程序或网站要确保残疾人特别是那些使用屏幕阅读器的人都能访问，那么在使用鼠标事件时就要格外小心。前面提到过，可以通过键盘上的回车键来触发 click 事件，但其他鼠标事件却无法通过键盘来触发。为此，我们 不建议使用 click 之外的其他鼠标事件来展示功能或引发代码执行 。因为 这样会给盲人或视障用户造成极大不 。以下是在使用鼠标事件时应当注意的几个易访问性问题。 使用 click 事件执行代码。有人指出通过 onmousedown 执行代码会让人觉得速度更快，对视力正常的人来说这是没错的。但是，在屏幕阅读器中，由于无法触发 mousedown 事件，结果就会造成代码无法执行。 不要使用 onmouseover 向用户显示新的选项。原因同上，屏幕阅读器无法触发这个事件。如果确实非要通过这种方式来显示新选项，可以考虑添加显示相同信息的键盘快捷方式。 不要使用 dblclick 执行重要的操作。键盘无法触发这个事件。 遵照以上提示可以极大地提升残疾人在访问你的 Web 应用程序或网站时的易访问性。 要了解如何在网页中实现无障碍访问的内容，请访问 www.webaim.org 和 http://yaccessibilityblog.com/ 。 键盘与文本事件用户在使用键盘时会触发键盘事件。“DOM2 级事件”最初规定了键盘事件，但在最终定稿之前又删除了相应的内容。结果，对键盘事件的支持主要遵循的是 DOM0 级 。 “DOM3 级事件”为键盘事件制定了规范，IE9 率先完全实现了该规范。其他浏览器也在着手实现这一标准，但仍然有很多遗留的问题。 有 3 个键盘事件，简述如下。 keydown ：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。 keypress ：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下 Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发 keypress事件。 keyup ：当用户释放键盘上的键时触发。 虽然所有元素都支持以上 3 个事件，但只有在用户通过文本框输入文本时才最常用到 。 只有一个文本事件： textInput 。这个事件是对 keypress 的补充，用意是在将文本显示给用户之前更容易拦截文本。在文本插入文本框之前会触发 textInput 事件 。 在用户 按了一下键盘上的字符键 时，首先会 触发 keydown 事件 ，然后 紧跟着是 keypress 事件 ，最后会 触发 keyup 事件 。其中， keydown 和 keypress 都是在文本框发生变化之前被触发的 ；而 keyup事件则是在文本框已经发生变化之后被触发的 。如果 用户按下了一个字符键不放 ，就会重复触发 keydown 和 keypress 事件 ，直到用户松开该键为止 。 如果用户 按下的是一个非字符键 ，那么首先会 触发 keydown 事件 ，然后就是 keyup 事件。如果 按住这个非字符键不放 ，那么 就会一直重复触发 keydown 事件 ，直到用户松开这个键 ，此时会触发 keyup事件 。 键盘事件与鼠标事件一样，都支持相同的修改键。而且，键盘事件的事件对象中也有 shiftKey 、 ctrlKey 、 altKey 和 metaKey 属性。IE 不支持 metaKey 。 键码在发生 keydown 和 keyup 事件 时，event 对象的 keyCode 属性中会包含一个代码 ，与键盘上一个特定的键对应 。对数字字母字符键 ， keyCode 属性的值与 ASCII 码中对应小写字母或数字的编码相同 。因此，数字键 7 的 keyCode 值为 55 ，而 字母 A 键的 keyCode 值为 65 ——与 Shift 键的状态无关。DOM 和 IE 的 event 对象都支持 keyCode 属性。请看下面这个例子： 12345var textbox = document.getElementById("myText");EventUtil.addHandler(textbox, "keyup", function(event)&#123; event = EventUtil.getEvent(event); alert(event.keyCode);&#125;); 在这个例子中，用户每次在文本框中按键触发 keyup 事件时，都会显示 keyCode 的值。下表列出了所有非字符键的键码。 无论 keydown 或 keyup 事件都会存在的一些特殊情况 。在Firefox和Opera中，按分号键时 keyCode 值为 59，也就是 ASCII 中分号的编码；但 IE 和 Safari 返回 186，即键盘中按键的键码。 字符编码 发生 keypress 事件意味着按下的键会影响到屏幕中文本的显示 。在所有浏览器中，按下能够插入或删除字符的键都会触发 keypress 事件 ；按下其他键能否触发此事件因浏览器而异 。由于截止到 2008 年，尚无浏览器实现“DOM3 级事件”规范，所以浏览器之间的键盘事件并没有多大的差异。 IE9、Firefox、Chrome 和 Safari 的 event 对象都支持一个 charCode 属性 ，这个属性只有在发生 keypress 事件时才包含值 ，而且 这个值是按下的那个键所代表字符的 ASCII 编码 。此时的 keyCode 通常等于0或者也可能等于所按键的键码 。IE8及之前版本和 Opera 则是 在 keyCode 中保存字符的ASCII编码 。要想以跨浏览器的方式取得字符编码 ，必须首先检测 charCode 属性是否可用 ，如果不可用则使用 keyCode ，如下面的例子所示。 12345678910111213141516var EventUtil = &#123; //省略的代码 getCharCode: function(event)&#123; if (typeof event.charCode == "number")&#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, //省略的代码&#125;;EventUtil.js 这个方法首先检测 charCode 属性是否包含数值（在不支持这个属性的浏览器中，值为 undefined），如果是，则返回该值。否则，就返回 keyCode 属性值。下面是使用这个方法的示例。 12345var textbox = document.getElementById("myText");EventUtil.addHandler(textbox, "keypress", function(event)&#123; event = EventUtil.getEvent(event); alert(EventUtil.getCharCode(event));&#125;); 在取得了字符编码之后 ，就可以 使用 String.fromCharCode() 将其转换成实际的字符 。 DOM3 级变化尽管所有浏览器都实现了某种形式的键盘事件 ，DOM3 级事件还是做出了一些改变。比如，DOM3 级事件中的键盘事件 ，不再包含 charCode 属性 ，而是包含两个新属性： key 和 char 。 其中， key 属性是为了取代 keyCode 而新增的 ，它的 值是一个字符串 。在按下某个字符键 时， key 的值就是相应的文本字符（如“k”或“M”）；在按下非字符键 时，key 的值是相应键的名（如“Shift”或“Down”）。而 char 属性在按下字符键时的行为与 key 相同 ，但在按下非字符键时值为 null 。 IE9 支持 key 属性，但不支持 char 属性。Safari 5 和 Chrome 支持名为 keyIdentifier 的属性，在按下非字符键（例如 Shift）的情况下与 key 的值相同。对于字符键， keyIdentifier 返回一个格式类似“U+0000”的字符串，表示 Unicode 值。 12345678var textbox = document.getElementById("myText");EventUtil.addHandler(textbox, "keypress", function(event)&#123; event = EventUtil.getEvent(event); var identifier = event.key || event.keyIdentifier; if (identifier)&#123; alert(identifi er); &#125;&#125;); 由于存在跨浏览器问题，因此本书不推荐使用 key 、 keyIdentifier 或 char 。 DOM3 级事件还添加了一个名为 location 的属性 ，这是一个 数值 ，表示 按下了什么位置上的键 ：0 表示默认键盘，1 表示左侧位置（例如左位的 Alt 键），2 表示右侧位置（例如右侧的 Shift 键），3 表示数字小键盘 ，4 表示移动设备键盘（也就是虚拟键盘），5 表示手柄（如任天堂 Wii控制器）。IE9 支持这个属性。Safari 和 Chrome 支持名为 keyLocation 的等价属性，但即有 bug——值始终是 0，除非按下了数字键盘（此时，值 为 3）；否则，不会是 1、2、4、5。 12345678var textbox = document.getElementById("myText");EventUtil.addHandler(textbox, "keypress", function(event)&#123; event = EventUtil.getEvent(event); var loc = event.location || event.keyLocation; if (loc)&#123; alert(loc); &#125;&#125;); 与 key 属性一样，支持 location 的浏览器也不多，所以在跨浏览器开发中不推荐使用。 最后是给 event 对象添加了 getModifierState() 方法 。这个方法接收一个参数，即 等于 Shift 、Control 、 AltGraph 或 Meta 的字符串 ，表示要检测的修改键 。如果 指定的修改键是活动的（也就是处于被按下的状态），这个方法 返回 true ，否则返回 false 。 1234567var textbox = document.getElementById("myText");EventUtil.addHandler(textbox, "keypress", function(event)&#123; event = EventUtil.getEvent(event); if (event.getModifierState)&#123; alert(event.getModifierState("Shift"));&#125;&#125;); 实际上，通过 event 对象的 shiftKey 、 altKey 、 ctrlKey 和 metaKey 属性已经可以取得类似的属性了。IE9 是唯一支持 getModifierState() 方法的浏览器。 textInput 事件“DOM3 级事件”规范中引入了一个新事件，名叫 textInput 。根据规范，当用户在可编辑区域中输入字符 时，就会触发这个事件 。这个 用于替代 keypress 的 textInput 事件的行为稍有不同 。区别之一就是 任何可以获得焦点的元素都可以触发 keypress 事件 ，但 只有可编辑区域才能触发 textInput 事件 。区别之二是 textInput 事件只会在用户按下能够输入实际字符的键时才会被触发 ，而 keypress 事件则在按下那些能够影响文本显示的键时也会触发（例如退格键）。 由于 textInput 事件主要考虑的是字符 ，因此它的 event 对象中还包含一个 data 属性 ，这个属性的值就是用户输入的字符 （而非字符编码）。换句话说，用户在没有按上档键的情况下按下了 S 键，data 的值就是 “s” ，而如果在按住上档键时按下该键， data 的值就是 “S” 。 以下是一个使用 textInput 事件的例子： 12345var textbox = document.getElementById("myText");EventUtil.addHandler(textbox, "textInput", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data);&#125;); 在这个例子中，插入到文本框中的字符会通过一个警告框显示出来。 另外， event 对象上还有一个属性，叫 inputMethod ，表示把文本输入到文本框中的方式 。 0，表示浏览器不确定是怎么输入的。 1，表示是使用键盘输入的。 2，表示文本是粘贴进来的。 3，表示文本是拖放进来的。 4，表示文本是使用 IME 输入的。 5，表示文本是通过在表单中选择某一项输入的。 6，表示文本是通过手写输入的（比如使用手写笔）。 7，表示文本是通过语音输入的。 8，表示文本是通过几种方法组合输入的。 9，表示文本是通过脚本输入的。 使用这个属性可以确定文本是如何输入到控件中的 ，从而可以验证其有效性 。支持 textInput 属性的浏览器有 IE9+、Safari 和 Chrome。只有 IE 支持 inputMethod 属性。 设备中的键盘事件任天堂 Wii 会在用户按下 Wii 遥控器上的按键时触发键盘事件。尽管没有办法访问 Wii遥控器中的所有按键，但还是有一些键可以触发键盘事件。下图展示了一些键的键码，通过这些键码可以知道用户按下了哪个键。 当用户按下十字键盘（键码为 175～178）、减号（170）、加号（174）、1（172）或 2（173）键时会触发键盘事件。但没有办法得知用户是否按下了电源开关、A、B 或主页键。 iOS 版 Safari 和 Android 版 WebKit 在使用屏幕键盘时会触发键盘事件。 复合事件复合事件（composition event）是 DOM3 级事件中新添加的一类事件，用于处理 IME 的输入序列。 IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符 。例如，使用拉丁文键盘的用户通过 IME 照样能输入日文字符。IME 通常需要同时按住多个键 ，但最终只输入一个字符 。复合事件就是针对检测和处理这种输入而设计的 。有以下三种复合事件。 compositionstart ：在 IME 的文本复合系统打开时触发，表示要开始输入了。 compositionupdate ：在向输入字段中插入新字符时触发。 compositionend ：在 IME 的文本复合系统关闭时触发，表示返回正常键盘输入状态。复合事件与文本事件在很多方面都很相似。在触发复合事件时，目标是接收文本的输入字段。但它比文本事件的事件对象多一个属性 data ，其中包含以下几个值中的一个： 如果在 compositionstart 事件发生时访问，包含正在编辑的文本（例如，已经选中的需要马上替换的文本）； 如果在 compositionupdate 事件发生时访问，包含正插入的新字符； 如果在 compositionend 事件发生时访问，包含此次输入会话中插入的所有字符。 与文本事件一样 ，必要时可以利用复合事件来筛选输入 。可以像下面这样使用它们： 123456789101112131415var textbox = document.getElementById("myText");EventUtil.addHandler(textbox, "compositionstart", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data);&#125;);EventUtil.addHandler(textbox, "compositionupdate", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data);&#125;);EventUtil.addHandler(textbox, "compositionend", function(event)&#123; event = EventUtil.getEvent(event); alert(event.data);&#125;); IE9+是到 2011 年唯一支持复合事件的浏览器。由于缺少支持，对于需要开发跨浏览器应用的开发人员，它的用处不大。要确定浏览器是否支持复合事件 ，可以使用以下代码： 1var isSupported = document.implementation.hasFeature("CompositionEvent", "3.0"); 变动事件DOM2 级的变动（mutation）事件能在 DOM中的某一部分发生变化时给出提示。变动事件 是 为 XML 或 HTML DOM设计的 ，并不特定于某种语言 。DOM2 级定义了如下变动事件。 DOMSubtreeModified ：在 DOM 结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。 DOMNodeInserted ：在一个节点作为子节点被插入到另一个节点中时触发。 DOMNodeRemoved ：在节点从其父节点中被移除时触发。 DOMNodeInsertedIntoDocument ：在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在 DOMNodeInserted 之后触发。 DOMNodeRemovedFromDocument ：在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在 DOMNodeRemoved 之后触发。 DOMAttrModified ：在特性被修改之后触发。 DOMCharacterDataModified ：在文本节点的值发生变化时触发。 使用下列代码可以 检测出浏览器是否支持变动事件 ： 12var isSupported = document.implementation.hasFeature("MutationEvents", "2.0");` IE8 及更早版本不支持任何变动事件。下表列出了不同浏览器对不同变动事件的支持情况。 由于 DOM3 级事件模块作废了很多变动事件，所以本节只介绍那些将来仍然会得到支持的事件。 删除节点在使用 removeChild() 或 replaceChild() 从DOM中删除节点时 ，首先会触发 DOMNodeRemoved 事件 。这个事件的目标（ event.target ）是被删除的节点，而 event.relatedNode 属性中包含着对目标节点父节点的引用 。在这个事件触发时，节点尚未从其父节点删除，因此其 parentNode 属性仍然指向父节点（与 event.relatedNode 相同）。这个事件会冒泡，因而可以在 DOM 的任何层次上面处理它。 如果被移除的节点包含子节点 ，那么在 其所有子节点以及这个被移除的节点上会相继触发 DOMNodeRemovedFromDocument 事件 。但这个事件不会冒泡，所以 只有直接指定给其中一个子节点的事件处理程序才会被调用 。这个事件的目标是相应的子节点或者那个被移除的节点，除此之外 event对象中不包含其他信息。 紧随其后 触发的是 DOMSubtreeModified 事件 。这个事件的 目标是被移除节点的父节点 ；此时的 event 对象也不会提供与事件相关的其他信息 。 为了理解上述事件的触发过程，下面我们就以一个简单的 HTML 页面为例。 12345678910111213&lt;! DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Node Removal Events Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="myList"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 在这个例子中，我们假设要移除 &lt;ul&gt; 元素。此时，就会依次触发以下事件。 1234(1) 在 `&lt;ul&gt;` 元素上触发 DOMNodeRemoved 事件。 relatedNode 属性等于 document.body 。(2) 在 `&lt;ul&gt;` 元素上触发 DOMNodeRemovedFromDocument 事件。(3) 在身为 `&lt;ul&gt;` 元素子节点的每个 `&lt;li&gt;` 元素及文本节点上触发DOMNodeRemovedFromDocument事件。(4) 在 document.body 上触发 DOMSubtreeModified 事件，因为 `&lt;ul&gt;` 元素是 document.body 的直接子元素。 运行下列代码可以 验证以上事件发生的顺序 。 123456789101112131415161718192021EventUtil.addHandler(window, "load", function(event)&#123; var list = document.getElementById("myList"); EventUtil.addHandler(document, "DOMSubtreeModified", function(event)&#123; alert(event.type); alert(event.target); &#125;); EventUtil.addHandler(document, "DOMNodeRemoved", function(event)&#123; alert(event.type); alert(event.target); alert(event.relatedNode); &#125;); EventUtil.addHandler(list.firstChild, "DOMNodeRemovedFromDocument", function(event)&#123; alert(event.type); alert(event.target); &#125;); list.parentNode.removeChild(list);&#125;); 以上代码为 document 添加了针对 DOMSubtreeModified 和 DOMNodeRemoved 事件的处理程序，以便在页面上处理这些事件。由于 DOMNodeRemovedFromDocument 不会冒泡，所以我们将针对它的事件处理程序直接添加给了 &lt;ul&gt; 元素的第一个子节点（在兼容 DOM 的浏览器中是一个文本节点）。在设置了以上事件处理程序后，代码从文档中移除了 &lt;ul&gt; 元素。 插入节点在使用 appendChild() 、 replaceChild() 或 insertBefore() 向 DOM 中 插入节点 时，首先会 触发 DOMNodeInserted 事件 。这个事件的目标是 被插入的节点 ，而 event.relatedNode 属性中包含一个对父节点的引用 。在这个事件触发时，节点已经被插入到了新的父节点中 。这个事件是 冒泡的 ，因此可以在 DOM 的各个层次上处理它。 紧接着，会在新插入的节点上面 触发 DOMNodeInsertedIntoDocument 事件 。这个事件 不冒泡 ，因此 必须在插入节点之前为它添加这个事件处理程序 。这个事件的 目标是被插入的节点 ，除此之外 event 对象中不包含其他信息 。 最后一个 触发的事件是 DOMSubtreeModified ，触发于新插入节点的父节点 。 我们仍以前面的 HTML 文档为例，可以通过下列 JavaScript 代码来验证上述事件的触发顺序。 1234567891011121314151617181920212223EventUtil.addHandler(window, "load", function(event)&#123; var list = document.getElementById("myList"); var item = document.createElement("li"); item.appendChild(document.createTextNode("Item 4")); EventUtil.addHandler(document, "DOMSubtreeModified", function(event)&#123; alert(event.type); alert(event.target); &#125;); EventUtil.addHandler(document, "DOMNodeInserted", function(event)&#123; alert(event.type); alert(event.target); alert(event.relatedNode); &#125;); EventUtil.addHandler(item, "DOMNodeInsertedIntoDocument", function(event)&#123; alert(event.type); alert(event.target); &#125;); list.appendChild(item);&#125;); 以上代码首先创建了一个包含文本 “Item 4” 的新 &lt;li&gt; 元素。由于DOMSubtreeModified 和 DOMNodeInserted 事件是冒泡的，所以把它们的事件处理程序添加到了文档中。在将列表项插入到其父节点之前，先将 DOMNodeInsertedIntoDocument 事件的事件处理程序添加给它。最后一步就是使用 appendChild() 来添加这个列表项；此时，事件开始依次被触发。首先是在新 &lt;li&gt; 元素项上触发DOMNodeInserted 事件，其 relatedNode 是 &lt;ul&gt; 元素。然后是触发新 &lt;li&gt; 元素上的 DOMNodeInsertedIntoDocument 事件，最后触发的是 &lt;ul&gt; 元素上的DOMSubtreeModified 事件。 HTML5 事件DOM 规范没有涵盖所有浏览器支持的所有事件。很多浏览器出于不同的目的——满足用户需求或解决特殊问题，还实现了一些自定义的事件。HTML5 详尽列出了浏览器应该支持的所有事件。本节只讨论其中得到浏览器完善支持的事件，但并非全部事件。（其他事件会在本书其他章节讨论。） contextmenu 事件Windows 95 在 PC 中引入了上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单。不久，这个概念也被引入了 Web 领域。为了实现上下文菜单，开发人员面临的主要问题是如何确定应该显示上下文菜单（在 Windows 中，是右键单击；在 Mac 中，是 Ctrl+单击），以及如何屏蔽与该操作关联的默认上下文菜单。为解决这个问题，就出现了 contextmenu 这个事件，用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。 由于 contextmenu 事件是冒泡的，因此可以为 document 指定一个事件处理程序，用以处理页面中发生的所有此类事件。这个事件的目标是发生用户操作的元素。在所有浏览器中都可以取消这个事件：在兼容 DOM 的浏览器中，使用 event.preventDefalut() ；在 IE 中，将 event.returnValue 的值设置为 false 。因为 contextmenu 事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有属性。通常使用 contextmenu 事件来显示自定义的上下文菜单，而使用 onclick 事件处理程序来隐藏该菜单。以下面的 HTML 页面为例。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ContextMenu Event Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;Right click or Ctrl+click me to get a custom context menu.Click anywhere else to get the default context menu.&lt;/div&gt; &lt;ul id="myMenu" style="position:absolute;visibility:hidden;background-color: silver"&gt; &lt;li&gt;&lt;a href="http://www.nczonline.net"&gt;Nicholas’ site&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.wrox.com"&gt;Wrox site&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.yahoo.com"&gt;Yahoo!&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 这里的 &lt;div&gt; 元素包含一个自定义的上下文菜单。其中， &lt;ul&gt; 元素作为自定义上下文菜单，并且在初始时是隐藏的。实现这个例子的 JavaScript 代码 如下所示。 1234567891011121314151617EventUtil.addHandler(window, "load", function(event)&#123; var div = document.getElementById("myDiv"); EventUtil.addHandler(div, "contextmenu", function(event)&#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event); var menu = document.getElementById("myMenu"); menu.style.left = event.clientX + "px"; menu.style.top = event.clientY + "px"; menu.style.visibility = "visible"; &#125;); EventUtil.addHandler(document, "click", function(event)&#123; document.getElementById("myMenu").style.visibility = "hidden"; &#125;);&#125;); 在这个例子中，我们为 &lt;div&gt; 元素添加了 oncontextmenu 事件的处理程序。这个事件处理程序首先会取消默认行为，以保证不显示浏览器默认的上下文菜单。然后，再根据 event 对象 clientX 和 clientY 属性的值，来确定放置 &lt;ul&gt; 元素的位置。最后一步就是通过将 visibility 属性设置为”visible” 来显示自定义上下文菜单。另外，还为 document 添加了一个 onclick 事件处理程序，以便用户能够通过鼠标单击来隐藏菜单（单击也是隐藏系统上下文菜单的默认操作）。 虽然这个例子很简单，但它却展示了 Web 上所有自定义上下文菜单的基本结构。只需为这个例子中的上下文菜单添加一些 CSS 样式，就可以得到非常棒的效果。 支持 contextmenu 事件的浏览器有 IE、Firefox、Safari、Chrome 和 Opera 11+。 beforeunload 事件之所以有发生在 window 对象上的 beforeunload 事件，是为了让开发人员有可能在页面卸载前阻止这一操作 。这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。但是，不能彻底取消这个事件，因为那就相当于让用户无法离开当前页面了。为此，这个事件的意图是将控制权交给用户。显示的消息会告知用户页面行将被卸载（正因为如此才会显示这个消息），询问用户是否真的要关闭页面，还是希望继续留下来（见下图）。 为了显示这个弹出对话框，必须将 event.returnValue 的值设置为要显示给用户的字符串（对 IE 及 Fiefox 而言），同时作为函数的值返回（对 Safari 和 Chrome 而言），如下面的例子所示。 123456EventUtil.addHandler(window, "beforeunload", function(event)&#123; event = EventUtil.getEvent(event); var message = "I'm really going to miss you if you go."; event.returnValue = message; return message;&#125;); IE 和 Firefox、Safari 和 Chrome 都支持 beforeunload 事件，也都会弹出这个对话框询问用户是否真想离开。Opera 11 及之前的版本不支持 beforeunload 事件。 DOMContentLoaded 事件如前所述， window 的 load 事件会在页面中的一切都加载完毕时触发 ，但这个过程可能会因为要加载的外部资源过多而颇费周折。而 DOMContentLoaded 事件则在形成完整的 DOM树之后就会触发 ，不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕。与 load 事件不同，DOMContentLoaded 支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面进行交互。 要处理 DOMContentLoaded 事件，可以为 document 或 window 添加相应的事件处理程序（尽管这个事件会冒泡到 window ，但它的目标实际上是 document ）。来看下面的例子。 123EventUtil.addHandler(document, "DOMContentLoaded", function(event)&#123; alert("Content loaded");&#125;); DOMContentLoaded 事件对象不会提供任何额外的信息（其 target 属性是 document ）。 IE9+、Firefox、Chrome、Safari 3.1+和 Opera 9+都支持 DOMContentLoaded 事件，通常这个事件既可以添加事件处理程序，也可以执行其他 DOM 操作。这个事件始终都会在 load 事件之前触发。 对于不支持 DOMContentLoaded 的浏览器，我们建议在页面加载期间设置一个时间为 0 毫秒的超时调用，如下面的例子所示。 123setTimeout(function()&#123; //在此添加事件处理程序&#125;, 0); 这段代码的实际意思就是：“在当前 JavaScript 处理完成后立即运行这个函数。”在页面下载和构建期间，只有一个 JavaScript 处理过程，因此超时调用会在该过程结束时立即触发。至于这个时间与 DOMContentLoaded 被触发的时间能否同步，主要还是取决于用户使用的浏览器和页面中的其他代码。 为了确保这个方法有效，必须将其作为页面中的第一个超时调用；即便如此，也还是无法保证在所有环境中该超时调用一定会早于 load 事件被触发。 readystatechange 事件IE 为 DOM 文档中的某些部分提供了 readystatechange 事件 。这个事件的目的是提供与文档或元素的加载状态有关的信息 ，但这个事件的行为有时候也很难预料。支持 readystatechange 事件的每个对象都有一个 readyState 属性 ，可能包含下列 5 个值中的一个。 uninitialized （未初始化）：对象存在但尚未初始化。 loading （正在加载）：对象正在加载数据。 loaded （加载完毕）：对象加载数据完成。 interactive （交互）：可以操作对象了，但还没有完全加载。 complete （完成）：对象已经加载完毕。 这些状态看起来很直观，但并非所有对象都会经历 readyState 的这几个阶段。换句话说，如果某个阶段不适用某个对象 ，则该对象完全可能跳过该阶段 ；并没有规定哪个阶段适用于哪个对象 。显然，这意味着 readystatechange 事件经常会少于 4 次，而 readyState 属性的值也不总是连续的。 对于 document 而言，值为 “interactive” 的 readyState 会在与 DOMContentLoaded 大致相同的时刻触发 readystatechange 事件。此时，DOM树已经加载完毕，可以安全地操作它了，因此就会进入交互（interactive）阶段。但与此同时，图像及其他外部文件不一定可用。下面来看一段处理 readystatechange 事件的代码。 12345EventUtil.addHandler(document, "readystatechange", function(event)&#123; if (document.readyState == "interactive")&#123; alert("Content loaded"); &#125;&#125;); 这个事件的 event 对象不会提供任何信息，也没有目标对象。 在与 load 事件一起使用时，无法预测两个事件触发的先后顺序。在包含较多或较大的外部资源的页面中，会在 load 事件触发之前先进入交互阶段；而在包含较少或较小的外部资源的页面中，则很难说 readystatechange 事件会发生在 load 事件前面。 让问题变得更复杂的是，交互阶段可能会早于也可能会晚于完成阶段出现，无法确保顺序。在包含较多外部资源的页面中，交互阶段更有可能早于完成阶段出现；而在页面中包含较少外部资源的情况下，完成阶段先于交互阶段出现的可能性更大。因此，为了尽可能抢到先机，有必要同时检测交互和完成阶段，如下面的例子所示。 123456EventUtil.addHandler(document, "readystatechange", function(event)&#123; if (document.readyState == "interactive" || document.readyState == "complete")&#123; EventUtil.removeHandler(document, "readystatechange", arguments.callee); alert("Content loaded"); &#125;&#125;); 对于上面的代码来说，当 readystatechange 事件触发时 ，会检测 document.readyState 的值 ，看当前是否已经进入交互阶段或完成阶段 。如果是，则移除相应的事件处理程序以免在其他阶段再执行。 注意，由于事件处理程序使用的是匿名函数，因此这里使用了 arguments.callee 来引用该函数。然后，会显示一个警告框，说明内容已经加载完毕。这样编写代码可以达到与使用 DOMContentLoaded 十分相近的效果。 支持 readystatechange 事件的浏览器有 IE、Firfox 4+和 Opera。 虽然使用 readystatechange 可以十分近似地模拟 DOMContentLoaded 事件，但它们本质上还是不同的 。在不同页面中， load 事件与 readystatechange 事件并不能保证以相同的顺序触发 。 另外， &lt;script&gt; （在 IE 和 Opera 中）和 &lt;link&gt; （仅 IE 中）元素也会触发 readystatechange 事件，可以用来确定外部的 JavaScript 和 CSS 文件是否已经加载完成。与在其他浏览器中一样，除非把动态创建的元素添加到页面中 ，否则浏览器不会 开 始下载外部资源 。 基于元素触发的 readystatechange 事件也存在同样的问题，即 readyState 属性无论等于 “loaded” 还是 “complete” 都可以表示资源已经可用。有时候， readyState 会停在 “loaded” 阶段而永远不会“完成”；有时候，又会跳过 “loaded” 阶段而直接“完成”。于是，还需要像对待 document 一样采取相同的编码方式。例如，下面展示了一段加载外部 JavaScript 文件的代码。 1234567891011121314EventUtil.addHandler(window, "load", function()&#123; var script = document.createElement("script"); EventUtil.addHandler(script, "readystatechange", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.readyState == "loaded" || target.readyState == "complete")&#123; EventUtil.removeHandler(target, "readystatechange", arguments. callee); alert("Script Loaded"); &#125; &#125;); script.src = "example.js"; document.body.appendChild(script);&#125;); 这个例子为新创建的 &lt;script&gt; 节点指定了一个事件处理程序。事件的目标是该节点本身，因此当触发 readystatechange 事件时，要检测目标的 readyState 属性是不是等于 “loaded” 或 “complete” 。如果进入了其中任何一个阶段，则移除事件处理程序（以防止被执行两次），并显示一个警告框。与此同时，就可以执行已经加载完毕的外部文件中的函数了。 同样的编码方式也适用于通过 &lt;link&gt; 元素加载 CSS 文件的情况，如下面的例子所示。 1234567891011121314151617EventUtil.addHandler(window, "load", function()&#123; var link = document.createElement("link"); link.type = "text/css"; link.rel= "stylesheet"; EventUtil.addHandler(script, "readystatechange", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.readyState == "loaded" || target.readyState == "complete")&#123; EventUtil.removeHandler(target, "readystatechange", arguments. callee); alert("CSS Loaded"); &#125; &#125;); link.href = "example.css"; document.getElementsByTagName("head")[0].appendChild(link);&#125;); 同样，最重要的是要一并检测 readyState 的两个状态 ，并在调用了一次事件处理程序后就将其移除 。 pageshow 和 pagehide 事件Firefox 和 Opera 有一个特性，名叫“往返缓存”（back-forward cache，或 bfcache），可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存中不仅保存着页面数据，还保存了 DOM 和 JavaScript 的状态；实际上是将整个页面都保存在了内存里。如果页面位于 bfcache 中，那么再次打开该页面时就不会触发 load 事件。尽管由于内存中保存了整个页面的状态，不触发 load 事件也不应该会导致什么问题，但为了更形象地说明 bfcache 的行为，Firefox 还是提供了一些新事件。 第一个事件就是 pageshow ，这个事件在页面显示时触发，无论该页面是否来自 bfcache。在重新加载的页面中， pageshow 会在 load 事件触发后触发；而对于 bfcache 中的页面， pageshow 会在页面状态完全恢复的那一刻触发。另外要注意的是，虽然这个事件的目标是 document ，但必须将其事件处理程序添加到 window 。来看下面的例子。 123456789101112(function()&#123; var showCount = 0; EventUtil.addHandler(window, "load", function()&#123; alert("Load fired"); &#125;); EventUtil.addHandler(window, "pageshow", function()&#123; showCount++; alert("Show has been fired " + showCount + " times."); &#125;);&#125;)(); 这个例子使用了私有作用域，以防止变量 showCount 进入全局作用域。当页面首次加载完成时，showCount 的值为 0 。此后，每当触发 pageshow 事件， showCount 的值就会递增并通过警告框显示出来。如果你在离开包含以上代码的页面之后，又单击“后退”按钮返回该页面，就会看到 showCount每次递增的值。这是因为该变量的状态，乃至整个页面的状态，都被保存在了内存中，当你返回这个页面时，它们的状态得到了恢复。如果你单击了浏览器的“刷新”按钮，那么 showCount 的值就会被重置为 0 ，因为页面已经完全重新加载了。 除了通常的属性之外， pageshow 事件的 event 对象还包含一个名为 persisted 的布尔值属性。如果页面被保存在了 bfcache 中，则这个属性的值为 true ；否则，这个属性的值为 false 。可以像下面这样在事件处理程序中检测这个属性。 1234567891011(function()&#123; var showCount = 0; EventUtil.addHandler(window, "load", function()&#123; alert("Load fired"); &#125;); EventUtil.addHandler(window, "pageshow", function()&#123; showCount++; alert("Show has been fired " + showCount + " times. Persisted? " + event.persisted); &#125;);&#125;)(); 通过检测 persisted 属性，就可以根据页面在 bfcache 中的状态来确定是否需要采取其他操作。与 pageshow 事件对应的是 pagehide 事件，该事件会在浏览器卸载页面的时候触发，而且是在 unload 事件之前触发。与 pageshow 事件一样， pagehide 在 document 上面触发，但其事件处理程序必须要添加到 window 对象。这个事件的 event 对象也包含 persisted 属性，不过其用途稍有不同。来看下面的例子。 123EventUtil.addHandler(window, "pagehide", function(event)&#123; alert("Hiding. Persisted? " + event.persisted);&#125;); 有时候，可能需要在 pagehide 事件触发时根据 persisted 的值采取不同的操作。对于 pageshow 事件，如果页面是从 bfcache 中加载的，那么 persisted 的值就是 true ；对于 pagehide 事件，如果页面在卸载之后会被保存在 bfcache 中，那么 persisted 的值也会被设置为 true 。因此，当第一次触发 pageshow 时， persisted 的值一定是 false ，而在第一次触发 pagehide 时， persisted 就会变成 true （除非页面不会被保存在 bfcache 中）。 支持 pageshow 和 pagehide 事件的浏览器有 Firefox、Safari 5+、Chrome 和 Opera。IE9 及之前版本不支持这两个事件。 指定了 onunload 事件处理程序的页面会被自动排除在 bfcache 之外，即使事件处理程序是空的。原因在于， onunload 最常用于撤销在 onload 中所执行的操作，而跳过 onload 后再次显示页面很可能就会导致页面不正常。 hashchange 事件HTML5 新增了 hashchange 事件 ，以便在 URL 的参数列表（及 URL 中“#”号后面的所有字符串）发生变化时通知开发人员 。之所以新增这个事件，是因为在 Ajax 应用中，开发人员经常要利用 URL 参数列表来保存状态或导航信息 。 必须要把 hashchange 事件处理程序添加给 window 对象 ，然后 URL 参数列表只要变化就会调用它 。此时的 event 对象应该额外包含两个属性： oldURL 和 newURL 。这两个属性分别保存着参数列表变化前后的完整 URL 。例如： 123EventUtil.addHandler(window, "hashchange", function(event)&#123; alert("Old URL: " + event.oldURL + "\nNew URL: " + event.newURL);&#125;); 支持 hashchange 事件的浏览器有 IE8+、Firefox 3.6+、Safari 5+、Chrome 和 Opera 10.6+。在这些浏览器中，只有 Firefox 6+、Chrome 和 Opera 支持 oldURL 和 newURL 属性。为此，最好是使用 location 对象来确定当前的参数列表。 123EventUtil.addHandler(window, "hashchange", function(event)&#123; alert("Current hash: " + location.hash);&#125;); 使用以下代码可以检测浏览器是否支持 hashchange 事件： 1var isSupported = ("onhashchange" in window); //这里有 bug 如果 IE8 是在 IE7 文档模式下运行，即使功能无效它也会返回 true 。为解决这个问题，可以使用以下这个更稳妥的检测方式： 12var isSupported = ("onhashchange" in window) &amp;&amp; (document.documentMode ===undefined || document.documentMode &gt; 7); 设备事件智能手机和平板电脑的普及，为用户与浏览器交互引入了一种新的方式，而一类新事件也应运而生。设备事件（device event）可以让开发人员确定用户在怎样使用设备。W3C 从 2011年开始着手制定一份关于设备事件的新草案（ http://dev.w3.org/geo/api/spec-source-orientation.html ），以涵盖不断增长的设备类型并为它们定义相关的事件。本节会同时讨论这份草案中涉及的 API 和特定于浏览器开发商的事件。 orientationchange 事件苹果公司为移动 Safari 中添加了 orientationchange 事件 ，以便开发人员能够确定用户何时将设备由横向查看模式切换为纵向查看模式 。移动 Safari 的 window.orientation 属性 中可能包含 3 个值：0 表示肖像模式 ， 90 表示向左旋转的横向模式 （“主屏幕”按钮在右侧）， -90 表示向右旋转的横向模式（“主屏幕”按钮在左侧）。相关文档中还提到一个值，即 180 表示 iPhone 头朝下；但这种模式至今尚未得到支持。下图展示了 window.orientation 的每个值的含义。 只要用户改变了设备的查看模式，就会触发 orientationchange 事件 。此时的 event 对象不包含任何有价值的信息，因为唯一相关的信息可以通过 window.orientation 访问到。下面是使用这个事件的典型示例。 1234567EventUtil.addHandler(window, &quot;load&quot;, function(event)&#123; var div = document.getElementById(&quot;myDiv&quot;); div.innerHTML = &quot;Current orientation is &quot; + window.orientation; EventUtil.addHandler(window, &quot;orientationchange&quot;, function(event)&#123; div.innerHTML = &quot;Current orientation is &quot; + window.orientation; &#125;);&#125;); 在这个例子中，当触发 load 事件时会显示最初的方向信息。然后，添加了处理 orientationchange 事件的处理程序。只要发生这个事件，就会有表示新方向的信息更新页面中的消息。 所有 iOS 设备都支持 orientationchange 事件和 window.orientation 属性。 由于可以将 orientationchange 看成 window 事件，所以也可以通过指定 &lt;body&gt; 元素的 onorientationchange 特性来指定事件处理程序。 MozOrientation 事件Firefox 3.6 为检测设备的方向引入了一个名为 MozOrientation 的新事件 。（前缀 Moz 表示这是特定于浏览器开发商的事件，不是标准事件。）当设备的加速计检测到设备方向改变时 ，就会触发这个事件 。但这个事件与 iOS 中的 orientationchange 事件不同，该事件只能提供一个平面的方向变化 。由于 MozOrientation 事件是在 window 对象上触发的 ，所以可以使用以下代码来处理。 123EventUtil.addHandler(window, "MozOrientation", function(event)&#123; //响应事件&#125;); 此时的 event 对象包含三个属性： x 、 y 和 z 。这几个属性的值都介于 1 到-1 之间，表示不同坐标轴上的方向。在静止状态下， x 值为 0， y 值为 0， z 值为 1（表示设备处于竖直状态）。如果设备向右倾斜， x 值会减小；反之，向左倾斜， x 值会增大。类似地，如果设备向远离用户的方向倾斜， y 值会减小，向接近用户的方向倾斜， y 值会增大。 z 轴检测垂直加速度度，1 表示静止不动，在设备移动时值会减小。（失重状态下值为 0。）以下是输出这三个值的一个简单的例子。 1234EventUtil.addHandler(window, "MozOrientation", function(event)&#123; var output = document.getElementById("output"); output.innerHTML = "X=" + event.x + ", Y=" + event.y + ", Z=" + event.z +"&lt;br&gt;";&#125;); 只有带加速计的设备才支持 MozOrientation 事件 ，包括 Macbook、Lenovo Thinkpad、Windows Mobile 和 Android 设备。请大家注意，这是一个实验性 API，将来可能会变（可能会被其他事件取代）。 deviceorientation 事件本质上，DeviceOrientation Event 规范定义的 deviceorientation 事件 与 MozOrientation 事件 类似。它也是在加速计检测到设备方向变化时在 window 对象上触发 ，而且 具有与 MozOrientation 事件相同的支持限制 。不过， deviceorientation 事件的意图是告诉开发人员设备在空间中朝向哪儿 ，而不是如何移动 。 设备在三维空间中是靠 x、y 和 z 轴来定位的。当设备静止放在水平表面上时，这三个值都是 0。x轴方向是从左往右，y 轴方向是从下往上，z 轴方向是从后往前（参见下图）。 触发 deviceorientation 事件时，事件对象中包含着每个轴相对于设备静止状态下发生变化的信息。事件对象包含以下 5 个属性。 alpha ：在围绕 z轴旋转时（即左右旋转时），y 轴的度数差；是一个介于 0 到 360 之间的浮点数。 beta ：在围绕 x轴旋转时（即前后旋转时），z轴的度数差；是一个介于180到 180之间的浮点数。 gamma ：在围绕 y轴旋转时（即扭转设备时），z轴的度数差；是一个介于90到 90之间的浮点数。 absolute ：布尔值，表示设备是否返回一个绝对值。 compassCalibrated ：布尔值，表示设备的指南针是否校准过。 下图是 alpha 、 beta 和 gamma 值含义的示意图。 下面是一个输出 alpha 、 beta 和 gamma 值的例子。 12345EventUtil.addHandler(window, "deviceorientation", function(event)&#123; var output = document.getElementById("output"); output.innerHTML = "Alpha=" + event.alpha + ", Beta=" + event.beta + ", Gamma=" + event.gamma + "&lt;br&gt;";&#125;); 通过这些信息，可以响应设备的方向，重新排列或修改屏幕上的元素。要响应设备方向的改变而旋转元素，可以参考如下代码。 1234EventUtil.addHandler(window, "deviceorientation", function(event)&#123; var arrow = document.getElementById("arrow"); arrow.style.webkitTransform = "rotate(" + Math.round(event.alpha) + "deg)";&#125;); 这个例子只能在移动 WebKit 浏览器中运行，因为它使用了专有的 webkitTransform 属性（即 CSS标准属性 transform 的临时版）。元素“arrow”会随着 event.alpha 值的变化而旋转，给人一种指南针的感觉。为了保证旋转平滑，这里的 CSS3 变换使用了舍入之后的值。 到 2011 年，支持 deviceorientation 事件的浏览器有 iOS 4.2+中的 Safari、Chrome 和 Android 版 WebKit。 devicemotion 事件DeviceOrientation Event 规范还定义了一个 devicemotion 事件 。这个事件是 要告诉开发人员设备什么时候移动 ，而 不仅仅是设备方向如何改变 。例如，通过 devicemotion 能够检测到设备是不是正在往下掉 ，或者 是不是被走着的人拿在手里 。 触发 devicemotion 事件时，事件对象包含以下属性。 acceleration ：一个包含 x 、 y 和 z 属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度。 accelerationIncludingGravity ：一个包含 x 、 y 和 z 属性的对象，在考虑 z 轴自然重力加速度的情况下，告诉你在每个方向上的加速度。 interval ：以毫秒表示的时间值，必须在另一个 devicemotion 事件触发前传入。这个值在每个事件中应该是一个常量。 rotationRate ：一个包含表示方向的 alpha 、 beta 和 gamma 属性的对象。 如果读取不到 acceleration 、 accelerationIncludingGravity 和 rotationRate 值，则它们的值为 null 。因此，在使用这三个属性之前，应该先检测确定它们的值不是 null 。例如： 12345678EventUtil.addHandler(window, "devicemotion", function(event)&#123; var output = document.getElementById("output"); if (event.rotationRate !== null)&#123; output.innerHTML += "Alpha=" + event.rotationRate.alpha + ", Beta=" + event.rotationRate.beta + ", Gamma=" + event.rotationRate.gamma; &#125;&#125;); 与 deviceorientation 事件类似，只有 iOS 4.2+中的 Safari、Chrome 和 Android 版 WebKit 实现了 devicemotion 事件。 触摸与手势事件iOS 版 Safari 为了向开发人员传达一些特殊信息，新增了一些专有事件。因为 iOS 设备既没有鼠标也没有键盘，所以在为移动 Safari 开发交互性网页时，常规的鼠标和键盘事件根本不够用。随着 Android 中的 WebKit 的加入，很多这样的专有事件变成了事实标准，导致 W3C 开始制定 Touch Events 规范（参见 https://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html ）。以下介绍的事件只针对触摸设备。 触摸事件包含 iOS 2.0 软件的 iPhone 3G 发布时，也包含了一个新版本的 Safari 浏览器。这款新的移动 Safari 提供了一些与触摸（touch）操作相关的新事件。后来，Android 上的浏览器也实现了相同的事件。触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发 。具体来说，有以下几个触摸事件。 touchstart ：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。 touchmove ：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用 preventDefault()可以阻止滚动。 touchend ：当手指从屏幕上移开时触发。 touchcancel ：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。 上面这几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在 DOM 规范中定义，但它们却是以兼容 DOM的方式实现的 。因此，每个触摸事件的 event 对象都提供了在鼠标事件中常见的属性：bubbles 、 cancelable 、 view 、 clientX 、 clientY 、 screenX 、 screenY 、 detail 、 altKey 、 shiftKey 、ctrlKey 和 metaKey 。 除了常见的 DOM属性外，触摸事件还包含下列三个用于跟踪触摸的属性。 touches ：表示当前跟踪的触摸操作的 Touch 对象的数组。 targetTouchs ：特定于事件目标的 Touch 对象的数组。 changeTouches ：表示自上次触摸以来发生了什么改变的 Touch 对象的数组。 每个 Touch 对象包含下列属性。 clientX ：触摸目标在视口中的 x 坐标。 clientY ：触摸目标在视口中的 y 坐标。 identifier ：标识触摸的唯一 ID。 pageX ：触摸目标在页面中的 x 坐标。 pageY ：触摸目标在页面中的 y 坐标。 screenX ：触摸目标在屏幕中的 x 坐标。 screenY ：触摸目标在屏幕中的 y 坐标。 target ：触摸的 DOM 节点目标。 使用这些属性可以跟踪用户对屏幕的触摸操作 。来看下面的例子。 1234567891011121314151617181920212223function handleTouchEvent(event)&#123; //只跟踪一次触摸 if (event.touches.length == 1)&#123; var output = document.getElementById("output"); switch(event.type)&#123; case "touchstart": output.innerHTML = "Touch started (" + event.touches[0].clientX + "," + event.touches[0].clientY + ")"; break; case "touchend": output.innerHTML += "&lt;br&gt;Touch ended (" + event.changedTouches[0].clientX + "," + event.changedTouches[0].clientY + ")"; break; case "touchmove": event.preventDefault(); //阻止滚动 output.innerHTML += "&lt;br&gt;Touch moved (" + event.changedTouches[0].clientX + "," + event.changedTouches[0].clientY + ")"; break; &#125; &#125;&#125;EventUtil.addHandler(document, "touchstart", handleTouchEvent);EventUtil.addHandler(document, "touchend", handleTouchEvent);EventUtil.addHandler(document, "touchmove", handleTouchEvent); 以上代码会跟踪屏幕上发生的一次触摸操作。为简单起见，只会在有一次活动触摸操作的情况下输出信息。当 touchstart 事件发生时，会将触摸的位置信息输出到 元素中。当 touchmove 事件发生时，会取消其默认行为，阻止滚动（触摸移动的默认行为是滚动页面），然后输出触摸操作的变化信息。而 touchend 事件则会输出有关触摸操作的最终信息。注意，在 touchend 事件发生时， touches 集合中就没有任何 Touch 对象了，因为不存在活动的触摸操作；此时，就必须转而使用 changeTouchs 集合。 这些事件会在文档的所有元素上面触发，因而可以分别操作页面的不同部分。在触摸屏幕上的元素时，这些事件（包括鼠标事件）发生的顺序如下： 1234567(1) touchstart(2) mouseover(3) mousemove （一次）(4) mousedown(5) mouseup(6) click(7) touchend 支持触摸事件的浏览器包括 iOS 版 Safari、Android 版 WebKit、bada 版 Dolfin、OS6+中的 BlackBerry WebKit、Opera Mobile 10.1+和 LG 专有 OS 中的 Phantom浏览器。目前只有 iOS 版 Safari 支持多点触摸。桌面版 Firefox 6+和 Chrome 也支持触摸事件。 手势事件iOS 2.0 中的 Safari 还引入了一组手势事件。当两个手指触摸屏幕时就会产生手势 ，手势通常会改变显示项的大小 ，或者 旋转显示项 。有三个手势事件，分别介绍如下。 gesturestart ：当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。 gesturechange ：当触摸屏幕的任何一个手指的位置发生变化时触发。 gestureend ：当任何一个手指从屏幕上面移开时触发。 只有两个手指都触摸到事件的接收容器时才会触发这些事件 。在一个元素上设置事件处理程序，意味着两个手指必须同时位于该元素的范围之内，才能触发手势事件（这个元素就是目标）。由于这些事件冒泡，所以将事件处理程序放在文档上也可以处理所有手势事件。此时，事件的目标就是两个手指都位于其范围内的那个元素。 触摸事件和手势事件之间存在某种关系。当一个手指放在屏幕上时，会触发 touchstart 事件。如果另一个手指又放在了屏幕上，则会先触发 gesturestart 事件，随后触发基于该手指的 touchstart 事件。如果一个或两个手指在屏幕上滑动，将会触发 gesturechange 事件。但只要有一个手指移开，就会触发 gestureend 事件，紧接着又会触发基于该手指的 touchend 事件。 与触摸事件一样，每个手势事件的 event 对象都包含着标准的鼠标事件属性： bubbles 、cancelable 、 view 、 clientX 、 clientY 、 screenX 、 screenY 、 detail 、 altKey 、 shiftKey 、ctrlKey 和 metaKey 。此外，还包含两个额外的属性： rotation 和 scale 。其中， rotation 属性表示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从 0 开始）。而 scale 属性表示两个手指间距离的变化情况（例如向内收缩会缩短距离）；这个值从 1 开始，并随距离拉大而增长，随距离缩短而减小。 下面是使用手势事件的一个示例。 123456789101112131415161718function handleGestureEvent(event)&#123; var output = document.getElementById("output"); switch(event.type)&#123; case "gesturestart": output.innerHTML = "Gesture started (rotation=" + event.rotation + ",scale=" + event.scale + ")"; break; case "gestureend": output.innerHTML += "&lt;br&gt;Gesture ended (rotation=" + event.rotation + ",scale=" + event.scale + ")"; break; case "gesturechange": output.innerHTML += "&lt;br&gt;Gesture changed (rotation=" + event.rotation + ",scale=" + event.scale + ")"; break; &#125;&#125;document.addEventListener("gesturestart", handleGestureEvent, false);document.addEventListener("gestureend", handleGestureEvent, false);document.addEventListener("gesturechange", handleGestureEvent, false); 与前面演示触摸事件的例子一样，这里的代码只是将每个事件都关联到同一个函数中，然后通过该函数输出每个事件的相关信息。 触摸事件也会返回 rotation 和 scale 属性，但这两个属性只会在两个手指与屏幕保持接触时才会发生变化。一般来说，使用基于两个手指的手势事件，要比管理触摸事件中的所有交互要容易得多。 内存和性能由于事件处理程序可以为现代 Web 应用程序提供交互能力，因此许多开发人员会不分青红皂白地向页面中添加大量的处理程序。在创建 GUI 的语言（如 C#）中，为 GUI 中的每个按钮添加一个 onclick 事件处理程序是司空见惯的事，而且这样做也不会导致什么问题。可是在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象 ，都会占用内存 ；内存中的对象越多，性能就越差 。其次，必须事先指定所有事件处理程序而导致的 DOM访问次数 ，会延迟整个页面的交互就绪时间 。事实上，从如何利用好事件处理程序的角度出发，还是有一些方法能够提升性能的。 事件委托对“事件处理程序过多 ”问题的解决方案就是 事件委托 。事件委托利用了事件冒泡 ，只指定一个事件处理程序 ，就可以管理某一类型的所有事件 。例如， click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。以下面的 HTML 代码为例。 12345&lt;ul id="myLinks"&gt; &lt;li id="goSomewhere"&gt;Go somewhere&lt;/li&gt; &lt;li id="doSomething"&gt;Do something&lt;/li&gt; &lt;li id="sayHi"&gt;Say hi&lt;/li&gt;&lt;/ul&gt; 其中包含 3 个被单击后会执行操作的列表项。按照 传统的做法 ，需要像下面这样为它们添加 3 个事件处理程序。 123456789101112131415var item1 = document.getElementById("goSomewhere");var item2 = document.getElementById("doSomething");var item3 = document.getElementById("sayHi");EventUtil.addHandler(item1, "click", function(event)&#123; location.href = "http://www.wrox.com";&#125;);EventUtil.addHandler(item2, "click", function(event)&#123; document.title = "I changed the document's title";&#125;);EventUtil.addHandler(item3, "click", function(event)&#123; alert("hi");&#125;); 如果在一个复杂的 Web 应用程序中，对所有可单击的元素都采用这种方式，那么结果就会有数不清的代码用于添加事件处理程序。此时，可以 利用事件委托技术解决这个问题 。使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序 ，如下面的例子所示。 1234567891011121314151617181920var list = document.getElementById("myLinks");EventUtil.addHandler(list, "click", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case "doSomething": document.title = "I changed the document's title"; break; case "goSomewhere": location.href = "http://www.wrox.com"; break; case "sayHi": alert("hi"); break; &#125;&#125;); 在这段代码里，我们 使用事件委托只为 &lt;ul&gt; 元素添加了一个 onclick 事件处理程序 。由于所有列表项都是这个元素的子节点，而且它们的事件会冒泡，所以单击事件最终会被这个函数处理。我们知道，事件目标是被单击的列表项，故而可以通过检测 id 属性来决定采取适当的操作。与前面未使用事件委托的代码比一比，会发现这段代码的事前消耗更低，因为只取得了一个 DOM 元素，只添加了一个事件处理程序。虽然对用户来说最终的结果相同，但这种技术需要占用的内存更少。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术 。 如果可行的话，也可以 考虑为 document 对象添加一个事件处理程序 ，用以处理页面上发生的某种特定类型的事件 。这样做与采取传统的做法相比具有如下优点。 document 对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待 DOMContentLoaded 或 load 事件）。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能。 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 DOM引用更少，所花的时间也更少。 整个页面占用的内存空间更少，能够提升整体性能。 最适合采用事件委托技术的事件包括 click 、 mousedown 、 mouseup 、 keydown 、 keyup 和 keypress 。虽然 mouseover 和 mouseout 事件也冒泡 ，但要适当处理它们并不容易 ，而且 经常需要计算元素的位置 。（因为当鼠标从一个元素移到其子节点时，或者当鼠标移出该元素时，都会触发 mouseout 事件。） 移除事件处理程序每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。如前所述，可以采用事件委托技术，限制建立的连接数量 。另外，在不需要的时候移除事件处理程序，也是解决这个问题的一种方案 。内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成 Web 应用程序内存与性能问题的主要原因 。 在两种情况下，可能会造成上述问题。第一种情况就是 从文档中移除带有事件处理程序的元素时 。这可能是通过纯粹的 DOM 操作，例如使用 removeChild() 和 replaceChild() 方法，但更多地是发生在使用 innerHTML 替换页面中某一部分的时候。如果 带有事件处理程序的元素被 innerHTML 删除了 ，那么 原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收 。来看下面的例子。 123456789101112&lt;div id="myDiv"&gt; &lt;input type="button" value="Click Me" id="myBtn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("myBtn"); btn.onclick = function()&#123; //先执行某些操作 document.getElementById("myDiv").innerHTML = "Processing..."; //麻烦了！ &#125;;&lt;/script&gt; 这里，有一个按钮被包含在 &lt;div&gt; 元素中。为避免双击，单击这个按钮时就将按钮移除并替换成一条消息；这是网站设计中非常流行的一种做法。但问题在于，当按钮被从页面中移除时，它还带着一个事件处理程序呢。在 &lt;div&gt; 元素上设置 innerHTML 可以把按钮移走，但事件处理程序仍然与按钮保持着引用关系。有的浏览器（尤其是 IE）在这种情况下不会作出恰当地处理，它们很有可能会将对元素和对事件处理程序的引用都保存在内存中。如果你知道某个元素即将被移除，那么最好手工移除事件处理程序 ，如下面的例子所示。 12345678910111213&lt;div id="myDiv"&gt; &lt;input type="button" value="Click Me" id="myBtn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("myBtn"); btn.onclick = function()&#123; //先执行某些操作 btn.onclick = null; // 移除事件处理程序 document.getElementById("myDiv").innerHTML = "Processing..."; &#125;;&lt;/script&gt; 在此，我们在设置 &lt;div&gt; 的 innerHTML 属性之前，先移除了按钮的事件处理程序。这样就确保了内存可以被再次利用，而从 DOM 中移除按钮也做到了干净利索。 注意，在事件处理程序中删除按钮也能阻止事件冒泡 。目标元素在文档中是事件冒泡的前提。 采用事件委托也有助于解决这个问题。如果事先知道将来有可能使用 innerHTML 替换掉页面中的某一部分，那么就可以不直接把事件处理程序添加到该部分的元素中。而通过把事件处理程序指定给较高层次的元素，同样能够处理该区域中的事件。 导致“空事件处理程序”的另一种情况，就是卸载页面的时候。毫不奇怪，IE8 及更早版本在这种情况下依然是问题最多的浏览器，尽管其他浏览器或多或少也有类似的问题。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。每次加载完页面再卸载页面时（可能是在两个页面间来回切换，也可以是单击了“刷新”按钮），内存中滞留的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。 一般来说，最好的做法是在页面卸载之前，先 通过 onunload 事件处理程序移除所有事件处理程序 。在此，事件委托技术再次表现出它的优势 —— 需要跟踪的事件处理程序越少 ，移除它们就越容易 。对这种类似撤销的操作，我们可以把它想象成：只要是通过 onload 事件处理程序添加的东西，最后都要通过 onunload 事件处理程序将它们移除。 不要忘了，使用 onunload 事件处理程序意味着页面不会被缓存在 bfcache 中。如果你在意这个问题，那么就只能在 IE中通过 onunload 来移除事件处理程序了。 模拟事件事件，就是网页中某个特别值得关注的瞬间 。事件经常由用户操作或通过其他浏览器功能来触发。但很少有人知道，也 可以使用 JavaScript 在任意时刻来触发特定的事件 ，而 此时的事件就如同浏览器创建的事件一样 。也就是说，这些事件该冒泡还会冒泡，而且照样能够导致浏览器执行已经指定的处理它们的事件处理程序。在测试 Web 应用程序，模拟触发事件是一种极其有用的技术。DOM2 级规范为此规定了模拟特定事件的方式，IE9、Opera、Firefox、Chrome 和 Safari 都支持这种方式。IE 有它自己模拟事件的方式。 DOM中的事件模拟可以在 document 对象上使用 createEvent() 方法创建 event 对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在 DOM2 级中，所有这些字符串都使用英文复数形式，而在 DOM3 级中都变成了单数。这个字符串可以是下列几字符串之一。 UIEvents ：一般化的 UI 事件。鼠标事件和键盘事件都继承自 UI 事件。DOM3 级中是 UIEvent 。 MouseEvents ：一般化的鼠标事件。DOM3 级中是 MouseEvent 。 MutationEvents ：一般化的 DOM 变动事件。DOM3 级中是 MutationEvent 。 HTMLEvents ：一般化的 HTML 事件。没有对应的 DOM3 级事件（HTML 事件被分散到其他类别中）。 要注意的是，“DOM2 级事件”并没有专门规定键盘事件，后来的“DOM3 级事件”中才正式将其作为一种事件给出规定。IE9 是目前唯一支持 DOM3 级键盘事件的浏览器。不过，在其他浏览器中，在现有方法的基础上，可以通过几种方式来模拟键盘事件。 在创建了 event 对象之后，还需要使用与事件有关的信息对其进行初始化。每种类型的 event 对象都有一个特殊的方法，为它传入适当的数据就可以初始化该 event 对象。不同类型的这个方法的名字也不相同，具体要取决于 createEvent() 中使用的参数。 模拟事件的最后一步就是触发事件。这一步需要使用 dispatchEvent() 方法，所有支持事件的DOM 节点都支持这个方法。调用 dispatchEvent() 方法时，需要传入一个参数，即表示要触发事件的 event 对象。触发事件之后，该事件就跻身“官方事件”之列了，因而能够照样冒泡并引发相应事件处理程序的执行。 模拟鼠标事件创建新的鼠标事件对象并为其指定必要的信息 ，就可以模拟鼠标事件 。创建鼠标事件对象的方法是为 createEvent() 传入字符串 “MouseEvents “ 。返回的对象有一个名为 initMouseEvent() 方法 ，用于指定与该鼠标事件有关的信息 。这个方法接收 15 个参数，分别与鼠标事件中每个典型的属性一一对应；这些参数的含义如下。 type （字符串）：表示要触发的事件类型，例如 “click” 。 bubbles （布尔值）：表示事件是否应该冒泡。为精确地模拟鼠标事件，应该把这个参数设置为true 。 cancelable （布尔值）：表示事件是否可以取消。为精确地模拟鼠标事件，应该把这个参数设置为 true 。 view （AbstractView）：与事件关联的视图。这个参数几乎总是要设置为 document.defaultView 。 detail （整数）：与事件有关的详细信息。这个值一般只有事件处理程序使用，但通常都设置为 0 。 screenX （整数）：事件相对于屏幕的 X 坐标。 screenY （整数）：事件相对于屏幕的 Y 坐标。 clientX （整数）：事件相对于视口的 X 坐标。 clientY （整数）：事件想对于视口的 Y 坐标。 ctrlKey （布尔值）：表示是否按下了 Ctrl 键。默认值为 false 。 altKey （布尔值）：表示是否按下了 Alt 键。默认值为 false 。 shiftKey （布尔值）：表示是否按下了 Shift 键。默认值为 false 。 metaKey （布尔值）：表示是否按下了 Meta 键。默认值为 false 。 button （整数）：表示按下了哪一个鼠标键。默认值为 0 。 relatedTarget （对象）：表示与事件相关的对象。这个参数只在模拟 mouseover 或 mouseout时使用。 显而易见， initMouseEvent() 方法的这些参数是与鼠标事件的 event 对象所包含的属性一一对应的 。其中，前 4 个参数对正确地激发事件至关重要，因为浏览器要用到这些参数；而剩下的所有参数只有在事件处理程序中才会用到。当把 event 对象传给 dispatchEvent() 方法时，这个对象的 target 属性会自动设置。下面，我们就通过一个例子来了解如何 模拟对按钮的单击事件 。 1234567891011var btn = document.getElementById("myBtn");//创建事件对象var event = document.createEvent("MouseEvents");//初始化事件对象event.initMouseEvent("click", true, true, document.defaultView, 0, 0, 0, 0, 0,false, false, false, false, 0, null);//触发事件btn.dispatchEvent(event); 在兼容 DOM 的浏览器中，也可以通过相同的方式来模拟其他鼠标事件（例如 dblclick ）。 模拟键盘事件前面曾经提到过，“DOM2 级事件”中没有就键盘事件作出规定，因此模拟键盘事件并没有现成的思路可循。“DOM2 级事件”的草案中本来包含了键盘事件，但在定稿之前又被删除了；Firefox 根据其草案实现了键盘事件。需要提请大家注意的是，“DOM3 级事件”中的键盘事件与曾包含在“DOM2 级事件”草案中的键盘事件有很大区别。 DOM3 级规定，调用 createEvent() 并传入 “ KeyboardEvent “ 就可以创建一个键盘事件。返回的事件对象会包含一个 initKeyEvent() 方法 ，这个方法接收下列参数。 type （字符串）：表示要触发的事件类型，如 “keydown” 。 bubbles （布尔值）：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为 true 。 cancelable （布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true 。 view （ AbstractView ）：与事件关联的视图。这个参数几乎总是要设置为 document.defaultView 。 key （布尔值）：表示按下的键的键码。 location （整数）：表示按下了哪里的键。0 表示默认的主键盘，1 表示左，2 表示右，3 表示数字键盘，4 表示移动设备（即虚拟键盘），5 表示手柄。 modifiers （字符串）：空格分隔的修改键列表，如 “Shift” 。 repeat （整数）：在一行中按了这个键多少次。 由于DOM3级不提倡使用 keypress 事件，因此 只能利用这种技术来模拟 keydown 和 keyup 事件 。 123456789101112var textbox = document.getElementById("myTextbox"), event;//以 DOM3 级方式创建事件对象if (document.implementation.hasFeature("KeyboardEvents", "3.0"))&#123; event = document.createEvent("KeyboardEvent"); //初始化事件对象 event.initKeyboardEvent("keydown", true, true, document.defaultView, "a", 0, "Shift", 0);&#125;//触发事件textbox.dispatchEvent(event); 这个例子模拟的是按住 Shift 的同 时又按下 A 键 。 在使用 document.createEvent(“KeyboardEvent”) 之前，应该先检测浏览器是否支持 DOM3 级事件；其他浏览器返回一个非标准的KeyboardEvent 对象。 在 Firefox 中，调用 createEvent() 并传入 “KeyEvents “ 就可以创建一个键盘事件。返回的事件对象会包含一个 initKeyEvent() 方法 ，这个方法接受下列 10 个参数。 type （字符串）：表示要触发的事件类型，如 “keydown” 。 bubbles （布尔值）：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为 true 。 cancelable （布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true 。 view （ AbstractView ）：与事件关联的视图。这个参数几乎总是要设置为 document.defaultView 。 ctrlKey （布尔值）：表示是否按下了 Ctrl 键。默认值为 false 。 altKey （布尔值）：表示是否按下了 Alt 键。默认值为 false 。 shiftKey （布尔值）：表示是否按下了 Shift 键。默认值为 false 。 metaKey （布尔值）：表示是否按下了 Meta 键。默认值为 false 。 keyCode （整数）：被按下或释放的键的键码。这个参数对 keydown 和 keyup 事件有用，默认值为 0 。 charCode （整数）：通过按键生成的字符的 ASCII 编码。这个参数对 keypress 事件有用，默认值为 0 。 将创建的 event 对象传入到 dispatchEvent() 方法就可以触发键盘事件 ，如下面的例子所示。 1234567891011//只适用于 Firefoxvar textbox = document.getElementById("myTextbox")// 创建事件对象var event = document.createEvent("KeyEvents");// 初始化事件对象event.initKeyEvent("keypress", true, true, document.defaultView, false, false, false, false, 65, 65);//触发事件textbox.dispatchEvent(event); 在 Firefox 中运行上面的代码，会在指定的文本框中输入字母 A。同样，也可以依此模拟 keyup 和 keydown 事件。 在其他浏览器中 ，则 需要创建一个通用的事件 ，然后 再向事件对象中添加键盘事件特有的信息 。例如： 1234567891011121314151617var textbox = document.getElementById("myTextbox");// 创建事件对象var event = document.createEvent("Events");// 初始化事件对象event.initEvent(type, bubbles, cancelable);event.view = document.defaultView;event.altKey = false;event.ctrlKey = false;event.shiftKey = false;event.metaKey = false;event.keyCode = 65;event.charCode = 65;//触发事件textbox.dispatchEvent(event); 以上代码首先创建了一个通用事件，然后调用 initEvent() 对其进行初始化，最后又为其添加了键盘事件的具体信息。在此必须要使用通用事件，而不能使用 UI 事件，因为 UI 事件不允许向 event 对象中再添加新属性（Safari 除外）。像这样模拟事件虽然会触发键盘事件，但却不会向文本框中写入文本，这是由于无法精确模拟键盘事件所造成的。 模拟其他事件虽然鼠标事件和键盘事件是在浏览器中最经常模拟的事件，但有时候同样需要模拟变动事件和 HTML 事件。要模拟变动事件，可以使用 createEvent(“MutationEvents”) 创建一个包含 initMutationEvent() 方法的变动事件对象。这个方法接受的参数包括： type 、 bubbles 、cancelable 、 relatedNode 、 preValue 、 newValue 、 attrName 和 attrChange 。下面来看一个模拟变动事件的例子。 123var event = document.createEvent("MutationEvents");event.initMutationEvent("DOMNodeInserted", true, false, someNode, "","","",0);target.dispatchEvent(event); 以上代码模拟了 DOMNodeInserted 事件。其他变动事件也都可以照这个样子来模拟，只要改一改参数就可以了。 要模拟 HTML 事件，同样需要先创建一个 event 对象——通过 createEvent(“HTMLEvents”) ，然后再使用这个对象的 initEvent() 方法来初始化它即可，如下面的例子所示。 123var event = document.createEvent("HTMLEvents");event.initEvent("focus", true, false);target.dispatchEvent(event); 这个例子展示了如何在给定目标上模拟 focus 事件。模拟其他 HTML 事件的方法也是这样。 浏览器中很少使用变动事件和 HTML 事件，因为使用它们会受到一些限制。 自定义 DOM 事件DOM3 级还定义了“自定义事件”。自定义事件不是由 DOM 原生触发的 ，它的目的是 让开发人员创建自己的事件 。要创建新的自定义事件，可以调用 createEvent(“CustomEvent”) 。返回的对象有一个名为 initCustomEvent() 的方法，接收如下 4 个参数。 type （字符串）：触发的事件类型，例如 “keydown” 。 bubbles （布尔值）：表示事件是否应该冒泡。 cancelable （布尔值）：表示事件是否可以取消。 detail （对象）：任意值，保存在 event 对象的 detail 属性中。 可以像分派其他事件一样在 DOM 中分派创建的自定义事件对象。例如： 123456789101112131415var div = document.getElementById("myDiv"),event;EventUtil.addHandler(div, "myevent", function(event)&#123; alert("DIV: " + event.detail);&#125;);EventUtil.addHandler(document, "myevent", function(event)&#123; alert("DOCUMENT: " + event.detail);&#125;);if (document.implementation.hasFeature("CustomEvents", "3.0"))&#123; event = document.createEvent("CustomEvent"); event.initCustomEvent("myevent", true, false, "Hello world!"); div.dispatchEvent(event);&#125; 这个例子创建了一个冒泡事件 “myevent” 。而 event.detail 的值被设置成了一个简单的字符串，然后在 &lt;div&gt; 元素和 document 上侦听这个事件。因为 initCustomEvent() 方法已经指定这个事件应该冒泡，所以浏览器会负责将事件向上冒泡到 document 。 支持自定义 DOM事件的浏览器有 IE9+和 Firefox 6+。 IE中的事件模拟在 IE8 及之前版本中模拟事件与在 DOM 中模拟事件的思路相似：先 创建 event 对象 ，然后 为其指定相应的信息 ，然后 再使用该对象来触发事件 。当然，IE 在实现每个步骤时都采用了不一样的方式。 调用 document.createEventObject() 方法可以在 IE 中创建 event 对象 。但与 DOM方式不同的是，这个方法不接受参数，结果会返回一个通用的 event 对象。然后，你必须手工为这个对象添加所有必要的信息（没有方法来辅助完成这一步骤）。最后一步就是在目标上调用 fireEvent() 方法，这个方法接受两个参数：事件处理程序的名称和 event 对象。在调用 fireEvent() 方法时，会自动为 event 对象添加 srcElement 和 type 属性；其他属性则都是必须通过手工添加的。换句话说，模拟任何 IE支持的事件都采用相同的模式。例如，下面的代码模拟了在一个按钮上触发 click 事件过程。 1234567891011121314151617var btn = document.getElementById("myBtn");//创建事件对象var event = document.createEventObject();//初始化事件对象event.screenX = 100;event.screenY = 0;event.clientX = 0;event.clientY = 0;event.ctrlKey = false;event.altKey = false;event.shiftKey = false;event.button = 0;//触发事件btn.fireEvent("onclick", event); 这个例子先创建了一个 event 对象，然后又用一些信息对其进行了初始化。注意，这里可以为对象随意添加属性，不会有任何限制——即使添加的属性 IE8 及更早版本并不支持也无所谓。在此添加的属性对事件没有什么影响，因为只有事件处理程序才会用到它们。 采用相同的模式也可以模拟触发 keypress 事件，如下面的例子所示。 12345678910111213var textbox = document.getElementById("myTextbox");//创建事件对象var event = document.createEventObject();//初始化事件对象event.altKey = false;event.ctrlKey = false;event.shiftKey = false;event.keyCode = 65;//触发事件textbox.fireEvent("onkeypress", event); 由于鼠标事件、键盘事件以及其他事件的 event 对象并没有什么不同，所以可以使用通用对象来触发任何类型的事件。不过，正如在DOM中模拟键盘事件一样，运行这个例子也不会因模拟了 keypress 而在文本框中看到任何字符，即使触发了事件处理程序也没有用。 小结事件是将 JavaScript 与网页联系在一起的主要方式。“DOM3 级事件”规范和 HTML5 定义了常见的大多数事件。即使有规范定义了基本事件，但很多浏览器仍然在规范之外实现了自己的专有事件，从而为开发人员提供更多掌握用户交互的手段。有些专有事件与特定设备关联，例如移动 Safari 中的 orientationchange 事件就是特定关联 iOS 设备的。 在使用事件时，需要考虑如下一些 内存与性能方面的问题 。 有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户感觉页面反应不够灵敏。 建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。 建议在浏览器卸载页面之前移除页面中的所有事件处理程序。 可以使用 JavaScript 在浏览器中模拟事件 。“DOM2 级事件”和“DOM3 级事件”规范规定了模拟事件的方法，为模拟各种有定义的事件提供了方便。此外，通过组合使用一些技术，还可以在某种程度上模拟键盘事件。IE8及之前版本同样支持事件模拟，只不过模拟的过程有些差异。 事件是 JavaScript中最重要的主题之一，深入理解事件的工作机制以及它们对性能的影响至关重要。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-DOM2和DOM3]]></title>
    <url>%2F2018%2F08%2F25%2FJavaScript-DOM2-and-DOM3%2F</url>
    <content type="text"><![CDATA[DOM2和DOM3DOM1 级主要定义的是 HTML 和 XML 文档的底层结构 。DOM2 和 DOM3 级则在这个结构的基础上引入了更多的交互能力 ，也支持了更高级的 XML 特性 。为此，DOM2 和 DOM3 级分为许多模块（模块之间具有某种关联），分别描述了 DOM 的某个非常具体的子集。这些模块如下。 DOM2 级 核心（DOM Level 2 Core）：在 1 级核心基础上构建，为节点添加了更多方法和属性 。 DOM2 级 视图（DOM Level 2 Views）：为文档定义了基于样式信息的不同视图 。 DOM2 级 事件（DOM Level 2 Events）：说明了 如何使用事件与 DOM 文档交互 。 DOM2 级 样式（DOM Level 2 Style）：定义了 如何以编程方式来访问和改变 CSS 样式信息 。 DOM2 级 遍历和范围（DOM Level 2 Traversal and Range）：引入了遍历 DOM 文档和选择其特定部分的新接口 。 DOM2 级 HTML（DOM Level 2 HTML）：在 1 级 HTML 基础上构建，添加了更多属性、方法和新接口 。 本章探讨除“DOM2 级事件”之外的所有模块，“DOM2 级事件”模块将在第 13 章进行全面讲解。 DOM3 级又增加了“XPath”模块和“加载与保存”（Load and Save）模块。这些模块将在第 18 章讨论。 DOM 变化DOM2 级和 3 级的目的在于扩展 DOM API ，以满足操作 XML 的所有需求 ，同时提供更好的错误处理及特性检测能力 。从某种意义上讲，实现这一目的很大程度意味着 对命名空间的支持 。“DOM2 级核心”没有引入新类型 ，它只是在 DOM1 级的基础上通过增加新方法和新属性来增强了既有类型 。“DOM3级核心”同样增强了既有类型 ，但也引入了一些新类型 。 类似地，“DOM2 级视图”和“DOM2 级 HTML”模块也增强了 DOM 接口 ，提供了新的属性和方法 。由于这两个模块很小，因此我们将把它们与“DOM2 级核心”放在一起，讨论基本 JavaScript 对象的变化。可以通过下列代码来确定浏览器是否支持这些 DOM 模块。 12345var supportsDOM2Core = document.implementation.hasFeature("Core", "2.0");var supportsDOM3Core = document.implementation.hasFeature("Core", "3.0");var supportsDOM2HTML = document.implementation.hasFeature("HTML", "2.0");var supportsDOM2Views = document.implementation.hasFeature("Views", "2.0");var supportsDOM2XML = document.implementation.hasFeature("XML", "2.0"); 本章只讨论那些已经有浏览器实现的部分，任何浏览器都没有实现的部分将不作讨论。 针对XML命名空间的变化有了 XML 命名空间 ，不同 XML 文档的元素就可以混合在一起 ，共同构成格式良好的文档 ，而不必担心发生命名冲突 。从技术上说，HTML 不支持 XML 命名空间 ，但 XHTML 支持 XML 命名空间 。因此，本节给出的都是 XHTML 的示例。 命名空间要使用 xmlns 特性来指定。XHTML 的命名空间是 http://www.w3.org/1999/xhtml ，在任何格式良好 XHTML 页面中 ，都应该将其包含在 &lt;html&gt; 元素中 ，如下面的例子所示。 12345678&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;title&gt;Example XHTML page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello world! &lt;/body&gt;&lt;/html&gt; 对这个例子而言，其中的 所有元素默认都被视为 XHTML 命名空间中的元素 。要想明确地为 XML命名空间创建前缀 ，可以使用 xmlns 后跟冒号 ，再后跟前缀 ，如下所示。 12345678&lt;xhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt; &lt;xhtml:head&gt; &lt;xhtml:title&gt;Example XHTML page&lt;/xhtml:title&gt; &lt;/xhtml:head&gt; &lt;xhtml:body&gt; Hello world! &lt;/xhtml:body&gt;&lt;/xhtml:html&gt; 这里为 XHTML 的命名空间定义了一个名为 xhtml 的前缀，并要求所有 XHTML 元素都以该前缀开头。有时候 为了避免不同语言间的冲突，也需要使用命名空间来限定特性 ，如下面的例子所示。 12345678&lt;xhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt; &lt;xhtml:head&gt; &lt;xhtml:title&gt;Example XHTML page&lt;/xhtml:title&gt; &lt;/xhtml:head&gt; &lt;xhtml:body xhtml:class="home"&gt; Hello world! &lt;/xhtml:body&gt;&lt;/xhtml:html&gt; 这个例子中的特性 class 带有一个 xhtml 前缀。在只基于一种语言编写 XML 文档的情况下，命名空间实际上也没有什么用。不过，在混合使用两种语言的情况下，命名空间的用处就非常大了 。来看一看下面这个混合了 XHTML 和 SVG 语言的文档： 12345678910&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;title&gt;Example XHTML page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" style="width:100%; height:100%"&gt; &lt;rect x="0" y="0" width="100" height="100" style="fill:red"/&gt; &lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; 在这个例子中，通过设置命名空间，将 &lt;svg&gt; 标识为了与包含文档无关的元素 。此时， &lt;svg&gt; 元素的所有子元素 ，以及这些元素的所有特性 ，都被认为属于 http://www.w3.org/2000/svg 命名空间 。即使这个文档从技术上说是一个 XHTML文档，但因为有了命名空间，其中的 SVG代码也仍然是有效的。对于类似这样的文档来说，最有意思的事发生在调用方法操作文档节点的情况下。例如，在创建一个元素时，这个元素属于哪个命名空间呢？在查询一个特殊标签名时，应该将结果包含在哪个命名空间中呢？“DOM2 级核心”通过为大多数 DOM1 级方法提供特定于命名空间的版本解决了这个问题。 Node 类型的变化在 DOM2 级中， Node 类型包含下列特定于命名空间的属性。 localName ：不带命名空间前缀的节点名称。 namespaceURI ：命名空间 URI 或者（在未指定的情况下是） null 。 prefix ：命名空间前缀或者（在未指定的情况下是） null 。 当节点使用了命名空间前缀时 ，其 nodeName 等于 prefix+”:”+ localName 。以下面的文档为例： 123456789&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;title&gt;Example XHTML page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;s:svg xmlns:s="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" style="width:100%; height:100%"&gt; &lt;s:rect x="0" y="0" width="100" height="100" style="fill:red"/&gt;&lt;/s:svg&gt; &lt;/body&gt;&lt;/html&gt; 对于 &lt;html&gt; 元素来说，它的 localName 和 tagName 是 “html” ， namespaceURI 是 “ http://www.w3.org/1999/xhtml “ ，而 prefix 是 null 。对于 &lt;s:svg&gt; 元素而言，它的 localName 是 “svg” ，tagName 是 “s:svg” ， namespaceURI 是 “ http://www.w3.org/2000/svg “ ，而 prefix 是 “s” 。 DOM3 级在此基础上更进一步，又引入了下列与命名空间有关的方法。 isDefaultNamespace (namespaceURI) ：在指定的 namespaceURI 是当前节点的默认命名空间的情况下返回 true 。 lookupNamespaceURI (prefix) ：返回给定 prefix 的命名空间 。 lookupPrefix (namespaceURI) ：返回给定 namespaceURI 的前缀 。 针对前面的例子，可以执行下列代码： 12345alert(document.body.isDefaultNamespace("http://www.w3.org/1999/xhtml"); //true//假设 svg 中包含着对&lt;s:svg&gt;的引用alert(svg.lookupPrefix("http://www.w3.org/2000/svg")); //"s"alert(svg.lookupNamespaceURI("s")); //"http://www.w3.org/2000/svg" 在取得了一个节点，但不知道该节点与文档其他元素之间关系的情况下，这些方法是很有用的。 Document 类型的变化DOM2 级中的 Document 类型也发生了变化，包含了下列与命名空间有关的方法。 createElementNS(namespaceURI, tagName) ：使用给定的 tagName 创建一个属于命名空间 namespaceURI 的新元素。 createAttributeNS(namespaceURI, attributeName) ：使用给定的 attributeName 创建一个属于命名空间 namespaceURI 的新特性。 getElementsByTagNameNS(namespaceURI, tagName) ：返回属于命名空间 namespaceURI的 tagName 元素的 NodeList 。 使用这些方法时需要传入表示命名空间的 URI （而不是命名空间前缀），如下面的例子所示。 12345678//创建一个新的 SVG 元素var svg = document.createElementNS("http://www.w3.org/2000/svg","svg");//创建一个属于某个命名空间的新特性var att = document.createAttributeNS("http://www.somewhere.com", "random");//取得所有 XHTML 元素var elems = document.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "*"); 只有在文档中存在两个或多个命名空间时 ，这些与命名空间有关的方法才是必需的 。 Element 类型的变化“DOM2 级核心”中有关 Element 的变化，主要涉及操作特性。新增的方法如下。 getAttributeNS(namespaceURI,localName) ：取得属于命名空间 namespaceURI 且名为localName 的特性。 getAttributeNodeNS(namespaceURI,localName) ：取得属于命名空间 namespaceURI 且名为 localName 的特性节点。 getElementsByTagNameNS(namespaceURI, tagName) ：返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList 。 hasAttributeNS(namespaceURI,localName) ：确定当前元素是否有一个名为 localName的特性，而且该特性的命名空间是 namespaceURI 。注意，“DOM2 级核心”也增加了一个hasAttribute() 方法，用于不考虑命名空间的情况。 removeAttriubteNS(namespaceURI,localName) ：删除属于命名空间 namespaceURI 且名为 localName 的特性。 setAttributeNS(namespaceURI,qualifiedName,value) ：设置属于命名空间 namespaceURI 且名为 qualifiedName 的特性的值为 value 。 setAttributeNodeNS(attNode) ：设置属于命名空间 namespaceURI 的特性节点。 除了第一个参数之外，这些方法与 DOM1 级中相关方法的作用相同；第一个参数始终都是一个命名空间 URI 。 NamedNodeMap 类型的变化NamedNodeMap 类型也新增了下列与命名空间有关的方法。由于特性是通过 NamedNodeMap 表示的，因此这些方法多数情况下只针对特性使用。 getNamedItemNS(namespaceURI,localName) ：取得属于命名空间 namespaceURI 且名为 localName 的项。 removeNamedItemNS(namespaceURI,localName) ：移除属于命名空间 namespaceURI 且名为 localName 的项。 setNamedItemNS(node) ：添加 node ，这个节点已经事先指定了命名空间信息。由于一般都是通过元素访问特性，所以这些方法很少使用。 其他方面的变化DOM 的其他部分在“DOM2 级核心”中也发生了一些变化。这些变化与 XML 命名空间无关，而是更倾向于确保 API 的可靠性及完整性。 DocumentType 类型的变化DocumentType 类型新增了 3 个属性 ： publicId 、 systemId 和 internalSubset 。其中，前两个属性 表示的是 文档类型声明中的两个信息段 ，这两个信息段在 DOM1 级中是没有办法访问到的。以下面的 HTML 文档类型声明为例。 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; 对这个文档类型声明而言， publicId 是 “-//W3C//DTD HTML 4.01//EN” ，而 systemId 是 “http://www.w3.org/TR/html4/strict.dtd “ 。在支持 DOM2 级的浏览器中，应该可以运行下列代码。 12alert(document.doctype.publicId);alert(document.doctype.systemId); 实际上，很少需要在网页中访问此类信息。 最后一个属性 internalSubset ，用于访问包含在文档类型声明中的额外定义 ，以下面的代码为例。 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" [&lt;!ELEMENT name (#PCDATA)&gt;] &gt; 访问 document.doctype.internalSubset 将得到 “&lt;!ELEMENT name (#PCDATA)&gt;” 。这种内部子集（internal subset）在 HTML 中极少用到，在 XML 中可能会更常见一些。 Document 类型的变化Document 类型的变化中唯一与命名空间无关的方法是 importNode() 。这个方法的用途是 从一个文档中取得一个节点，然后将其导入到另一个文档 ，使其成为这个文档结构的一部分。需要注意的是，每个节点都有一个 ownerDocument 属性 ，表示所属的文档 。如果 调用 appendChild() 时传入的节点属于不同的文档 （ ownerDocument 属性的值不一样），则 会导致错误 。但在 调用 importNode() 时传入不同文档的节点则会返回一个新节点 ，这个新节点的所有权归当前文档所有 。 说起来，importNode() 方法与 Element 的 cloneNode() 方法非常相似 ，它接受两个参数：要复制的节点 和 一个表示是否复制子节点的布尔值 。返回的结果是原来节点的副本 ，但 能够在当前文档中使用 。来看下面的例子： 12var newNode = document.importNode(oldNode, true); //导入节点及其所有子节点document.body.appendChild(newNode); 这个方法在 HTML 文档中并不常用，在 XML 文档中用得比较多（更多讨论请参见第 18 章）。 “DOM2 级视图”模块添加了一个名为 defaultView 的属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架）。除此之外，“视图”规范没有提供什么时候其他视图可用的信息，因而这是唯一一个新增的属性。除 IE 之外的所有浏览器都支持 defaultView 属性。在 IE 中有一个等价的属性名叫 parentWindow （Opera 也支持这个属性）。因此，要确定文档的归属窗口，可以使用以下代码。 1var parentWindow = document.defaultView || document.parentWindow; 除了上述一个方法和一个属性之外，“DOM2级核心”还为 document.implementation 对象规定了两个新方法 ： createDocumentType() 和 createDocument() 。前者用于创建一个新的 DocumentType 节点 ，接受 3 个参数：文档类型名称 、 publicId 、 systemId 。例如，下列代码会创建一个新的 HTML 4.01 Strict 文档类型。 1var doctype = document.implementation.createDocumentType("html", "-//W3C//DTD HTML 4.01//EN", "http://www.w3.org/TR/html4/strict.dtd"); 由于既有文档的文档类型不能改变，因此 createDocumentType() 只在创建新文档时有用 ；创建新文档时需要用到 createDocument() 方法 。这个方法接受 3 个参数：针对文档中元素的 namespaceURI 、文档元素的标签名 、新文档的文档类型 。下面这行代码将会 创建一个空的新 XML 文档 。 1var doc = document.implementation.createDocument("", "root", null); 这行代码会创建一个没有命名空间的新文档，文档元素为 &lt;root&gt; ，而且没有指定文档类型。要想 创建一个 XHTML 文档 ，可以使用以下代码。 123var doctype = document.implementation.createDocumentType("html", " -//W3C//DTD XHTML 1.0 Strict//EN", "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd");var doc = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", doctype); 这样，就创建了一个带有适当命名空间和文档类型的新 XHTML 文档。不过，新文档当前只有文档元素 &lt;html&gt; ，剩下的所有元素都需要继续添加。 “DOM2 级 HTML”模块也为 document.implementation 新增了一个方法 ，名叫 createHTMLDocument() 。这个方法的用途是 创建一个完整的 HTML 文档 ，包括 &lt;html&gt; 、 &lt;head&gt; 、 &lt;title&gt; 和 &lt;body&gt; 元素。这个方法只接受一个参数，即 新创建文档的标题 （放在 &lt;title&gt; 元素中的字符串），返回 新的 HTML 文档 ，如下所示： 123var htmldoc = document.implementation.createHTMLDocument("New Doc");alert(htmldoc.title); //"New Doc"alert(typeof htmldoc.body); //"object" 通过调用 createHTMLDocument() 创建的这个文档 ，是 HTMLDocument 类型的实例 ，因而具有该类型的所有属性和方法 ，包括 title 和 body 属性。只有 Opera 和 Safari 支持这个方法。 Node 类型的变化Node 类型中唯一与命名空间无关的变化，就是添加了 isSupported() 方法 。与DOM1级为 document.implementation 引入的 hasFeature() 方法类似， isSupported() 方法用于确定当前节点具有什么能力。这个方法也接受相同的两个参数：特性名 和 特性版本号。如果浏览器实现了相应特性，而且 能够基于给定节点执行该特性 ， isSupported() 就返回 true 。来看一个例子： 123if (document.body.isSupported("HTML", "2.0"))&#123; //执行只有"DOM2 级 HTML"才支持的操作&#125; 由于不同实现在决定对什么特性返回 true 或 false 时并不一致，这个方法同样也存在与 hasFeature()方法相同的问题。为此，我们建议在确定某个特性是否可用时，最好还是使用能力检测。 DOM3 级引入了两个辅助比较节点的方法 ： isSameNode() 和 isEqualNode() 。这两个方法都接受一个节点参数，并 在传入节点与引用的节点相同或相等时返回 true 。所谓 相同 ，指的是两个节点引用的是同一个对象 。所谓 相等 ，指的是两个节点是相同的类型 ，具有相等的属性（ nodeName 、 nodeValue ，等等），而且 它们的 attributes 和 childNodes 属性也相等 （相同位置包含相同的值）。来看一个例子。 123456789var div1 = document.createElement("div");div1.setAttribute("class", "box");var div2 = document.createElement("div");div2.setAttribute("class", "box");alert(div1.isSameNode(div1)); //truealert(div1.isEqualNode(div2)); //truealert(div1.isSameNode(div2)); //false 这里创建了两个具有相同特性的 &lt;div&gt; 元素。这两个元素相等，但不相同。 DOM3 级还针对为 DOM 节点添加额外数据引入了新方法 。其中， setUserData() 方法 会将数据指定给节点，它接受 3 个参数：要设置的键 、实际的数据（可以是任何数据类型）和 处理函数 。以下代码可以将数据指定给一个节点。 1document.body.setUserData("name", "Nicholas", function()&#123;&#125;); 然后，使用 getUserData() 并传入相同的键 ，就可以取得该数据 ，如下所示： 1var value = document.body.getUserData("name"); 传入 setUserData() 中的处理函数会在带有数据的节点被复制、删除、重命名或引入一个文档时调用 ，因而你可以事先决定在上述操作发生时如何处理用户数据。处理函数接受 5 个参数：表示操作类型的数值（1 表示复制，2 表示导入，3 表示删除，4 表示重命名）、数据键 、数据值 、源节点 和 目标节点 。在删除节点时，源节点是 null ；除在复制节点时 ，目标节点均为 null 。在函数内部 ，你可以决定如何存储数据 。来看下面的例子。 123456789var div = document.createElement("div");div.setUserData("name", "Nicholas", function(operation, key, value, src, dest)&#123; if (operation == 1)&#123; dest.setUserData(key, value, function()&#123;&#125;); &#125;&#125;);var newDiv = div.cloneNode(true);alert(newDiv.getUserData("name")); //"Nicholas" 这里，先创建了一个 &lt;div&gt; 元素，然后又为它添加了一些数据（用户数据）。在使用 cloneNode() 复制这个元素时，就会调用处理函数，从而将数据自动复制到了副本节点。结果在通过副本节点调用 getUserData() 时，就会返回与原始节点中包含的相同的值。 框架的变化框架和内嵌框架分别用 HTMLFrameElement 和 HTMLIFrameElement 表示 ，它们在 DOM2 级中都有了一个新属性，名叫 contentDocument 。这个属性包含一个指针，指向表示框架内容的文档对象 。在此之前，无法直接通过元素取得这个文档对象（只能使用 frames 集合）。可以像下面这样使用这个属性。 12var iframe = document.getElementById("myIframe");var iframeDoc = iframe.contentDocument; //在 IE8 以前的版本中无效 由于 contentDocument 属性是 Document 类型的实例 ，因此可以像使用其他 HTML 文档一样使用它 ，包括所有属性和方法 。Opera、Firefox、Safari 和 Chrome 支持这个属性。IE8 之前不支持框架中的 contentDocument 属性，但支持一个名叫 contentWindow 的属性，该属性返回框架的 window 对象，而这个 window 对象又有一个 document 属性。因此，要想在上述所有浏览器中访问内嵌框架的文档对象，可以使用下列代码。 12var iframe = document.getElementById("myIframe");var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; 所有浏览器都支持 contentWindow 属性 。访问框架或内嵌框架的文档对象要受到跨域安全策略的限制 。如果 某个框架中的页面来自其他域或不同子域 ，或者 使用了不同的协议 ，那么要访问这个框架的文档对象就会导致错误 。 样式在 HTML 中定义样式的方式有 3 种 ：通过 &lt;link/&gt; 元素包含外部样式表文件 、使用 &lt;style/&gt; 元素定义嵌入式样式 ，以及 使用 style 特性定义针对特定元素的样式 。“DOM2 级样式”模块围绕这 3 种应用样式的机制提供了一套 API 。要 确定浏览器是否支持 DOM2级定义的 CSS能力 ，可以使用下列代码。 12var supportsDOM2CSS = document.implementation.hasFeature("CSS", "2.0");var supportsDOM2CSS2 = document.implementation.hasFeature("CSS2", "2.0"); 访问元素的样式任何支持 style 特性的 HTML 元素在 JavaScript 中都有一个对应的 style 属性 。这个 style 对象 是 CSSStyleDeclaration 的实例 ，包含着通过 HTML 的 style 特性指定的所有样式信息 ，但 不包含与外部样式表或嵌入样式表经层叠而来的样式 。在 style 特性中指定的任何 CSS 属性都将表现为这个 style 对象的相应属性。对于使用短划线（分隔不同的词汇，例如 background-image ）的 CSS 属性名 ，必须将其转换成驼峰大小写形式 ，才能通过 JavaScript 来访问 。下表列出了几个常见的 CSS 属性及其在 style 对象中对应的属性名。 多数情况下，都可以通过简单地转换属性名的格式来实现转换 。其中一个不能直接转换的 CSS 属性就是 float 。由于 float 是 JavaScript 中的保留字，因此不能用作属性名。“DOM2 级样式”规范规定样式对象上相应的属性名应该是 cssFloat ；Firefox、Safari、Opera 和 Chrome 都支持这个属性，而 IE 支持的则是 styleFloat 。 只要取得一个有效的 DOM元素的引用 ，就可以随时使用 JavaScript为其设置样式 。以下是几个例子。 1234567891011var myDiv = document.getElementById("myDiv");//设置背景颜色myDiv.style.backgroundColor = "red";//改变大小myDiv.style.width = "100px";myDiv.style.height = "200px";//指定边框myDiv.style.border = "1px solid black"; 在以这种方式改变样式时，元素的外观会自动被更新 。 在标准模式下 ，所有度量值都必须指定一个度量单位 。在混杂模式下 ，可以将vstyle.width 设置为 “20” ，浏览器会假设它是 “20px” ；但在标准模式下，将 style.width 设置为 “20” 会导致被忽略——因为没有度量单位。在实践中，最好始终都指定度量单位 。 通过 style 对象同样可以取得在 style 特性中指定的样式。以下面的 HTML 代码为例。 1&lt;div id="myDiv" style="background-color:blue; width:10px; height:25px"&gt;&lt;/div&gt; 在 style 特性中指定的样式信息可以通过下列代码取得 。 123alert(myDiv.style.backgroundColor); //"blue"alert(myDiv.style.width); //"10px"alert(myDiv.style.height); //"25px" 如果 没有为元素设置 style 特性 ，那么 style 对象中可能会包含一些默认的值 ，但这些值并不能准确地反映该元素的样式信息。 DOM 样式属性和方法“DOM2级样式”规范还为 style 对象定义了一些属性和方法。这些属性和方法在提供元素的 style 特性值的同时，也可以修改样式。下面列出了这些属性和方法。 cssText ：如前所述，通过它能够访问到 style 特性中的 CSS 代码。 length ：应用给元素的 CSS 属性的数量。 parentRule ：表示 CSS 信息的 CSSRule 对象。本节后面将讨论 CSSRule 类型。 getPropertyCSSValue(propertyName) ：返回包含给定属性值的 CSSValue 对象。 getPropertyPriority(propertyName) ：如果给定的属性使用了 !important 设置，则返回 “important” ；否则，返回空字符串。 getPropertyValue(propertyName) ：返回给定属性的字符串值。 item(index) ：返回给定位置的 CSS 属性的名称。 removeProperty(propertyName) ：从样式中删除给定属性。 setProperty(propertyName,value,priority) ：将给定属性设置为相应的值，并加上优先权标志（ “important” 或者一个空字符串）。 通过 cssText 属性可以访问 style 特性中的 CSS 代码 。在 ** 读取模式 下， cssText 返回浏览器对 style 特性中 CSS 代码的内部表示 。在 写入模式 下，赋给 cssText 的值会重写整个 style 特性的值 ；也就是说，以前通过 style 特性指定的样式信息都将丢失 。例如，如果通过 style 特性为元素设置了边框，然后再以不包含边框的规则重写 cssText ，那么就会抹去元素上的边框。下面是使用 cssText 属性的一个例子。 12myDiv.style.cssText = "width: 25px; height: 100px; background-color: green";alert(myDiv.style.cssText); 设置 cssText 是为元素应用多项变化最快捷的方式 ，因为可以一次性地应用所有变化。 设计 length 属性的目的 ，就是将其与 item() 方法配套使用 ，以便迭代在元素中定义的 CSS 属性 。在 使用 length 和 item() 时， style 对象实际上就相当于一个集合 ，都可以使用方括号语法来代替 item() 来取得给定位置的 CSS 属性 ，如下面的例子所示。 123for (var i=0, len=myDiv.style.length; i &lt; len; i++)&#123; alert(myDiv.style[i]); //或者 myDiv.style.item(i)&#125; 无论是使用方括号语法还是使用 item() 方法 ，都可以取得 CSS 属性名（ “background-color” ，不是 “backgroundColor” ）。然后，就可以在 getPropertyValue() 中使用取得的属性名进一步取得属性的值，如下所示。 123456var prop, value, i, len;for (i=0, len=myDiv.style.length; i &lt; len; i++)&#123; prop = myDiv.style[i]; // 或者 myDiv.style.item(i) value = myDiv.style.getPropertyValue(prop); alert(prop + " : " + value);&#125; getPropertyValue() 方法取得的始终都是 CSS 属性值的字符串表示 。如果你需要更多信息，可以使用 getPropertyCSSValue() 方法 ，它 返回一个包含两个属性的 CSSValue 对象 ，这两个属性分别是： cssText 和 cssValueType 。其中， cssText 属性的值 与 getPropertyValue() 返回的值相同 ，而 cssValueType 属性 则是 一个数值常量 ，表示值的类型：0 表示继承的值，1 表示基本的值，2 表示值列表，3 表示自定义的值 。以下代码既输出 CSS 属性值，也输出值的类型。 123456var prop, value, i, len;for (i=0, len=myDiv.style.length; i &lt; len; i++)&#123; prop = myDiv.style[i]; //或者 myDiv.style.item(i) value = myDiv.style.getPropertyCSSValue(prop); alert(prop + " : " + value.cssText + " (" + value.cssValueType + ")");&#125; 在实际开发中， getPropertyCSSValue() 使用得比 getPropertyValue() 少得多。IE9+、Safarie 3+以及 Chrome 支持这个方法。Firefox 7 及之前版本也提供这个访问，但调用总返回 null 。 要从元素的样式中移除某个 CSS 属性，需要使用 removeProperty() 方法 。使用这个方法移除一个属性，意味着 将会为该属性应用默认的样式（从其他样式表经层叠而来）。例如，要移除通过 style 特性设置的 border 属性，可以使用下面的代码。 1myDiv.style.removeProperty("border"); 在不确定某个给定的 CSS 属性拥有什么默认值的情况下，就可以使用这个方法 。只要移除相应的属性，就可以为元素应用默认值 。 除非另有说明，本节讨论的属性和方法都得到了 IE9+、Firefox、Safari、Opera 9+ 以及 Chrome 的支持。 计算的样式虽然 style 对象能够提供支持 style 特性的任何元素的样式信息，但它不包含那些从其他样式表层叠而来并影响到当前元素的样式信息 。“DOM2 级样式”增强了 document.defaultView ，提供了 getComputedStyle() 方法 。这个方法接受两个参数：要取得计算样式的元素 和 一个伪元素字符串（例如 “:after” ） 。如果不需要伪元素信息，第二个参数可以是 null 。 getComputedStyle() 方法 返回一个 CSSStyleDeclaration 对象 （与 style 属性的类型相同），其中包含当前元素的所有计算的样式。 以下面这个 HTML 页面为例。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Computed Styles Example&lt;/title&gt; &lt;style type="text/css"&gt; #myDiv &#123; background-color: blue; width: 100px; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv" style="background-color: red; border: 1px solid black"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 应用给这个例子中 &lt;div&gt; 元素的样式一方面来自嵌入式样式表（ &lt;style&gt; 元素中的样式），另一方面来自其 style 特性。但是， style 特性中设置了 backgroundColor 和 border ，没有设置 width 和 height ，后者是通过样式表规则应用的。以下代码可以取得这个元素计算后的样式。 1234567var myDiv = document.getElementById("myDiv");var computedStyle = document.defaultView.getComputedStyle(myDiv, null);alert(computedStyle.backgroundColor); // "red"alert(computedStyle.width); // "100px"alert(computedStyle.height); // "200px"alert(computedStyle.border); // 在某些浏览器中是"1px solid black" 在这个元素计算后的样式中，背景颜色的值是 “red” ，宽度值是 “100px” ，高度值是 “200px” 。我们注意到，背景颜色不是 “blue” ，因为这个样式在自身的 style 特性中已经被覆盖了。边框属性可能会也可能不会返回样式表中实际的 border 规则（Opera 会返回，但其他浏览器不会）。存在这个差别的原因是不同浏览器解释综合（rollup）属性（如 border ）的方式不同，因为设置这种属性实际上会涉及很多其他属性。在设置 border 时，实际上是设置了四个边的边框宽度、颜色、样式属性（ border-left-width 、 border-top-color 、 border-bottom-style ， 等 等 ）。 因此 ， 即 使 computedStyle.border 不会在所有浏览器中都返回值，但 computedStyle.borderLeftWidth 会返回值。 需要注意的是，即使有些浏览器支持这种功能 ，但 表示值的方式可能会有所区别 。例如，Firefox 和 Safari 会将所有颜色转换成 RGB 格式（例如红色是 rgb(255,0,0)）。 因此，在使用 getComputedStyle() 方法 时，最好多在几种浏览器中测试一下 。IE 不支持 getComputedStyle() 方法，但它有一种类似的概念。在 IE 中，每个具有 style 属性的元素还有一个 currentStyle 属性 。这个属性是 CSSStyleDeclaration 的实例 ，包含当前元素全部计算后的样式。取得这些样式的方式也差不多，如下面的例子所示。 1234567var myDiv = document.getElementById("myDiv");var computedStyle = myDiv.currentStyle;alert(computedStyle.backgroundColor); //"red"alert(computedStyle.width); //"100px"alert(computedStyle.height); //"200px"alert(computedStyle.border); //undefined 与 DOM 版本的方式一样，IE 也没有返回 border 样式，因为这是一个综合属性。 无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的 CSS 属性 。此外，计算后的样式也包含属于浏览器内部样式表的样式信息 ，因此 任何具有默认值的 CSS 属性都会表现在计算后的样式中 。例如，所有浏览器中的 visibility 属性都有一个默认值，但这个值会因实现而异。在默认情况下，有的浏览器将 visibility 属性设置为 “visible” ，而有的浏览器则将其设置为 “inherit” 。换句话说，不能指望某个 CSS 属性的默认值在不同浏览器中是相同的 。如果你需要元素具有某个特定的默认值，应该手工在样式表中指定该值 。 操作样式表CSSStyleSheet 类型表示的是样式表 ，包括 通过 &lt;link&gt; 元素包含的样式表 和 在 &lt;style&gt; 元素中定义的样式表 。有读者可能记得，这两个元素本身分别是由 HTMLLinkElement 和 HTMLStyleElement 类型表示的。但是，CSSStyleSheet 类型相对更加通用一些 ，它只表示样式表，而不管这些样式表在 HTML 中是如何定义的 。此外，上述两个针对元素的类型允许修改 HTML特性 ，但 CSSStyleSheet 对象则是一套只读的接口（有一个属性例外）。使用下面的代码可以确定浏览器是否支持 DOM2级样式表。 1var supportsDOM2StyleSheets = document.implementation.hasFeature("StyleSheets", "2.0"); CSSStyleSheet 继承自 StyleSheet ，后者可以作为一个基础接口来定义非 CSS 样式表 。从StyleSheet 接口继承而来的属性如下。 disabled ：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为 true 可以禁用样式表。 href ：如果样式表是通过 &lt;link&gt; 包含的，则是样式表的 URL；否则，是 null 。 media ：当前样式表支持的所有媒体类型的集合。与所有 DOM 集合一样，这个集合也有一个length 属性和一个 item() 方法。也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。在 IE 中， media 是一个反映 &lt;link&gt; 和 &lt;style&gt; 元素 media 特性值的字符串。 ownerNode ：指向拥有当前样式表的节点的指针，样式表可能是在 HTML 中通过 &lt;link&gt; 或 &lt;style/&gt; 引入的（在 XML 中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过 @import 导入的，则这个属性值为 null 。IE 不支持这个属性。 parentStyleSheet ：在当前样式表是通过 @import 导入的情况下，这个属性是一个指向导入它的样式表的指针。 title ： ownerNode 中 title 属性的值。 type ：表示样式表类型的字符串。对 CSS 样式表而言，这个字符串是 “type/css” 。 除了 disabled 属性之外，其他属性都是只读的 。在支持以上所有这些属性的基础上，CSSStyleSheet 类型还支持下列属性和方法： cssRules ：样式表中包含的样式规则的集合。IE 不支持这个属性，但有一个类似的 rules 属性。 ownerRule ：如果样式表是通过@import 导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为 null 。IE不支持这个属性。 deleteRule(index) ：删除 cssRules 集合中指定位置的规则。IE 不支持这个方法，但支持一个类似的 removeRule() 方法。 insertRule(rule,index) ：向 cssRules 集合中指定的位置插入 rule 字符串。IE 不支持这个方法，但支持一个类似的 addRule() 方法。 应用于文档的所有样式表是通过 document.styleSheets 集合来表示的 。通过这个集合的 length属性 可以获知 文档中样式表的数量 ，而通过方括号语法 或 item() 方法 可以 访问每一个样式表 。来看一个例子。 12345var sheet = null;for (var i=0, len=document.styleSheets.length; i &lt; len; i++)&#123; sheet = document.styleSheets[i]; alert(sheet.href);&#125; 以上代码可以输出文档中使用的每一个样式表的 href 属性（ &lt;style&gt; 元素包含的样式表没有 href 属性）。 不同浏览器的 document.styleSheets 返回的样式表也不同 。所有浏览器都会包含 &lt;style&gt; 元素和 rel 特性被设置为 “stylesheet” 的 &lt;link&gt; 元素引入的样式表。IE 和 Opera也包含 rel 特性被设置为 “alternate stylesheet” 的 &lt;link&gt; 元素引入的样式表。 也可以直接通过 &lt;link&gt; 或 &lt;style&gt; 元素取得 CSSStyleSheet 对象 。DOM 规定了一个 包含 CSSStyleSheet 对象的属性 ，名叫 sheet ；除了 IE，其他浏览器都支持这个属性。IE 支持的是 styleSheet 属性 。要想在不同浏览器中都能取得样式表对象，可以使用下列代码。 1234567function getStyleSheet(element)&#123; return element.sheet || element.styleSheet;&#125;//取得第一个&lt;link/&gt;元素引入的样式表var link = document.getElementsByTagName("link")[0];var sheet = getStylesheet(link); 这里的 getStyleSheet() 返回的样式表对象与 document.styleSheets 集合中的样式表对象相同。 CSS 规则CSSRule 对象表示样式表中的每一条规则。实际上， CSSRule 是一个供其他多种类型继承的基类型，其中最常见的就是 CSSStyleRule 类型，表示样式信息（其他规则还有 @import 、 @font-face 、@page 和 @charset ，但这些规则很少有必要通过脚本来访问）。 CSSStyleRule 对象包含下列属性。 cssText ：返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样；Safari 始终都会将文本转换成全部小写。IE 不支持这个属性。 parentRule ：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为 null 。IE 不支持这个属性。 parentStyleSheet ：当前规则所属的样式表。IE 不支持这个属性。 selectorText ：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样（例如，Safari 3 之前的版本始终会将文本转换成全部小写）。在 Firefox、Safari、Chrome和 IE中这个属性是只读的。Opera允许修改 selectorText 。 style ：一个 CSSStyleDeclaration 对象，可以通过它设置和取得规则中特定的样式值。 type ：表示规则类型的常量值。对于样式规则，这个值是 1。IE 不支持这个属性。 其中三个最常用的属性是 cssText 、 selectorText 和 style 。 cssText 属性与 style.cssText 属性类似，但并不相同。前者包含选择符文本和围绕样式信息的花括号 ，后者只包含样式信息（类似于元素的 style.cssText ）。此外， cssText 是只读的 ，而 style.cssText 也可以被重写 。 大多数情况下，仅使用 style 属性就可以满足所有操作样式规则的需求了。这个对象就像每个元素上的 style 属性一样 ，可以通过它读取和修改规则中的样式信息 。以下面的 CSS 规则为例。 12345div.box &#123; background-color: blue; width: 100px; height: 200px;&#125; 假设这条规则位于页面中的第一个样式表中，而且这个样式表中只有这一条样式规则，那么通过下列代码可以取得这条规则的各种信息。 12345678var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules; //取得规则列表var rule = rules[0]; //取得第一条规则alert(rule.selectorText); //"div.box"alert(rule.style.cssText); //完整的 CSS 代码alert(rule.style.backgroundColor); //"blue"alert(rule.style.width); //"100px"alert(rule.style.height); //"200px" 使用这种方式，可以像确定元素的行内样式信息一样，确定与规则相关的样式信息 。与使用元素的方式一样，在这种方式下也可以修改样式信息，如下面的例子所示。 1234var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules; //取得规则列表var rule = rules[0]; //取得第一条规则rule.style.backgroundColor = "red" 必须要注意的是，以这种方式修改规则会影响页面中适用于该规则的所有元素 。换句话说，如果 有两个带有 box 类的 &lt;div&gt; 元素 ，那么 这两个元素都会应用修改后的样式 。 创建规则DOM 规定，要向现有样式表中添加新规则，需要使用 insertRule() 方法 。这个方法接受两个参数：规则文本 和 表示在哪里插入规则的索引 。下面是一个例子。 1sheet.insertRule("body &#123; background-color: silver &#125;", 0); //DOM 方法 这个例子插入的规则会改变元素的背景颜色。插入的规则将成为样式表中的第一条规则（插入到了位置 0）—— 规则的次序在确定层叠之后应用到文档的规则时至关重要 。Firefox、Safari、Opera 和 Chrome 都支持 insertRule() 方法。 IE8 及更早版本支持一个类似的方法，名叫 addRule() ，也接收两必选参数：选择符文本 和 CSS 样式信息 ；一个可选参数：插入规则的位置 。在 IE 中插入与前面例子相同的规则，可使用如下代码。 1sheet.addRule("body", "background-color: silver", 0); //仅对 IE 有效 有关这个方法的规定中说，最多可以使用 addRule() 添加 4 095 条样式规则 。超出这个上限的调用将会导致错误。 要以跨浏览器的方式向样式表中插入规则，可以使用下面的函数 。这个函数接受 4 个参数：要向其中 添加规则的样式表 以及 与 addRule() 相同的 3 个参数 ，如下所示。 1234567function insertRule(sheet, selectorText, cssText, position)&#123; if (sheet.insertRule)&#123; sheet.insertRule(selectorText + "&#123;" + cssText + "&#125;", position); &#125; else if (sheet.addRule)&#123; sheet.addRule(selectorText, cssText, position); &#125;&#125; 下面是调用这个函数的示例代码。 1insertRule(document.styleSheets[0], "body", "background-color: silver", 0); 虽然可以像这样来添加规则，但随着要添加规则的增多，这种方法就会变得非常繁琐 。因此，如果要添加的规则非常多，我们建议还是采用第 10 章介绍过的动态加载样式表的技术。 删除规则从样式表中删除规则的方法是 deleteRule() ，这个方法接受一个参数：要删除的规则的位置 。例如，要删除样式表中的第一条规则，可以使用以下代码。 1sheet.deleteRule(0); //DOM 方法 IE 支持的类似方法叫 removeRule() ，使用方法相同，如下所示： 1sheet.removeRule(0); //仅对 IE 有效 下面是一个能够跨浏览器删除规则的函数 。第一个参数是 要操作的样式表 ，第二个参数是 要删除的规则的索引 。 1234567function deleteRule(sheet, index)&#123; if (sheet.deleteRule)&#123; sheet.deleteRule(index); &#125; else if (sheet.removeRule)&#123; sheet.removeRule(index); &#125;&#125; 调用这个函数的方式如下。 1deleteRule(document.styleSheets[0], 0); 与添加规则相似，删除规则也不是实际 Web 开发中常见的做法 。考虑到删除规则可能会影响 CSS层叠的效果 ，因此 请大家慎重使用 。 元素大小本节介绍的属性和方法并不属于“DOM2 级样式”规范，但却与 HTML 元素的样式息息相关。DOM 中没有规定如何确定页面中元素的大小。IE 为此率先引入了一些属性，以便开发人员使用。目前，所有主要的浏览器都已经支持这些属性。 偏移量 首先要介绍的属性涉及 偏移量（offset dimension），包括元素在屏幕上占用的所有可见的空间 。元素的可见大小由其高度、宽度决定 ，包括所有 内边距 、滚动条 和 边框大小（注意，不包括外边距）。通过下列 4 个属性可以取得元素的偏移量。 offsetHeight ：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。 offsetWidth ：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。 offsetLeft ：元素的左外边框至包含元素的左内边框之间的像素距离。 offsetTop ：元素的上外边框至包含元素的上内边框之间的像素距离。 其中， offsetLeft 和 offsetTop 属性 与包含元素有关 ，包含元素的引用保存在 offsetParent 属性中 。 offsetParent 属性不一定与 parentNode 的值相等 。例如， &lt;td&gt; 元素的 offsetParent 是作为其祖先元素的 &lt;table&gt; 元素，因为 &lt;table&gt; 是在 DOM层次中距 &lt;td&gt; 最近的一个具有大小的元素。 下图形象地展示了上面几个属性表示的不同大小。 要想知道某个元素在页面上的偏移量 ，将这个元素的 offsetLeft 和 offsetTop 与其 offsetParent 的相同属性相加 ，如此循环直至根元素 ，就可以得到一个基本准确的值 。以下两个函数就可以用于分别取得元素的左和上偏移量。 12345678910111213141516171819function getElementLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125;function getElementTop(element)&#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null)&#123; actualTop += current. offsetTop; current = current.offsetParent; &#125; return actualTop;&#125; 这两个函数利用 offsetParent 属性在 DOM 层次中逐级向上回溯，将每个层次中的偏移量属性合计到一块。对于简单的 CSS 布局的页面 ，这两函数可以得到非常精确的结果 。对于使用表格和内嵌框架布局的页面 ，由于不同浏览器实现这些元素的方式不同 ，因此得到的值就不太精确了 。一般来说，页面中的所有元素都会被包含在几个 &lt;div&gt; 元素中，而这些 &lt;div&gt; 元素的 offsetParent 又是&lt;body&gt; 元素，所以 getElementLeft() 与 getElementTop() 会返回与 offsetLeft 和 offsetTop 相同的值 。 所有这些偏移量属性都是只读的 ，而且 每次访问它们都需要重新计算 。因此，应该尽量避免重复访问这些属性 ；如果需要重复使用其中某些属性的值 ，可以将它们保存在局部变量中 ，以提高性能。 客户区大小元素的客户区大小（client dimension），指的是 元素内容及其内边距所占据的空间大小 。有关客户区大小的属性有两个： clientWidth 和 clientHeight 。其中， clientWidth 属性是元素内容区宽度加上左右内边距宽度 ； clientHeight 属性是元素内容区高度加上上下内边距高度 。下图形象地说明了这些属性表示的大小。 从字面上看，客户区大小就是元素内部的空间大小 ，因此 滚动条占用的空间不计算在内 。最常用到这些属性的情况，就是像第 8 章讨论的确定浏览器视口大小的时候。如下面的例子所示，要确定浏览器视口大小，可以使用 document.documentElement 或 document.body （在 IE7 之前的版本中）的 clientWidth 和 clientHeight 。 12345678910111213function getViewport()&#123; if (document.compatMode == "BackCompat")&#123; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125;; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;; &#125;&#125; 这个函数首先检查 document.compatMode 属性，以确定浏览器是否运行在混杂模式。Safari 3.1 之前的版本不支持这个属性，因此就会自动执行 else 语句。Chrome、Opera 和 Firefox 大多数情况下都运行在标准模式下，因此它们也会前进到 else 语句。这个函数会返回一个对象，包含两个属性： width 和 height ；表示浏览器视口（ &lt;html&gt; 或 &lt;body&gt; 元素）的大小。 与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的 。 滚动大小最后要介绍的是 滚动大小（scroll dimension），指的是包含滚动内容的元素的大小 。有些元素（例如 &lt;html&gt; 元素），即使 没有执行任何代码也能自动地添加滚动条 ；但 另外一些元素 ，则 需要通过 CSS 的 overflow 属性进行设置才能滚动 。以下是 4 个与滚动大小相关的属性。 scrollHeight ：在没有滚动条的情况下，元素内容的总高度。 scrollWidth ：在没有滚动条的情况下，元素内容的总宽度。 scrollLeft ：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 scrollTop ：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 下图展示了这些属性代表的大小。 scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小 。例如，通常认为 &lt;html&gt; 元素是在 Web 浏览器的视口中滚动的元素（IE6 之前版本运行在混杂模式下时是 &lt;body&gt; 元素）。因此，带有垂直滚动条的页面总高度就是 document.documentElement.scrollHeight 。 对于不包含滚动条的页面而言 ， scrollWidth 和 scrollHeight 与 clientWidth 和 clientHeight 之间的关系并不十分清晰 。在这种情况下，基于 document.documentElement 查看这些属性会在不同浏览器间发现一些不一致性问题，如下所述。 Firefox 中这两组属性始终都是相等的，但大小代表的是文档内容区域的实际尺寸，而非视口的尺寸。 Opera、Safari 3.1 及更高版本、Chrome 中的这两组属性是有差别的，其中 scrollWidth 和 scrollHeight 等于视口大小，而 clientWidth 和 clientHeight 等于文档内容区域的大小。 IE（在标准模式）中的这两组属性不相等，其中 scrollWidth 和 scrollHeight 等于文档内容区域的大小，而 clientWidth 和 clientHeight 等于视口大小。 在确定文档的总高度时（包括基于视口的最小高度时），必须取得 scrollWidth/clientWidth 和 scrollHeight/clientHeight 中的最大值 ，才能保证在跨浏览器的环境下得到精确的结果 。下面就是这样一个例子。 12var docHeight = Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight);var docWidth = Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth); 注意，对于运行 在混杂模式下的 IE ，则 需要用 document.body 代替document.documentElement 。 通过 scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态 ，也可以设置元素的滚动位置 。在 元素尚未被滚动 时，这两个属性的值都等于 0 。如果 元素被垂直滚动了 ，那么 scrollTop 的值会大于 0 ，且 表示元素上方不可见内容的像素高度 。如果 元素被水平滚动了 ，那么 scrollLeft 的值会大于 0 ，且 表示元素左侧不可见内容的像素宽度 。这两个属性都是可以设置的 ，因此 将元素的 scrollLeft 和 scrollTop 设置为 0 ，就 可以重置元素的滚动位置 。下面这个函数会检测元素是否位于顶部，如果不是就将其回滚到顶部。 12345function scrollToTop(element)&#123; if (element.scrollTop != 0)&#123; element.scrollTop = 0; &#125;&#125; 这个函数既取得了 scrollTop 的值，也设置了它的值。 确定元素大小IE、Firefox 3+、Safari 4+、Opera 9.5及 Chrome为每个元素都提供了一个 getBoundingClientRect() 方法 。这个方法 返回会一个矩形对象 ，包含 4 个属性： left 、 top 、 right 和 bottom 。这些属性给出了元素在页面中相对于视口的位置 。但是，浏览器的实现稍有不同 。IE8 及更早版本认为文档的左上角坐标是(2, 2)，而其他浏览器包括 IE9 则将传统的(0,0)作为起点坐标。因此，就需要在一开始检查一下位于 (0,0)处的元素的位置，在 IE8 及更早版本中，会返回(2,2)，而在其他浏览器中会返回(0,0)。来看下面的函数： 12345678910111213141516171819function getBoundingClientRect(element)&#123; if (typeof arguments.callee.offset != "number")&#123; var scrollTop = document.documentElement.scrollTop; var temp = document.createElement("div"); temp.style.cssText = "position:absolute;left:0;top:0;"; document.body.appendChild(temp); arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; document.body.removeChild(temp); temp = null; &#125; var rect = element.getBoundingClientRect(); var offset = arguments.callee.offset; return &#123; left: rect.left + offset, right: rect.right + offset, top: rect.top + offset, bottom: rect.bottom + offset &#125;;&#125; 这个函数使用了它自身的属性来确定是否要对坐标进行调整。第一步是检测属性是否有定义，如果没有就定义一个。最终的 offset 会被设置为新元素上坐标的负值，实际上就是在 IE 中设置为2，在 Firefox 和 Opera 中设置为0。为此，需要创建一个临时的元素，将其位置设置在(0,0)，然后再调用其 getBoundingClientRect() 。而之所以要减去视口的 scrollTop ，是为了防止调用这个函数时窗口被滚动了。这样编写代码，就无需每次调用这个函数都执行两次 getBoundingClientRect() 了。接下来，再在传入的元素上调用这个方法并基于新的计算公式创建一个对象。 对于不支持 getBoundingClientRect() 的浏览器，可以通过其他手段取得相同的信息 。一般来说， right 和 left 的差值与 offsetWidth 的值相等 ，而 bottom 和 top 的差值与 offsetHeight 相等 。而且， left 和 top 属性大致等于使用本章前面定义的 getElementLeft() 和 getElementTop() 函数取得的值 。综合上述，就可以创建出下面这个 跨浏览器的函数 ： 123456789101112131415161718192021222324252627282930313233343536function getBoundingClientRect(element)&#123; var scrollTop = document.documentElement.scrollTop; var scrollLeft = document.documentElement.scrollLeft; if (element.getBoundingClientRect)&#123; if (typeof arguments.callee.offset != "number")&#123; var temp = document.createElement("div"); temp.style.cssText = "position:absolute;left:0;top:0;"; document.body.appendChild(temp); arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; document.body.removeChild(temp); temp = null; &#125; var rect = element.getBoundingClientRect(); var offset = arguments.callee.offset; return &#123; left: rect.left + offset, right: rect.right + offset, top: rect.top + offset, bottom: rect.bottom + offset &#125;; &#125; else &#123; var actualLeft = getElementLeft(element); var actualTop = getElementTop(element); return &#123; left: actualLeft - scrollLeft, right: actualLeft + element.offsetWidth - scrollLeft, top: actualTop - scrollTop, bottom: actualTop + element.offsetHeight - scrollTop &#125; &#125;&#125; 这个函数在 getBoundingClientRect() 有效时，就使用这个原生方法，而在这个方法无效时则使用默认的计算公式 。在某些情况下，这个函数返回的值可能会有所不同，例如使用表格布局或使用滚动元素的情况下。 由于这里使用了 arguments.callee ，所以这个方法不能在严格模式下使用。 遍历“DOM2 级遍历和范围”模块定义了两个用于辅助完成 顺序遍历 DOM结构的类型 ： NodeIterator 和 TreeWalker 。这两个类型能够基于给定的起点对 DOM结构执行深度优先（depth-first）的遍历操作 。在与 DOM 兼容的浏览器中（Firefox 1 及更高版本、Safari 1.3 及更高版本、Opera 7.6 及更高版本、Chrome 0.2 及更高版本），都可以访问到这些类型的对象。IE 不支持 DOM 遍历。使用下列代码可以检测浏览器对 DOM2 级遍历能力的支持情况。 123var supportsTraversals = document.implementation.hasFeature("Traversal", "2.0");var supportsNodeIterator = (typeof document.createNodeIterator == "function");var supportsTreeWalker = (typeof document.createTreeWalker == "function"); 如前所述，DOM 遍历是深度优先的 DOM 结构遍历 ，也就是说，移动的方向至少有两个（取决于使用的遍历类型）。遍历以给定节点为根，不可能向上超出 DOM 树的根节点 。以下面的 HTML 页面为例。 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 下图展示了这个页面的 DOM树。 任何节点都可以作为遍历的根节点 。如果假设 &lt;body&gt; 元素为根节点，那么遍历的第一步就是访问 &lt;p&gt;元素，然后再访问同为 &lt;body&gt; 元素后代的两个文本节点。不过，这次遍历永远不会到达 &lt;html&gt; 、 &lt;head&gt; 元素，也不会到达不属于 &lt;body&gt; 元素子树的任何节点。而以 document 为根节点的遍历则可以访问到文档中的全部节点。下图展示了对 以 document 为根节点的 DOM树进行深度优先遍历的先后顺序 。 从 document 开始依序向前，访问的第一个节点是 document ，访问的最后一个节点是包含”world!” 的文本节点。从文档最后的文本节点开始，遍历可以反向移动到 DOM 树的顶端。此时，访问的第一个节点是包含 “Hello” 的文本节点，访问的最后一个节点是 document 节点。 NodeIterator 和 TreeWalker 都以这种方式执行遍历。 NodeIteratorNodeIterator 类型是两者中比较简单的一个，可以使用 document.createNodeIterator() 方法创建它的新实例。这个方法接受下列 4 个参数。 root ：想要作为搜索起点的树中的节点。 whatToShow ：表示要访问哪些节点的数字代码。 filter ：是一个 NodeFilter 对象，或者一个表示应该接受还是拒绝某种特定节点的函数。 entityReferenceExpansion ：布尔值，表示是否要扩展实体引用。这个参数在 HTML 页面中没有用，因为其中的实体引用不能扩展。 whatToShow 参数 是一个 位掩码 ，通过应用一或多个过滤器（filter）来确定要访问哪些节点 。这个参数的值以常量形式在 NodeFilter 类型中定义，如下所示。 NodeFilter.SHOW_ALL ：显示所有类型的节点。 NodeFilter.SHOW_ELEMENT ：显示元素节点。 NodeFilter.SHOW_ATTRIBUTE ：显示特性节点。由于 DOM结构原因，实际上不能使用这个值。 NodeFilter.SHOW_TEXT ：显示文本节点。 NodeFilter.SHOW_CDATA_SECTION ：显示 CDATA 节点。对 HTML 页面没有用。 NodeFilter.SHOW_ENTITY_REFERENCE ：显示实体引用节点。对 HTML 页面没有用。 NodeFilter.SHOW_ENTITYE ：显示实体节点。对 HTML 页面没有用。 NodeFilter.SHOW_PROCESSING_INSTRUCTION ：显示处理指令节点。对 HTML 页面没有用。 NodeFilter.SHOW_COMMENT ：显示注释节点。 NodeFilter.SHOW_DOCUMENT ：显示文档节点。 NodeFilter.SHOW_DOCUMENT_TYPE ：显示文档类型节点。 NodeFilter.SHOW_DOCUMENT_FRAGMENT ：显示文档片段节点。对 HTML 页面没有用。 NodeFilter.SHOW_NOTATION ：显示符号节点。对 HTML 页面没有用。 除了 NodeFilter.SHOW_ALL 之外，可以使用按位或操作符来组合多个选项 ，如下面的例子所示： 1var whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT; 可以通过 createNodeIterator() 方法 的 filter 参数来 指定自定义的 NodeFilter 对象 ，或者 指定一个功能类似节点过滤器（node filter）的函数 。每个 NodeFilter 对象只有一个方法 ，即 acceptNode() ；如果 应该访问给定的节点 ，该方法返回 NodeFilter.FILTER_ACCEPT ，如果 不应该访问给定的节点 ，该方法返回 NodeFilter.FILTER_SKIP 。由于 NodeFilter 是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含 acceptNode() 方法的对象 ，然后 将这个对象传入 createNodeIterator() 中即可 。例如，下列代码展示了如何创建一个只显示 &lt;p&gt; 元素的节点迭代器。 12345678910var filter = &#123; acceptNode: function(node)&#123; return node.tagName.toLowerCase() == "p" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;&#125;; var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT,filter, false); 第三个参数也可以是一个与 acceptNode() 方法类似的函数 ，如下所示。 1234567var filter = function(node)&#123; return node.tagName.toLowerCase() == "p" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;&#125;;var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter, false); 一般来说，这就是在 JavaScript 中使用这个方法的形式，这种形式比较简单，而且也跟其他的 JavaScript 代码很相似。如果不指定过滤器，那么应该在第三个参数的位置上传入 null 。 下面的代码创建了 一个能够访问所有类型节点的简单的 NodeIterator 。 1var iterator = document.createNodeIterator(document, NodeFilter.SHOW_ALL, null, false); NodeIterator 类型的两个主要方法是 nextNode() 和 previousNode() 。顾名思义，在深度优先的 DOM 子树遍历中 ， nextNode() 方法用于向前前进一步 ，而 previousNode() 用于向后后退一步 。在刚刚创建的 NodeIterator 对象中，有一个内部指针指向根节点，因此第一次调用 nextNode() 会返回根节点。当遍历到 DOM子树的最后一个节点时 ，nextNode() 返回 null 。 previousNode() 方法的工作机制类似 。当遍历到 DOM 子树的最后一个节点，且 previousNode() 返回根节点之后，再次调用它就会返回 null 。 以下面的 HTML 片段为例。 12345678&lt;div id="div1"&gt; &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; &lt;ul&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 假设我们想要 遍历 &lt;div&gt; 元素中的所有元素 ，那么可以使用下列代码。 1234567var div = document.getElementById("div1");var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, null, false);var node = iterator.nextNode(); while (node !== null) &#123; alert(node.tagName); //输出标签名 node = iterator.nextNode();&#125; 在这个例子中，第一次调用 nextNode() 返回 &lt;p&gt; 元素。因为在到达 DOM子树末端时 nextNode() 返回 null ，所以 这里使用了 while 语句在每次循环时检查对 nextNode() 的调用是否返回了 null 。 执行上面的代码会显示如下标签名： 1234567DIVPBULLILILI 也许用不着显示那么多信息，你 只想返回遍历中遇到的 &lt;li&gt; 元素 。很简单，只要使用一个过滤器即可，如下面的例子所示。 1234567891011121314var div = document.getElementById("div1");var filter = function(node)&#123; return node.tagName.toLowerCase() == "li" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;&#125;;var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, filter, false);var node = iterator.nextNode();while (node !== null) &#123; alert(node.tagName); //输出标签名 node = iterator.nextNode();&#125; 在这个例子中，迭代器只会返回 &lt;li&gt; 元素。 由于 nextNode() 和 previousNode() 方法都基于 NodeIterator 在 DOM 结构中的内部指针工作 ，所以 DOM结构的变化会反映在遍历的结果中 。 Firefox 3.5 之前的版本没有实现 createNodeIterator() 方法，但却支持下一节要讨论的 createTreeWalker() 方法。 TreeWalkerTreeWalker 是 NodeIterator 的一个更高级的版本 。除了包括 nextNode() 和 previousNode() 在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历 DOM 结构的方法。 parentNode() ：遍历到当前节点的父节点； firstChild() ：遍历到当前节点的第一个子节点； lastChild() ：遍历到当前节点的最后一个子节点； nextSibling() ：遍历到当前节点的下一个同辈节点； previousSibling() ：遍历到当前节点的上一个同辈节点。 创建 TreeWalker 对象要使用 document.createTreeWalker() 方法 ，这个方法接受的 4 个参数与 document.createNodeIterator() 方法相同：作为遍历起点的根节点 、要显示的节点类型 、过滤器 和 一个表示是否扩展实体引用的布尔值 。由于这两个创建方法很相似，所以 很容易用 TreeWalker 来代替 NodeIterator ，如下面的例子所示。 1234567891011121314var div = document.getElementById("div1");var filter = function(node)&#123; return node.tagName.toLowerCase() == "li"? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;&#125;;var walker= document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false);var node = iterator.nextNode();while (node !== null) &#123; alert(node.tagName); //输出标签名 node = iterator.nextNode();&#125; 在这里，filter 可以返回的值有所不同。除了 NodeFilter.FILTER_ACCEPT 和 NodeFilter.FILTER_SKIP 之外 ，还可以使用 NodeFilter.FILTER_REJECT 。在使用 NodeIterator 对象时，NodeFilter.FILTER_SKIP 与 NodeFilter.FILTER_REJECT 的作用相同：跳过指定的节点。但在使用 TreeWalker 对象时， NodeFilter.FILTER_SKIP 会跳过相应节点继续前进到子树中的下一个节点，而 NodeFilter.FILTER_REJECT 则会跳过相应节点及该节点的整个子树。例如，将前面例子中的 NodeFilter.FILTER_SKIP 修改成 NodeFilter.FILTER_REJECT ，结果就是不会访问任何节点。这是因为第一个返回的节点是 &lt;div&gt; ，它的标签名不是 “li” ，于是就会返回 NodeFilter.FILTER_REJECT ，这意味着遍历会跳过整个子树。在这个例子中， &lt;div&gt; 元素是遍历的根节点，于是结果就会停止遍历。 当然，TreeWalker 真正强大的地方在于能够在 DOM 结构中沿任何方向移动 。使用 TreeWalker 遍历 DOM 树，即使不定义过滤器，也可以取得所有 &lt;li&gt; 元素，如下面的代码所示。 1234567891011var div = document.getElementById("div1");var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, null, false);walker.firstChild(); // 转到&lt;p&gt;walker.nextSibling(); // 转到&lt;ul&gt;var node = walker.firstChild(); // 转到第一个&lt;li&gt;while (node !== null) &#123; alert(node.tagName); node = walker.nextSibling();&#125; 因为我们知道 &lt;li&gt; 元素在文档结构中的位置，所以可以直接定位到那里，即使用 firstChild() 转到 &lt;p&gt; 元素，使用 nextSibling() 转到 &lt;ul&gt; 元素，然后再使用 firstChild() 转到第一个 &lt;li&gt; 元素。 注意，此处 TreeWalker 只返回元素（由传入到 createTreeWalker() 的第二个参数决定）。因此，可以放心地 使用 nextSibling() 访问每一个 &lt;li&gt; 元素 ，直至这个方法最后返回 null 。 TreeWalker 类型还有一个属性，名叫 currentNode ，表示任何遍历方法在上一次遍历中返回的节点 。通过设置这个属性也可以修改遍历继续进行的起点，如下面的例子所示。 123var node = walker.nextNode();alert(node === walker.currentNode); //truewalker.currentNode = document.body; //修改起点 与 NodeIterator 相比， TreeWalker 类型在遍历 DOM 时拥有更大的灵活性 。由于 IE 中没有对应的类型和方法，所以使用遍历的跨浏览器解决方案非常少见。 范围为了让开发人员更方便地控制页面，“DOM2 级遍历和范围”模块定义了“范围”（range）接口。通过范围可以选择文档中的一个区域，而不必考虑节点的界限 （选择在后台完成，对用户是不可见的）。 在常规的 DOM操作不能更有效地修改文档时，使用范围往往可以达到目的。Firefox、Opera、Safari 和 Chrome 都支持 DOM 范围。IE 以专有方式实现了自己的范围特性。12.4.1 DOM中的范围 DOM2 级在 Document 类型中定义了 createRange() 方法。在兼容 DOM 的浏览器中，这个方法属于 document 对象。使用 hasFeature() 或者直接检测该方法，都可以确定浏览器是否支持范围 。 12var supportsRange = document.implementation.hasFeature("Range", "2.0");var alsoSupportsRange = (typeof document.createRange == "function"); 如果浏览器支持范围，那么就可以使用 createRange() 来创建 DOM 范围，如下所示： 1var range = document.createRange(); 与节点类似，新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档 。创建了范围之后，接下来就可以使用它在后台选择文档中的特定部分。而 创建范围并设置了其位置之后 ，还 可以针对范围的内容执行很多种操作 ，从而实现对底层 DOM 树的更精细的控制 。 每个范围由一个 Range 类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范围在文档中的位置信息。 startContainer ：包含范围起点的节点（即选区中第一个节点的父节点）。 startOffset ：范围在 startContainer 中起点的偏移量。如果 startContainer 是文本节点、注释节点或 CDATA 节点，那么 startOffset 就是范围起点之前跳过的字符数量。否则，startOffset 就是范围中第一个子节点的索引。 endContainer ：包含范围终点的节点（即选区中最后一个节点的父节点）。 endOffset ：范围在 endContainer 中终点的偏移量（与 startOffset 遵循相同的取值规则）。 commonAncestorContainer ： startContainer 和 endContainer 共同的祖先节点在文档树中位置最深的那个。 在把范围放到文档中特定的位置时，这些属性都会被赋值 。 用 DOM 范围实现简单选择要使用范围来选择文档中的一部分 ，最简的方式就是使用 selectNode() 或 selectNodeContents() 。这两个方法都接受一个参数，即 一个 DOM 节点 ，然后使用该节点中的信息来填充范围 。其中，selectNode() 方法选择整个节点 ，包括其子节点 ；而 selectNodeContents() 方法则只选择节点的子节点 。以下面的 HTML 代码为例。 123456&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;p id="p1"&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 我们可以使用下列代码来创建范围： 123456var range1 = document.createRange(); range2 = document.createRange(); p1 = document.getElementById("p1");range1.selectNode(p1);range2.selectNodeContents(p1); 这里创建的两个范围包含文档中不同的部分： rang1 包含 &lt;p/&gt; 元素及其所有子元素 ，而 rang2 包含 &lt;b/&gt; 元素 、文本节点 “Hello” 和文本节点 “world!” （如下图所示）。 在调用 selectNode() 时， startContainer 、 endContainer 和 commonAncestorContainer 都等于传入节点的父节点，也就是这个例子中的 document.body 。而 startOffset 属性等于给定节点在其父节点的 childNodes 集合中的索引（在这个例子中是 1——因为兼容 DOM 的浏览器将空格算作一个文本节点）， endOffset 等于 startOffset 加 1（因为只选择了一个节点）。 在调用 selectNodeContents() 时， startContainer 、 endContainer 和 commonAncestorContainer 等于传入的节点，即这个例子中的 &lt;p&gt; 元素。而 startOffset 属性始终等于 0，因为范围从给定节点的第一个子节点开始。最后， endOffset 等于子节点的数量（ node.childNodes.length ），在这个例子中是 2。 此外，为了更精细地控制将哪些节点包含在范围中，还可以使用下列方法。 setStartBefore(refNode) ：将范围的起点设置在 refNode 之前，因此 refNode 也就是范围选区中的第一个子节点。同时会将 startContainer 属性设置为 refNode.parentNode ，将startOffset 属性设置为 refNode 在其父节点的 childNodes 集合中的索引。 setStartAfter(refNode) ：将范围的起点设置在 refNode 之后，因此 refNode 也就不在范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将 startContainer 属性设置为 refNode.parentNode ，将 startOffset 属性设置为 refNode 在其父节点的childNodes 集合中的索引加 1。 setEndBefore(refNode) ：将范围的终点设置在 refNode 之前，因此 refNode 也就不在范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将 endContainer 属性设置为 refNode.parentNode ，将 endOffset 属性设置为 refNode 在其父节点的 childNodes集合中的索引。 setEndAfter(refNode) ：将范围的终点设置在 refNode 之后，因此 refNode 也就是范围选区中的最后一个子节点。同时会将 endContainer 属性设置为 refNode.parentNode ，将 endOffset 属性设置为 refNode 在其父节点的 childNodes 集合中的索引加 1。 在调用这些方法时，所有属性都会自动为你设置好 。不过，要想创建复杂的范围选区，也可以直接指定这些属性的值。 用 DOM 范围实现复杂选择要创建复杂的范围就得使用 setStart() 和 setEnd() 方法 。这两个方法都接受两个参数：一个参照节点 和 一个偏移量值 。对 setStart() 来说，参照节点会变成 startContainer ，而 偏移量值会变成 startOffset 。对于 setEnd() 来说，参照节点会变成 endContainer ，而 偏移量值会变成 endOffset 。 可以使用这两个方法来模仿 selectNode() 和 selectNodeContents() 。来看下面的例子： 12345678910111213141516var range1 = document.createRange(); range2 = document.createRange(); p1 = document.getElementById("p1"); p1Index = -1; i, len;for (i=0, len=p1.parentNode.childNodes.length; i &lt; len; i++) &#123; if (p1.parentNode.childNodes[i] == p1) &#123; p1Index = i; break; &#125;&#125;range1.setStart(p1.parentNode, p1Index);range1.setEnd(p1.parentNode, p1Index + 1);range2.setStart(p1, 0);range2.setEnd(p1, p1.childNodes.length); 显然，要选择这个节点（使用 range1 ），就必须确定当前节点（ p1 ）在其父节点的 childNodes集合中的索引。而要选择这个节点的内容（使用 range2 ），也不必计算什么；只要通过 setStart()和 setEnd() 设置默认值即可。模仿 selectNode() 和 selectNodeContents() 并不是 setStart() 和 setEnd() 的主要用途，它们更胜一筹的地方在于能够选择节点的一部分。 假设你只想选择前面 HTML 示例代码中从 “Hello” 的 “llo” 到 “world!” 的 “o” ——很容易做到。 第一步是取得所有节点的引用，如下面的例子所示： 123var p1 = document.getElementById("p1");helloNode = p1.firstChild.firstChild;worldNode = p1.lastChild; 实际上， “Hello” 文本节点是 &lt;p&gt; 元素的孙子节点，因为它本身是 &lt;b&gt; 元素的一个子节点。因此，p1.firstChild 取得的是 &lt;b&gt; ，而 p1.firstChild.firstChild 取得的才是这个文本节点。 “world!” 文本节点是 &lt;p&gt; 元素的第二个子节点（也是最后一个子节点），因此可以使用 p1.lastChild 取得该节点。然后，必须在创建范围时指定相应的起点和终点，如下面的例子所示。 123var range = document.createRange();range.setStart(helloNode, 2);range.setEnd(worldNode, 3); 因为这个范围的选区应该从 “Hello” 中 “e” 的后面开始，所以在 setStart() 中传入 helloNode 的同时，传入了偏移量 2（即 “e” 的下一个位置； “H” 的位置是 0）。设置选区的终点时，在 setEnd() 中传入 worldNode 的同时传入了偏移量 3，表示选区之外的第一个字符的位置，这个字符是 “r” ，它的位置是 3（位置 0 上还有一个空格）。如下图所示。 由于 helloNode 和 worldNode 都是文本节点，因此它们分别变成了新建范围的 startContainer 和 endContainer 。此时 startOffset 和 endOffset 分别用以确定两个节点所包含的文本中的位置，而不是用以确定子节点的位置（就像传入的参数为元素节点时那样）。此时的 commonAncestorContainer 是 &lt;p&gt; 元素，也就是同时包含这两个节点的第一个祖先元素。 当然，仅仅是选择了文档中的某一部分用处并不大。但重要的是，选择之后才可以对选区进行操作 。 操作 DOM 范围中的内容在创建范围时 ，内部会为这个范围创建一个文档片段 ，范围所属的全部节点都被添加到了这个文档片段中 。为了创建这个文档片段，范围内容的格式必须正确有效 。在前面的例子中，我们创建的选区分别开始和结束于两个文本节点的内部，因此不能算是格式良好的 DOM 结构，也就无法通过 DOM 来表示。但是，范围知道自身缺少哪些开标签和闭标签，它能够重新构建有效的 DOM 结构以便我们对其进行操作 。 对于前面的例子而言，范围经过计算知道选区中缺少一个开始的 &lt;b&gt; 标签，因此就会在后台动态加入一个该标签，同时还会在前面加入一个表示结束的 &lt;/b&gt; 标签以结束 “He” 。于是，修改后的 DOM 就变成了如下所示。 1&lt;p&gt;&lt;b&gt;He&lt;/b&gt;&lt;b&gt;llo&lt;/b&gt; world!&lt;/p&gt; 另外，文本节点 “world!” 也被拆分为两个文本节点，一个包含 “wo” ，另一个包含 “rld!” 。最终的 DOM 树如下图所示，右侧是表示范围的文档片段的内容。 像这样创建了范围之后，就可以使用各种方法对范围的内容进行操作了（注意，表示范围的内部文档片段中的所有节点，都只是指向文档中相应节点的指针）。 第一个方法，也是最容易理解的方法，就是 deleteContents() 。这个方法 能够从文档中删除范围所包含的内容 。例如： 123456789var p1 = document.getElementById(&quot;p1&quot;); helloNode = p1.firstChild.firstChild; worldNode = p1.lastChild; range = document.createRange();range.setStart(helloNode, 2);range.setEnd(worldNode, 3);range.deleteContents(); 执行以上代码后，页面中会显示如下 HTML 代码： 1&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt; 由于范围选区在修改底层 DOM 结构时能够保证格式良好 ，因此 即使内容被删除了 ，最终的 DOM结构依旧是格式良好的。 与 deleteContents() 方法相似 ， extractContents() 也会从文档中移除范围选区 。但这两个方法的区别在于，extractContents() 会返回范围的文档片段 。利用这个返回的值 ，可以将范围的内容插入到文档中的其他地方 。如下面的例子所示： 12345678910var p1 = document.getElementById("p1"); helloNode = p1.firstChild.firstChild; worldNode = p1.lastChild; range = document.createRange();range.setStart(helloNode, 2);range.setEnd(worldNode, 3);var fragment = range.extractContents();p1.parentNode.appendChild(fragment); 在这个例子中，我们将提取出来的文档片段添加到了文档 &lt;body&gt; 元素的末尾。（记住，在将文档片段传入 appendChild() 方法中时 ，添加到文档中的只是片段的子节点，而非片段本身 。）结果得到如下HTML 代码： 12&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt;&lt;b&gt;llo&lt;/b&gt; wo 还一种做法，即 使用 cloneContents() 创建范围对象的一个副本 ，然后 在文档的其他地方插入该副本 。如下面的例子所示： 12345678910var p1 = document.getElementById("p1"), helloNode = p1.firstChild.firstChild, worldNode = p1.lastChild, range = document.createRange();range.setStart(helloNode, 2);range.setEnd(worldNode, 3);var fragment = range.cloneContents();p1.parentNode.appendChild(fragment); 这个方法与 extractContents() 非常类似，因为它们都返回文档片段 。它们的主要区别在于，cloneContents() 返回的文档片段包含的是范围中节点的副本 ，而 不是实际的节点 。执行上面的操作后，页面中的 HTML 代码应该如下所示： 12&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;&lt;b&gt;llo&lt;/b&gt; wo 有一点请读者注意，那就是在调用上面介绍的方法之前，拆分的节点并不会产生格式良好的文档片段 。换句话说，原始的 HTML 在 DOM 被修改之前会始终保持不变 。 插入 DOM 范围中的内容利用范围，可以删除或复制内容 ，还可以像前面介绍的那样操作范围中的内容 。使用 insertNode()方法 可以 向范围选区的开始处插入一个节点 。假设我们想在前面例子中的 HTML 前面插入以下 HTML 代码： 1&lt;span style="color: red"&gt;Inserted text&lt;/span&gt; 那么，就可以使用下列代码： 123456789101112var p1 = document.getElementById("p1"); helloNode = p1.firstChild.firstChild; worldNode = p1.lastChild; range = document.createRange();range.setStart(helloNode, 2);range.setEnd(worldNode, 3);var span = document.createElement("span");span.style.color = "red";span.appendChild(document.createTextNode("Inserted text"));range.insertNode(span); 运行以上 JavaScript 代码，就会得到如下 HTML 代码： 1&lt;p id="p1"&gt;&lt;b&gt;He&lt;span style="color: red"&gt;Inserted text&lt;/span&gt;llo&lt;/b&gt; world&lt;/p&gt; 注意，&lt;span&gt; 正好被插入到了 “Hello” 中的 “llo” 前面，而该位置就是范围选区的开始位置。还要注意的是，由于这里没有使用上一节介绍的方法，结果原始的 HTML 并没有添加或删除 &lt;b&gt; 元素。使用这种技术可以插入一些帮助提示信息，例如在打开新窗口的链接旁边插入一幅图像。 除了向范围内部插入内容之外 ，还可以 环绕范围插入内容 ，此时就要使用 surroundContents() 方法 。这个方法接受一个参数，即 环绕范围内容的节点 。在环绕范围插入内容时，后台会执行下列步骤。 提取出范围中的内容（类似执行 extractContent() ）； 将给定节点插入到文档中原来范围所在的位置上； 将文档片段的内容添加到给定节点中。 可以使用这种技术来突出显示网页中的某些词句，例如下列代码： 12345678910var p1 = document.getElementById("p1"); helloNode = p1.firstChild.firstChild; worldNode = p1.lastChild; range = document.createRange();range.selectNode(helloNode);var span = document.createElement("span");span.style.backgroundColor = "yellow";range.surroundContents(span); 会给范围选区加上一个黄色的背景。得到的 HTML 代码如下所示： 1&lt;p&gt;&lt;b&gt;&lt;span style="background-color:yellow"&gt;Hello&lt;/span&gt;&lt;/b&gt; world!&lt;/p&gt; 为了插入 &lt;span&gt; ，范围必须包含整个 DOM 选区（不能仅仅包含选中的 DOM 节点）。 折叠 DOM 范围所谓折叠范围，就是指范围中未选择文档的任何部分 。可以用文本框来描述折叠范围的过程 。假设文本框中有一行文本，你用鼠标选择了其中一个完整的单词。然后，你单击鼠标左键，选区消失，而光标则落在了其中两个字母之间。同样，在折叠范围时，其位置会落在文档中的两个部分之间，可能是范围选区的开始位置，也可能是结束位置。下图展示了折叠范围时发生的情形。 使用 collapse() 方法 来折叠范围，这个方法接受一个参数，一个布尔值 ，表示 要折叠到范围的哪一端 。参数 true 表示折叠到范围的起点 ，参数 false 表示折叠到范围的终点 。要确定范围已经折叠完毕 ，可以检查 collapsed 属性 ，如下所示： 12range.collapse(true); //折叠到起点alert(range.collapsed); //输出 true 检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻。例如，对于下面的 HTML 代码： 1&lt;p id="p1"&gt;Paragraph 1&lt;/p&gt;&lt;p id="p2"&gt;Paragraph 2&lt;/p&gt; 如果我们不知道其实际构成（比如说，这行代码是动态生成的），那么可以像下面这样创建一个范围。 1234567var p1 = document.getElementById("p1"), p2 = document.getElementById("p2"), range = document.createRange();range.setStartAfter(p1);range.setStartBefore(p2);alert(range.collapsed); //输出 true 在这个例子中，新创建的范围是折叠的，因为 p1 的后面和 p2 的前面什么也没有。 比较 DOM 范围 在有多个范围的情况下，可以使用 compareBoundaryPoints() 方法 来 确定这些范围是否有公共的边界（起点或终点）。这个方法接受两个参数：表示比较方式的常量值 和 要比较的范围 。表示比较方式的常量值如下所示。 Range.START_TO_START(0) ：比较第一个范围和第二个范围的起点； Range.START_TO_END(1) ：比较第一个范围的起点和第二个范围的终点； Range.END_TO_END(2) ：比较第一个范围和第二个范围的终点； Range.END_TO_START(3) ：比较第一个范围的终点和第一个范围的起点。 compareBoundaryPoints() 方法 可能的返回值如下：如果 第一个范围中的点位于第二个范围中的点之前 ，返回 -1 ；如果 两个点相等 ，返回 0 ；如果 第一个范围中的点位于第二个范围中的点之后 ，返回 1 。来看下面的例子。 12345678910var range1 = document.createRange();var range2 = document.createRange();var p1 = document.getElementById("p1");range1.selectNodeContents(p1);range2.selectNodeContents(p1);range2.setEndBefore(p1.lastChild);alert(range1.compareBoundaryPoints(Range.START_TO_START, range2)); //0alert(range1.compareBoundaryPoints(Range.END_TO_END, range2)); //1 在这个例子中，两个范围的起点实际上是相同的 ，因为它们的起点都是由 selectNodeContents() 方法设置的默认值来指定的 。因此，第一次比较返回 0 。但是， range2 的终点由于调用 setEndBefore() 已经改变了，结果是 range1 的终点位于 range2 的终点后面（见下图），因此第二次比较返回 1 。 复制 DOM 范围可以使用 cloneRange() 方法复制范围 。这个方法会创建调用它的范围的一个副本。 1var newRange = range.cloneRange(); 新创建的范围与原来的范围包含相同的属性，而修改它的端点不会影响原来的范围 。 清理 DOM 范围在使用完范围之后，最好是调用 detach() 方法，以便从创建范围的文档中分离出该范围 。调用 detach() 之后，就 可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存了 。来看下面的例子。 12range.detach(); //从文档中分离range = null; //解除引用 在使用范围的最后再执行这两个步骤是我们推荐的方式。一旦分离范围，就不能再恢复使用了 。 IE8 及更早版本中的范围虽然 IE9 支持 DOM 范围，但 IE8 及之前版本不支持 DOM范围。不过，IE8 及早期版本支持一种类似的概念，即文本范围（text range）。文本范围是 IE 专有的特性，其他浏览器都不支持。顾名思义，文本范围处理的主要是文本（不一定是 DOM节点）。通过 &lt;body&gt; 、&lt;button&gt; 、 &lt;input&gt; 和 &lt;textarea&gt; 等这几个元素，可以调用 createTextRange() 方法来创建文本范围 。以下是一个例子： 1var range = document.body.createTextRange(); 像这样 通过 document 创建的范围可以在页面中的任何地方使用（通过其他元素创建的范围则只能在相应的元素中使用）。与 DOM 范围类似，使用 IE 文本范围的方式也有很多种。 用 IE 范围实现简单的选择选择页面中某一区域的最简单方式，就是使用范围的 findText() 方法 。这个方法会找到第一次出现的给定文本，并将范围移过来以环绕该文本。如果没有找到文本，这个方法返回 false ；否则返回 true 。同样，仍然以下面的 HTML 代码为例。 1&lt;p id="p1"&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; 要选择 “Hello” ，可以使用下列代码。 12var range = document.body.createTextRange();var found = range.findText("Hello"); 在执行完第二行代码之后，文本 “Hello” 就被包围在范围之内了。为此，可以检查范围的 text 属性来确认（这个属性返回范围中包含的文本），或者也可以检查 findText() 的返回值——在找到了文本的情况下返回值为 true 。例如： 12alert(found); //truealert(range.text); //"Hello" 还可以为 findText() 传入另一个参数 ，即 一个表示向哪个方向继续搜索的数值 。负值表示应该从当前位置向后搜索 ，而 正值表示应该从当前位置向前搜索 。因此，要查找文档中前两个 “Hello” 的实例，应该使用下列代码。 12var found = range.findText("Hello");var foundAgain = range.findText("Hello", 1); IE 中与 DOM 中的 selectNode() 方法最接近的方法是 moveToElementText() ，这个方法接受 一个 DOM 元素 ，并 选择该元素的所有文本 ，包括 HTML 标签。下面是一个例子。 123var range = document.body.createTextRange();var p1 = document.getElementById("p1");range.moveToElementText(p1); 在文本范围中包含 HTML 的情况下，可以使用 htmlText 属性取得范围的全部内容 ，包括 HTML和文本 ，如下面的例子所示。 1alert(range.htmlText); IE 的范围没有任何属性可以随着范围选区的变化而动态更新 。不过，其 parentElement() 方法倒是与 DOM 的 commonAncestorContainer 属性类似 。 1var ancestor = range.parentElement(); 这样得到的父元素始终都可以反映文本选区的父节点 。 使用 IE 范围实现复杂的选择在 IE 中创建复杂范围的方法，就是以特定的增量向四周移动范围 。为此，IE 提供了 4 个方法：move() 、 moveStart() 、 moveEnd() 和 expand() 。这些方法都接受两个参数：移动单位 和 移动单位的数量 。其中，移动单位是下列一种字符串值。 “character” ：逐个字符地移动。 “word” ：逐个单词（一系列非空格字符）地移动。 “sentence” ：逐个句子（一系列以句号、问号或叹号结尾的字符）地移动。 “textedit” ：移动到当前范围选区的开始或结束位置。 通过 moveStart() 方法可以移动范围的起点，通过 moveEnd() 方法可以移动范围的终点，移动的幅度由单位数量指定，如下面的例子所示。 12range.moveStart("word", 2); //起点移动 2 个单词range.moveEnd("character", 1); //终点移动 1 个字符 使用 expand() 方法可以将范围规范化 。换句话说， expand() 方法的作用是将任何部分选择的文本全部选中 。例如，当前选择的是一个单词中间的两个字符，调用 expand(“word”) 可以将整个单词都包含在范围之内。 而 move() 方法则首先会折叠当前范围（让起点和终点相等），然后 再将范围移动指定的单位数量 ，如下面的例子所示。 1range.move("character", 5); //移动 5 个字符 调用 move() 之后，范围的起点和终点相同 ，因此 必须再使用 moveStart() 或 moveEnd() 创建新的选区 。 操作 IE 范围中的内容在 IE 中操作范围中的内容可以使用 text 属性或 pasteHTML() 方法 。如前所述，通过 text 属性可以取得范围中的内容文本 ；但是，也可以 通过这个属性设置范围中的内容文本 。来看一个例子。 123var range = document.body.createTextRange();range.findText("Hello");range.text = "Howdy"; 如果仍以前面的 Hello World代码为例，执行以上代码后的 HTML 代码如下。 1&lt;p id="p1"&gt;&lt;b&gt;Howdy&lt;/b&gt; world!&lt;/p&gt; 注意，在设置 text 属性的情况下，HTML 标签保持不变。 要向范围中插入 HTML 代码，就得使用 pasteHTML() 方法，如下面的例子所示。 123var range = document.body.createTextRange();range.findText("Hello");range.pasteHTML("&lt;em&gt;Howdy&lt;/em&gt;"); 执行这些代码后，会得到如下 HTML。 1&lt;p id="p1"&gt;&lt;b&gt;&lt;em&gt;Howdy&lt;/em&gt;&lt;/b&gt; world!&lt;/p&gt; 不过，在范围中包含 HTML 代码时，不应该使用 pasteHTML() ，因为 这样很容易导致不可预料的结果 ——很可能是格式不正确的 HTML。 折叠 IE 范围IE 为范围提供的 collapse() 方法与相应的 DOM 方法用法一样：传入 true 把范围折叠到起点，传入 false 把范围折叠到终点。例如： 1range.collapse(true); //折叠到起点 可惜的是，没有对应的 collapsed 属性让我们知道范围是否已经折叠完毕 。为此，必须 使用 boundingWidth 属性 ，该属性返回范围的宽度 （以像素为单位）。如果 boundingWidth 属性等于 0，就说明范围已经折叠了 ： 1var isCollapsed = (range.boundingWidth == 0); 此外，还有 boundingHeight 、 boundingLeft 和 boundingTop 等属性，虽然它们都不像 boundingWidth 那么有用，但也可以提供一些有关范围位置的信息。 比较 IE 范围IE 中的 compareEndPoints() 方法与 DOM 范围的 compareBoundaryPoints() 方法类似 。这个方法接受两个参数：比较的类型 和 要比较的范围 。比较类型的取值范围是下列几个字符串值：”StartToStart” 、 “StartToEnd” 、 “EndToEnd” 和 “EndToStart” 。这几种比较类型与比较 DOM范围时使用的几个值是相同的。 同样与 DOM 类似的是，compareEndPoints() 方法也会按照相同的规则返回值 ，即如果 第一个范围的边界位于第二个范围的边界前面 ，返回 -1 ；如果 二者边界相同 ，返回 0 ；如果 第一个范围的边界位于第二个范围的边界后面 ，返回 1 。仍以前面的 Hello World 代码为例，下列代码将创建两个范围，一个选择 “Hello world!” （包括 &lt;b&gt; 标签），另一个选择 “Hello” 。 123456var range1 = document.body.createTextRange();var range2 = document.body.createTextRange();range1.findText("Hello world!");range2.findText("Hello");alert(range1.compareEndPoints("StartToStart", range2)); //0alert(range1.compareEndPoints("EndToEnd", range2)); //1 由于这两个范围共享同一个起点，所以使用 compareEndPoints() 比较起点返回 0 。而 range1的终点在 range2 的终点后面，所以 compareEndPoints() 返回 1 。IE 中还有两个方法，也是用于比较范围的： isEqual() 用于确定两个范围是否相等， inRange() 用于确定一个范围是否包含另一个范围。下面是相应的示例。 123456var range1 = document.body.createTextRange();var range2 = document.body.createTextRange();range1.findText("Hello World");range2.findText("Hello");alert("range1.isEqual(range2): " + range1.isEqual(range2)); //falsealert("range1.inRange(range2):" + range1.inRange(range2)); //true 这个例子使用了与前面相同的范围来示范这两个方法。由于这两个范围的终点不同，所以它们不相等，调用 isEqual() 返回 false 。由于 range2 实际位于 range1 内部，它的终点位于后者的终点之前、起点之后，所以 range2 被包含在 range1 内部，调用 inRange() 返回 true 。 复制 IE 范围在 IE 中使用 duplicate() 方法可以复制文本范围 ，结果会创建原范围的一个副本 ，如下面的例子所示。 1var newRange = range.duplicate(); 新创建的范围会带有与原范围完全相同的属性 。 小结DOM2 级规范定义了一些模块，用于增强 DOM1 级。“DOM2 级核心”为不同的 DOM 类型引入了一些与 XML 命名空间有关的方法 。这些变化 只在使用 XML 或 XHTML 文档时才有用 ；对于 HTML文档没有实际意义 。除了与 XML 命名空间有关的方法外，“DOM2 级核心”还定义了以编程方式创建 Document 实例的方法 ，也 支持了创建 DocumentType 对象 。 “DOM2 级样式”模块主要针对操作元素的样式信息而开发 ，其特性简要总结如下。 每个元素都有一个关联的 style 对象，可以用来确定和修改行内的样式。 要确定某个元素的计算样式（包括应用给它的所有 CSS 规则），可以使用 getComputedStyle()方法。 IE不支持 getComputedStyle() 方法，但为所有元素都提供了能够返回相同信息 currentStyle 属性。 可以通过 document.styleSheets 集合访问样式表。 除 IE 之外的所有浏览器都支持针对样式表的这个接口，IE 也为几乎所有相应的 DOM功能提供了自己的一套属性和方法。 “DOM2 级遍历和范围”模块提供了与 DOM结构交互的不同方式 ，简要总结如下。 遍历即使用 NodeIterator 或 TreeWalker 对 DOM 执行深度优先的遍历。 NodeIterator 是一个简单的接口，只允许以一个节点的步幅前后移动。而 TreeWalker 在提供相同功能的同时，还支持在 DOM 结构的各个方向上移动，包括父节点、同辈节点和子节点等方向。 范围是选择 DOM结构中特定部分，然后再执行相应操作的一种手段。 使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中的相应部分。 IE8 及更早版本不支持“DOM2 级遍历和范围”模块，但它提供了一个专有的文本范围对象，可以用来完成简单的基于文本的范围操作。IE9 完全支持 DOM遍历。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-DOM扩展]]></title>
    <url>%2F2018%2F08%2F23%2FJavaScript-DOM-extend%2F</url>
    <content type="text"><![CDATA[DOM 扩展尽管 DOM 作为 API 已经非常完善了，但为了实现更多的功能，仍然会有一些标准或专有的扩展。2008 年之前，浏览器中几乎所有的 DOM扩展都是专有的。此后，W3C 着手将一些已经成为事实标准的专有扩展标准化并写入规范当中。 对 DOM 的两个主要的扩展是 Selectors API（选择符 API）和 HTML5 。这两个扩展都源自开发社区，而将某些常见做法及 API 标准化一直是众望所归。此外，还有一个不那么引人瞩目的 Element Traversal（元素遍历）规范 ，为 DOM 添加了一些属性 。虽然前述两个主要规范（特别是 HTML5）已经涵盖了大量的 DOM 扩展，但专有扩展依然存在。本章也会介绍专有的 DOM 扩展。 选择符 API众多 JavaScript 库中最常用的一项功能，就是 根据 CSS 选择符选择与某个模式匹配的 DOM 元素 。实际上，jQuery（ www.jquery.com ）的核心就是 通过 CSS 选择符查询 DOM 文档取得元素的引用 ，从而抛开了 getElementById() 和 getElementsByTagName() 。 Selectors API（ www.w3.org/TR/selectors-api/ ）是由 W3C 发起制定的一个标准，致力于让浏览器原生支持 CSS 查询 。所有实现这一功能的 JavaScript 库都会写一个基础的 CSS 解析器，然后再使用已有的DOM 方法查询文档并找到匹配的节点。尽管库开发人员在不知疲倦地改进这一过程的性能，但到头来都只能通过运行 JavaScript 代码来完成查询操作。而把这个功能变成原生 API 之后，解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大地改善了性能。 Selectors API Level 1 的核心是两个方法： querySelector() 和 querySelectorAll() 。在兼容的浏览器中，可以通过 Document 及 Element 类型的实例调用它们 。目前已完全支持 Selectors API Level 1 的浏览器有 IE 8+、Firefox 3.5+、Safari 3.1+、Chrome和 Opera 10+。 querySelector() 方法querySelector() 方法 接收一个 CSS 选择符 ，返回与该模式匹配的第一个元素 ，如果没有找到匹配的元素 ，返回 null 。请看下面的例子。 1234567891011//取得 body 元素var body = document.querySelector("body");//取得 ID 为"myDiv"的元素var myDiv = document.querySelector("#myDiv");//取得类为"selected"的第一个元素var selected = document.querySelector(".selected");//取得类为"button"的第一个图像元素var img = document.body.querySelector("img.button"); 通过 Document 类型调用 querySelector() 方法 时，会在文档元素的范围内查找匹配的元素 。而 通过 Element 类型调用 querySelector() 方法 时，只会在该元素后代元素的范围内查找匹配的元素 。 CSS 选择符可以简单也可以复杂，视情况而定。如果传入了不被支持的选择符， querySelector() 会抛出错误 。 querySelectorAll() 方法querySelectorAll() 方法 接收的参数与 querySelector() 方法一样，都是 一个 CSS 选择符 ，但 返回的是所有匹配的元素 而不仅仅是一个元素。这个方法返回的是一个 NodeList 的实例 。 具体来说，返回的值实际上是带有所有属性和方法的 NodeList ，而其底层实现则类似于 一组元素的快照 ，而非不断对文档进行搜索的动态查询 。这样实现可以避免使用 NodeList 对象通常会引起的大多数性能问题 。 只要传给 querySelectorAll() 方法 的 CSS 选择符有效，该方法都会 返回一个 NodeList 对象 ，而 不管找到多少匹配的元素 。如果没有找到匹配的元素 ， NodeList 就是空的 。 与 querySelector() 类似，能够调用 querySelectorAll() 方法的类型包括 Document 、DocumentFragment 和 Element 。下面是几个例子。 12345678//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName("em")）var ems = document.getElementById("myDiv").querySelectorAll("em");//取得类为"selected"的所有元素var selecteds = document.querySelectorAll(".selected");//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll("p strong"); 要取得返回的 NodeList 中的每一个元素 ，可以使用 item() 方法 ，也可以使用 方括号语法 ，比如： 12345var i, len, strong;for (i=0, len=strongs.length; i &lt; len; i++)&#123; strong = strongs[i]; //或者 strongs.item(i) strong.className = "important";&#125; 同样与 querySelector() 类似，如果传入了浏览器不支持的选择符或者选择符中有语法错误 ，querySelectorAll() 会抛出错误 。 matchesSelector() 方法Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector() 。这个方法接收一个参数，即 CSS 选择符 ，如果调用元素与该选择符匹配，返回 true ；否则，返回 false 。看例子。 123if (document.body.matchesSelector("body.page1"))&#123; //true&#125; 在取得某个元素引用的情况下，使用这个方法能够方便地检测它是否会被 querySelector() 或 querySelectorAll() 方法返回 。 截至 2011 年年中，还没有浏览器支持 matchesSelector() 方法；不过，也有一些实验性的实现。IE 9+通过 msMatchesSelector() 支持该方法，Firefox 3.6+通过 mozMatchesSelector() 支持该方法，Safari 5+和 Chrome 通过 webkitMatchesSelector() 支持该方法。因此，如果你想使用这个方法，最好是编写一个包装函数 。 1234567891011121314151617function matchesSelector(element, selector)&#123; if (element.matchesSelector)&#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector)&#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector)&#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector)&#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error("Not supported."); &#125;&#125;if (matchesSelector(document.body, "body.page1"))&#123; //执行操作&#125; 元素遍历对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用 childNodes 和 firstChild 等属性时的行为不一致。为了弥补这一差异，而同时又保持 DOM规范不变，Element Traversal规范（ www.w3.org/TR/ElementTraversal/ ）新定义了一组属性 。 Element Traversal API 为 DOM 元素添加了以下 5 个属性。 childElementCount ：返回子元素（不包括文本节点和注释）的个数。 firstElementChild ：指向第一个子元素； firstChild 的元素版。 lastElementChild ：指向最后一个子元素； lastChild 的元素版。 previousElementSibling ：指向前一个同辈元素； previousSibling 的元素版。 nextElementSibling ：指向后一个同辈元素； nextSibling 的元素版。 支持的浏览器为 DOM 元素添加了这些属性，利用这些元素不必担心空白文本节点 ， 从而可以更方便地查找 DOM元素了 。 下面来看一个例子。过去，要 跨浏览器遍历某元素的所有子元素 ，需要像下面这样写代码。 123456789var i, len, child = element.firstChild;while(child != element.lastChild)&#123; if (child.nodeType == 1)&#123; //检查是不是元素 processChild(child); &#125; child = child.nextSibling;&#125; 而 使用 Element Traversal 新增的元素 ，代码会更简洁。 1234567var i, len, child = element.firstElementChild;while(child != element.lastElementChild)&#123; processChild(child); //已知其是元素 child = child.nextElementSibling;&#125; 支持 Element Traversal 规范的浏览器有 IE 9+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10+。 HTML5对于传统 HTML 而言，HTML5 是一个叛逆。所有之前的版本对 JavaScript 接口的描述都不过三言两语，主要篇幅都用于定义标记，与 JavaScript 相关的内容一概交由 DOM 规范去定义。 而 HTML5 规范则围绕如何使用新增标记定义了大量 JavaScript API 。其中一些 API 与 DOM 重叠，定义了浏览器应该支持的 DOM扩展。 因为 HTML5 涉及的面非常广，本节只讨论与 DOM 节点相关的内容。HTML5 的其他相关内容将在本书其他章节中穿插介绍。 与类相关的扩充HTML4 在 Web 开发领域得到广泛采用后导致了一个很大的变化，即 class 属性用得越来越多 ，一方面 可以通过它为元素添加样式 ，另一方面 还可以用它表示元素的语义 。于是，自然就有很多 JavaScript 代码会来操作 CSS 类，比如动态修改类或者搜索文档中具有给定类或给定的一组类的元素，等等。为了让开发人员适应并增加对 class 属性的新认识，HTML5 新增了很多 API，致力于简化 CSS 类的用法 。 getElementsByClassName() 方法HTML5 添加的 getElementsByClassName() 方法 是最受人欢迎的一个方法，可以通过 document 对象及所有 HTML 元素调用该方法 。这个方法最早出现在 JavaScript 库 中，是 通过既有的 DOM 功能实现的 ，而 原生的实现具有极大的性能优势 。 getElementsByClassName() 方法 接收一个参数，即 一个包含一或多个类名的字符串 ，返回带有指定类的所有元素的 NodeList 。传入多个类名 时，类名的先后顺序不重要 。来看下面的例子。 12345//取得所有类中包含"username"和"current"的元素，类名的先后顺序无所谓var allCurrentUsernames = document.getElementsByClassName("username current");//取得 ID 为"myDiv"的元素中带有类名"selected"的所有元素var selected = document.getElementById("myDiv").getElementsByClassName("selected"); 调用这个方法时，只有位于调用元素子树中的元素才会返回。在 document 对象上调用getElementsByClassName() 始终会返回与类名匹配的所有元素 ，在元素上调用该方法就只会返回后代元素中匹配的元素 。 使用这个方法可以更方便地为带有某些类的元素添加事件处理程序，从而不必再局限于使用 ID或标签名。不过别忘了，因为 返回的对象是 NodeList ，所以 使用这个方法与使用 getElementsByTagName() 以及其他返回 NodeList 的 DOM 方法都具有同样的性能问题 。支持 getElementsByClassName() 方法的浏览器有 IE 9+、Firefox 3+、Safari 3.1+、Chrome 和 Opera 9.5+。 classList 属性在操作类名时，需要通过 className 属性 添加、删除和替换类名。因为 className 中是一个字符串 ，所以 即使只修改字符串一部分，也必须每次都设置整个字符串的值 。比如，以下面的 HTML 代码为例。 1&lt;div class="bd user disabled"&gt;...&lt;/div&gt; 这个 &lt;div&gt; 元素一共有三个类名。要从中删除一个类名，需要把这三个类名拆开，删除不想要的那个，然后再把其他类名拼成一个新字符串。请看下面的例子。 123456789101112131415161718192021//删除"user"类//首先，取得类名字符串并拆分成数组var classNames = div.className.split(/\s+/);//找到要删的类名var pos = -1, i, len;for (i=0, len=classNames.length; i &lt; len; i++)&#123; if (classNames[i] == "user")&#123; pos = i; break; &#125;&#125;//删除类名classNames.splice(i,1);//把剩下的类名拼成字符串并重新设置div.className = classNames.join(" "); 为了从 &lt;div&gt; 元素的 class 属性中删除 “user” ，以上这些代码都是必需的。必须得通过类似的算法替换类名并确认元素中是否包含该类名。添加类名可以通过拼接字符串完成，但必须要通过检测确定不会多次添加相同的类名。很多 JavaScript 库都实现了这个方法，以简化这些操作。 HTML5 新增了一种操作类名的方式 ，可以让操作更简单也更安全，那就是 为所有元素添加 classList 属性 。这个 classList 属性 是 新集合类型 DOMTokenList 的实例 。与其他 DOM 集合类似，DOMTokenList 有一个表示自己包含多少元素的 length 属性 ，而 要取得每个元素可以使用 item() 方法 ，也 可以使用方括号语法 。此外，这个新类型还定义如下方法。 add(value) ：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 contains(value) ：表示列表中是否存在给定的值，如果存在则返回 true ，否则返回 false 。 remove(value) ：从列表中删除给定的字符串。 toggle(value) ：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 这样，前面那么多行代码用下面这一行代码就可以代替了： 1div.classList.remove("user"); 以上代码能够确保其他类名不受此次修改的影响。其他方法也能极大地减少类似基本操作的复杂性，如下面的例子所示。 1234567891011121314151617//删除"disabled"类div.classList.remove("disabled");//添加"current"类div.classList.add("current");//切换"user"类div.classList.toggle("user");//确定元素中是否包含既定的类名if (div.classList.contains("bd") &amp;&amp; !div.classList.contains("disabled"))&#123; //执行操作)//迭代类名for (var i=0, len=div.classList.length; i &lt; len; i++)&#123; doSomething(div.classList[i]);&#125; 有了 classList 属性 ，除非你需要全部删除所有类名 ，或者完全重写元素的 class 属性 ，否则也就用不到 className 属性了 。 支持 classList 属性的浏览器有 Firefox 3.6+和 Chrome。 焦点管理HTML5 也添加了辅助管理 DOM 焦点的功能 。首先就是 document.activeElement 属性 ，这个属性 始终会引用 DOM 中当前获得了焦点的元素 。元素获得焦点的方式 有 页面加载 、用户输入（通常是通过按 Tab 键）和 在代码中调用 focus() 方法 。来看几个例子。 123var button = document.getElementById("myButton");button.focus();alert(document.activeElement === button); //true 默认情况下，文档刚刚加载完成时， document.activeElement 中保存的是 document.body 元素的引用。文档加载期间， document.activeElement 的值为 null 。另外就是新增了 document.hasFocus() 方法，这个方法用于确定文档是否获得了焦点。 123var button = document.getElementById("myButton");button.focus();alert(document.hasFocus()); //true 通过检测文档是否获得了焦点，可以知道用户是不是正在与页面交互。 查询文档获知哪个元素获得了焦点，以及确定文档是否获得了焦点 ，这两个功能最重要的用途是提高 Web 应用的无障碍性。无障碍 Web 应用的一个主要标志就是恰当的焦点管理，而确切地知道哪个元素获得了焦点是一个极大的进步，至少我们不用再像过去那样靠猜测了。 实现了这两个属性的浏览器的包括 IE 4+、Firefox 3+、Safari 4+、Chrome 和 Opera 8+。 HTMLDocument 的变化HTML5 扩展了 HTMLDocument ，增加了新的功能 。与 HTML5 中新增的其他 DOM 扩展类似，这些变化同样基于那些已经得到很多浏览器完美支持的专有扩展。所以，尽管这些扩展被写入标准的时间相对不长，但很多浏览器很早就已经支持这些功能了。 readyState 属性IE4 最早为 document 对象引入了 readyState 属性。然后，其他浏览器也都陆续添加这个属性，最终 HTML5 把这个属性纳入了标准当中。 Document 的 readyState 属性有两个可能的值： loading ，正在加载文档； complete ，已经加载完文档。 使用 document.readyState 的最恰当方式，就是 通过它来实现一个指示文档已经加载完成的指示器 。在这个属性得到广泛支持之前，要实现这样一个指示器，必须借助 onload 事件处理程序设置一个标签，表明文档已经加载完毕。 document.readyState 属性的基本用法如下。 123if (document.readyState == "complete")&#123; //执行操作&#125; 支持 readyState 属性的浏览器有 IE4+、Firefox 3.6+、Safari、Chrome和 Opera 9+。 兼容模式自从 IE6 开始区分渲染页面的模式是标准的还是混杂的，检测页面的兼容模式就成为浏览器的必要功能 。IE 为此给 document 添加了一个名为 compatMode 的属性，这个属性就是为了告诉开发人员浏览器采用了哪种渲染模式。就像下面例子中所展示的那样，在 标准模式 下， document.compatMode 的值 等于 “CSS1Compat “ ，而在 混杂模式 下， document.compatMode 的值 等于 “BackCompat “ 。 12345if (document.compatMode == "CSS1Compat")&#123; alert("Standards mode");&#125; else &#123; alert("Quirks mode");&#125; 后来，陆续实现这个属性的浏览器有 Firefox、Safari 3.1+、Opera 和 Chrome。最终，HTML5 也把这个属性纳入标准，对其实现做出了明确规定。 head 属性作为对 document.body 引用文档的 &lt;body&gt; 元素的补充 ，HTML5 新增了 document.head 属性 ，引用文档的 &lt;head&gt; 元素。要引用文档的 &lt;head&gt; 元素，可以结合使用这个属性和另一种后备方法。 1var head = document.head || document.getElementsByTagName("head")[0]; 如果可用，就使用 document.head ，否则仍然使用 getElementsByTagName() 方法 。 实现 document.head 属性的浏览器包括 Chrome 和 Safari 5。 字符集属性 HTML5 新增了几个与文档字符集有关的属性。其中， charset 属性 表示 文档中实际使用的字符集 ，也可以 用来指定新字符集 。默认情况 下，这个属性的值为 “UTF-16“ ，但可以通过 &lt;meta&gt; 元素 、响应头部 或 直接设置 charset 属性 修改这个值。来看一个例子。 12alert(document.charset); //"UTF-16"document.charset = "UTF-8"; 另一个属性是 defaultCharset ，表示根据默认浏览器及操作系统的设置 ，当前文档默认的字符集应该是什么。如果文档没有使用默认的字符集 ，那 charset 和 defaultCharset 属性的值可能会不一样 ，例如： 123if (document.charset != document.defaultCharset)&#123; alert("Custom character set being used.");&#125; 通过这两个属性可以得到文档使用的字符编码的具体信息 ，也能对字符编码进行准确地控制 。运行适当的情况下，可以保证用户正常查看页面或使用应用 。 支持 document.charset 属性的浏览器有 IE、Firefox、Safari、Opera 和 Chrome。支持 document.defaultCharset 属性的浏览器有 IE、Safari 和 Chrome。 自定义数据属性HTML5 规定可以为元素添加非标准的属性 ，但要添加前缀 data- ，目的是为元素提供与渲染无关的信息 ，或者提供语义信息 。这些属性可以任意添加、随便命名，只要以 data- 开头即可 。来看一个例子。 1&lt;div id="myDiv" data-appId="12345" data-myname="Nicholas"&gt;&lt;/div&gt; 添加了自定义属性之后，可以 通过元素的 dataset 属性来访问自定义属性的值 。 dataset 属性的值 是 DOMStringMap 的一个实例 ，也就是 一个名值对儿的映射 。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性 ，只不过属性名没有 data- 前缀（比如，自定义属性是 data-myname ，那映射中对应的属性就是 myname ）。还是看一个例子吧。 123456789101112131415//本例中使用的方法仅用于演示var div = document.getElementById("myDiv");//取得自定义属性的值var appId = div.dataset.appId;var myName = div.dataset.myname;//设置值div.dataset.appId = 23456;div.dataset.myname = "Michael";//有没有"myname"值呢？if (div.dataset.myname)&#123; alert("Hello, " + div.dataset.myname);&#125; 如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性 。在跟踪链接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分。 在编写本书时，支持自定义数据属性的浏览器有 Firefox 6+和 Chrome。 插入标记虽然 DOM 为操作节点提供了细致入微的控制手段，但在需要给文档插入大量新 HTML 标记的情况下，通过 DOM 操作仍然非常麻烦，因为不仅要创建一系列 DOM 节点，而且还要小心地按照正确的顺序把它们连接起来。相对而言，使用 插入标记的技术 ，直接插入 HTML 字符串不仅更简单 ，速度也更快 。以下与插入标记相关的 DOM 扩展已经纳入了 HTML5 规范。 ####innerHTML 属性 在读模式下， innerHTML 属性 返回 与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记。在写模式下， innerHTML 会根据指定的值创建新的 DOM 树 ，然后用这个 DOM 树完全替换调用元素原先的所有子节点 。下面是一个例子。 12345678&lt;div id="content"&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对于上面的 &lt;div&gt; 元素来说，它的 innerHTML 属性会返回如下字符串。 123456&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 但是，不同浏览器返回的文本格式会有所不同 。IE 和 Opera 会将所有标签转换为大写形式，而 Safari、Chrome 和 Firefox 则会原原本本地按照原先文档中（或指定这些标签时）的格式返回 HTML，包括空格和缩进。不要指望所有浏览器返回的 innerHTML 值完全相同。 在 写模式 下， innerHTML 的值会被解析为 DOM 子树 ，替换调用元素原来的所有子节点 。因为 它的值被认为是 HTML ，所以 其中的所有标签都会按照浏览器处理 HTML 的标准方式转换为元素（同样，这里的转换结果也因浏览器而异）。如果 设置的值仅是文本而没有 HTML 标签 ，那么 结果就是设置纯文本 ，如下所示。 1div.innerHTML = "Hello world!"; 为 innerHTML 设置的包含 HTML 的字符串值与解析后 innerHTML 的值大不相同 。来看下面的例子。 1div.innerHTML = "Hello &amp; welcome, &lt;b&gt;\"reader\"!&lt;/b&gt;"; 以上操作得到的结果如下： 1&lt;div id="content"&gt;Hello &amp;amp; welcome, &lt;b&gt;&amp;quot;reader&amp;quot;!&lt;/b&gt;&lt;/div&gt; 设置了 innerHTML 之后，可以像访问文档中的其他节点一样访问新创建的节点。 为 innerHTML 设置 HTML 字符串后，浏览器会将这个字符串解析为相应的 DOM 树。因此设置了 innerHTML 之后，再从中读取 HTML 字符串，会得到与设置时不一样的结果。原因在于返回的字符串是根据原始 HTML 字符串创建的 DOM树经过序列化之后的结果。 使用 innerHTML 属性也有一些限制。比如，在大多数浏览器 中，通过 innerHTML 插入 &lt;script&gt; 元素并不会执行其中的脚本 。IE8 及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一些条件。一是必须为 &lt;script&gt; 元素指定 defer 属性，二是 &lt;script&gt; 元素必须位于（微软所谓的）“有作用域的元素”（scoped element）之后。 &lt;script&gt; 元素被认为是“无作用域的元素”（NoScope element），也就是在页面中看不到的元素，与 &lt;style&gt; 元素或注释类似。如果通过 innerHTML 插入的字符串开头就是一个“无作用域的元素” ，那么 IE 会在解析这个字符串前先删除该元素 。换句话说，以下代码达不到目的： 1div.innerHTML = "&lt;script defer&gt;alert('hi');&lt;\/script&gt;"; //无效 此时， innerHTML 字符串一开始（而且整个）就是一个“无作用域的元素”，所以这个字符串会变成空字符串。如果想插入这段脚本，必须在前面添加一个“有作用域的元素”，可以是一个文本节点，也可以是一个没有结束标签的元素如 &lt;input&gt; 。例如，下面这几行代码都可以正常执行： 123div.innerHTML = "_&lt;script defer&gt;alert('hi');&lt;\/script&gt;";div.innerHTML = "&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;script defer&gt;alert('hi');&lt;\/script&gt;";div.innerHTML = "&lt;input type=\"hidden\"&gt;&lt;script defer&gt;alert('hi');&lt;\/script&gt;"; 第一行代码会在 &lt;script&gt; 元素前插入一个文本节点。事后，为了不影响页面显示，你可能需要移除这个文本节点。第二行代码采用的方法类似，只不过使用的是一个包含非换行空格的 &lt;div&gt; 元素。如果仅仅插入一个空的 &lt;div&gt; 元素，还是不行；必须要包含一点儿内容，浏览器才会创建文本节点。同样，为了不影响页面布局，恐怕还得移除这个节点。第三行代码使用的是一个隐藏的 &lt;input&gt; 域，也能达到相同的效果。不过，由于隐藏的 &lt;input&gt; 域不影响页面布局，因此这种方式在大多数情况下都是首选。 大多数浏览器都支持以直观的方式通过 innerHTML 插入 &lt;style&gt; 元素，例如： 1div.innerHTML = "&lt;style type=\"text/css\"&gt;body &#123;background-color: red; &#125;&lt;/style&gt;"; 但在 IE8 及更早版本中， &lt;style&gt; 也是一个“没有作用域的元素”，因此 必须像下面这样给它前置一个“有作用域的元素” ： 12div.innerHTML = "_&lt;style type=\"text/css\"&gt;body &#123;background-color: red; &#125;&lt;/style&gt;";div.removeChild(div.firstChild); 并 不是所有元素都支持 innerHTML 属性 。不支持 innerHTML 的元素有： &lt;col&gt; 、 &lt;colgroup&gt; 、&lt;frameset&gt; 、 &lt;head&gt; 、 &lt;html&gt; 、 &lt;style&gt; 、 &lt;table&gt; 、 &lt;tbody&gt; 、 &lt;thead&gt; 、 &lt;tfoot&gt; 和 &lt;tr&gt; 。此外，在 IE8 及更早版本中， &lt;title&gt; 元素也没有 innerHTML 属性。 Firefox对在内容类型为application/xhtml+xml 的 XHTML 文档中设置 innerHTML 有严格的限制。在 XHTML 文档中使用 innerHTML 时，XHTML 代码必须完全符合要求。如果代码格式不正确，设置 innerHTML 将会静默地失败。 无论什么时候，只要使用 innerHTML 从外部插入 HTML ，都应该首先以可靠的方式处理 HTML 。IE8 为此提供了 window.toStaticHTML() 方法，这个方法接收一个参数，即一个 HTML 字符串 ；返回一个经过无害处理后的版本 —— 从源 HTML 中删除所有脚本节点和事件处理程序属性 。下面就是一个例子： 123var text = "&lt;a href=\"#\" onclick=\"alert('hi')\"&gt;Click Me&lt;/a&gt;";var sanitized = window.toStaticHTML(text); //Internet Explorer 8 onlyalert(sanitized); //"&lt;a href=\"#\"&gt;Click Me&lt;/a&gt;" 这个例子将一个 HTML 链接字符串传给了 toStaticHTML() 方法，得到的无害版本中去掉了 onclick 属性。虽然目前只有 IE8 原生支持这个方法，但我们还是建议读者在通过 innerHTML 插入代码之前，尽可能先手工检查一下其中的文本内容。 outerHTML 属性在读模式下， outerHTML 返回调用它的元素及所有子节点的 HTML 标签 。在写模式下， outerHTML 会根据指定的 HTML 字符串创建新的 DOM子树 ，然后用这个 DOM 子树完全替换调用元素 。下面是一个例子。 12345678&lt;div id="content"&gt;&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;li&gt;Item 2&lt;/li&gt;&lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; 如果 在 &lt;div&gt; 元素上调用 outerHTML ，会返回与上面相同的代码 ，包括 &lt;div&gt; 本身。不过，由于浏览器解析和解释 HTML 标记的不同 ，结果也可能会有所不同 。（这里的不同与使用 innerHTML 属性时存在的差异性质是一样的。） 使用 outerHTML 属性以下面这种方式设置值： 1div.outerHTML = "&lt;p&gt;This is a paragraph.&lt;/p&gt;"; 这行代码完成的操作与下面这些 DOM 脚本代码一样： 123var p = document.createElement("p");p.appendChild(document.createTextNode("This is a paragraph."));div.parentNode.replaceChild(p, div); 结果，就是新创建的 &lt;p&gt; 元素会取代 DOM 树中的 &lt;div&gt; 元素。 支持 outerHTML 属性的浏览器有 IE4+、Safari 4+、Chrome和 Opera 8+。Firefox 7 及之前版本都不支持 outerHTML 属性。 insertAdjacentHTML() 方法插入标记的最后一个新增方式是 insertAdjacentHTML() 方法 。这个方法最早也是在IE中出现的，它接收两个参数：插入位置 和 要插入的 HTML 文本。第一个参数必须是下列值之一： “beforebegin” ，在当前元素之前插入一个紧邻的同辈元素； “afterbegin” ，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素； “beforeend” ，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素； “afterend” ，在当前元素之后插入一个紧邻的同辈元素。 注意，这些值都必须是小写形式 。第二个参数 是 一个 HTML 字符串（与 innerHTML 和 outerHTML 的值相同），如果浏览器无法解析该字符串 ，就会抛出错误 。以下是这个方法的基本用法示例。 1234567891011//作为前一个同辈元素插入element.insertAdjacentHTML("beforebegin", "&lt;p&gt;Hello world!&lt;/p&gt;");//作为第一个子元素插入element.insertAdjacentHTML("afterbegin", "&lt;p&gt;Hello world!&lt;/p&gt;");//作为最后一个子元素插入element.insertAdjacentHTML("beforeend", "&lt;p&gt;Hello world!&lt;/p&gt;");//作为后一个同辈元素插入element.insertAdjacentHTML("afterend", "&lt;p&gt;Hello world!&lt;/p&gt;"); 支持 insertAdjacentHTML() 方法的浏览器有 IE、Firefox 8+、Safari、Opera 和 Chrome。 内存与性能问题使用本节介绍的方法替换子节点可能会导致浏览器的内存占用问题 ，尤其是在 IE 中，问题更加明显。在删除带有事件处理程序或引用了其他 JavaScript 对象子树时，就有可能导致内存占用问题。假设某个元素有一个事件处理程序（或者引用了一个 JavaScript 对象作为属性），在使用前述某个属性将该元素从文档树中删除后，元素与事件处理程序（或 JavaScript 对象）之间的绑定关系在内存中并没有一并删除。如果这种情况频繁出现，页面占用的内存数量就会明显增加。因此，在使用 innerHTML 、 outerHTML 属性和 insertAdjacentHTML() 方法 时，最好先手工删除要被替换的元素的所有事件处理程序和 JavaScript 对象属性 （第 13 章将进一步讨论事件处理程序）。 不过，使用这几个属性——特别是使用 innerHTML ，仍然还是可以为我们提供很多便利的。一般来说，在插入大量新 HTML 标记时，使用 innerHTML 属性与通过多次 DOM 操作先创建节点再指定它们之间的关系相比，效率要高得多 。这是因为 在设置 innerHTML 或 outerHTML 时，就会创建一个 HTML 解析器 。这个解析器是在浏览器级别的代码（通常是 C++编写的）基础上运行的 ，因此比执行 JavaScript 快得多 。不可避免地，创建和销毁 HTML 解析器也会带来性能损失，所以最好能够将设置 innerHTML 或 outerHTML 的次数控制在合理的范围内。例如，下列代码使用 innerHTML 创建了很多列表项： 123for (var i=0, len=values.length; i &lt; len; i++)&#123; ul.innerHTML += "&lt;li&gt;" + values[i] + "&lt;/li&gt;"; //要避免这种频繁操作！！&#125; 这种每次循环都设置一次 innerHTML 的做法效率很低。而且，每次循环还要从 innerHTML 中读取一次信息，就意味着每次循环要访问两次 innerHTML 。最好的做法是单独构建字符串，然后再一次性地将结果字符串赋值给 innerHTML ，像下面这样： 12345var itemsHtml = "";for (var i=0, len=values.length; i &lt; len; i++)&#123; itemsHtml += "&lt;li&gt;" + values[i] + "&lt;/li&gt;";&#125;ul.innerHTML = itemsHtml; 这个例子的效率要高得多，因为它只对 innerHTML 执行了一次赋值操作。 scrollIntoView() 方法如何滚动页面也是 DOM 规范没有解决的一个问题 。为了解决这个问题，浏览器实现了一些方法，以方便开发人员更好地控制页面滚动。在各种专有方法中，HTML5 最终选择了 scrollIntoView() 作为标准方法。 scrollIntoView() 可以在所有 HTML 元素上调用 ，通过滚动浏览器窗口或某个容器元素 ，调用元素就可以出现在视口中 。如果给这个方法 传入 true 作为参数，或者 不传入任何参数 ，那么 窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐 。如果 传入 false 作为参数，调用元素会尽可能全部出现在视口中 ，（可能的话，调用元素的底部会与视口顶部平齐。）不过顶部不一定平齐 ，例如： 12//让元素可见document.forms[0].scrollIntoView(); 当页面发生变化时，一般会用这个方法来吸引用户的注意力。实际上，为某个元素设置焦点也会导致浏览器滚动并显示出获得焦点的元素。 支持 scrollIntoView() 方法的浏览器有 IE、Firefox、Safari 和 Opera。 专有扩展虽然所有浏览器开发商都知晓坚持标准的重要性，但在发现某项功能缺失时，这些开发商都会一如既往地向 DOM中添加专有扩展，以弥补功能上的不足。表面上看，这种各行其事的做法似乎不太好，但实际上专有扩展为 Web 开发领域提供了很多重要的功能，这些功能最终都在 HTML5 规范中得到了标准化。即便如此，仍然还有大量专有的 DOM 扩展没有成为标准。但这并不是说它们将来不会被写进标准，而只是说在编写本书的时候，它们还是专有功能，而且只得到了少数浏览器的支持。 文档模式IE8 引入了一个新的概念叫“文档模式 ”（document mode）。页面的文档模式决定了可以使用什么功能 。换句话说，文档模式决定了你可以使用哪个级别的 CSS ，可以在 JavaScript 中使用哪些 API ，以及 如何对待文档类型（doctype）。到了 IE9，总共有以下 4 种文档模式。 IE5：以混杂模式渲染页面（IE5 的默认模式就是混杂模式）。IE8 及更高版本中的新功能都无法使用。 IE7：以 IE7 标准模式渲染页面。IE8 及更高版本中的新功能都无法使用。 IE8：以 IE8 标准模式渲染页面。IE8 中的新功能都可以使用，因此可以使用 Selectors API、更多CSS2 级选择符和某些 CSS3 功能，还有一些 HTML5 的功能。不过 IE9 中的新功能无法使用。 IE9：以 IE9 标准模式渲染页面。IE9 中的新功能都可以使用，比如 ECMAScript 5、完整的 CSS3以及更多 HTML5 功能。这个文档模式是最高级的模式。 要理解 IE8 及更高版本的工作原理，必须理解文档模式。要强制浏览器以某种模式渲染页面，可以使用 HTTP 头部信息 X-UA-Compatible ，或通过等价的 &lt;meta&gt; 标签来设置： 1&lt;meta http-equiv="X-UA-Compatible" content="IE=IEVersion"&gt; 注意，这里 IE 的版本（ IEVersion ）有以下一些不同的值，而且这些值并不一定与上述 4 种文档模式对应。 Edge ：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于 IE8，始终保持以 IE8 标准模式渲染页面。对于 IE9，则以 IE9 标准模式渲染页面。 EmulateIE9 ：如果有文档类型声明，则以 IE9 标准模式渲染页面，否则将文档模式设置为 IE5。 EmulateIE8 ：如果有文档类型声明，则以 IE8 标准模式渲染页面，否则将文档模式设置为 IE5。 EmulateIE7 ：如果有文档类型声明，则以 IE7 标准模式渲染页面，否则将文档模式设置为 IE5。 9 ：强制以 IE9 标准模式渲染页面，忽略文档类型声明。 8 ：强制以 IE8 标准模式渲染页面，忽略文档类型声明。 7 ：强制以 IE7 标准模式渲染页面，忽略文档类型声明。 5 ：强制将文档模式设置为 IE5，忽略文档类型声明。 比如，要想让文档模式像在 IE7 中一样，可以使用下面这行代码： 1&lt;meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7"&gt; 如果不打算考虑文档类型声明，而直接使用 IE7 标准模式，那么可以使用下面这行代码： 1&lt;meta http-equiv="X-UA-Compatible" content="IE=7"&gt; 没有规定说必须在页面中设置 X-UA-Compatible 。默认情况下，浏览器会通过文档类型声明来确定是使用最佳的可用文档模式，还是使用混杂模式。 通过 document.documentMode 属性 可以 知道给定页面使用的是什么文档模式 。这个属性是 IE8 中新增的，它会返回使用的文档模式的版本号（在 IE9 中，可能返回的版本号为 5 、 7 、 8 、 9 ）： 1var mode = document.documentMode; 知道页面采用的是什么文档模式 ，有助于理解页面的行为方式 。无论在什么文档模式下，都可以访问这个属性。 children 属性由于 IE9 之前的版本与其他浏览器在处理文本节点中的空白符时有差异，因此就出现了 children 属性 。这个属性是 HTMLCollection 的实例 ，只包含元素中同样还是元素的子节点 。除此之外 ， children 属性 与 childNodes 没有什么区别，即 在元素只包含元素子节点时 ，这两个属性的值相同 。 下面是访问 children 属性的示例代码： 12var childCount = element.children.length;var firstChild = element.children[0]; 支持 children 属性的浏览器有 IE5、Firefox 3.5、Safari 2（但有 bug）、Safari 3（完全支持）、Opera8 和 Chrome（所有版本）。IE8 及更早版本的 children 属性中也会包含注释节点，但 IE9 之后的版本则只返回元素节点。 contains() 方法在实际开发中，经常 需要知道某个节点是不是另一个节点的后代 。IE 为此率先引入了 contains() 方法 ，以便不通过在 DOM 文档树中查找即可获得这个信息 。调用 contains() 方法的应该是祖先节点 ，也就是 搜索开始的节点 ，这个方法接收一个参数，即 要检测的后代节点。如果 被检测的节点是后代节点 ，该方法 返回 true ；否则 ，返回 false 。以下是一个例子： 1alert(document.documentElement.contains(document.body)); //true 这个例子测试了 &lt;body&gt; 元素是不是 &lt;html&gt; 元素的后代，在格式正确的 HTML 页面中，以上代码返回 true 。支持 contains() 方法的浏览器有 IE、Firefox 9+、Safari、Opera 和 Chrome。 使用 DOM Level 3 compareDocumentPosition() 也能够确定节点间的关系。支持这个方法的浏览器有 IE9+、Firefox、Safari、Opera 9.5+和 Chrome。如前所述，这个方法用于确定两个节点间的关系 ，回一个表示该关系的位掩码（ bitmask）。下表列出了这个位掩码的值。 为模仿 contains() 方法，应该关注的是掩码 16。可以对 compareDocumentPosition() 的结果执行按位与，以确定参考节点（调用 compareDocumentPosition() 方法的当前节点）是否包含给定的节点（传入的节点）。来看下面的例子： 12var result = document.documentElement.compareDocumentPosition(document.body);alert(!!(result &amp; 16)); 执行上面的代码后，结果会变成 20（表示“居后”的 4 加上表示“被包含”的 16）。对掩码 16 执行按位操作会返回一个非零数值，而两个逻辑非操作符会将该数值转换成布尔值。 使用一些浏览器及能力检测，就可以写出如下所示的一个通用的 contains 函数： 123456789101112131415161718function contains(refNode, otherNode)&#123; if (typeof refNode.contains == "function" &amp;&amp; (!client.engine.webkit || client.engine.webkit &gt;= 522))&#123; return refNode.contains(otherNode); &#125; else if (typeof refNode.compareDocumentPosition == "function")&#123; return !!(refNode.compareDocumentPosition(otherNode) &amp; 16); &#125; else &#123; var node = otherNode.parentNode; do &#123; if (node === refNode)&#123; return true; &#125; else &#123; node = node.parentNode; &#125; &#125; while (node !== null); return false; &#125;&#125; 这个函数组合使用了三种方式来确定一个节点是不是另一个节点的后代。函数的第一个参数是参考节点，第二个参数是要检查的节点。在函数体内，首先检测 refNode 中是否存在 contains() 方法（能力检测）。这一部分代码还检查了当前浏览器所用的 WebKit 版本号。如果方法存在而且不是 WebKit（ !client.engine.webkit ），则继续执行代码。否则，如果浏览器是 WebKit 且至少是 Safari 3（WebKit版本号为 522 或更高），那么也可以继续执行代码。在 WebKit 版本号小于 522 的 Safari 浏览器中，contains() 方法不能正常使用。 接下来检查是否存在 compareDocumentPosition() 方法，而函数的最后一步则是自 otherNode开始向上遍历 DOM 结构，以递归方式取得 parentNode ，并检查其是否与 refNode 相等。在文档树的顶端， parentNode 的值等于 null ，于是循环结束。这是针对旧版本 Safari 设计的一个后备策略。 插入文本前面介绍过，IE 原来专有的插入标记的属性 innerHTML 和 outerHTML 已经被 HTML5 纳入规范。但另外两个插入文本的专有属性则没有这么好的运气。这两个没有被 HTML5 看中的属性是 innerText 和 outerText 。 innerText 属性通过 innertText 属性可以操作元素中包含的所有文本内容 ，包括子文档树中的文本 。在通过 innerText 读取值 时，它会按照由浅入深的顺序 ，将子文档树中的所有文本拼接起来 。在 通过 innerText 写入值 时，结果会删除元素的所有子节点 ，插入包含相应文本值的文本节点 。来看下面这个 HTML 代码示例。 12345678&lt;div id="content"&gt; &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对于这个例子中的 &lt;div&gt; 元素而言，其 innerText 属性会返回下列字符串： 1234This is a paragraph with a list following it.Item 1Item 2Item 3 由于 不同浏览器处理空白符的方式不同 ，因此输出的文本可能会也可能不会包含原始 HTML 代码中的缩进。 使用 innerText 属性设置这个 &lt;div&gt; 元素的内容，则只需一行代码： 1div.innerText = "Hello world!"; 执行这行代码后，页面的 HTML 代码就会变成如下所示。 1&lt;div id="content"&gt;Hello world!&lt;/div&gt; 设置 innerText 属性移除了先前存在的所有子节点 ，完全改变了DOM子树 。此外，设置 innerText 属性的同时 ，也对文本中存在的 HTML 语法字符（小于号、大于号、引号及和号）进行了编码 。再看一个例子。 1div.innerText = "Hello &amp; welcome, &lt;b&gt;\"reader\"!&lt;/b&gt;"; 运行以上代码之后，会得到如下所示的结果。 1&lt;div id="content"&gt;Hello &amp;amp; welcome, &amp;lt;b&amp;gt;&amp;quot;reader&amp;quot;!&amp;lt;/b&amp;gt;&lt;/div&gt; 设置 innerText 永远只会生成当前节点的一个子文本节点 ，而 为了确保只生成一个子文本节点 ，就必须要对文本进行 HTML 编码 。利用这一点，可以通过 innerText 属性过滤掉 HTML 标签 。方法是将 innerText 设置为等于 innerText ，这样就可以去掉所有 HTML 标签，比如： 1div.innerText = div.innerText; 执行这行代码后，就用原来的文本内容替换了容器元素中的所有内容（包括子节点，因而也就去掉了 HTML 标签）。 支持 innerText 属性的浏览器包括 IE4+、Safari 3+、Opera 8+和 Chrome。Firefox 虽然不支持 innerText，但支持作用类似的 textContent 属性 。 textContent 是 DOM Level 3 规定的一个属性 ，其他支持 textContent 属性的浏览器还有 IE9+、Safari 3+、Opera 10+和 Chrome。为了确保跨浏览器兼容，有必要编写一个类似于下面的函数来检测可以使用哪个属性。 123456789101112function getInnerText(element)&#123; return (typeof element.textContent == "string") ? element.textContent : element.innerText;&#125;function setInnerText(element, text)&#123; if (typeof element.textContent == "string")&#123; element.textContent = text; &#125; else &#123; element.innerText = text; &#125;&#125; 这两个函数都接收一个元素作为参数，然后检查这个元素是不是有 textContent 属性。如果有，那么 typeof element.textContent 应该是 “string” ；如果没有，那么这两个函数就会改为使用 innerText 。可以像下面这样调用这两个函数。 12setInnerText(div, "Hello world!");alert(getInnerText(div)); //"Hello world!" 使用这两个函数可以确保在不同的浏览器中使用正确的属性。 实际上， innerText 与 textContent 返回的内容并不完全一样。比如，innerText 会忽略行内的样式和脚本，而 textContent 则会像返回其他文本一样返回行内的样式和脚本代码。避免跨浏览器兼容问题的最佳途径，就是从不包含行内样式或行内脚本的 DOM 子树副本或 DOM 片段中读取文本。 outerText 属性除了作用范围扩大到了包含调用它的节点之外 ， outerText 与 innerText 基本上没有多大区别 。在 读取文本值 时，outerText 与 innerText 的结果完全一样 。但在 写模式 下， outerText 就完全不同了 ： outerText 不只是替换调用它的元素的子节点 ，而是 会替换整个元素 （包括子节点）。比如： 1div.outerText = "Hello world!"; 这行代码实际上相当于如下两行代码： 12var text = document.createTextNode("Hello world!");div.parentNode.replaceChild(text, div); 本质上，新的文本节点会完全取代调用 outerText 的元素 。此后，该元素就从文档中被删除 ，无法访问 。 支持 outerText 属性的浏览器有 IE4+、Safari 3+、Opera 8+和 Chrome。由于这个属性会导致调用它的元素不存在，因此并不常用。我们也建议读者尽可能不要使用这个属性。 滚动如前所述，HTML5 之前的规范并没有就与页面滚动相关的 API 做出任何规定。但 HTML5 在将 scrollIntoView() 纳入规范之后，仍然还有其他几个专有方法可以在不同的浏览器中使用。下面列出的几个方法都是对 HTMLElement 类型的扩展，因此在所有元素中都可以调用。 scrollIntoViewIfNeeded(alignCenter) ：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见 。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的 alignCenter 参数设置为 true ，则表示尽量将元素显示在视口中部（垂直方向）。Safari 和 Chrome 实现了这个方法。 scrollByLines(lineCount) ：将元素的内容滚动指定的行高， lineCount 值可以是正值，也可以是负值 。Safari 和 Chrome 实现了这个方法。 scrollByPages(pageCount) ：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定 。Safari 和 Chrome 实现了这个方法。 希望大家要注意的是，scrollIntoView() 和 scrollIntoViewIfNeeded() 的 作用对象是元素的容器 ，而 scrollByLines() 和 scrollByPages() 影响的则是 元素自身 。下面还是来看几个示例吧。 12345678//将页面主体滚动 5 行document.body.scrollByLines(5);//在当前元素不可见的时候，让它进入浏览器的视口document.images[0].scrollIntoViewIfNeeded();//将页面主体往回滚动 1 页document.body.scrollByPages(-1); 由于 scrollIntoView() 是唯一一个所有浏览器都支持的方法，因此还是这个方法最常用。 小结虽然 DOM 为与 XML 及 HTML 文档交互制定了一系列核心 API，但仍然有几个规范对标准的 DOM 进行了扩展。这些扩展中有很多原来是浏览器专有的，但后来成为了事实标准，于是其他浏览器也都提供了相同的实现。本章介绍的三个这方面的规范如下。 Selectors API，定义了两个方法，让开发人员能够基于 CSS 选择符从 DOM中取得元素，这两个方法是 querySelector() 和 querySelectorAll() 。 Element Traversal，为 DOM 元素定义了额外的属性，让开发人员能够更方便地从一个元素跳到另一个元素。之所以会出现这个扩展，是因为浏览器处理 DOM 元素间空白符的方式不一样。 HTML5，为标准的 DOM 定义了很多扩展功能。其中包括在 innerHTML 属性这样的事实标准基础上提供的标准定义，以及为管理焦点、设置字符集、滚动页面而规定的扩展 API。 虽然目前 DOM 扩展的数量还不多，但随着 Web 技术的发展，相信一定还会涌现出更多扩展来 。很多浏览器都在试验专有的扩展，而这些扩展一旦获得认可，就能成为“伪”标准，甚至会被收录到规范的更新版本中。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-DOM]]></title>
    <url>%2F2018%2F08%2F21%2FJavaScript-DOM%2F</url>
    <content type="text"><![CDATA[DOMDOM（文档对象模型）是 针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。DOM 描绘了 一个层次化的节点树 ，允许开发人员添加、移除和修改页面的某一部分 。DOM 脱胎于 Netscape 及微软公司创始的 DHTML（动态 HTML），但现在 它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式 。 1998 年 10 月 DOM１级规范成为 W3C 的推荐标准，为基本的文档结构及查询提供了接口 。本章主要讨论与浏览器中的 HTML 页面相关的 DOM1 级的特性和应用，以及 JavaScript 对 DOM1 级的实现。IE、Firefox、Safari、Chrome 和 Opera 都非常完善地实现了 DOM。 注意，IE 中的所有 DOM 对象都是以 COM 对象的形式实现的 。这意味着 IE 中的 DOM 对象与原生 JavaScript 对象的行为或活动特点并不一致。本章将较多地谈及这些差异。 节点层次DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构 。节点分为几种不同的类型 ，每种类型 分别表示 文档中不同的信息 及（或）标记 。每个节点 都拥有 各自的特点、数据和方法 ，另外 也与其他节点存在某种关系 。节点之间的关系构成了层次 ，而 所有页面标记则表现为一个以特定节点为根节点的树形结构 。以下面的 HTML 为例： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 可以将这个简单的 HTML 文档表示为一个层次结构，下图所示。文档节点 是 每个文档的根节点 。在这个例子中，文档节点只有一个子节点，即 &lt;html&gt; 元素 ，我们称之为 文档元素 。文档元素是 文档的最外层元素 ，文档中的其他所有元素都包含在文档元素中 。每个文档只能有一个文档元素 。在 HTML 页面中，文档元素始终都是 &lt;html&gt; 元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。 每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示 。总共有 12 种节点类型，这些类型都继承自一个基类型。 Node 类型DOM1 级定义了一个 Node 接口，该接口将 由 DOM 中的所有节点类型实现 。这个 Node 接口 在 JavaScript 中是 作为 Node 类型实现的 ；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型 。JavaScript 中的 所有节点类型都继承自 Node 类型 ，因此 所有节点类型都共享着相同的基本属性和方法 。 每个节点 都有一个 nodeType 属性 ，用于表明节点的类型 。节点类型 由在 Node 类型中定义的下列 12 个数值常量来表示 ，任何节点类型必居其一 ： Node.ELEMENT_NODE (1)； Node.ATTRIBUTE_NODE (2)； Node.TEXT_NODE (3)； Node.CDATA_SECTION_NODE (4)； Node.ENTITY_REFERENCE_NODE (5)； Node.ENTITY_NODE (6)； Node.PROCESSING_INSTRUCTION_NODE (7)； Node.COMMENT_NODE (8)； Node.DOCUMENT_NODE (9)； Node.DOCUMENT_TYPE_NODE (10)； Node.DOCUMENT_FRAGMENT_NODE (11)； Node.NOTATION_NODE (12)。 通过比较上面这些常量，可以很容易地确定节点的类型，例如： 123if (someNode.nodeType == Node.ELEMENT_NODE)&#123; //在 IE 中无效 alert("Node is an element.");&#125; 这个例子比较了 someNode.nodeType 与 Node.ELEMENT_NODE 常量。如果二者相等，则意味着 someNode 确实是一个元素。然而，由于 IE 没有公开 Node 类型的构造函数，因此上面的代码在 IE 中会导致错误。为了确保跨浏览器兼容，最好还是 将 nodeType 属性与数字值进行比较 ，如下所示： 123if (someNode.nodeType == 1)&#123; // 适用于所有浏览器 alert("Node is an element.");&#125; 并不是所有节点类型都受到 Web 浏览器的支持。开发人员最常用的就是元素和文本节点。本章后面将详细讨论每个节点类型的受支持情况及使用方法。 nodeName 和 nodeValue 属性要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。这两个属性的值完全取决于节点的类型 。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。 123if (someNode.nodeType == 1)&#123; value = someNode.nodeName; //nodeName 的值是元素的标签名&#125; 在这个例子中，首先 检查节点类型 ，看它是不是一个元素 。如果是，则取得并保存 nodeName 的值。对于 元素节点 ， nodeName 中 保存的始终都是元素的标签名 ，而 nodeValue 的值则 始终为 null 。 节点关系文档中所有的节点之间都存在这样或那样的关系。节点间的各种关系 可以 用传统的家族关系来描述 ，相当于把文档树比喻成家谱 。在 HTML 中，可以将 &lt;body&gt; 元素看成是 &lt;html&gt; 元素的子元素；相应地，也就可以将 &lt;html&gt; 元素看成是 &lt;body&gt; 元素的父元素。而 &lt;head&gt; 元素，则可以看成是 &lt;body&gt; 元素的同胞元素，因为它们都是同一个父元素 的直接子元素。 每个节点都有一个 childNodes 属性 ，其中 保存着一个 NodeList 对象 。 NodeList 是 一种类数组对象 ，用于保存一组有序的节点 ，可以通过位置来访问这些节点 。请注意，虽然可以 通过方括号语法来访问 NodeList 的值 ，而且 这个对象也有 length 属性 ，但 它并不是 Array 的实例 。 NodeList 对象 的独特之处在于，它实际上是 基于 DOM 结构动态执行查询的结果 ，因此 DOM 结构的变化能够自动反映在 NodeList 对象中 。我们常说， NodeList 是有生命、有呼吸的对象 ，而不是在我们第一次访问它们的某个瞬间拍摄下来的一张快照。 下面的例子展示了如何访问保存在 NodeList 中的节点——可以通过 方括号 ，也可以使用 item()方法 。 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length; 无论使用方括号还是使用 item() 方法都没有问题，但使用方括号语法看起来与访问数组相似，因此颇受一些开发人员的青睐。另外，要注意 length 属性表示的是访问 NodeList 的那一刻，其中包含的节点数量。我们在本书前面介绍过，对 arguments 对象使用 Array.prototype.slice() 方法可以将其转换为数组 。而采用同样的方法，也可以 将 NodeList 对象转换为数组 。来看下面的例子： 12//在 IE8 及之前版本中无效var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0); 除 IE8 及更早版本之外，这行代码能在任何浏览器中运行。由于 IE8 及更早版本将 NodeList实现为一个 COM 对象，而我们不能像使用 JScript 对象那样使用这种对象，因此上面的代码会导致错误。要想在 IE 中将 NodeList 转换为数组，必须手动枚举所有成员 。下列代码在所有浏览器中都可以运行： 12345678910111213function convertToArray(nodes)&#123; var array = null; try &#123; array = Array.prototype.slice.call(nodes, 0); //针对非 IE 浏览器 &#125; catch (ex) &#123; array = new Array(); for (var i=0, len=nodes.length; i &lt; len; i++)&#123; array.push(nodes[i]); &#125; &#125; return array;&#125; 这个 convertToArray() 函数 首先尝试了 创建数组的最简单方式 。如果导致了错误（说明是在IE8 及更早版本中），则通过 try-catch 块来捕获错误，然后 手动创建数组 。这是另一种检测怪癖的形式。 每个节点都有一个 parentNode 属性 ，该属性 指向文档树中的父节点 。包含在 childNodes 列表中的所有节点都具有相同的父节点，因此它们的 parentNode 属性都指向同一个节点。此外，包含在 childNodes 列表 中的 每个节点相互之间都是同胞节点 。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以 访问同一列表中的其他节点 。列表中 第一个节点的 previousSibling 属性值为 null ，而列表中最后一个节点的 nextSibling 属性的值同样也为 null ，如下面的例子所示： 12345if (someNode.nextSibling === null)&#123; alert("Last node in the parent’s childNodes list.");&#125; else if (someNode.previousSibling === null)&#123; alert("First node in the parent’s childNodes list.");&#125; 当然，如果列表中只有一个节点，那么该节点的 nextSibling 和 previousSibling 都为 null 。 父节点与其第一个和最后一个子节点之间也存在特殊关系。父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和最后一个节点 。其中，someNode.firstChild 的值始终等于 someNode.childNodes[0] ， 而 someNode.lastChild 的 值 始 终 等 于 someNode.childNodes [someNode.childNodes.length-1] 。在只有一个子节点的情况下， firstChild 和lastChild 指向同一个节点。如果没有子节点，那么 firstChild 和 lastChild 的值均为 null 。明确这些关系能够对我们查找和访问文档结构中的节点提供极大的便利。下图 形象地展示了上述关系。 在反映这些关系的所有属性当中， childNodes 属性与其他属性相比更方便一些，因为 只须使用简单的关系指针，就可以通过它访问文档树中的任何节点 。另外， hasChildNodes() 也是一个非常有用的方法，这个方法 在节点包含一或多个子节点的情况下返回 true ；应该说，这是比查询 childNodes 列表的 length 属性更简单的方法。 所有节点都有的最后一个属性是 ownerDocument ，该属性 指向表示整个文档的文档节点 。这种关系表示的是 任何节点都属于它所在的文档 ，任何节点都不能同时存在于两个或更多个文档中 。通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。 虽然所有节点类型都继承自 Node ，但并不是每种节点都有子节点。本章后面将会讨论不同节点类型之间的差异。 操作节点因为 关系指针都是只读的 ，所以 DOM 提供了一些操作节点的方法 。其中，最常用的方法是 appendChild() ，用于 向 childNodes 列表的末尾添加一个节点 。添加节点后， childNodes 的新增节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后， appendChild() 返回新增的节点 。来看下面的例子： 123var returnedNode = someNode.appendChild(newNode);alert(returnedNode == newNode); //truealert(someNode.lastChild == newNode); //true 如果传入到 appendChild() 中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置 。即使可以将 DOM 树看成是由一系列指针连接起来的，但任何 DOM 节点也不能同时出现在文档中的多个位置上。因此，如果在调用 appendChild() 时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点 ，如下面的例子所示。 1234//someNode 有多个子节点var returnedNode = someNode.appendChild(someNode.firstChild);alert(returnedNode == someNode.firstChild); //falsealert(returnedNode == someNode.lastChild); //true 如果需要 把节点放在 childNodes 列表中某个特定的位置 上，而不是放在末尾，那么可以使用 insertBefore() 方法。这个方法接受两个参数：要插入的节点 和 作为参照的节点 。插入节点后，被插入的节点会变成参照节点的前一个同胞节点 （ previousSibling ），同时 被方法返回 。如果 参照节点是 null ，则 insertBefore() 与 appendChild() 执行相同的操作 ，如下面的例子所示。 123456789101112//插入后成为最后一个子节点returnedNode = someNode.insertBefore(newNode, null);alert(newNode == someNode.lastChild); //true//插入后成为第一个子节点var returnedNode = someNode.insertBefore(newNode, someNode.firstChild);alert(returnedNode == newNode); //truealert(newNode == someNode.firstChild); //true//插入到最后一个子节点前面returnedNode = someNode.insertBefore(newNode, someNode.lastChild);alert(newNode == someNode.childNodes[someNode.childNodes.length-2]); //true 前面介绍的 appendChild() 和 insertBefore() 方法都只插入节点，不会移除节点。而下面要介绍的 replaceChild() 方法 接受的两个参数是：要插入的节点 和 要替换的节点 。要替换的节点 将由这个方法返回并从文档树中被移除 ，同时 由要插入的节点占据其位置 。来看下面的例子。 12345//替换第一个子节点var returnedNode = someNode.replaceChild(newNode, someNode.firstChild);//替换最后一个子节点returnedNode = someNode.replaceChild(newNode, someNode.lastChild); 在使用 replaceChild() 插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置 。 如果 只想移除而非替换节点 ，可以使用 removeChild() 方法 。这个方法接受一个参数，即 要移除的节点 。被移除的节点将成为方法的返回值 ，如下面的例子所示。 12345//移除第一个子节点var formerFirstChild = someNode.removeChild(someNode.firstChild);//移除最后一个子节点var formerLastChild = someNode.removeChild(someNode.lastChild); 与使用 replaceChild() 方法一样，通过 removeChild() 移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置 。 前面介绍的四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点（使用 parentNode 属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生 。 其他方法有两个方法是所有类型的节点都有的。第一个就是 cloneNode() ，用于创建调用这个方法的节点的一个完全相同的副本 。 cloneNode() 方法接受一个 布尔值参数 ，表示 是否执行深复制 。在参数为 true 的情况下，执行深复制，也就是复制节点及其整个子节点树 ；在参数为 false 的情况下，执行浅复制，即 只复制节点本身 。复制后返回的节点副本属于文档所有，但并没有为它指定父节点 。因此，这个节点副本就成为了一个“孤儿”，除非通过 appendChild() 、 insertBefore() 或 replaceChild() 将它添加到文档中。例如，假设有下面的 HTML 代码。 12345&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt; 如果我们已经将 &lt;ul&gt; 元素的引用保存在了变量 myList 中，那么通常下列代码就可以看出使用 cloneNode() 方法的两种模式。 12345var deepList = myList.cloneNode(true);alert(deepList.childNodes.length); //3（IE &lt; 9）或 7（其他浏览器）var shallowList = myList.cloneNode(false);alert(shallowList.childNodes.length); //0 在这个例子中， deepList 中保存着一个对 myList 执行深复制得到的副本。因此， deepList 中包含 3 个列表项，每个列表项中都包含文本。而变量 shallowList 中保存着对 myList 执行浅复制得到的副本，因此它不包含子节点。 deepList.childNodes.length 中的差异主要是因为 IE8 及更早版本与其他浏览器处理空白字符的方式不一样。IE9 之前的版本不会为空白符创建节点。 cloneNode() 方法不会复制添加到 DOM 节点中的 JavaScript 属性 ，例如 事件处理程序 等。这个方法 只复制特性 、（在明确指定的情况下也复制）子节点 ，其他一切都不会复制。IE 在此存在一个 bug，即它会复制事件处理程序 ，所以我们建议 在复制之前最好先移除事件处理程序 。 我们要介绍的最后一个方法是 normalize() ，这个方法唯一的 作用就是处理文档树中的文本节点 。由于解析器的实现或 DOM 操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。本章后面还将进一步讨论这个方法。 Document 类型JavaScript 通过 Document 类型表示文档。在浏览器中， document 对象 是 HTMLDocument （继承自 Document 类型）的一个实例 ，表示 整个 HTML 页面 。而且， document 对象是 window 对象的一个属性 ，因此 可以将其作为全局对象来访问 。 Document 节点具有下列特征： nodeType 的值为 9； nodeName 的值为 “#document” ； nodeValue 的值为 null ； parentNode 的值为 null ； ownerDocument 的值为 null ； 其子节点可能是一个 DocumentType （最多一个）、 Element （最多一个）、 ProcessingInstruction 或 Comment 。 Document 类型 可以 表示 HTML 页面或者其他基于 XML 的文档 。不过，最常见的应用还是 作为 HTMLDocument 实例的 document 对象 。通过这个文档对象，不仅可以 取得与页面有关的信息 ，而且还能 操作页面的外观及其底层结构 。 在 Firefox、Safari、Chrome 和 Opera 中，可以通过脚本访问 Document 类型的构造函数和原型。但在所有浏览器中都可以访问 HTMLDocument 类型的构造函数和原型，包括 IE8及后续版本。 文档的子节点虽然 DOM 标准规定 Document 节点的子节点 可以是 DocumentType 、 Element 、 ProcessingInstruction 或 Comment ，但还有两个内置的访问其子节点的快捷方式。第一个就是 documentElement属性 ，该属性始终 指向 HTML 页面中的 元素 。另一个就是通过 childNodes 列表访问文档元素 ，但通过 documentElement 属性则能更快捷、更直接地访问该元素 。以下面这个简单的页面为例。 12345&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这个页面在经过浏览器解析后，其文档中只包含一个子节点，即 &lt;html&gt; 元素。可以通过 documentElement 或 childNodes 列表来访问这个元素，如下所示。 123var html = document.documentElement; //取得对&lt;html&gt;的引用alert(html === document.childNodes[0]); //truealert(html === document.firstChild); //true 这个例子说明， documentElement 、 firstChild 和 childNodes[0] 的值相同 ，都指向 &lt;html&gt; 元素 。 作为 HTMLDocument 的实例， document 对象还有一个 body 属性，直接指向 元素。因为开发人员经常要使用这个元素，所以 document.body 在 JavaScript代码中出现的频率非常高，其用法如下。 1var body = document.body; //取得对&lt;body&gt;的引用 所有浏览器都支持 document.documentElement 和 document.body 属性。 Document 另一个可能的子节点是 DocumentType 。通常 将 &lt;!DOCTYPE&gt; 标签看成一个与文档其他部分不同的实体 ，可以通过 doctype 属性（在浏览器中是 document.doctype ）来访问它的信息。 1var doctype = document.doctype; //取得对&lt;!DOCTYPE&gt;的引用 浏览器对 document.doctype 的支持差别很大，可以给出如下总结。 IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作 Comment 节点；而 document.doctype 的值始终为 null 。 IE9+及 Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点； document.doctype 是一个 DocumentType 节点，也可以通过 document.firstChild 或 document.childNodes[0] 访问同一个节点。 Safari、Chrome和 Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。 document.doctype 是一个 DocumentType 节点，但该节点不会出现在 document.childNodes 中。 由于浏览器对 document.doctype 的支持不一致，因此这个属性的用处很有限。 从技术上说，出现在 &lt;html&gt; 元素外部的注释应该算是文档的子节点。然而，不同的浏览器在是否解析这些注释以及能否正确处理它们等方面，也存在很大差异 。以下面简单的 HTML 页面为例。 1234567&lt;!--第一条注释 --&gt;&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--第二条注释 --&gt; 看起来这个页面应该有 3 个子节点：注释、 &lt;html&gt; 元素、注释。从逻辑上讲，我们会认为 document.childNodes 中应该包含与这 3 个节点对应的 3 项。但是，现实中的浏览器在处理位于 &lt;html&gt; 外部的注释方面存在如下差异。 IE8 及之前版本、Safari 3.1 及更高版本、Opera 和 Chrome 只为第一条注释创建节点，不为第二条注释创建节点。结果，第一条注释就会成为 document.childNodes 中的第一个子节点。 IE9 及更高版本会将第一条注释创建为 document.childNodes 中的一个注释节点，也会将第二条注释创建为 document.childNodes 中的注释子节点。 Firefox 以及 Safari 3.1 之前的版本会完全忽略这两条注释。 同样，浏览器间的这种不一致性也导致了位于 &lt;html&gt; 元素外部的注释没有什么用处 。 多数情况下，我们都用不着在 document 对象上调用 appendChild() 、 removeChild() 和 replaceChild() 方法，因为文档类型（如果存在的话）是只读的，而且它只能有一个元素子节点（该节点通常早就已经存在了）。 文档信息作为 HTMLDocument 的一个实例， document 对象还有一些标准的 Document 对象所没有的属性。这些属性提供了 document 对象所表现的网页的一些信息。其中第一个属性就是 title ，包含着 &lt;title&gt; 元素 中的文本——显示在浏览器窗口的标题栏或标签页上 。通过这个属性可以 取得当前页面的标题 ，也可以 修改当前页面的标题并反映在浏览器的标题栏中 。修改 title 属性的值不会改变 &lt;title&gt;元素。来看下面的例子。 12345//取得文档标题var originalTitle = document.title;//设置文档标题document.title = "New page title"; 接下来要介绍的 3 个属性都与对 网页的请求有关 ，它们是 URL 、 domain 和 referrer 。 URL 属性 中 包含页面完整的 URL （即地址栏中显示的 URL）， domain 属性 中只 包含页面的域名 ，而 referrer 属性 中则 保存着链接到当前页面的那个页面的 URL 。在没有来源页面的情况下， referrer 属性 中可能会包含空字符串。所有 这些信息都存在于请求的 HTTP 头部，只不过是通过这些属性让我们能够在 JavaScript 中访问它们而已 ，如下面的例子所示。 12345678//取得完整的 URLvar url = document.URL;//取得域名var domain = document.domain;//取得来源页面的 URLvar referrer = document.referrer; URL 与 domain 属性是相互关联的。例如，如果 document.URL 等于 http://www.wrox.com/WileyCDA/，那么 document.domain 就等于 www.wrox.com。 在这 3 个属性中，只有 domain 是可以设置的 。但由于安全方面的限制，也并非可以给 domain 设置任何值。如果 URL 中包含一个子域名，例如 p2p.wrox.com ，那么就只能将 domain 设置为 “wrox.com”（URL 中包含 “www” ，如 www.wrox.com 时，也是如此）。不能将这个属性设置为 URL 中不包含的域 ，如下面的例子所示。 123//假设页面来自 p2p.wrox.com 域document.domain = "wrox.com"; // 成功document.domain = "nczonline.net"; // 出错！ 当页面中包含来自其他子域的框架或内嵌框架时，能够设置 document.domain 就非常方便了。由于跨域安全限制 ，来自不同子域的页面无法通过 JavaScript 通信 。 而通过将每个页面的 document.domain 设置为相同的值，这些页面就可以互相访问对方包含的 JavaScript 对象了。例如，假设有一个页面加载自 www.wrox.com ，其中包含一个内嵌框架，框架内的页面加载自 p2p.wrox.com。由于 document.domain 字符串不一样，内外两个页面之间无法相互访问对方的 JavaScript 对象。但如果将这两个页面的 document.domain 值都设置为 “wrox.com” ，它们之间就可以通信了。 浏览器对 domain 属性还有一个限制，即 如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight） 。换句话说，在将 document.domain 设置为 “wrox.com” 之后，就不能再将其设置回 “p2p.wrox.com” ，否则将会导致错误，如下面的例子所示。 123//假设页面来自于 p2p.wrox.com 域document.domain = "wrox.com"; //松散的（成功）document.domain = "p2p.wrox.com"; //紧绷的（出错！） 所有浏览器中都存在这个限制，但 IE8 是实现这一限制的最早的 IE 版本。 查找元素说到最常见的 DOM 应用，恐怕就要数 取得特定的某个或某组元素的引用 ，然后再执行一些操作了。取得元素的操作可以使用 document 对象的几个方法来完成。其中， Document 类型为此提供了两个方法： getElementById() 和 getElementsByTagName() 。 第一个方法，getElementById() ，接收一个参数：要取得的元素的 ID 。如果 找到相应的元素则返回该元素 ，如果 不存在带有相应 ID 的元素 ，则 返回 null 。注意，这里的 ID 必须与页面中元素的 id 特性（attribute）严格匹配，包括大小写 。以下面的元素为例。 1&lt;div id="myDiv"&gt;Some text&lt;/div&gt; 可以使用下面的代码取得这个元素： 1var div = document.getElementById("myDiv"); //取得 `&lt;div&gt;` 元素的引用 但是，下面的代码在除 IE7 及更早版本之外的所有浏览器中都将返回 null 。 1var div = document.getElementById("mydiv"); //无效的 ID（在 IE7 及更早版本中可以） IE8 及较低版本不区分 ID 的大小写 ，因此 “myDiv” 和 “mydiv” 会被当作相同的元素 ID。 如果页面中多个元素的 ID 值相同， getElementById() 只返回文档中第一次出现的元素。IE7 及较低版本还为此方法添加了一个有意思的“怪癖”： name 特性与给定 ID 匹配的表单元素（ &lt;input&gt; 、&lt;textarea&gt; 、 &lt;button&gt; 及 &lt;select&gt; ）也会被该方法返回。如果 有哪个表单元素的 name 特性等于指定的 ID ，而且 该元素在文档中位于带有给定 ID 的元素前面 ，那么 IE 就会返回那个表单元素 。来看下面的例子。 12&lt;input type="text" name="myElement" value="Text field"&gt;&lt;div id="myElement"&gt;A div&lt;/div&gt; 基于这段 HTML 代码，在 IE7 中调用 document.getElementById(“myElement “) ，结果会返回 &lt;input&gt; 元素；而在其他所有浏览器中，都会返回对 &lt;div&gt; 元素的引用。为了避免 IE 中存在的这个问题 ，最好的办法是不让表单字段的 name 特性与其他元素的 ID 相同 。 另一个常用于取得元素引用的方法是 getElementsByTagName() 。这个方法接受一个参数，即 要取得元素的标签名 ，而 返回的是包含零或多个元素的 NodeList 。在 HTML 文档中，这个方法会返回一个 HTMLCollection 对象，作为一个“动态”集合，该对象与 NodeList 非常类似。例如，下列代码会取得页面中所有的 &lt;img&gt; 元素，并返回一个 HTMLCollection 。 1var images = document.getElementsByTagName("img"); 这行代码会将一个 HTMLCollection 对象保存在 images 变量中。与 NodeList 对象类似，可以使用 方括号语法 或 item() 方法 来访问 HTMLCollection 对象中的项。而 这个对象中元素的数量则可以通过其 length 属性取得 ，如下面的例子所示。 123alert(images.length); //输出图像的数量alert(images[0].src); //输出第一个图像元素的 src 特性alert(images.item(0).src); //输出第一个图像元素的 src 特性 HTMLCollection 对象还有一个方法，叫做 namedItem() ，使用这个方法可以通过元素的 name 特性取得集合中的项 。例如，假设上面提到的页面中包含如下 &lt;img&gt; 元素： 1&lt;img src="myimage.gif" name="myImage"&gt; 那么就可以通过如下方式从 images 变量中取得这个 &lt;img&gt; 元素： 1var myImage = images.namedItem("myImage"); 在提供按索引访问项的基础上 ， HTMLCollection 还支持按名称访问项 ，这就为我们取得实际想要的元素提供了便利。而且，对命名的项也可以使用方括号语法来访问，如下所示： 1var myImage = images["myImage"]; 对 HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用 item() ，而 对字符串索引就会调用 namedItem() 。 要想取得文档中的所有元素 ，可以向 getElementsByTagName() 中传入 “ *“ 。在 JavaScript 及 CSS 中，星号（ * ）通常表示“全部”。下面看一个例子。 1var allElements = document.getElementsByTagName("*"); 仅此一行代码返回的 HTMLCollection 中，就包含了整个页面中的所有元素——按照它们出现的先后顺序。换句话说，第一项是 &lt;html&gt; 元素，第二项是 &lt;head&gt; 元素，以此类推。由于 IE 将注释（ Comment ）实现为元素（ Element ） ，因此 在 IE 中调用 getElementsByTagName(“*”) 将会返回所有注释节点 。 虽然标准规定标签名需要区分大小写，但为了最大限度地与既有 HTML 页面兼容，传给 getElementsByTagName() 的标签名是不需要区分大小写的 。但 对于 XML页面 而言（包括 XHTML）， getElementsByTagName() 方法就会区分大小写 。 第三个方法，也是只有 HTMLDocument 类型才有的方法，是 getElementsByName() 。顾名思义，这个方法会 返回带有给定 name 特性的所有元素 。最常使用getElementsByName() 方法的情况是 取得单选按钮 ；为了确保发送给浏览器的值正确无误，所有 单选按钮必须具有相同的 name 特性 ，如下面的例子所示。 1234567891011&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt;&lt;input type="radio" value="red" name="color" id="colorRed"&gt; &lt;label for="colorRed"&gt;Red&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type="radio" value="green" name="color" id="colorGreen"&gt; &lt;label for="colorGreen"&gt;Green&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type="radio" value="blue" name="color" id="colorBlue"&gt; &lt;label for="colorBlue"&gt;Blue&lt;/label&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/fieldset&gt; 如这个例子所示，其中所有单选按钮的 name 特性值都是 “color” ，但它们的 ID 可以不同。ID 的作用在于 将 &lt;label&gt; 元素应用到每个单选按钮 ，而 name 特性则用以确保三个值中只有一个被发送给浏览器 。这样，我们就可以使用如下代码取得所有单选按钮： 1var radios = document.getElementsByName("color"); 与 getElementsByTagName() 类似， getElementsByName() 方法也会返回一个 HTMLCollectioin 。但是，对于这里的单选按钮来说， namedItem() 方法则只会取得第一项（因为每一项的 name 特性都相同）。 特殊集合除了属性和方法， document 对象还有一些特殊的集合。这些集合都是 HTMLCollection 对象，为访问文档常用的部分提供了快捷方式，包括： document.anchors ，包含文档中 所有带 name 特性的 &lt;a&gt; 元素 ； document.applets ，包含文档中 所有的 &lt;applet&gt; 元素 ，因为不再推荐使用 &lt;applet&gt; 元素，所以这个集合已经不建议使用了； document.forms ，包含文档中 所有的 &lt;form&gt; 元素 ，与 document.getElementsByTagName(“form”)得到的结果相同； document.images ，包含文档中 所有的 &lt;img&gt; 元素 ，与 document.getElementsByTagName (“img”) 得到的结果相同； document.links ，包含文档中 所有带 href 特性的 &lt;a&gt; 元素 。这个特殊集合始终都可以通过 HTMLDocument 对象访问到，而且，与 HTMLCollection 对象类似，集合中的项也会随着当前文档内容的更新而更新。 DOM 一致性检测由于 DOM 分为多个级别，也包含多个部分，因此检测浏览器实现了 DOM 的哪些部分就十分必要了。 document.implementation 属性 就是为此提供相应信息和功能的对象，与浏览器对 DOM 的实现直接对应。DOM1 级只为 document.implementation 规定了一个方法，即 hasFeature() 。这个方法接受两个参数：要检测的 DOM 功能的名称及版本号 。如果 浏览器支持给定名称和版本的功能 ，则 该方法返回 true ，如下面的例子所示： 1var hasXmlDom = document.implementation.hasFeature("XML", "1.0"); 下表列出了可以检测的不同的值及版本号。 尽管使用 hasFeature() 确实方便，但也有缺点。因为实现者可以自行决定是否与 DOM 规范的不同部分保持一致。事实上，要想让 hasFearture() 方法针对所有值都返回 true 很容易，但返回 true 有时候也不意味着实现与规范一致。例如，Safari 2.x 及更早版本会在没有完全实现某些 DOM 功能的情况下也返回 true 。为此，我们建议多数情况下，在使用 DOM 的某些特殊的功能之前，最好除了检测 hasFeature() 之外，还同时使用能力检测。 文档写入有一个 document 对象的功能已经存在很多年了，那就是 将输出流写入到网页中的能力 。这个能力体现在下列 4 个方法中： write() 、 writeln() 、 open() 和 close() 。其中， write() 和 writeln() 方法都接受一个字符串参数，即 要写入到输出流中的文本 。write() 会 原样写入，而 writeln() 则 会在字符串的末尾添加一个换行符（ \n ）。在页面被加载的过程中 ，可以使用这两个方法向页面中动态地加入内容 ，如下面的例子所示。 123456789101112&lt;html&gt;&lt;head&gt; &lt;title&gt;document.write() Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;The current date and time is: &lt;script type="text/javascript"&gt; document.write("&lt;strong&gt;" + (new Date()).toString() + "&lt;/strong&gt;"); &lt;/script&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这个例子展示了在页面加载过程中输出当前日期和时间的代码。其中，日期被包含在一个&lt;strong&gt; 元素中，就像在 HTML 页面中包含普通的文本一样。这样做会创建一个 DOM 元素，而且可以在将来访问该元素。通过 write() 和 writeln() 输出的任何 HTML 代码都将如此处理。 此外，还可以使用 write() 和 writeln() 方法动态地包含外部资源，例如 JavaScript 文件等。在包含 JavaScript 文件时，必须注意不能像下面的例子那样直接包含字符串 “&lt;/script&gt;“ ，因为这会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行。 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;document.write() Example 2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; document.write("&lt;script type=\"text/javascript\" src=\"file.js\"&gt;" + "&lt;/script&gt;"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 即使这个文件看起来没错，但字符串 “&lt;/script&gt;“ 将被解释为与外部的 &lt;script&gt; 标签匹配，结果文本 “); 将会出现在页面中。为避免这个问题，只需加入转义字符\即可；第 2 章也曾经提及这个问题，解决方案如下。 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;document.write() Example 3&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; document.write("&lt;script type=\"text/javascript\" src=\"file.js\"&gt;" + "&lt;\/script&gt;"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 字符串 “&lt;\/script&gt;“ 不会被当作外部 &lt;script&gt; 标签的关闭标签 ，因而页面中也就不会出现多余的内容了。 前面的例子使用 document.write() 在页面被呈现的过程中直接向其中输出了内容。如果在文档加载结束后再调用 document.write() ，那么输出的内容将会重写整个页面，如下面的例子所示： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;title&gt;document.write() Example 4&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is some content that you won't get to see because it will be overwritten.&lt;/p&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; document.write("Hello world!"); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在这个例子中，我们使用了 window.onload 事件处理程序（事件将在第 13 章讨论），等到页面完全加载之后延迟执行函数。函数执行之后，字符串 “Hello world!” 会重写整个页面内容。 方法 open() 和 close() 分别 用于打开和关闭网页的输出流 。如果是在页面加载期间使用 write() 或 writeln() 方法，则不需要用到这两个方法。 严格型 XHTML 文档不支持文档写入。对于那些按照 application/xml+xhtml 内容类型提供的页面，这两个方法也同样无效。 Element 类型除了 Document 类型之外， Element 类型就要算是 Web 编程中最常用的类型了。 Element 类型 用于 表现 XML或 HTML元素 ，提供了对元素标签名、子节点及特性的访问 。 Element 节点具有以下特征： nodeType 的值为 1； nodeName 的值为元素的标签名； nodeValue 的值为 null ； parentNode 可能是 Document 或 Element ； 其子节点可能是 Element 、 Text 、 Comment 、 ProcessingInstruction 、 CDATASection 或 EntityReference 。 要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性 ；这两个属性会返回相同的值（使用后者主要是为了清晰起见）。以下面的元素为例： 1&lt;div id="myDiv"&gt;&lt;/div&gt; 可以像下面这样取得这个元素及其标签名： 123var div = document.getElementById("myDiv");alert(div.tagName); //"DIV"alert(div.tagName == div.nodeName); //true 这里的元素标签名是 div ，它拥有一个值为 “myDiv” 的 ID。可是， div.tagName 实际上输出的是 “DIV” 而非 “div” 。在 HTML 中，标签名始终都以全部大写表示；而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在 HTML 还是 XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式 ，如下面的例子所示： 1234567if (element.tagName == "div")&#123; //不能这样比较，很容易出错！ //在此执行某些操作&#125;if (element.tagName.toLowerCase() == "div")&#123; //这样最好（适用于任何文档） //在此执行某些操作&#125; 这个例子展示了围绕 tagName 属性的两次比较操作。第一次比较非常容易出错，因为其代码在 HTML 文档中不管用。第二次比较将标签名转换成了全部小写，是我们推荐的做法，因为这种做法适用于 HTML 文档，也适用于 XML 文档。 可以在任何浏览器中通过脚本访问 Element 类型的构造函数及原型，包括 IE8及之前版本。在 Safari 2之前版本和 Opera 8之前的版本中，不能访问 Element 类型的构造函数。 HTML 元素所有 HTML 元素都由 HTMLElement 类型表示 ，不是直接通过这个类型，也是通过它的子类型来表示。 HTMLElement 类型直接继承自 Element 并添加了一些属性 。添加的这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。 id ，元素在文档中的 唯一标识符。 title ，有关元素的附加说明信息 ，一般 通过工具提示条显示出来 。 lang ，元素内容的语言代码 ，很少使用。 dir ，语言的方向v，值为 “ltr” （left-to-right，从左至右）或 “rtl” （right-to-left，从右至左），也很少使用。 className ，与元素的 class 特性对应 ，即为元素指定的CSS类 。没有将这个属性命名为 class ，是因为 class 是 ECMAScript 的保留字（有关保留字的信息，请参见第 1 章）。 上述 这些属性都可以用来取得或修改相应的特性值 。以下面的 HTML 元素为例： 1&lt;div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"&gt;&lt;/div&gt; 元素中指定的所有信息 ，都可以通过下列 JavaScript 代码取得： 123456var div = document.getElementById("myDiv");alert(div.id); //"myDiv""alert(div.className); //"bd"alert(div.title); //"Body text"alert(div.lang); //"en"alert(div.dir); //"ltr" 当然，像下面这样通过为每个属性赋予新的值，也可以 修改对应的每个特性 ： 12345div.id = "someOtherId";div.className = "ft";div.title = "Some other text";div.lang = "fr";div.dir ="rtl"; 并不是对所有属性的修改都会在页面中直观地表现出来。对 id 或 lang 的修改对用户而言是透明不可见的（假设没有基于它们的值设置的 CSS 样式），而对 title 的修改则只会在鼠标移动到这个元素之上时才会显示出来。对 dir 的修改会在属性被重写的那一刻，立即影响页面中文本的左、右对齐方式。修改 className 时，如果新类关联了与此前不同的 CSS 样式，那么就会立即应用新的样式。 前面提到过，所有 HTML 元素都是由 HTMLElement 或者其更具体的子类型来表示的。下表列出了所有 HTML 元素以及与之关联的类型（以斜体印刷的元素表示已经不推荐使用了）。注意，表中的这些类型在 Opera、Safari、Chrome 和 Firefox 中都可以通过 JavaScript 访问，但在 IE8 之前的版本中不能通过 JavaScript 访问。 表中的每一种类型都有与之相关的特性和方法。本书将会讨论其中很多类型。 取得特性每个元素都有一或多个特性，这些特性的用途是 给出相应元素或其内容的附加信息 。操作特性的 DOM 方法主要有三个，分别是 getAttribute() 、 setAttribute() 和 removeAttribute() 。这三个方法可以针对任何特性使用，包括 那些以 HTMLElement 类型属性的形式定义的特性 。来看下面的例子： 123456var div = document.getElementById("myDiv");alert(div.getAttribute("id")); //"myDiv"alert(div.getAttribute("class")); //"bd"alert(div.getAttribute("title")); //"Body text"alert(div.getAttribute("lang")); //"en"alert(div.getAttribute("dir")); //"ltr" 注意，传递给 getAttribute() 的 特性名与实际的特性名相同 。因此要想得到 class 特性值，应该传入 “class” 而不是 “className “ ，后者只有在通过对象属性访问特性时才用 。如果 给定名称的特性不存在 ， getAttribute() 返回 null 。 通过 getAttribute() 方法 也 可以取得自定义特性（即标准 HTML 语言中没有的特性）的值，以下面的元素为例： 1&lt;div id="myDiv" my_special_attribute="hello!"&gt;&lt;/div&gt; 这个元素包含一个名为 my_special_attribute 的自定义特性，它的值是 “hello!” 。可以像取得其他特性一样取得这个值，如下所示： 1var value = div.getAttribute("my_special_attribute"); 不过，特性的名称是不区分大小写的 ，即 “ID” 和 “id” 代表的都是同一个特性。另外也要注意，根据 HTML5 规范 ，自定义特性应该加上 data- 前缀以便验证 。 任何元素的所有特性，也都可以通过 DOM 元素本身的属性来访问。当然， HTMLElement 也会有 5 个属性与相应的特性一一对应。不过，只有公认的（非自定义的）特性才会以属性的形式添加到 DOM 对象中。以下面的元素为例： 1&lt;div id="myDiv" align="left" my_special_attribute="hello!"&gt;&lt;/div&gt; 因为 id 和 align 在 HTML 中是 &lt;div&gt; 的公认特性，因此该元素的 DOM 对象中也将存在对应的属性。不过，自定义特性 my_special_attribute 在 Safari、Opera、Chrome 及 Firefox 中是不存在的；但 IE 却会为自定义特性也创建属性，如下面的例子所示： 123alert(div.id); //"myDiv"alert(div.my_special_attribute); //undefined（IE 除外）alert(div.align); //"left" 有两类特殊的特性，它们虽然有对应的属性名，但 属性的值 与 通过 getAttribute() 返回的 值并不相同 。第一类特性就是 style ，用于通过 CSS 为元素指定样式。在 通过 getAttribute() 访问 时，返回的 style 特性值中包含的是 CSS 文本，而 通过属性来访问 它则会 返回一个对象 。由于 style 属性是用于以编程方式访问元素样式的（本章后面讨论），因此并没有直接映射到 style 特性。 第二类与众不同的特性是 onclick 这样的事件处理程序 。当在元素上使用时， onclick 特性中包含的是 JavaScript 代码，如果 通过 getAttribute() 访问 ，则会 返回相应代码的字符串 。而在 访问 onclick 属性 时，则会 返回一个 JavaScript 函数 （如果未在元素中指定相应特性，则返回 null ）。这是因为 onclick 及其他事件处理程序属性本身就应该被赋予函数值 。 由于存在这些差别，在通过 JavaScript 以编程方式操作 DOM 时，开发人员经常不使用 getAttribute() ，而是只使用对象的属性。只有在取得自定义特性值的情况下 ，才会使用 getAttribute() 方法 。 在IE7及以前版本中，通过 getAttribute() 方法访问 style 特性或 onclick 这样的事件处理特性时，返回的值与属性的值相同。换句话说， getAttribute(“style”) 返回一个对象，而 getAttribute(“onclick”) 返回一个函数。虽然 IE8 已经修复了这个 bug，但不同 IE 版本间的不一致性，也是导致开发人员不使用 getAttribute() 访问HTML特性的一个原因。 设置特性 与 getAttribute() 对应的方法是 setAttribute() ，这个方法接受两个参数：要设置的特性名和值 。如果 特性已经存在 ， setAttribute() 会以指定的值替换现有的值 ；如果 特性不存在 ， setAttribute()则创建该属性并设置相应的值 。来看下面的例子： 12345div.setAttribute("id", "someOtherId");div.setAttribute("class", "ft");div.setAttribute("title", "Some other text");div.setAttribute("lang","fr");div.setAttribute("dir", "rtl"); 通过 setAttribute() 方法既 可以操作 HTML 特性 也 可以操作自定义特性。通过这个方法 设置的特性名会被统一转换为小写形式 ，即 “ID” 最终会变成 “id” 。因为 所有特性都是属性 ，所以 直接给属性赋值可以设置特性的值 ，如下所示。 12div.id = "someOtherId";div.align = "left"; 不过，像下面这样为 DOM 元素添加一个自定义的属性，该属性不会自动成为元素的特性。 12div.mycolor = "red";alert(div.getAttribute("mycolor")); //null（IE 除外） 这个例子添加了一个名为 mycolor 的属性并将它的值设置为 “red” 。在大多数浏览器中，这个属性都不会自动变成元素的特性 ，因此想通过 getAttribute() 取得同名特性的值 ，结果会返回 null 。可是，自定义属性在 IE 中会被当作元素的特性，反之亦然 在 IE7 及以前版本中， setAttribute() 存在一些异常行为。通过这个方法设置 class 和 style 特性，没有任何效果，而使用这个方法设置事件处理程序特性时也一样。尽管到了 IE8 才解决这些问题，但我们还是推荐通过属性来设置特性。 要介绍的最后一个方法是 removeAttribute() ，这个方法 用于彻底删除元素的特性 。调用这个方法不仅 会清除特性的值 ，而且 也会从元素中完全删除特性 ，如下所示： 1div.removeAttribute("class"); 这个方法并不常用，但在序列化 DOM 元素时，可以通过它来确切地指定要包含哪些特性。 IE6 及以前版本不支持 removeAttribute() 。 attributes 属性Element 类型是使用 attributes 属性的唯一一个 DOM节点类型 。attributes 属性 中包含一个 NamedNodeMap ，与 NodeList 类似 ，也是一个“动态”的集合 。元素的每一个特性都由一个 Attr 节点表示 ，每个节点都保存在 NamedNodeMap 对象中 。 NamedNodeMap 对象拥有下列方法。 getNamedItem(name) ：返回 nodeName 属性等于 name 的节点； removeNamedItem(name) ：从列表中移除 nodeName 属性等于 name 的节点； setNamedItem(node) ：向列表中添加节点，以节点的 nodeName 属性为索引； item(pos) ：返回位于数字 pos 位置处的节点。 attributes 属性 中 包含一系列节点 ，每个节点的 nodeName 就是 特性的名称 ，而 节点的 nodeValue 就是 特性的值 。要取得元素的 id 特性，可以使用以下代码。 1var id = element.attributes.getNamedItem("id").nodeValue; 以下是 使用方括号语法通过特性名称访问节点 的简写方式。 1var id = element.attributes[&quot;id&quot;].nodeValue; 也 可以使用这种语法来设置特性的值 ，即先取得特性节点，然后再将其 nodeValue 设置为新值，如下所示。 1element.attributes["id"].nodeValue = "someOtherId"; 调用 removeNamedItem() 方法与在元素上调用 removeAttribute() 方法的效果相同 —— 直接删除具有给定名称的特性 。下面的例子展示了两个方法间唯一的区别，即 removeNamedItem() 返回表示被删除特性的 Attr 节点 。 1var oldAttr = element.attributes.removeNamedItem("id"); 最后， setNamedItem() 是一个很不常用的方法，通过这个方法可以为元素添加一个新特性 ，为此 需要为它传入一个特性节点 ，如下所示。 1element.attributes.setNamedItem(newAttr); 一般来说，由于前面介绍的 attributes 的方法不够方便，因此开发人员更多的会使用 getAttribute() 、 removeAttribute() 和 setAttribute() 方法。 不过，如果想要 遍历元素的特性 ， attributes 属性倒是可以派上用场 。在需要将 DOM结构序列化为 XML 或 HTML 字符串时，多数都会涉及遍历元素特性。以下代码展示了如何迭代元素的每一个特性，然后将它们构造成 name=”value” name=”value” 这样的字符串格式。 123456789101112131415function outputAttributes(element)&#123; var pairs = new Array(), attrName, attrValue, i, len; for (i=0, len=element.attributes.length; i &lt; len; i++)&#123; attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; pairs.push(attrName + "=\"" + attrValue + "\""); &#125; return pairs.join(" ");&#125; 这个函数使用了一个数组来保存名值对，最后再以空格为分隔符将它们拼接起来（这是序列化长字符串时的一种常用技巧）。通过 attributes.length 属性， for 循环会遍历每个特性，将特性的名称和值输出为字符串。关于以上代码的运行结果，以下是两点必要的说明。 针对 attributes 对象中的特性，不同浏览器返回的顺序不同。这些特性在 XML 或 HTML代码中出现的先后顺序，不一定与它们出现在 attributes 对象中的顺序一致。 IE7 及更早的版本会返回 HTML 元素中所有可能的特性，包括没有指定的特性。换句话说，返回 100 多个特性的情况会很常见。 针对 IE7 及更早版本中存在的问题，可以对上面的函数加以改进，让它只返回指定的特性。每个特性节点都有一个名为 specified 的属性 ，这个属性的值如果为 true ，则意味着要么是在 HTML 中指定了相应特性 ，要么是通过 setAttribute() 方法设置了该特性 。在 IE 中，所有未设置过的特性的该属性值都为 false ，而在其他浏览器中根本不会为这类特性生成对应的特性节点（因此，在这些浏览器中，任何特性节点的 specified 值始终为 true ）。改进后的代码如下所示。 12345678910111213141516function outputAttributes(element)&#123; var pairs = new Array(), attrName, attrValue, i, len; for (i=0, len=element.attributes.length; i &lt; len; i++)&#123; attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; if (element.attributes[i].specified) &#123; pairs.push(attrName + "=\"" + attrValue + "\""); &#125; return pairs.join(" ");&#125; 这个经过改进的函数可以确保即使在 IE7 及更早的版本中，也会只返回指定的特性。 创建元素使用 document.createElement() 方法 可以 创建新元素 。这个方法只接受一个参数，即 要创建元素的标签名 。这个标签名在 HTML 文档 中 不区分大小写 ，而在 XML（包括 XHTML）文档 中，则是 区分大小写 的。例如，使用下面的代码可以创建一个 &lt;div&gt; 元素。 1var div = document.createElement("div"); 在使用 createElement() 方法 创建新元素 的同时，也为 新元素设置了 ownerDocuemnt 属性 。此时，还可以操作元素的特性，为它添加更多子节点 ，以及执行其他操作 。来看下面的例子。 12div.id = "myNewDiv";div.className = "box"; 在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树 ，可以使用 appendChild() 、 insertBefore() 或 replaceChild() 方法。下面的代码会把新创建的元素添加到文档的 &lt;body&gt; 元素中。 1document.body.appendChild(div); 一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。 在 IE 中可以以另一种方式使用 createElement() ，即 为这个方法传入完整的元素标签 ，也可以包含属性 ，如下面的例子所示。 1var div = document.createElement("&lt;div id=\"myNewDiv\" class=\"box\"&gt;&lt;/div &gt;"); 这种方式有助于避开在 IE7 及更早版本中动态创建元素的某些问题。下面是已知的一些这类问题。 不能设置动态创建的 &lt;iframe&gt; 元素的 name 特性。 不能通过表单的 reset() 方法重设动态创建的 &lt;input&gt; 元素（第 13 章将讨论 reset() 方法）。 动态创建的 type 特性值为 “reset” 的 &lt;buttou&gt; 元素重设不了表单。 动态创建的一批 name 相同的单选按钮彼此毫无关系。 name 值相同的一组单选按钮本来应该用于表示同一选项的不同值，但动态创建的一批这种单选按钮之间却没有这种关系。 上述所有问题都可以通过在 createElement() 中指定完整的HTML标签来解决，如下面的例子所示。 1234567891011121314if (client.browser.ie &amp;&amp; client.browser.ie &lt;=7)&#123; //创建一个带 name 特性的 iframe 元素 var iframe = document.createElement("&lt;iframe name=\"myframe\"&gt;&lt;/iframe&gt;"); //创建 input 元素 var input = document.createElement("&lt;input type=\"checkbox\"&gt;"); //创建 button 元素 var button = document.createElement("&lt;button type=\"reset\"&gt;&lt;/button&gt;"); //创建单选按钮 var radio1 = document.createElement("&lt;input type=\"radio\" name=\"choice\" "＋ "value=\"1\"&gt;"); var radio2 = document.createElement("&lt;input type=\"radio\" name=\"choice\" "＋ "value=\"2\"&gt;");&#125; 与使用 createElement() 的惯常方式一样，这样的用法也会 返回一个 DOM 元素的引用 。可以将这个引用添加到文档中，也可以对其加以增强。但是，由于这样的用法要求使用浏览器检测，因此我们建议只在需要避开 IE 及更早版本中上述某个问题的情况下使用。其他浏览器都不支持这种用法。 元素的子节点元素可以有任意数目的子节点和后代节点 ，因为元素可以是其他元素的子节点。元素的 childNodes 属性中包含了它的所有子节点 ，这些 子节点 有可能是 元素 、文本节点 、注释 或 处理指令 。不同浏览器在看待这些节点方面存在显著的不同 ，以下面的代码为例。 12345&lt;ul id="myList"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 如果是 IE 来解析这些代码，那么 &lt;ul&gt; 元素会有 3 个子节点，分别是 3 个 &lt;li&gt; 元素。但如果是在其他浏览器中， &lt;ul&gt; 元素都会有 7 个元素，包括 3 个 &lt;li&gt; 元素和 4 个文本节点（表示 &lt;li&gt; 元素之间的空白符）。如果像下面这样将元素间的空白符删除，那么所有浏览器都会返回相同数目的子节点 。 1&lt;ul id="myList"&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;li&gt;Item 2&lt;/li&gt;&lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 对于这段代码， &lt;ul&gt; 元素在任何浏览器中都会包含 3 个子节点。如果需要通过 childNodes 属性遍历子节点 ，那么一定不要忘记浏览器间的这一差别 。这意味着 在执行某项操作以前 ，通常都要先检查一下 nodeTpye 属性 ，如下面的例子所示。 12345for (var i=0, len=element.childNodes.length; i &lt; len; i++)&#123; if (element.childNodes[i].nodeType == 1)&#123; //执行某些操作 &#125;&#125; 这个例子会循环遍历特定元素的每一个子节点，然后只在子节点的 nodeType 等于 1（表示是元素节点）的情况下，才会执行某些操作。 如果想通过某个特定的标签名取得子节点或后代节点该怎么办呢？实际上，元素也支持 getElementsByTagName() 方法 。在通过元素调用这个方法时，除了搜索起点是当前元素之外，其他方面都跟通过 document 调用这个方法相同，因此结果只会返回当前元素的后代。例如，要想取得前面 &lt;ul&gt; 元素中包含的所有 &lt;li&gt; 元素 ，可以使用下列代码。 12var ul = document.getElementById("myList");var items = ul.getElementsByTagName("li"); 要注意的是，这里 &lt;ul&gt; 的后代中只包含直接子元素 。不过，如果 它包含更多层次的后代元素 ，那么 各个层次中包含的 &lt;li&gt; 元素也都会返回 。 Text 类型文本节点由 Text 类型表示 ，包含的是可以照字面解释的纯文本内容v。纯文本 中 可以包含转义后的 HTML 字符 ，但 不能包含 HTML 代码 。 Text 节点具有以下特征： nodeType 的值为 3； nodeName 的值为 “#text” ； nodeValue 的值为节点所包含的文本； parentNode 是一个 Element ； 不支持（没有）子节点。 可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本，这两个属性中包含的值相同。对 nodeValue 的修改也会通过 data 反映出来，反之亦然。使用下列方法可以操作节点中的文本。 appendData(text) ：将 text 添加到节点的末尾。 deleteData(offset, count) ：从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text) ：在 offset 指定的位置插入 text 。 replaceData(offset, count, text) ：用 text 替换从 offset 指定的位置开始到 offset+count 为止处的文本。 splitText(offset) ：从 offset 指定的位置将当前文本节点分成两个文本节点。 substringData(offset, count) ：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。 除了这些方法之外，文本节点还有一个 length 属性 ，保存着节点中字符的数目 。而且，nodeValue.length 和 data.length 中 也保存着同样的值 。 在默认情况下，每个可以包含内容的元素最多只能有一个文本节点 ，而且必须确实有内容存在 。来看几个例子。 12345678&lt;!-- 没有内容，也就没有文本节点 --&gt;&lt;div&gt;&lt;/div&gt;&lt;!-- 有空格，因而有一个文本节点 --&gt;&lt;div&gt; &lt;/div&gt;&lt;!-- 有内容，因而有一个文本节点 --&gt;&lt;div&gt;Hello World!&lt;/div&gt; 上面代码给出的第一个 &lt;div&gt; 元素没有内容，因此也就不存在文本节点。开始与结束标签之间只要存在内容 ，就会创建一个文本节点 。因此，第二个 &lt;div&gt; 元素中虽然 只包含一个空格 ，但 仍然有一个文本子节点 ；文本节点的 nodeValue 值是一个空格 。第三个 &lt;div&gt; 也有一个文本节点，其 nodeValue 的值为 “Hello World!” 。可以使用以下代码来访问这些文本子节点。 1var textNode = div.firstChild; //或者 div.childNodes[0] 在取得了文本节点的引用后，就可以像下面这样来修改它了。 1div.firstChild.nodeValue = "Some other message"; 如果 这个文本节点当前存在于文档树 中，那么 修改文本节点的结果就会立即得到反映 。另外，在修改文本节点时还要注意 ，此时的字符串会经过 HTML（或 XML，取决于文档类型）编码 。换句话说，小于号、大于号或引号都会像下面的例子一样被转义 。 12//输出结果是"Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message"div.firstChild.nodeValue = "Some &lt;strong&gt;other&lt;/strong&gt; message"; 应该说，这是 在向 DOM 文档中插入文本之前 ，先对其进行 HTML 编码的一种有效方式 。在 IE8、Firefox、Safari、Chrome和 Opera中，可以通过脚本访问 Text 类型的构造函数和原型。 创建文本节点可以使用 document.createTextNode() 创建新文本节点 ，这个方法接受一个参数—— 要插入节点中的文本 。与设置已有文本节点的值一样，作为参数的文本也将按照 HTML 或 XML 的格式进行编码 。 1var textNode = document.createTextNode("&lt;strong&gt;Hello&lt;/strong&gt; world!"); 在 创建新文本节点 的同时，也会为其设置 ownerDocument 属性 。不过，除非把新节点添加到文档树中已经存在的节点中 ，否则我们不会在浏览器窗口中看到新节点。下面的代码会创建一个 &lt;div&gt; 元素并向其中添加一条消息。 1234567var element = document.createElement("div");element.className = "message";var textNode = document.createTextNode("Hello world!");element.appendChild(textNode);document.body.appendChild(element); 这个例子创建了一个新 &lt;div&gt; 元素并为它指定了值为 “message” 的 class 特性。然后，又创建了一个文本节点，并将其添加到前面创建的元素中。最后一步，就是将这个元素添加到了文档的 &lt;body&gt; 元素中，这样就可以在浏览器中看到新创建的元素和文本节点了。 一般情况下 ，每个元素只有一个文本子节点 。不过，在某些情况下也可能包含多个文本子节点 ，如下面的例子所示。 12345678910var element = document.createElement("div");element.className = "message";var textNode = document.createTextNode("Hello world!");element.appendChild(textNode);var anotherTextNode = document.createTextNode("Yippee!");element.appendChild(anotherTextNode);document.body.appendChild(element); 如果 两个文本节点是相邻的同胞节点 ，那么 这两个节点中的文本就会连起来显示，中间不会有空格 。 规范化文本节点DOM 文档中存在相邻的同胞文本节点很容易导致混乱 ，因为分不清哪个文本节点表示哪个字符串。另外，DOM 文档中出现相邻文本节点的情况也不在少数，于是就催生了一个 能够将相邻文本节点合并的方法 。这个方法是由 Node 类型定义的（因而在所有节点类型中都存在），名叫 normalize() 。如果在一个包含两个或多个文本节点的父元素上调用 normalize() 方法 ，则会将所有文本节点合并成一个节点 ，结果节点的 nodeValue 等于将合并前每个文本节点的 nodeValue 值拼接起来的值 。来看一个例子。 12345678910111213141516var element = document.createElement("div");element.className = "message";var textNode = document.createTextNode("Hello world!");element.appendChild(textNode);var anotherTextNode = document.createTextNode("Yippee!");element.appendChild(anotherTextNode);document.body.appendChild(element);alert(element.childNodes.length); //2element.normalize();alert(element.childNodes.length); //1alert(element.firstChild.nodeValue); // "Hello world!Yippee!" 浏览器在解析文档时永远不会创建相邻的文本节点 。这种情况只会作为执行 DOM 操作的结果出现。 在某些情况下，执行 normalize() 方法会导致 IE6 崩溃。不过，在 IE6 后来的补丁中，可能已经修复了这个问题（未经证实）。IE7 及更高版本中不存在这个问题。 分割文本节点Text 类型提供了一个作用与 normalize() 相反的方法 ： splitText() 。这个方法会 将一个文本节点分成两个文本节点 ，即 按照指定的位置分割 nodeValue 值 。原来的文本节点将包含从开始到指定位置之前的内容 ，新文本节点将包含剩下的文本 。这个方法会 返回一个新文本节点 ，该节点与原节点的 parentNode 相同 。来看下面的例子。 123456789101112var element = document.createElement("div");element.className = "message";var textNode = document.createTextNode("Hello world!");element.appendChild(textNode);document.body.appendChild(element);var newNode = element.firstChild.splitText(5);alert(element.firstChild.nodeValue); //"Hello"alert(newNode.nodeValue); //" world!"alert(element.childNodes.length); //2 在这个例子中，包含 “Hello world!” 的文本节点被分割为两个文本节点，从位置 5 开始。位置 5 是 “Hello” 和 “world!” 之间的空格，因此原来的文本节点将包含字符串 “Hello” ，而新文本节点将包含文本 “world!” （包含空格）。分割文本节点是从文本节点中提取数据的一种常用 DOM 解析技术 。 Comment 类型注释在 DOM 中是通过 Comment 类型来表示的 。 Comment 节点具有下列特征： nodeType 的值为 8； nodeName 的值为 “#comment” ； nodeValue 的值是注释的内容； parentNode 可能是 Document 或 Element ； 不支持（没有）子节点。 Comment 类型 与 Text 类型继承自相同的基类 ，因此 它拥有除 splitText() 之外的所有字符串操作方法 。与 Text 类型相似 ，也可以通过 nodeValue 或 data 属性来取得注释的内容 。 注释节点可以通过其父节点来访问，以下面的代码为例。 1&lt;div id="myDiv"&gt;&lt;!--A comment --&gt;&lt;/div&gt; 在此，注释节点是 &lt;div&gt; 元素的一个子节点，因此可以通过下面的代码来访问它。 123var div = document.getElementById("myDiv");var comment = div.firstChild;alert(comment.data); //"A comment" 另外，使用 document.createComment() 并为其 传递注释文本 也 可以创建注释节点 ，如下面的例子所示。 1var comment = document.createComment("A comment "); 显然，开发人员很少会创建和访问注释节点，因为注释节点对算法鲜有影响。此外，浏览器也不会识别位于 &lt;/html&gt; 标签后面的注释。如果要访问注释节点 ，一定要保证它们是 &lt;html&gt; 元素的后代 （即位于 &lt;html&gt; 和 &lt;/html&gt; 之间）。 在 Firefox、Safari、Chrome 和 Opera 中，可以访问 Comment 类型的构造函数和原型。在 IE8 中，注释节点被视作标签名为 “!” 的元素。也就是说，使用 getElementsByTagName() 可以取得注释节点。尽管 IE9 没有把注释当成元素，但它仍然通过一个名为 HTMLCommentElement 的构造函数来表示注释。 CDATASection 类型CDATASection 类型只针对基于 XML 的文档 ，表示的是 CDATA 区域 。与 Comment 类似，CDATASection 类型继承自 Text 类型 ，因此拥有除 splitText() 之外的所有字符串操作方法 。CDATASection 节点具有下列特征： nodeType 的值为 4； nodeName 的值为 “#cdata-section” ； nodeValue 的值是 CDATA 区域中的内容； parentNode 可能是 Document 或 Element ； 不支持（没有）子节点。 CDATA 区域只会出现在 XML 文档中 ，因此 多数浏览器都会把 CDATA 区域错误地解析为 Comment 或 Element 。以下面的代码为例： 1&lt;div id="myDiv"&gt;&lt;![CDATA[This is some content.]]&gt;&lt;/div&gt; 这个例子中的 &lt;div&gt; 元素应该包含一个 CDATASection 节点。可是，四大主流浏览器无一能够这样解析它。即使对于有效的 XHTML 页面，浏览器也没有正确地支持嵌入的 CDATA 区域 。 在 真正的 XML 文档 中，可以 使用 document.createCDataSection() 来创建 CDATA 区域 ，只需为其传入节点的内容即可 。 在 Firefox、Safari、Chrome 和 Opera 中，可以访问 CDATASection 类型的构造函数和原型。IE9 及之前版本不支持这个类型。 DocumentType 类型DocumentType 类型在 Web 浏览器中并不常用 ，仅有Firefox、Safari 和 Opera 支持它（ Chrome 4.0 也支持 DocumentType 类型。） 。DocumentType 包含着与文档的 doctype 有关的所有信息 ，它具有下列特征： nodeType 的值为 10； nodeName 的值为 doctype 的名称； nodeValue 的值为 null ； parentNode 是 Document ； 不支持（没有）子节点。 在 DOM1 级 中， DocumentType 对象不能动态创建 ，而 只能通过解析文档代码的方式来创建 。支持它的浏览器会把 DocumentType 对象保存在document.doctype 中 。 DOM1级描述了 DocumentType 对象的 3 个属性： name 、 entities 和 notations 。其中， name 表示文档类型的名称 ；entities 是由文档类型描述的实体的 NamedNodeMap 对 ； notations 是由文档类型描述的符号的 NamedNodeMap 对象 。通常，浏览器中的文档使用的都是 HTML 或 XHTML 文档类型，因而 entities 和 notations 都是空列表（列表中的项来自行内文档类型声明）。但不管怎样，只有 name 属性是有用的。这个属性中保存的是文档类型的名称 ，也就是出现在 &lt;!DOCTYPE 之后的文本 。以下面严格型 HTML 4.01 的文档类型声明为例： 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; DocumentType 的 name 属性中保存的就是 “HTML” ： 1alert(document.doctype.name); //"HTML" IE 及更早版本不支持 DocumentType ，因此 document.doctype 的值始终都等于 null 。可是，这些浏览器会把文档类型声明错误地解释为注释，并且为它创建一个注释节点。IE9 会给 document.doctype 赋正确的对象 ，但仍然不支持访问 DocumentType 类型。 DocumentFragment 类型在所有节点类型中，只有 DocumentFragment 在文档中没有对应的标记 。DOM 规定文档片段（document fragment）是一种“轻量级”的文档 ，可以包含和控制节点 ，但不会像完整的文档那样占用额外的资源 。 DocumentFragment 节点具有下列特征： nodeType 的值为 11； nodeName 的值为 “#document-fragment” ； nodeValue 的值为 null ； parentNode 的值为 null ； 子节点可以是 Element 、 ProcessingInstruction 、 Comment 、 Text 、 CDATASection 或EntityReference 。 虽然 不能把文档片段直接添加到文档 中，但 可以将它作为一个“仓库”来使用 ，即 可以在里面保存将来可能会添加到文档中的节点 。要 创建文档片段 ，可以使用 document.createDocumentFragment() 方法 ，如下所示： 1var fragment = document.createDocumentFragment(); 文档片段继承了 Node 的所有方法 ，通常用于执行那些针对文档的 DOM操作 。如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，也不会从浏览器中再看到该节点。添加到文档片段中的新节点同样也不属于文档树 。可以通过 appendChild() 或 insertBefore() 将文档片段中内容添加到文档中 。在将文档片段作为参数传递给这两个方法时，实际上 只会将文档片段的所有子节点添加到相应位置上 ；文档片段本身永远不会成为文档树的一部分 。来看下面的 HTML 示例代码： 1&lt;ul id="myList"&gt;&lt;/ul&gt; 假设我们想为这个 &lt;ul&gt; 元素添加 3 个列表项。如果逐个地添加列表项 ，将会导致浏览器反复渲染（呈现）新信息 。为避免这个问题，可以像下面这样使用一个文档片段来保存创建的列表项，然后再一次性将它们添加到文档中 。 1234567891011var fragment = document.createDocumentFragment();var ul = document.getElementById("myList");var li = null;for (var i=0; i &lt; 3; i++)&#123; li = document.createElement("li"); li.appendChild(document.createTextNode("Item " + (i+1))); fragment.appendChild(li);&#125;ul.appendChild(fragment); 在这个例子中，我们先创建一个文档片段并取得了对 &lt;ul&gt; 元素的引用。然后，通过 for 循环创建 3 个列表项，并通过文本表示它们的顺序。为此，需要分别创建 &lt;li&gt; 元素、创建文本节点，再把文本节点添加到 &lt;li&gt; 元素。接着使用 appendChild() 将 &lt;li&gt; 元素添加到文档片段中。循环结束后，再调用 appendChild() 并传入文档片段，将所有列表项添加到 &lt;ul&gt; 元素中。此时，文档片段的所有子节点都被删除并转移到了 &lt;ul&gt; 元素中 。 Attr 类型元素的特性在 DOM 中以 Attr 类型来表示 。在所有浏览器中（包括 IE8），都 可以 访问 Attr 类型的构造函数和原型 。从技术角度讲，特性就是存在于元素的 attributes 属性中的节点 。特性节点具有下列特征： nodeType 的值为 2； nodeName 的值是特性的名称； nodeValue 的值是特性的值； parentNode 的值为 null ； 在 HTML 中不支持（没有）子节点； 在 XML 中子节点可以是 Text 或 EntityReference 。 尽管它们也是节点，但特性却不被认为是 DOM 文档树的一部分。开发人员最常使用的是 getAttribute() 、 setAttribute() 和 remveAttribute() 方法，很少直接引用特性节点。 Attr 对象有 3 个属性：name、value 和 specified 。其中， name 是特性名称（与 nodeName 的值相同）， value 是特性的值（与 nodeValue 的值相同），而 specified 是一个布尔值 ，用以区别特性是在代码中指定的，还是默认的 。 使用 document.createAttribute() 并 传入特性的名称可以创建新的特性节点 。例如，要为元素添加 align 特性 ，可以使用下列代码： 123456var attr = document.createAttribute("align");attr.value = "left";element.setAttributeNode(attr);alert(element.attributes["align"].value); //"left"alert(element.getAttributeNode("align").value); //"left"alert(element.getAttribute("align")); //"left" 这个例子创建了一个新的特性节点。由于在调用 createAttribute() 时已经为 name 属性赋了值，所以后面就不必给它赋值了。之后，又把 value 属性的值设置为 “left” 。为了将新创建的特性添加到元素中，必须使用元素的 setAttributeNode() 方法。添加特性之后，可以通过下列任何方式访问该特性： attributes 属性、 getAttributeNode() 方法以及 getAttribute() 方法。其中，attributes 和 getAttributeNode() 都会返回对应特性的 Attr 节点 ，而 getAttribute() 则只返回特性的值 。 我们并 不建议直接访问特性节点 。实际上，使用 getAttribute() 、 setAttribute()和 removeAttribute() 方法远比操作特性节点更为方便 。 DOM 操作技术很多时候，DOM 操作都比较简明，因此用 JavaScript 生成那些通常原本是用 HTML 代码生成的内容并不麻烦。不过，也有一些时候，操作 DOM 并不像表面上看起来那么简单。由于浏览器中充斥着隐藏的陷阱和不兼容问题，用 JavaScript 代码处理 DOM 的某些部分要比处理其他部分更复杂一些 。 动态脚本使用 &lt;script&gt; 元素可以向页面中插入 JavaScript 代码 ，一种方式是 通过其 src 特性包含外部文件 ，另一种方式就是 用这个元素本身来包含代码 。而这一节要讨论的动态脚本，指的是在页面加载时不存在但将来的某一时刻通过修改 DOM 动态添加的脚本。跟操作 HTML 元素一样，创建动态脚本也有两种方式：插入外部文件 和 直接插入 JavaScript 代码 。 动态加载的外部 JavaScript 文件能够立即运行 ，比如下面的 &lt;script&gt; 元素： 1&lt;script type="text/javascript" src="client.js"&gt;&lt;/script&gt; 这个 &lt;script&gt; 元素包含了第 9 章的客户端检测脚本。而创建这个节点的 DOM 代码如下所示： 1234var script = document.createElement("script");script.type = "text/javascript";script.src = "client.js";document.body.appendChild(script); 显然，这里的 DOM 代码如实反映了相应的 HTML 代码。不过，在执行最后一行代码把 &lt;script&gt; 元素添加到页面中之前 ，是不会下载外部文件的 。也可以把这个元素添加到 &lt;head&gt; 元素中，效果相同。整个过程可以使用下面的函数来封装： 123456function loadScript(url)&#123; var script = document.createElement("script"); script.type = "text/javascript"; script.src = url; document.body.appendChild(script);&#125; 然后，就可以通过调用这个函数来加载外部的 JavaScript 文件了： 1loadScript(&quot;client.js&quot;); 加载完成后，就可以在页面中的其他地方使用这个脚本了。问题只有一个：怎么知道脚本加载完成呢？遗憾的是，并没有什么标准方式来探知这一点。不过，与此相关的一些事件倒是可以派上用场，但要取决于所用的浏览器，详细讨论请见第 13 章。 另一种 指定 JavaScript 代码的方式是行内方式 ，如下面的例子所示： 12345&lt;script type="text/javascript"&gt; function sayHi()&#123; alert("hi"); &#125;&lt;/script&gt; 从逻辑上讲，下面的 DOM 代码是有效的： 1234var script = document.createElement("script");script.type = "text/javascript";script.appendChild(document.createTextNode("function sayHi()&#123;alert('hi');&#125;"));document.body.appendChild(script); 在 Firefox、Safari、Chrome 和 Opera 中，这些 DOM 代码可以正常运行。但在 IE 中，则会导致错误。IE 将 &lt;script&gt; 视为一个特殊的元素，不允许 DOM 访问其子节点。不过，可以使用 &lt;script&gt; 元素的 text 属性来指定 JavaScript 代码 ，像下面的例子这样： 1234var script = document.createElement("script");script.type = "text/javascript";script.text = "function sayHi()&#123;alert('hi');&#125;";document.body.appendChild(script); 经过这样修改之后的代码可以在 IE、Firefox、Opera 和 Safari 3 及之后版本中运行。Safari 3.0 之前的版本虽然不能正确地支持 text 属性，但却允许使用文本节点技术来指定代码。如果需要兼容早期版本的 Safari，可以使用下列代码： 123456789var script = document.createElement("script");script.type = "text/javascript";var code = "function sayHi()&#123;alert('hi');&#125;";try &#123; script.appendChild(document.createTextNode("code"));&#125; catch (ex)&#123; script.text = "code";&#125;document.body.appendChild(script); 这里，首先尝试标准的 DOM文本节点方法 ，因为除了 IE（在 IE 中会导致抛出错误），所有浏览器都支持这种方式。如果这行代码抛出了错误 ，那么说明是 IE，于是就必须使用 text 属性了 。整个过程可以用以下函数来表示： 12345678910function loadScriptString(code)&#123; var script = document.createElement("script"); script.type = "text/javascript"; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex)&#123; script.text = code; &#125; document.body.appendChild(script);&#125; 下面是调用这个函数的示例： 1loadScriptString("function sayHi()&#123;alert('hi');&#125;"); 以这种方式加载的代码会在全局作用域中执行，而且 当脚本执行后将立即可用。实际上，这样执行代码与在全局作用域中把相同的字符串传递给 eval() 是一样的 。 动态样式能够把 CSS 样式包含到 HTML 页面中的元素有两个。其中， &lt;link&gt; 元素用于包含来自外部的文件 ，而 &lt;style&gt; 元素用于指定嵌入的样式 。与动态脚本类似，所谓 动态样式是指在页面刚加载时不存在的样式 ；动态样式是在页面加载完成后动态添加到页面中的 。 我们以下面这个典型的 &lt;link&gt; 元素为例： 1&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; 使用 DOM 代码可以很容易地动态创建出这个元素： 123456var link = document.createElement("link");link.rel = "stylesheet";link.type = "text/css";link.href = "style.css";var head = document.getElementsByTagName("head")[0];head.appendChild(link); 以上代码在所有主流浏览器中都可以正常运行。需要注意的是，必须将 &lt;link&gt; 元素添加到 &lt;head&gt;而不是 &lt;body&gt; 元素 ，才能保证在所有浏览器中的行为一致 。整个过程可以用以下函数来表示： 12345678function loadStyles(url)&#123; var link = document.createElement("link"); link.rel = "stylesheet"; link.type = "text/css"; link.href = url; var head = document.getElementsByTagName("head")[0]; head.appendChild(link);&#125; 调用 loadStyles() 函数的代码如下所示： 1loadStyles("styles.css"); 加载外部样式文件的过程是异步的，也就是加载样式与执行 JavaScript 代码的过程没有固定的次序。一般来说，知不知道样式已经加载完成并不重要；不过，也存在几种利用事件来检测这个过程是否完成的技术，这些技术将在第 13 章讨论。 另一种定义样式的方式是使用 &lt;style&gt; 元素来包含嵌入式 CSS，如下所示： 12345&lt;style type="text/css"&gt;body &#123; background-color: red;&#125;&lt;/style&gt; 按照相同的逻辑，下列 DOM代码应该是有效的： 12345var style = document.createElement("style");style.type = "text/css";style.appendChild(document.createTextNode("body&#123;background-color:red&#125;"));var head = document.getElementsByTagName("head")[0];head.appendChild(style); 以上代码可以在 Firefox、Safari、Chrome 和 Opera 中运行，在 IE 中则会报错。IE 将 &lt;style&gt; 视为一个特殊的、与 &lt;script&gt; 类似的节点，不允许访问其子节点。事实上，IE 此时抛出的错误与向 &lt;script&gt; 元素添加子节点时抛出的错误相同。解决 IE 中这个问题的办法，就是访问元素的 styleSheet 属性，该属性又有一个 cssText 属性，可以接受 CSS 代码（第 13 章将进一步讨论这两个属性），如下面的例子所示。 123456789var style = document.createElement("style");style.type = "text/css";try&#123; style.appendChild(document.createTextNode("body&#123;background-color:red&#125;"));&#125; catch (ex)&#123; style.styleSheet.cssText = "body&#123;background-color:red&#125;";&#125;var head = document.getElementsByTagName("head")[0];head.appendChild(style); 与动态添加嵌入式脚本类似，重写后的代码使用了 try-catch 语句来捕获 IE 抛出的错误，然后再使用针对 IE 的特殊方式来设置样式。因此，通用的解决方案如下。 1234567891011function loadStyleString(css)&#123; var style = document.createElement("style"); style.type = "text/css"; try&#123; style.appendChild(document.createTextNode(css)); &#125; catch (ex)&#123; style.styleSheet.cssText = css; &#125; var head = document.getElementsByTagName("head")[0]; head.appendChild(style);&#125; 调用这个函数的示例如下： 1loadStyleString("body&#123;background-color:red&#125;"); 这种方式会实时地向页面中添加样式 ，因此能够马上看到变化 。 如果专门针对 IE 编写代码，务必小心使用 styleSheet.cssText 属性。在重用同一个 &lt;style&gt; 元素并再次设置这个属性时 ，有可能会导致浏览器崩溃 。同样，将 cssText 属性设置为空字符串也可能导致浏览器崩溃 。我们希望 IE 中的这个 bug 能够在将来被修复。 操作表格&lt;table&gt; 元素是 HTML 中最复杂的结构之一。要想创建表格，一般都必须涉及表示表格行、单元格、表头等方面的标签 。由于涉及的标签多，因而 使用核心 DOM 方法创建和修改表格往往都免不了要编写大量的代码 。假设我们要使用 DOM 来创建下面的 HTML 表格。 123456789101112&lt;table border="1" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Cell 1,1&lt;/td&gt; &lt;td&gt;Cell 2,1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cell 1,2&lt;/td&gt; &lt;td&gt;Cell 2,2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 要使用核心 DOM方法创建这些元素，得需要像下面这么多的代码： 12345678910111213141516171819202122232425262728293031//创建 tablevar table = document.createElement("table");table.border = 1;table.width = "100%";//创建 tbodyvar tbody = document.createElement("tbody");table.appendChild(tbody);//创建第一行var row1 = document.createElement("tr");tbody.appendChild(row1);var cell1_1 = document.createElement("td");cell1_1.appendChild(document.createTextNode("Cell 1,1"));row1.appendChild(cell1_1);var cell2_1 = document.createElement("td");cell2_1.appendChild(document.createTextNode("Cell 2,1"));row1.appendChild(cell2_1);//创建第二行var row2 = document.createElement("tr");tbody.appendChild(row2);var cell1_2 = document.createElement("td");cell1_2.appendChild(document.createTextNode("Cell 1,2"));row2.appendChild(cell1_2);var cell2_2= document.createElement("td");cell2_2.appendChild(document.createTextNode("Cell 2,2"));row2.appendChild(cell2_2);//将表格添加到文档主体中document.body.appendChild(table); 显然，DOM代码很长，还有点不太好懂。为了方便构建表格，HTML DOM 还为 &lt;table&gt; 、 &lt;tbody&gt; 和 &lt;tr&gt; 元素添加了一些属性和方法。 为 &lt;table&gt; 元素添加的属性和方法如下。 caption ：保存着对 &lt;caption&gt; 元素（如果有）的指针。 tBodies ：是一个 &lt;tbody&gt; 元素的 HTMLCollection 。 tFoot ：保存着对 &lt;tfoot&gt; 元素（如果有）的指针。 tHead ：保存着对 &lt;thead&gt; 元素（如果有）的指针。 rows ：是一个表格中所有行的 HTMLCollection 。 createTHead() ：创建 &lt;thead&gt; 元素，将其放到表格中，返回引用。 createTFoot() ：创建 &lt;tfoot&gt; 元素，将其放到表格中，返回引用。 createCaption() ：创建 &lt;caption&gt; 元素，将其放到表格中，返回引用。 deleteTHead() ：删除 &lt;thead&gt; 元素。 deleteTFoot() ：删除 &lt;tfoot&gt; 元素。 deleteCaption() ：删除 &lt;caption&gt; 元素。 deleteRow(pos) ：删除指定位置的行。 insertRow(pos) ：向 rows 集合中的指定位置插入一行。为 &lt;tbody&gt; 元素添加的属性和方法如下。 rows ：保存着 &lt;tbody&gt; 元素中行的 HTMLCollection 。 deleteRow(pos) ：删除指定位置的行。 insertRow(pos) ：向 rows 集合中的指定位置插入一行，返回对新插入行的引用。为 &lt;tr&gt; 元素添加的属性和方法如下。 cells ：保存着 &lt;tr&gt; 元素中单元格的 HTMLCollection 。 deleteCell(pos) ：删除指定位置的单元格。 insertCell(pos) ：向 cells 集合中的指定位置插入一个单元格，返回对新插入单元格的引用。 使用这些属性和方法，可以极大地减少创建表格所需的代码数量。例如，使用这些属性和方法可以将前面的代码重写如下（加阴影的部分是重写后的代码）。 12345678910111213141516171819202122232425//创建 tablevar table = document.createElement("table");table.border = 1;table.width = "100%";//创建 tbodyvar tbody = document.createElement("tbody");table.appendChild(tbody);// 创建第一行tbody.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1,1"));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2,1"));// 创建第二行tbody.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 1,2"));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 2,2"));//将表格添加到文档主体中document.body.appendChild(table); 在这次的代码中，创建 &lt;table&gt; 和 &lt;tbody&gt; 的代码没有变化。不同的是创建两行的部分，其中使用了 HTML DOM 定义的表格属性和方法 。在创建第一行时，通过 &lt;tbody&gt; 元素调用了 insertRow() 方法 ，传入了参数 0——表示应该将插入的行放在什么位置上。执行这一行代码后，就会自动创建一行并将其插入到 &lt;tbody&gt; 元素的位置 0 上，因此就可以马上通过 tbody.rows[0] 来引用新插入的行。 创建单元格的方式也十分相似，即通过 &lt;tr&gt; 元素调用 insertCell() 方法 并传入放置单元格的位置。然后，就可以通过 tbody.rows[0].cells[0] 来引用新插入的单元格，因为新创建的单元格被插入到了这一行的位置 0 上。 总之，使用这些属性和方法创建表格的逻辑性更强 ，也 更容易看懂 ，尽管技术上这两套代码都是正确的。 使用 NodeList理解 NodeList 及其“近亲” NamedNodeMap 和 HTMLCollection ，是从整体上透彻理解 DOM 的关键所在。这三个集合都是“动态的” ；换句话说，每当文档结构发生变化时，它们都会得到更新 。因此，它们始终都会保存着最新、最准确的信息 。从本质上说，所有 NodeList 对象都是在访问 DOM文档时实时运行的查询 。例如，下列代码会导致无限循环： 12345678var divs = document.getElementsByTagName("div"), i, div; for (i=0; i &lt; divs.length; i++)&#123; div = document.createElement("div"); document.body.appendChild(div);&#125; 第一行代码会取得文档中所有 &lt;div&gt; 元素的 HTMLCollection 。由于这个集合是“动态的”，因此只要有新 &lt;div&gt; 元素被添加到页面中，这个元素也会被添加到该集合中。浏览器不会将创建的所有集合都保存在一个列表中，而是在下一次访问集合时再更新集合。结果，在遇到上例中所示的循环代码时，就会导致一个有趣的问题。每次循环都要对条件 i &lt; divs.length 求值，意味着会运行取得所有 &lt;div&gt; 元素的查询。考虑到循环体每次都会创建一个新 &lt;div&gt; 元素并将其添加到文档中，因此 divs.length 的值在每次循环后都会递增。既然 i 和 divs.length 每次都会同时递增，结果它们的值永远也不会相等。 如果想要迭代一个 NodeList ，最好是使用 length 属性初始化第二个变量，然后将迭代器与该变量进行比较，如下面的例子所示： 123456789var divs = document.getElementsByTagName("div"), i, len, div; for (i=0, len=divs.length; i &lt; len; i++)&#123; div = document.createElement("div"); document.body.appendChild(div);&#125; 这个例子中初始化了第二个变量 len 。由于 len 中保存着对 divs.length 在循环开始时的一个快照，因此就会避免上一个例子中出现的无限循环问题。在本章演示迭代 NodeList 对象的例子中，使用的都是这种更为保险的方式。 一般来说，应该尽量减少访问 NodeList 的次数 。因为 v每次访问 NodeList ，都会运行一次基于文档的查询 。所以，可以考虑将从 NodeList 中取得的值缓存起来** 。 小结DOM 是语言中立的 API，用于访问和操作 HTML 和 XML 文档。DOM1 级将 HTML 和 XML 文档形象地看作一个层次化的节点树，可以使用 JavaScript 来操作这个节点树，进而改变底层文档的外观和结构。 DOM 由各种节点构成，简要总结如下。 最基本的节点类型是 Node ，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自 Node 。 Document 类型表示整个文档，是一组分层节点的根节点。在 JavaScript 中， document 对象是 Document 的一个实例。使用 document 对象，有很多种方式可以查询和取得节点。 Element 节点表示文档中的所有 HTML 或 XML 元素，可以用来操作这些元素的内容和特性。 另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA 区域和文档片段。 访问 DOM 的操作在多数情况下都很直观，不过在处理 &lt;script&gt; 和 &lt;style&gt; 元素时还是存在一些复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用 innerHTML 时，以及在创建新元素时的一些问题。 理解 DOM 的关键，就是理解 DOM 对性能的影响 。DOM 操作往往是 JavaScript程序中开销最大的部分 ，而因访问 NodeList 导致的问题为最多 。 NodeList 对象都是“动态的”，这就 意味着每次访问 NodeList 对象 ，都会运行一次查询 。有鉴于此，最好的办法就是尽量减少 DOM 操作 。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-客户端检测]]></title>
    <url>%2F2018%2F08%2F21%2FJavaScript-customer-service-test%2F</url>
    <content type="text"><![CDATA[客服端检测浏览器提供商虽然在实现公共接口方面投入了很多精力，但结果仍然是每一种浏览器都有各自的长处，也都有各自的缺点。即使是那些跨平台的浏览器，虽然从技术上看版本相同，也照样存在不一致性问题 。面对普遍存在的不一致性问题 ，开发人员要么采取迁就各方的“最小公分母”策略，要么（也是更常见的）就得 利用各种客户端检测方法 ，来突破或者规避种种局限性。迄今为止，客户端检测仍然是 Web 开发领域中一个饱受争议的话题。一谈到这个话题，人们总会不约而同地提到浏览器应该支持一组最常用的公共功能。在理想状态下，确实应该如此。但是，在现实当中，浏览器之间的差异以及不同浏览器的“怪癖”（quirk），多得简直不胜枚举。因此，客户端检测除了是一种补救措施之外，更是一种行之有效的开发策略 。检测 Web 客户端的手段很多，而且各有利弊。但最重要的还是要知道，不到万不得已 ，就 不要使用客户端检测 。只要能找到更通用的方法 ，就 应该优先采用更通用的方法 。一言以蔽之，先设计最通用的方案 ，然后再使用特定于浏览器的技术增强该方案 。 能力检测最常用也最为人们广泛接受的客户端检测形式是 能力检测（又称特性检测）。能力检测的目标 不是识别特定的浏览器，而 是识别浏览器的能力 。采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力 ，就可以给出解决方案 。能力检测的基本模式如下： 123if (object.propertyInQuestion)&#123; //使用 object.propertyInQuestion&#125; 举例来说，IE5.0 之前的版本不支持 document.getElementById() 这个 DOM 方法。尽管可以使用非标准的 document.all 属性实现相同的目的，但 IE 的早期版本中确实不存在 document.get-ElementById() 。于是，也就有了类似下面的能力检测代码： 123456789function getElement(id)&#123; if (document.getElementById)&#123; return document.getElementById(id); &#125; else if (document.all)&#123; return document.all[id]; &#125; else &#123; throw new Error("No way to retrieve element!"); &#125;&#125; 这里的 getElement() 函数的用途是返回具有给定 ID 的元素。因为 document.getElementById() 是 实现这一目的的标准方式 ，所以 一开始就测试了这个方法 。如果 该函数存在（不是未定义），则 使用该函数 。否则，就要继续检测 document.all 是否存在 ，如果是，则 使用它 。如果 上述两个特性都不存在（很有可能），则 创建并抛出错误 ，表示 这个函数无法使用 。要理解能力检测，首先必须理解两个重要的概念。如前所述，第一个概念就是 先检测达成目的的最常用的特性 。对前面的例子来说，就是要先检测 document.getElementById() ，后检测 document.all 。先检测最常用的特性可以保证代码最优化 ，因为在多数情况下都可以避免测试多个条件。第二个重要的概念就是必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在。来看一个例子： 1234567function getWindowWidth()&#123; if (document.all)&#123; //假设是 IE return document.documentElement.clientWidth; //错误的用法！！！ &#125; else &#123; return window.innerWidth; &#125;&#125; 这是一个 错误使用能力检测 的例子。 getWindowWidth() 函数首先检查 document.all 是否存在，如果是则返回 document.documentElement.clientWidth 。第 8 章曾经讨论过，IE8 及之前版本确实不支持 window.innerWidth 属性。但问题是 document.all 存在也不一定表示浏览器就是 IE。实际上，也可能是 Opera；Opera 支持 document.all ，也支持 window.innerWidth 。 更可靠的能力检测能力检测 对于 想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用 。上一节中的例子 利用类型转换来确定某个对象成员是否存在 ，但这样你还是不知道该成员是不是你想要的。来看下面的函数，它用来确定一个对象是否支持排序。 1234//不要这样做！这不是能力检测——只检测了是否存在相应的方法function isSortable(object)&#123; return !!object.sort;&#125; 这个函数通过检测对象是否存在 sort() 方法，来确定对象是否支持排序。问题是，任何包含 sort属性的对象也会返回 true 。 1var result = isSortable(&#123; sort: true &#125;); 检测某个属性是否存在并不能确定对象是否支持排序。更好的方式是检测 sort 是不是一个函数 。 1234//这样更好：检查 sort 是不是函数function isSortable(object)&#123; return typeof object.sort == "function";&#125; 这里的 typeof 操作符 用于 确定 sort 的确是一个函数 ，因此可以调用它对数据进行排序。在可能的情况下，要尽量使用 typeof 进行能力检测。特别是，宿主对象没有义务让 typeof 返回合理的值。最令人发指的事儿就发生在 IE 中。大多数浏览器在检测到 document.createElement() 存在时，都会返回 true 。 1234//在 IE8 及之前版本中不行function hasCreateElement()&#123; return typeof document.createElement == "function";&#125; 在 IE8 及之前版本中，这个函数返回 false ，因为 typeof document.createElement 返回的是 “object“ ，而不是 “function” 。如前所述，DOM 对象是宿主对象 ，IE 及更早版本中的 宿主对象是通过 COM 而非 JScript 实现的。因此， document.createElement() 函数确实是一个 COM 对象，所以 typeof 才会返回 “object” 。IE9 纠正了这个问题，对所有 DOM 方法都返回 “function” 。 关于 typeof 的行为不标准 ，IE 中还可以举出例子来。ActiveX 对象（只有 IE 支持）与其他对象的行为差异很大。例如，不使用 typeof 测试某个属性会导致错误，如下所示。 12345//在 IE 中会导致错误var xhr = new ActiveXObject("Microsoft.XMLHttp");if (xhr.open)&#123; //这里会发生错误 //执行操作&#125; 像这样直接把函数作为属性访问会导致 JavaScript 错误。使用 typeof 操作符会更靠谱一点，但 IE 对 typeof xhr.open 会返回 “unknown” 。这就意味着，在浏览器环境下测试任何对象的某个特性是否存在 ，要使用下面这个函数。 1234567//作者：Peter Michauxfunction isHostMethod(object, property) &#123; var t = typeof object[property]; return t=='function' || (!!(t=='object' &amp;&amp; object[property])) || t=='unknown';&#125; 可以像下面这样使用这个函数： 12result = isHostMethod(xhr, "open"); //trueresult = isHostMethod(xhr, "foo"); //false 目前使用 isHostMethod() 方法还是比较可靠的，因为它考虑到了浏览器的怪异行为。不过也要注意，宿主对象没有义务保持目前的实现方式不变，也不一定会模仿已有宿主对象的行为。所以，这个函数——以及其他类似函数，都不能百分之百地保证永远可靠。作为开发人员，必须对自己要使用某个功能的风险作出理性的估计。 要想深入了解围绕 JavaScript 中能力检测的一些观点，请参考 Peter Michaux的文章“Feature Detection: State of the Art Browser Scripting”，网址为 http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting 。 能力检测，不是浏览器检测检测某个或某几个特性并不能够确定浏览器 。下面给出的这段代码（或与之差不多的代码）可以在许多网站中看到，这种“浏览器检测”代码就是 错误地依赖能力检测 的典型示例。 12345//错误！还不够具体var isFirefox = !!(navigator.vendor &amp;&amp; navigator.vendorSub);//错误！假设过头了var isIE = !!(document.all &amp;&amp; document.uniqueID); 这两行代码代表了对能力检测的典型误用。以前，确实可以通过检测 navigator.vendor 和 navigator.vendorSub 来确定 Firefox 浏览器。但是，Safari 也依葫芦画瓢地实现了相同的属性。于是，这段代码就会导致人们作出错误的判断。为检测 IE，代码测试了 document.all 和 document.uniqueID 。这就相当于假设 IE 将来的版本中仍然会继续存在这两个属性，同时还假设其他浏览器都不会实现这两个属性。最后，这两个检测都使用了双逻辑非操作符来得到布尔值（比先存储后访问的效果更好）。实际上，根据浏览器不同将能力组合起来是更可取的方式。如果你知道自己的应用程序需要使用某些特定的浏览器特性 ，那么 最好是一次性检测所有相关特性 ，而 不要分别检测 。看下面的例子。 123456//确定浏览器是否支持 Netscape 风格的插件var hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);//确定浏览器是否具有 DOM1 级规定的能力var hasDOM1 = !!(document.getElementById &amp;&amp; document.createElement &amp;&amp; document.getElementsByTagName); 以上例子展示了两个检测：一个 检测浏览器是否支持 Netscapte 风格的插件 ；另一个 检测浏览器是否具备 DOM1 级所规定的能力 。得到的布尔值可以在以后继续使用，从而节省重新检测能力的时间。 在实际开发中，应该 将能力检测作为确定下一步解决方案的依据 ，而 不是用它来判断用户使用的是什么浏览器 。 怪癖检测与能力检测类似，怪癖检测（quirks detection）的目标是 识别浏览器的特殊行为 。但与 能力检测确认浏览器支持什么能力不同 ，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是 bug）。这通常需要运行一小段代码，以确定某一特性不能正常工作。例如，IE8 及更早版本中存在一个 bug，即如果某个实例属性与 [[Enumerable]] 标记为 false 的某个原型属性同名，那么该实例属性将不会出现在 for-in 循环当中。可以使用如下代码来检测这种“怪癖”。 1234567891011var hasDontEnumQuirk = function()&#123; var o = &#123; toString : function()&#123;&#125; &#125;; for (var prop in o)&#123; if (prop == "toString")&#123; return false; &#125; &#125; return true;&#125;(); 以上代码通过一个匿名函数来测试该“怪癖”，函数中创建了一个带有 toString() 方法的对象。在正确的 ECMAScript 实现中， toString 应该在 for-in 循环中作为属性返回。 另一个经常需要检测的“怪癖”是 Safari 3 以前版本会枚举被隐藏的属性。可以用下面的函数来检测该“怪癖”。 123456789101112var hasEnumShadowsQuirk = function()&#123; var o = &#123; toString : function()&#123;&#125; &#125;; var count = 0; for (var prop in o)&#123; if (prop == "toString")&#123; count++; &#125; &#125; return (count &gt; 1);&#125;(); 如果浏览器存在这个 bug，那么使用 for-in 循环枚举带有自定义的 toString() 方法的对象，就会返回两个 toString 的实例。 一般来说，“怪癖”都是个别浏览器所独有的 ，而且通常被归为 bug。在相关浏览器的新版本中，这些问题可能会也可能不会被修复。由于检测“怪癖”涉及运行代码，因此我们建议仅检测那些对你有直接影响的“怪癖”，而且 最好在脚本一开始就执行此类检测 ，以便尽早解决问题 。 用户代理检测第三种，也是争议最大的一种客户端检测技术叫做 用户代理检测 。用户代理检测通过 检测用户代理字符串 来 确定实际使用的浏览器 。在每一次 HTTP 请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过 JavaScript 的 navigator.userAgent 属性访问。在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。而在客户端，用户代理检测 一般 被当作一种万不得已才用的做法 ，其优先级排在能力检测和（或）怪癖检测之后 。 提到与用户代理字符串有关的争议，就不得不提到电子欺骗（spoofing）。所谓 电子欺骗 ，就是 指浏览器通过在自己的用户代理字符串加入一些错误或误导性信息 ，来达到欺骗服务器的目的 。要弄清楚这个问题的来龙去脉，必须从 Web 问世初期用户代理字符串的发展讲起。 用户代理字符串的历史HTTP 规范（包括 1.0 和 1.1版）明确规定，浏览器应该发送 简短的用户代理字符串 ，指明浏览器的名称和版本号 。RFC 2616（即 HTTP 1.1 协议规范）是这样描述用户代理字符串的：“产品标识符常用于通信应用程序标识自身，由软件名和版本组成。使用产品标识符的大多数领域也允许列出作为应用程序主要部分的子产品，由空格分隔。按照惯例，产品要按照相应的重要程度依次列出，以便标识应用程序。 ” 上述规范进一步规定，用户代理字符串应该以一组产品的形式给出，字符串格式为：标识符/产品版本号 。但是，现实中的用户代理字符串则绝没有如此简单。 早期的浏览器1993 年，美国 NCSA（National Center for Supercomputing Applications，国家超级计算机中心）发布了世界上第一款 Web 浏览器 Mosaic。这款浏览器的用户代理字符串非常简单，类似如下所示。 1Mosaic/0.9 尽管这个字符串在不同操作系统和不同平台下会有所变化，但其基本格式还是简单明了的。正斜杠前面的文本表示 产品名称（有时候会出现 NCSA Mosaic 或其他类似字样），而斜杠后面的 文本是产品的版本号。 Netscape Communications 公司介入浏览器开发领域后，遂将自己产品的代号定名为 Mozilla（Mosaic Killer 的简写，意即 Mosaic 杀手）。该公司第一个公开发行版，Netscape Navigator 2 的用户代理字符串具有如下格式。 Mozilla/版本号 [语言] (平台; 加密类型) Netscape 在坚持将产品名和版本号作为用户代理字符串开头的基础上，又在后面依次添加了下列信息。 语言 ：即语言代码，表示应用程序针对哪种语言设计。 平台 ：即操作系统和（或）平台，表示应用程序的运行环境。 加密类型 ：即安全加密的类型。可能的值有 U（128 位加密）、I（40 位加密）和 N（未加密）。典型的 Netscape Navigator 2 的用户代理字符串如下所示。 1Mozilla/2.02 [fr] (WinNT; I) 这个字符串表示浏览器是 Netscape Navigator 2.02，为法语国家编译，运行在 Windows NT 平台下，加密类型为 40 位。那个时候，通过用户代理字符串中的产品名称，至少还能够轻易地确定用户使用的是什么浏览器。 Netscape Navigator 3 和 Internet Explorer 31996 年，Netscape Navigator 3 发布，随即超越 Mosaic 成为当时最流行的 Web 浏览器。而用户代理字符串只作了一些小的改变，删除了语言标记，同时允许添加操作系统或系统使用的 CPU 等可选信息。于是，格式变成如下所示。 Mozilla/版本号 (平台; 加密类型 [; 操作系统或 CPU 说明]) 运行在 Windows系统下的 Netscape Navigator 3的用户代理字符串大致如下。 1Mozilla/3.0 (Win95; U) 这个字符串表示 Netscape Navigator 3 运行在 Windows 95 中，采用了 128 位加密技术。可见，在Windows系统中，字符串中的操作系统或 CPU 说明被省略了。Netscape Navigator 3 发布后不久，微软也发布了其第一款赢得用户广泛认可的 Web 浏览器，即 Internet Explorer 3。由于 Netscape 浏览器在当时占绝对市场份额，许多服务器在提供网页之前都要专门检测该浏览器。如果用户通过 IE 打不开相关网页，那么这个新生的浏览器很可能就会夭折。于是，微软决定将 IE 的用户代理字符串修改成兼容 Netscape 的形式，结果如下： 1Mozilla/2.0 (compatible; MSIE 版本号; 操作系统) 例如，Windows 95 平台下的 Internet Explorer 3.02带有如下用户代理字符串： 1Mozilla/2.0 (compatible; MSIE 3.02; Windows 95) 由于当时的大多数浏览器嗅探程序只检测用户代理字符串中的产品名称部分，结果 IE 就成功地将自己标识为 Mozilla，从而伪装成 Netscape Navigator。微软的这一做法招致了很多批评，因为它违反了浏览器标识的惯例。更不规范的是，IE 将真正的浏览器版本号插入到了字符串的中间。字符串中另外一个有趣的地方是标识符 Mozilla 2.0（而不是 3.0）。毕竟，当时的主流版本是 3.0，改成 3.0 应该对微软更有利才对。但真正的谜底到现在还没有揭开——但很可能只是人为疏忽所致。 Netscape Communicator 4 和 IE4～IE81997 年 8 月，Netscapte Communicator 4 发布（这一版将浏览器名字中的 Navigator 换成了 Communicator）。Netscape 继续遵循了第 3 版时的用户代理字符串格式： Mozilla/版本号 (平台; 加密类型 [; 操作系统或 CPU 说明]) 因此，Windows 98 平台中第 4 版的用户代理字符串如下所示： 1Mozilla/4.0 (Win98; I) Netscape 在发布补丁时，子版本号也会相应提高，用户代理字符串如下面的 4.79 版所示： 1Mozilla/4.79 (Win98; I) 但是，微软在发布 Internet Explorer 4时，顺便将用户代理字符串修改成了如下格式： 1Mozilla/4.0 (compatible; MSIE 版本号; 操作系统) 换句话说，对于 Windows 98 中运行的 IE4 而言，其用户代理字符串为： 1Mozilla/4.0 (compatible; MSIE 4.0; Windows 98) 经过此番修改，Mozilla 版本号就与实际的 IE 版本号一致了，为识别它们的第四代浏览器提供了方便。但令人遗憾的是，两者的一致性仅限于这一个版本。在 Internet Explorer 4.5 发布时（只针对 Macs），虽然 Mozilla 版本号还是 4，但 IE 版本号则改成了如下所示： 1Mozilla/4.0 (compatible; MSIE 4.5; Mac_PowerPC) 此后，IE 的版本一直到 7 都沿袭了这个模式： 1Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1) 而 IE8 的用户代理字符串中添加了呈现引擎（Trident）的版本号： 1Mozilla/4.0 (compatible; MSIE 版本号; 操作系统; Trident/Trident 版本号) 例如： 1Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0) 这个新增的 Trident 记号是为了让开发人员知道 IE8 是不是在兼容模式下运行。如果是，则 MSIE 的版本号会变成 7，但 Trident 及版本号还会留在用户代码字符串中： 1Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0) 增加这个记号有助于分辨浏览器到底是 IE7（没有 Trident 记号），还是运行在兼容模式下的 IE8。 IE9 对字符串格式做了一点调整。Mozilla 版本号增加到了 5.0，而 Trident 的版本号也升到了 5.0。IE9默认的用户代理字符串如下： 1Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0) 如果 IE9 运行在兼容模式下，字符串中的 Mozilla 版本号和 MSIE 版本号会恢复旧的值，但 Trident 的版本号仍然是 5.0。例如，下面就是 IE9 运行在 IE7 兼容模式下的用户代理字符串： 1Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0) 所有这些变化都是为了确保过去的用户代理检测脚本能够继续发挥作用，同时还能给新脚本提供更丰富的信息。 GeckoGecko 是 Firefox 的呈现引擎。当初的 Gecko 是作为通用 Mozilla 浏览器的一部分开发的，而第一个采用 Gecko 引擎的浏览器是 Netscape 6。为 Netscape 6 编写的一份规范中规定了未来版本中用户代理字符串的构成。这个新格式与 4.x 版本中相对简单的字符串相比，有着非常大的区别，如下所示： Mozilla/Mozilla 版本号 (平台; 加密类型; 操作系统或 CPU; 语言; 预先发行版本) Gecko/Gecko 版本号 应用程序或产品/应用程序或产品版本号 这个明显复杂了很多的用户代理字符串中蕴含很多新想法。下表列出了字符串中各项的用意。 为了帮助读者更好地理解 Gecko 的用户代理字符串，下面我们来看几个从基于 Gecko 的浏览器中取得的字符串。 Windows XP 下的 Netscape 6.21： 1Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:0.9.4) Gecko/20011128 Netscape6/6.2.1 Linux 下的 SeaMonkey 1.1a： 1Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1b2) Gecko/20060823 SeaMonkey/1.1a Windows XP 下的 Firefox 2.0.0.11： 1Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11 Mac OS X下的 Camino 1.5.1： 1Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809 Camino/1.5.1 以上这些用户代理字符串都取自基于 Gecko的浏览器（只是版本有所不同）。很多时候，检测特定的浏览器还不如搞清楚它是否基于 Gecko更重要。每个字符串中的 Mozilla版本都是 5.0，自从第一个基于Gecko的浏览器发布时修改成这个样子，至今就没有改变过；而且，看起来以后似乎也不会有什么变化。随着 Firefox 4 发布，Mozilla 简化了这个用户代理字符串。主要改变包括以下几方面。 删除了“语言”记号（例如，前面例子中的“en-US”）。 在浏览器使用强加密（默认设置）时，不显示“加密类型”。也就是说，Mozilla 用户代理字符串中不会再出现“U”，而“I”和“N”还会照常出现。 “平台”记号从 Windows 用户代理字符串中删除了，“操作系统或 CPU”中始终都包含 “Windows”字符串。 “Gecko 版本号”固定为“Gecko/20100101”。 最后，Firefox 4 用户代理字符串变成了下面这个样子： 1Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox 4.0.1 WebKit2003 年，Apple 公司宣布要发布自己的 Web 浏览器，名字定为 Safari。Safari 的呈现引擎叫 WebKit，是 Linux 平台中 Konqueror 浏览器的呈现引擎 KHTML 的一个分支。几年后，WebKit 独立出来成为了一个开源项目，专注于呈现引擎的开发。 这款新浏览器和呈现引擎的开发人员也遇到了与 Internet Explorer 3.0 类似的问题：如何确保这款浏览器不被流行的站点拒之门外？答案就是向用户代理字符串中放入足够多的信息，以便站点能够信任它与其他流行的浏览器是兼容的。于是，WebKit 的用户代理字符串就具备了如下格式： Mozilla/5.0 (平台; 加密类型; 操作系统或 CPU; 语言) AppleWebKit/AppleWebKit 版本号(KHTML, like Gecko) Safari/Safari 版本号 以下就是一个示例： 1Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/124 (KHTML, like Gecko) Safari/125.1 显然，这又是一个很长的用户代理字符串。其中不仅包含了 Apple WebKit 的版本号，也包含了 Safari 的版本号。出于兼容性的考虑，有关人员很快就决定了将 Safari 标识为 Mozilla。至今，基于 WebKi所有浏览器都将自己标识为 Mozilla 5.0，与基于 Gecko 的浏览器完全一样。但 Safari 的版本号则通常浏览器的编译版本号，不一定与发布时的版本号对应。换句话说，虽然 Safari 1.25 的用户代理字符串中包含数字 125.1，但两者却不一一对应。 Safari 预发行 1.0 版用户代理字符串中最耐人寻味，也是最饱受诟病的部分就是字符串 “(KHTML, like Gecko)” 。Apple 因此收到许多开发人员的反馈，他们认为这个字符串明显是在欺骗客户端和服务器，实际上是想让它们把 Safari 当成 Gecko（好像光添加 Mozilla/5.0 还嫌不够）。Apple的回应与微软在 IE 的用户代理字符串遭到责难时如出一辙：Safari 与 Mozilla 兼容，因此网站不应该将 Safari 用户拒之门外，否则用户就会认为自己的浏览器不受支持。 到了 Safari 3.0 发布时，其用户代理字符串又稍微变长了一点。下面这个新增的 Version 记号一直到现在都被用来标识 Safari 实际的版本号： 12Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/522.15.5 (KHTML, likeGecko) Version/3.0.3 Safari/522.15.5 需要注意的是，这个变化只在 Safari 中有，在 WebKit 中没有。换句话说，其他基于 WebKit 的浏览器可能没有这个变化。一般来说，确定浏览器是否基于 WebKit 要比确定它是不是 Safari 更有价值，就像针对 Gecko 一样。 Konqueror与 KDE Linux 集成的 Konqueror，是一款基于 KHTML 开源呈现引擎的浏览器。尽管 Konqueror只能在 Linux 中使用，但它也有数量可观的用户。为确保最大限度的兼容性，Konqueror 效仿 IE 选择了如下用户代理字符串格式： Mozilla/5.0 (compatible; Konqueror/ 版本号; 操作系统或 CPU ) 不过，为了与 WebKit 的用户代理字符串的变化保持一致，Konqueror 3.2 又有了变化，以如下格式将自己标识为 KHTML： Mozilla/5.0 (compatible; Konqueror/ 版本号; 操作系统或 CPU) KHTML/ KHTML 版本号 (like Gecko) 下面是一个例子： 1Mozilla/5.0 (compatible; Konqueror/3.5; SunOS) KHTML/3.5.0 (like Gecko) 其中，Konqueror与KHTML的版本号比较一致，即使有差别也很小，例如Konqueror 3.5使用KHTML 3.5.1。 Chrome谷歌公司的 Chrome 浏览器以 WebKit 作为呈现引擎，但使用了不同的 JavaScript 引擎。在 Chrome 0.2这个最初的 beta 版中，用户代理字符串完全取自 WebKit，只添加了一段表示 Chrome版本号的信息，格式如下： Mozilla/5.0 ( 平台; 加密类型; 操作系统或 CPU; 语言) AppleWebKit/AppleWebKit 版本号 (KHTML, like Gecko) Chrome/ Chrome 版本号 Safari/ Safari 版本 Chrome 7的完整的用户代理字符串如下： 12Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML,like Gecko) Chrome/7.0.517.44 Safari/534.7 其中，WebKit 版本与 Safari 版本看起来似乎始终会保持一致，尽管没有十分的把握。 Opera仅就用户代理字符串而言，Opera 应该是最有争议的一款浏览器了。Opera 默认的用户代理字符串是所有现代浏览器中最合理的——正确地标识了自身及其版本号。在 Opera 8.0 之前，其用户代理字符串采用如下格式： Opera/ 版本号 (操作系统或 CPU; 加密类型) [语言] Windows XP 中的 Opera 7.54 会显示下面的用户代理字符串： 1Opera/7.54 (Windows NT 5.1; U) [en] Opera 8 发布后，用户代理字符串的“语言”部分被移到圆括号内，以便更好地与其他浏览器匹配，如下所示： Opera/ 版本号 (操作系统或 CPU; 加密类型; 语言) Windows XP 中的 Opera 8 会显示下面的用户代理字符串： 1Opera/8.0 (Windows NT 5.1; U; en) 默认情况下，Opera 会以上面这种简单的格式返回一个用户代理字符串。目前来看，Opera 也是主要浏览器中唯一一个使用产品名和版本号来完全彻底地标识自身的浏览器。可是，与其他浏览器一样，Opera 在使用自己的用户代理字符串时也遇到了问题。即使技术上正确，但因特网上仍然有不少浏览器嗅探代码，只钟情于报告 Mozilla 产品名的那些用户代理字符串。另外还有相当数量的代码则只对 IE 或Gecko 感兴趣。Opera 没有选择通过修改自身的用户代理字符串来迷惑嗅探代码，而是干脆选择通过修改自身的用户代理字符串将自身标识为一个完全不同的浏览器。 Opera 9 以后，出现了两种修改用户代理字符串的方式。一种方式是将自身标识为另外一个浏览器，如 Firefox 或者 IE。在这种方式下，用户代理字符串就如同 Firefox 或 IE 的用户代理字符串一样，只不过末尾追加了字符串 Opera 及 Opera 的版本号。下面是一个例子： 123Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50 第一个字符串将 Opera 9.5 标识为 Firefox 2，同时带有 Opera 版本信息。第二个字符串将 Opera 9.5标识为 IE6，也包含了 Opera 版本信息。这两个用户代理字符串可以通过针对 Firefox 或 IE 的大多数测试，不过还是为识别 Opera 留下了余地。 Opera 标识自身的另一种方式，就是把自己装扮成 Firefox 或 IE。在这种隐瞒真实身份的情况下，用户代理字符串实际上与其他浏览器返回的相同——既没有 Opera 字样，也不包含 Opera 版本信息。换句话说，在启用了身份隐瞒功能的情况下，无法将 Opera 和其他浏览器区别开来。另外，由于 Opera 喜欢在不告知用户的情况下针对站点来设置用户代理字符串，因此问题就更复杂化了。例如，打开 MyYahoo!站点（ http://my.yahoo.com ）会自动导致 Opera 将自己装扮成 Firefox。如此一来，要想识别 Opera 就难上加难了。 在 Opera 7 以前的版本中，Opera 会解析 Windows操作系统字符串的含义。例如， Windows NT 5.1 实际上就是 Windows XP，因此 Opera 会在用户代理字符串中包含 Windows XP 而非 Windows NT 5.1。为了与其他浏览器更兼容，Opera 7 开始包含正式的操作系统版本，而非解析后的版本。 pera 10 对代理字符串进行了修改。现在的格式是： Opera/9.80 (操作系统或 CPU; 加密类型; 语言) Presto/Presto 版本号 Version/版本号 注意，初始的版本号 Opera/9.80 是固定不变的。实际并没有 Opera 9.8，但工程师们担心写得不好的浏览器嗅探脚本会将 Opera/10.0 错误的解释为 Opera 1，而不是 Opera 10。因此，Opera 10 又增加了 Presto 记号（Presto 是 Opera 的呈现引擎）和 Version 记号，后者用以保存实际的版本号。以下是 Windows7 中 Opera 10.63 的用户代理字符串： 1Opera/9.80 (Windows NT 6.1; U; en) Presto/2.6.30 Version/10.63 iOS 和 Android移动操作系统 iOS 和 Android 默认的浏览器都基于 WebKit，而且都像它们的桌面版一样，共享相同的基本用户代理字符串格式。iOS 设备的基本格式如下： Mozilla/5.0 (平台; 加密类型; 操作系统或 CPU like Mac OS X; 语言) AppleWebKit/AppleWebKit 版本号 (KHTML, like Gecko) Version/浏览器版本号 Mobile/移动版本号 Safari/Safari 版本号 注意用于辅助确定 Mac 操作系统的 “like Mac OS X” 和额外的 Mobile 记号。一般来说，Mobile记号的版本号（移动版本号）没什么用，主要是用来确定 WebKit 是移动版，而非桌面版。而平台则可能是 “iPhone” 、 “iPod” 或 “iPad” 。例如： 1Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_0 like Mac OS X; enus)AppleWebKit/528.18 (KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16 在 iOS 3 之前，用户代理字符串中不会出现操作系统版本号。 Android 浏览器中的默认格式与 iOS 的格式相似，没有移动版本号（但有 Mobile 记号）。例如： 12Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91)AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 这是 Google Nexus One 手机的用户代理字符串。不过，其他 Android 设备的模式也一样。 用户代理字符串检测技术考虑到历史原因以及现代浏览器中用户代理字符串的使用方式，通过用户代理字符串来检测特定的浏览器并不是一件轻松的事。因此，首先要确定的往往是你需要多么具体的浏览器信息。一般情况下，知道呈现引擎和最低限度的版本就足以决定正确的操作方法 了。例如，我们不推荐使用下列代码： 123if (isIE6 || isIE7) &#123; //不推荐!!! //代码&#125; 这个例子是 想要在浏览器为 IE6 或 IE7 时执行相应代码 。这种代码其实是很脆弱的 ，因为 它要依据特定的版本来决定做什么 。如果是 IE8 怎么办呢？只要 IE 有新版本出来，就必须更新这些代码。不过，像下面这样 使用相对版本号 则可以避免此问题： 123if (ieVer &gt;=6)&#123; //代码&#125; 这个例子首先检测 IE 的版本号是否至少等于 6，如果是则执行相应操作。这样就可以确保相应的代码将来照样能够起作用。我们下面的浏览器检测脚本就将本着这种思路来编写。 识别呈现引擎如前所述，确切知道浏览器的名字和版本号不如 确切知道它使用的是什么呈现引擎 。如果 Firefox、Camino 和 Netscape 都使用相同版本的 Gecko，那它们一定支持相同的特性。类似地，不管是什么浏览器，只要它跟 Safari 3 使用的是同一个版本的 WebKit，那么该浏览器也就跟 Safari 3 具备同样的功能。因此，我们要编写的脚本将主要检测五大呈现引擎：IE 、Gecko 、WebKit 、KHTML 和 Opera 。 为了不在全局作用域中添加多余的变量，我们将使用模块增强模式来封装检测脚本。检测脚本的基本代码结构如下所示： 123456789101112131415161718192021var client = function()&#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体的版本号 ver: null &#125;; //在此检测呈现引擎、平台和设备 return &#123; engine : engine &#125;;&#125;(); 这里声明了一个名为 client 的全局变量，用于保存相关信息。匿名函数内部定义了一个局部变量 engine ，它是一个包含默认设置的对象字面量。在这个对象字面量中，每个呈现引擎都对应着一个属性，属性的值默认为 0。如果检测到了哪个呈现引擎，那么就以浮点数值形式将该引擎的版本号写入相应的属性。而呈现引擎的完整版本（是一个字符串），则被写入 ver 属性。作这样的区分可以支持像下面这样编写代码： 1234567if (client.engine.ie) &#123; //如果是 IE，client.ie 的值应该大于 0 //针对 IE 的代码&#125; else if (client.engine.gecko &gt; 1.5)&#123; if (client.engine.ver == "1.8.1")&#123; //针对这个版本执行某些操作 &#125;&#125; 在检测到一个呈现引擎之后，其 client.engine 中对应的属性将被设置为一个大于 0 的值，该值可以转换成布尔值 true 。这样，就可以在 if 语句中检测相应的属性，以确定当前使用的呈现引擎，连具体的版本号都不必考虑。鉴于每个属性都包含一个浮点数值，因此有可能丢失某些版本信息。例如，将字符串 “1.8.1” 传入 parseFloat() 后会得到数值 1.8。不过，在必要的时候可以检测 ver 属性，该属性中会保存完整的版本信息。 要正确地识别呈现引擎，关键是检测顺序要正确。由于用户代理字符串存在诸多不一致的地方，如果检测顺序不对，很可能会导致检测结果不正确。为此，第一步就是识别 Opera，因为它的用户代理字符串有可能完全模仿其他浏览器。我们不相信 Opera，是因为（任何情况下）其用户代理字符串（都）不会将自己标识为 Opera。 要识别 Opera，必须得检测 window.opera 对象。Opera 5 及更高版本中都有这个对象，用以保存与浏览器相关的标识信息以及与浏览器直接交互。在 Opera 7.6 及更高版本中，调用 version() 方法可以返回一个表示浏览器版本的字符串，而这也是确定Opera 版本号的最佳方式。要检测更早版本的 Opera，可以直接检查用户代理字符串，因为那些版本还不支持隐瞒身份。不过，2007 底 Opera 的最高版本已经是 9.5 了，所以不太可能有人还在使用 7.6 之前的版本。那么，检测呈现引擎代码的第一步，就是编写如下代码： 1234if (window.opera)&#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; 这里，将版本的字符串表示保存在了 engine.ver 中，将浮点数值表示的版本保存在了engine.opera 中。如果浏览器是 Opera，测试 window.opera 就会返回 true ；否则，就要看看是其他的什么浏览器了。 应该放在第二位检测的呈现引擎是 WebKit。因为 WebKit 的用户代理字符串中包含 “Gecko” 和”KHTML” 这两个子字符串，所以如果首先检测它们，很可能会得出错误的结论。 不过，WebKit 的用户代理字符串中的”AppleWebKit” 是独一无二的，因此检测这个字符串最合适。下面就是检测该字符串的示例代码： 12345678var ua = navigator.userAgent;if (window.opera)&#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.webkit = parseFloat(engine.ver);&#125; 代码首先将用户代理字符串保存在变量 ua 中。然后通过正则表达式来测试其中是否包含字符串”AppleWebKit” ，并使用捕获组来取得版本号。由于实际的版本号中可能会包含数字、小数点和字母，所以捕获组中使用了表示非空格的特殊字符（ \S ）。用户代理字符串中的版本号与下一部分的分隔符是一个空格，因此这个模式可以保证捕获所有版本信息。 test() 方法基于用户代理字符串运行正则表达式。如果返回 true ，就将捕获的版本号保存在 engine.ver 中，而将版本号的浮点表示保存在engine.webkit 中。WebKit 版本与 Safari 版本的详细对应情况如下表所示。 有时候，Safari 版本并不会与 WebKit 版本严格地一一对应，也可能会存在某些小版本上的差异。这个表中只是列出了最可能的 WebKit版本，但不保证精确。 接下来要测试的 呈现引擎是 KHTML 。同样，KHTML 的用户代理字符串中也包含 “Gecko”，因此在排除 KHTML 之前，我们无法准确检测基于 Gecko 的浏览器。KHTML 的版本号与 WebKit 的版本号在用户代理字符串中的格式差不多，因此可以使用类似的正则表达式。此外，由于 Konqueror 3.1 及更早版本中不包含 KHTML 的版本，故而就要使用 Konqueror 的版本来代替。下面就是相应的检测代码。 1234567891011var ua = navigator.userAgent;if (window.opera)&#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.webkit = parseFloat(engine.ver);&#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.khtml = parseFloat(engine.ver);&#125; 与前面一样，由于 KHTML 的版本号与后继的标记之间有一个空格，因此仍然要使用特殊的非空格字符来取得与版本有关的所有字符。然后，将字符串形式的版本信息保存在 engine.ver 中，将浮点数值形式的版本保存在 engin.khtml 中。如果 KHTML 不在用户代理字符串中，那么就要匹配 Konqueror 后跟一个斜杠，再后跟不包含分号的所有字符。 在排除了 WebKit 和 KHTML 之后，就可以准确地检测 Gecko 了。但是，在用户代理字符串中，Gecko 的版本号不会出现在字符串 “Gecko” 的后面，而是会出现在字符串 “rv:” 的后面。这样，我们就必须使用一个比前面复杂一些的正则表达式，如下所示。 1234567891011121314var ua = navigator.userAgent;if (window.opera)&#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.webkit = parseFloat(engine.ver);&#125; else if (/KHTML\/(\S+)/.test(ua)) &#123; engine.ver = RegExp["$1"]; engine.khtml = parseFloat(engine.ver);&#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.gecko = parseFloat(engine.ver);&#125; Gecko 的版本号位于字符串 “rv:” 与一个闭括号之间，因此为了提取出这个版本号，正则表达式要查找所有不是闭括号的字符，还要查找字符串 “Gecko/“ 后跟 8 个数字。如果上述模式匹配，就提取出版本号并将其保存在相应的属性中。Gecko 版本号与 Firefox 版本号的对应关系如下表所示。 与 Safari 跟 WebKit 一样，Firefox 与 Gecko 的版本号也不一定严格对应。 最后一个要检测的呈现引擎就是 IE 了。IE 的版本号位于字符串 “MSIE” 的后面、一个分号的前面，因此相应的正则表达式非常简单，如下所示： 1234567891011121314151617var ua = navigator.userAgent;if (window.opera)&#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.webkit = parseFloat(engine.ver);&#125; else if (/KHTML\/(\S+)/.test(ua)) &#123; engine.ver = RegExp["$1"]; engine.khtml = parseFloat(engine.ver);&#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.gecko = parseFloat(engine.ver);&#125; else if (/MSIE ([^;]+)/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.ie = parseFloat(engine.ver);&#125; 以上呈现引擎检测脚本的最后一部分，就是在正则表达式中使用取反的字符类来取得不是分号的所有字符。IE 通常会保证以标准浮点数值形式给出其版本号，但有时候也不一定。因此，取反的字符类 [^;] 可以确保取得多个小数点以及任何可能的字符。 识别浏览器大多数情况下，识别了浏览器的呈现引擎就足以为我们采取正确的操作提供依据了。可是，只有呈现引擎还不能说明存在所需的 JavaScript 功能。苹果公司的 Safari 浏览器和谷歌公司的 Chrome 浏览器都使用 WebKit 作为呈现引擎，但它们的 JavaScript 引擎却不一样。在这两款浏览器中， client.webkit 都会返回非 0值，但仅知道这一点恐怕还不够。对于它们，有必要像下面这样为 client 对象再添加一些新的属性。 1234567891011121314151617181920212223242526272829303132var client = function()&#123;var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体的版本 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 具体的版本 ver: null &#125;; //在此检测呈现引擎、平台和设备 return &#123; engine: engine, browser: browser &#125;;&#125;(); 代码中又添加了私有变量 browser ，用于保存每个主要浏览器的属性。与 engine 变量一样，除了当前使用的浏览器，其他属性的值将保持为 0；如果是当前使用的浏览器，则这个属性中保存的是浮点数值形式的版本号。同样， ver 属性中在必要时将会包含字符串形式的浏览器完整版本号。由于大多数浏览器与其呈现引擎密切相关，所以下面示例中检测浏览器 的代码与 检测呈现引擎 的代码是 混合在一起 的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//检测呈现引擎及浏览器var ua = navigator.userAgent;if (window.opera)&#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.webkit = parseFloat(engine.ver); // 确定是 Chrome 还是 Safari if (/Chrome\/(\S+)/.test(ua))&#123; browser.ver = RegExp["$1"]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\/(\S+)/.test(ua))&#123; browser.ver = RegExp["$1"]; browser.safari = parseFloat(browser.ver); &#125; else &#123; // 近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100)&#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312)&#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412)&#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125;&#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp["$1"]; engine.khtml = browser.konq = parseFloat(engine.ver);&#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.gecko = parseFloat(engine.ver); // 确定是不是 Firefox if (/Firefox\/(\S+)/.test(ua))&#123; browser.ver = RegExp["$1"]; browser.firefox = parseFloat(browser.ver); &#125;&#125; else if (/MSIE ([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp["$1"]; engine.ie = browser.ie = parseFloat(engine.ver);&#125; 对 Opera 和 IE 而言， browser 对象中的值等于 engine 对象中的值。对 Konqueror 而言， browser.konq 和 browser.ver 属性分别等于 engine.khtml 和 engine.ver 属性。 为了检测 Chrome 和 Safari，我们在检测引擎的代码中添加了 if 语句。提取 Chrome 的版本号时，需要查找字符串 “Chrome/“ 并取得该字符串后面的数值。而提取 Safari 的版本号时，则需要查找字符串”Version/“ 并取得其后的数值。由于这种方式仅适用于 Safari 3 及更高版本，因此需要一些备用的代码，将 WebKit 的版本号近似地映射为 Safari 的版本号（参见上一小节中的表格）。 在检测 Firefox 的版本时，首先要找到字符串 “Firefox/“ ，然后提取出该字符串后面的数值（即版本号）。当然，只有呈现引擎被判别为 Gecko 时才会这样做。 有了上面这些代码之后，我们就可以编写下面的逻辑。 12345678910111213if (client.engine.webkit) &#123; //if it’s WebKit if (client.browser.chrome)&#123; //执行针对 Chrome 的代码 &#125; else if (client.browser.safari)&#123; //执行针对 Safari 的代码 &#125;&#125; else if (client.engine.gecko)&#123; if (client.browser.firefox)&#123; //执行针对 Firefox 的代码 &#125; else &#123; //执行针对其他 Gecko 浏览器的代码 &#125;&#125; 识别平台很多时候，只要知道呈现引擎就足以编写出适当的代码了。但在某些条件下，平台可能是必须关注的问题。那些具有各种平台版本的浏览器（如 Safari、Firefox 和 Opera）在不同的平台下可能会有不同的问题。目前的三大主流平台是 Windows、Mac 和 Unix（包括各种 Linux）。为了检测这些平台，还需要像下面这样再添加一个新对象。 123456789101112131415161718192021222324252627282930313233343536373839var client = function()&#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体的版本号 ver: null &#125;; var browser = &#123; //浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体的版本号 ver: null &#125;; var system = &#123; win: false, mac: false, x11: false &#125;; //在此检测呈现引擎、平台和设备 return &#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 显然，上面的代码中又添加了一个包含 3 个属性的新变量 system 。其中， win 属性表示是否为Windows 平台， mac 表示 Mac，而 x11 表示 Unix。与呈现引擎不同，在不能访问操作系统或版本的情况下，平台信息通常是很有限的。对这三个平台而言，浏览器一般只报告 Windows 版本。为此，新变量 system 的每个属性最初都保存着布尔值 false ，而不是像呈现引擎属性那样保存着数字值。 在确定平台时，检测 navigator.platform 要比检测用户代理字符串更简单，后者在不同浏览器中会给出不同的平台信息。而 navigator.platform 属性可能的值包括 “Win32” 、 “Win64” 、”MacPPC” 、 “MacIntel” 、 “X11” 和 “Linux i686” ，这些值在不同的浏览器中都是一致的。检测平台的代码非常直观，如下所示： 1234var p = navigator.platform;system.win = p.indexOf("Win") == 0;system.mac = p.indexOf("Mac") == 0;system.x11 = (p.indexOf("X11") == 0) || (p.indexOf("Linux") == 0); 以上代码使用 indexOf() 方法来查找平台字符串的开始位置。虽然 “Win32” 是当前浏览器唯一支持的 Windows 字符串，但随着向 64 位 Windows架构的迁移，将来很可能会出现 “Win64” 平台信息值。为了对此有所准备，检测平台的代码中查找的只是字符串 “Win” 的开始位置。而检测 Mac 平台的方式也类似，同样是考虑到了 MacPPC 和 MacIntel 。在检测 Unix 时，则同时检查了字符串 “X11” 和 “Linux”在平台字符串中的开始位置，从而确保了代码能够向前兼容其他变体。 Gecko的早期版本在所有 Windows平台中都返回字符串 “Windows” ，在所有 Mac平台中则都返回字符串 “Macintosh” 。不过，这都是 Firefox 1发布以前的事了，Firefox 1 确定了 navigator.platform 的值。 识别 Windows 操作系统在 Windows平台下，还可以 从用户代理字符串中进一步取得具体的操作系统信息 。在 Windows XP之前，Windows有两种版本，分别针对家庭用户和商业用户。针对家庭用户的版本分别是 Windows 95、98 和 Windows ME。而针对商业用户的版本则一直叫做 Window NT，最后由于市场原因改名为 Windows2000。这两个产品线后来又合并成一个由 Windows NT 发展而来的公共的代码基，代表产品就是 WindowsXP。随后，微软在 Windows XP 基础上又构建了 Windows Vista。只有了解这些信息，才能搞清楚用户代理字符串中 Windows操作系统的具体版本。下表列出了不同浏览器在表示不同的 Windows操作系统时给出的不同字符串。 由于用户代理字符串中的 Windows 操作系统版本表示方法各异，因此检测代码并不十分直观。好在，从 Windows 2000 开始，表示操作系统的字符串大部分都还相同，只有版本号有变化。为了检测不同的 Windows 操作系统 ，必须要使用正则表达式。由于使用 Opera 7 之前版本的用户已经不多了，因此我们可以忽略这部分浏览器。 第一步就是匹配 Windows 95 和 Windows 98 这两个字符串。对这两个字符串，只有 Gecko 与其他浏览器不同，即没有 “dows” ，而且 “Win” 与版本号之间没有空格。要匹配这个模式，可以使用下面这个简单的正则表达式。 1/Win(?:dows )?([^do]&#123;2&#125;)/ 这个正则表达式中的捕获组会返回操作系统的版本。由于版本可能是任何两个字符编码（例如 95、98、9x、NT、ME 及 XP），因此要使用两个非空格字符。Gecko 在表示 Windows NT 时会在末尾添加 “4.0” ，与其查找实际的字符串，不如像下面这样查找小数值更合适。 1/Win(?:dows )?([^do]&#123;2&#125;)(\d+\.\d+)?/ 这样，正则表达式中就包含了第二个捕获组，用于取得 NT 的版本号。由于该版本号对于 Windows 95 和 Windows 98 而言是不存在的，所以必须设置为可选。这个模式与 Opera 表示 Windows NT 的字符串之间唯一的区别，就是 “NT” 与 “4.0” 之间的空格，这在模式中很容易添加。 1/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/ 经过一番修改之后，这个 正则表达式也可以成功地匹配 Windows ME、Windows XP 和 Windows Vista的字符串 了。具体来说，第一个捕获组将会匹配 95、98、9x、NT、ME 或 XP。第二个捕获组则只针对 Windows ME 及所有 Windows NT 的变体。这个信息可以作为具体的操作系统信息保存在 system.win 属性中，如下所示。 123456789101112131415161718192021222324252627if (system.win)&#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/.test(ua))&#123; if (RegExp["$1"] == "NT")&#123; switch(RegExp["$2"])&#123; case "5.0": system.win = "2000"; break; case "5.1": system.win = "XP"; break; case "6.0": system.win = "Vista"; break; case "6.1": system.win = "7"; break; default: system.win = "NT"; break; &#125; &#125; else if (RegExp["$1"] == "9x")&#123; system.win = "ME"; &#125; else &#123; system.win = RegExp["$1"]; &#125; &#125;&#125; 如果 system.win 的值为 true ，那么就使用这个正则表达式从用户代理字符串中提取具体的信息。鉴于 Windows 将来的某个版本也许不能使用这个方法来检测，所以第一步应该先检测用户代理字符串是否与这个模式匹配。在模式匹配的情况下，第一个捕获组中可能会包含 “95” 、 “98” 、 “9x” 或 “NT” 。如果这个值是 “NT” ，可以将 system.win 设置为相应操作系统的字符串；如果是 “9x” ，那么 system.win 就要设置成 “ME” ；如果是其他值，则将所捕获的值直接赋给 system.win 。有了这些检测平台的代码后，我们就可以编写如下代码。 1234567if (client.system.win)&#123; if (client.system.win == "XP") &#123; //说明是 XP &#125; else if (client.system.win == "Vista")&#123; //说明是 Vista &#125;&#125; 由于非空字符串会转换为布尔值 true ，因此可以将 client.system.win 作为布尔值用在 if 语句中。而在需要更多有关操作系统的信息时，则可以使用其中保存的字符串值。 识别移动设备 2006 年到 2007 年，移动设备中 Web 浏览器的应用呈爆炸性增长。四大主要浏览器都推出了手机版和在其他设备中运行的版本。要检测相应的设备，第一步是为要 检测的所有移动设备添加属性 ，如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var client = function()&#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体的版本号 ver: null &#125;; var browser = &#123; //浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体的版本号 ver: null &#125;; var system = &#123; win: false, mac: false, x11: false, // 移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false &#125;; //在此检测呈现引擎、平台和设备 return &#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 然后，通常简单地检测字符串 “iPhone” 、 “iPod” 和 “iPad” ，就可以分别设置相应属性的值了。 123system.iphone = ua.indexOf("iPhone") &gt; -1;system.ipod = ua.indexOf("iPod") &gt; -1;system.ipod = ua.indexOf("iPad") &gt; -1; 除了知道iOS设备，最好还能知道iOS的版本号。在iOS 3之前，用户代理字符串中只包含 “CPU like Mac OS” ，后来 iPhone 中又改成 “CPU iPhone OS 3_0 like Mac OS X” ，iPad 中又改成 “CPU OS 3_2 like Mac OS X” 。也就是说，检测 iOS 需要正则表达式反映这些变化。 12345678//检测 iOS 版本if (system.mac &amp;&amp; ua.indexOf("Mobile") &gt; -1)&#123; if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua))&#123; system.ios = parseFloat(RegExp.$1.replace("_", ".")); &#125; else &#123; system.ios = 2; //不能真正检测出来，所以只能猜测 &#125;&#125; 检查系统是不是 Mac OS、字符串中是否存在 “Mobile” ，可以保证无论是什么版本， system.ios中都不会是 0。然后，再使用正则表达式确定是否存在 iOS 的版本号。如果有，将 system.ios 设置为表示版本号的浮点值；否则，将版本设置为 2。（因为没有办法确定到底是什么版本，所以设置为更早的版本比较稳妥。） 检测 Android 操作系统也很简单，也就是搜索字符串 “Android” 并取得紧随其后的版本号。 1234//检测 Android 版本if (/Android (\d+\.\d+)/.test(ua))&#123; system.android = parseFloat(RegExp.$1);&#125; 由于所有版本的 Android 都有版本值，因此这个正则表达式可以精确地检测所有版本，并将 system.android 设置为正确的值。诺基亚 N 系列手机使用的也是 WebKit，其用户代理字符串与其他基于 WebKit 的手机很相似，例如： 1Mozilla/5.0 (SymbianOS/9.2; U; Series60/3.1 NokiaN95/11.0.026; Profile MIDP-2.0 Configuration/CLDC-1.1) AppleWebKit/413 (KHTML, like Gecko) Safari/413 虽然诺基亚 N 系列手机在用户代理字符串中声称使用的是 “Safari” ，但实际上并不是 Safari，尽管确实是基于 WebKit 引擎。只要像下面检测一下用户代理字符串中是否存在 “NokiaN” ，就足以确定是不是该系列的手机了。 1system.nokiaN = ua.indexOf("NokiaN") &gt; -1; 在了解这些设备信息的基础上，就可以通过下列代码来确定用户使用的是什么设备中的 WebKit 来访问网页： 123456789if (client.engine.webkit)&#123; if (client.system. iOS)&#123; //iOS 手机的内容 &#125; else if (client.system.android)&#123; //Android 手机的内容 &#125; else if (client.system.nokiaN)&#123; //诺基亚手机的内容 &#125;&#125; 最后一种主要的移动设备平台是 Windows Mobile（也称为 Windows CE），用于 Pocket PC 和 Smartphone 中。由于从技术上说这些平台都属于 Windows 平台，因此 Windows 平台和操作系统都会返回正确的值。对于 Windows Mobile 5.0 及以前版本，这两种设备的用户代理字符串非常相似，如下所示： 12Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; PPC; 240x320)Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; Smartphone; 176x220) 第一个来自 Pocket PC中的移动 Internet Explorer 4.01，第二个来自 Smartphone 中的同一个浏览器。当 Windows 操作系统检测脚本检测这两个字符串时， system.win 将被设置为 “CE” ，因此在检测 Windows Mobile 时可以使用这个值： 1system.winMobile = (system.win == "CE"); 不建议测试字符串中的 “PPC” 或 “Smartphone” ，因为在 Windows Mobile 5.0 以后版本的浏览器中，这些记号已经被移除了。不过，一般情况下，只知道某个设备使用的是 Windows Mobile 也就足够了。Windows Phone 7 的用户代理字符串稍有改进，基本格式如下： 1Mozilla/4.0 (compatible; MSIE 7.0; Windows Phone OS 7.0; Trident/3.1; IEMobile/7.0) Asus;Galaxy6 其中，Windows 操作符的标识符与已往完全不同，因此在这个用户代理中client.system.win 等于 “Ph” 。从中可以取得有关系统的更多信息： 123456789//windows mobileif (system.win == "CE")&#123; system.winMobile = system.win;&#125; else if (system.win == "Ph")&#123; if(/Windows Phone OS (\d+.\d+)/.test(ua))&#123;; system.win = "Phone"; system.winMobile = parseFloat(RegExp["$1"]); &#125;&#125; 如果 system.win 的值是 “CE” ，就说明是老版本的 Windows Mobile，因此 system.winMobile 会被设置为相同的值（只能知道这个信息）。如果 system.win 的值是 “Ph” ，那么这个设备就可能是Windows Phone 7 或更新版本。因此就用正则表达式来测试格式并提取版本号，将 system.win 的值重置为 “Phone” ，而将 system.winMobile 设置为版本号。 识别游戏系统除了移动设备之外，视频游戏系统中的 Web 浏览器也开始日益普及。任天堂 Wii 和 Playstation 3 或者内置 Web 浏览器，或者提供了浏览器下载。Wii 中的浏览器实际上是定制版的 Opera，是专门为 WiiRemote 设计的。Playstation 的浏览器是自己开发的，没有基于前面提到的任何呈现引擎。这两个浏览器中的用户代理字符串如下所示： 12Opera/9.10 (Nintendo Wii;U; ; 1621; en)Mozilla/5.0 (PLAYSTATION 3; 2.00) 第一个字符串来自运行在 Wii 中的 Opera，它忠实地继承了 Opera 最初的用户代理字符串格式（Wii 上的 Opera 不具备隐瞒身份的能力）。第二个字符串来自 Playstation3，虽然它为了兼容性而将自己标识为 Mozilla 5.0，但并没有给出太多信息。而且，设备名称居然全部使用了大写字母，让人觉得很奇怪；强烈希望将来的版本能够改变这种情况。 在检测这些设备以前，我们必须先为 client.system 中添加适当的属性，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var client = function()&#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体的版本号 ver: null &#125;; var browser = &#123; //浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体的版本号 ver: null &#125;; var system = &#123; win: false, mac: false, x11: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, // 游戏系统 wii: false, ps: false &#125;; //在此检测呈现引擎、平台和设备 return &#123; engine: engine, browser: browser, system: system &#125;;&#125;();` 检测前述游戏系统的代码如下： 12system.wii = ua.indexOf("Wii") &gt; -1;system.ps = /playstation/i.test(ua); 对于 Wii，只要检测字符串 “Wii” 就够了，而其他代码将发现这是一个 Opera 浏览器，并将正确的版本号保存在 client.browser.opera 中。对于 Playstation，我们则使用正则表达式来以不区分大小写的方式测试用户代理字符串。 完整的代码以下是完整的用户代理字符串检测脚本，包括检测 呈现引擎 、平台 、Windows操作系统 、移动设备 和 游戏系统 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179var client = function()&#123; //呈现引擎 var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //完整的版本号 ver: null &#125;; //浏览器 var browser = &#123; //主要浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体的版本号 ver: null &#125;; //平台、设备和操作系统 var system = &#123; win: false, mac: false, x11: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, //游戏系统 wii: false, ps: false &#125;; //检测呈现引擎和浏览器 var ua = navigator.userAgent; if (window.opera)&#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.webkit = parseFloat(engine.ver); //确定是 Chrome 还是 Safari if (/Chrome\/(\S+)/.test(ua))&#123; browser.ver = RegExp["$1"]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\/(\S+)/.test(ua))&#123; browser.ver = RegExp["$1"]; browser.safari = parseFloat(browser.ver); &#125; else &#123; //近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100)&#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312)&#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412)&#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp["$1"]; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp["$1"]; engine.gecko = parseFloat(engine.ver); //确定是不是 Firefox if (/Firefox\/(\S+)/.test(ua))&#123; browser.ver = RegExp["$1"]; browser.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp["$1"]; engine.ie = browser.ie = parseFloat(engine.ver); &#125; //检测浏览器 browser.ie = engine.ie; browser.opera = engine.opera; //检测平台 var p = navigator.platform; system.win = p.indexOf("Win") == 0; system.mac = p.indexOf("Mac") == 0; system.x11 = (p == "X11") || (p.indexOf("Linux") == 0); //检测 Windows 操作系统 if (system.win)&#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/.test(ua))&#123; if (RegExp["$1"] == "NT")&#123; switch(RegExp["$2"])&#123; case "5.0": system.win = "2000"; break; case "5.1": system.win = "XP"; break; case "6.0": system.win = "Vista"; break; case "6.1": system.win = "7"; break; default: system.win = "NT"; break; &#125; &#125; else if (RegExp["$1"] == "9x")&#123; system.win = "ME"; &#125; else &#123; system.win = RegExp["$1"]; &#125; &#125; &#125; //移动设备 system.iphone = ua.indexOf("iPhone") &gt; -1; system.ipod = ua.indexOf("iPod") &gt; -1; system.ipad = ua.indexOf("iPad") &gt; -1; system.nokiaN = ua.indexOf("NokiaN") &gt; -1; //windows mobile if (system.win == "CE")&#123; system.winMobile = system.win; &#125; else if (system.win == "Ph")&#123; if(/Windows Phone OS (\d+.\d+)/.test(ua))&#123;; system.win = "Phone"; system.winMobile = parseFloat(RegExp["$1"]); &#125; &#125; //检测 iOS 版本 if (system.mac &amp;&amp; ua.indexOf("Mobile") &gt; -1)&#123; if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua))&#123; system.ios = parseFloat(RegExp.$1.replace("_", ".")); &#125; else &#123; system.ios = 2; //不能真正检测出来，所以只能猜测 &#125; &#125; //检测 Android 版本 if (/Android (\d+\.\d+)/.test(ua))&#123; system.android = parseFloat(RegExp.$1); &#125; //游戏系统 system.wii = ua.indexOf("Wii") &gt; -1; system.ps = /playstation/i.test(ua); //返回这些对象 return &#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 使用方法我们在前面已经强调过了，用户代理检测是客户端检测的最后一个选择。只要可能，都应该优先采用能力检测和怪癖检测。用户代理检测一般适用于下列情形。 不能直接准确地使用能力检测或怪癖检测 。例如，某些浏览器实现了为将来功能预留的存根（stub）函数。在这种情况下，仅测试相应的函数是否存在还得不到足够的信息。 同一款浏览器在不同平台下具备不同的能力 。这时候，可能就有必要确定浏览器位于哪个平台下。 为了跟踪分析等目的需要知道确切的浏览器 。 小结客户端检测是 JavaScript 开发中最具争议的一个话题。由于浏览器间存在差别，通常需要根据不同浏览器的能力分别编写不同的代码。有不少客户端检测方法，但下列是最经常使用的。 能力检测 ：在编写代码之前先检测特定浏览器的能力。例如，脚本在调用某个函数之前，可能要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出来，让他们把注意力集中到相应的能力是否存在上。能力检测无法精确地检测特定的浏览器和版本。 怪癖检测 ：怪癖实际上是浏览器实现中存在的 bug，例如早期的 WebKit 中就存在一个怪癖，即它会在 for-in 循环中返回被隐藏的属性。怪癖检测通常涉及到运行一小段代码，然后确定浏览器是否存在某个怪癖。由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干扰脚本运行的情况下使用。怪癖检测无法精确地检测特定的浏览器和版本。 用户代理检测 ：通过检测用户代理字符串来识别浏览器。用户代理字符串中包含大量与浏览器有关的信息，包括浏览器、平台、操作系统及浏览器版本。用户代理字符串有过一段相当长的发展历史，在此期间，浏览器提供商试图通过在用户代理字符串中添加一些欺骗性信息，欺骗网站相信自己的浏览器是另外一种浏览器。用户代理检测需要特殊的技巧，特别是要注意 Opera会隐瞒其用户代理字符串的情况。即便如此，通过用户代理字符串仍然能够检测出浏览器所用的呈现引擎以及所在的平台，包括移动设备和游戏系统。 在决定使用哪种客户端检测方法时，一般应 优先考虑 使用 能力检测 。怪癖检测 是确定应该如何处理代码的 第二选择 。而 用户代理检测则 是客户端检测的 最后一种方案 ，因为这种方法对用户代理字符串具有很强的依赖性。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-BOM]]></title>
    <url>%2F2018%2F08%2F20%2FJavaScript-BOM%2F</url>
    <content type="text"><![CDATA[BOMECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 BOM（浏览器对象模型）则无疑才是真正的核心 。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关 。多年来，缺少事实上的规范导致 BOM 既有意思又有问题 ，因为 浏览器提供商会按照各自的想法随意去扩展它 。于是，浏览器之间共有的对象就成为了事实上的标准。这些对象在浏览器中得以存在，很大程度上是由于它们提供了与浏览器的互操作性。W3C 为了把浏览器中 JavaScript 最基本的部分标准化 ，已经将 BOM 的主要方面纳入了 HTML5 的规范中 。 window 对象BOM 的核心对象是 window ，它表示浏览器的一个实例 。在浏览器中， window 对象有双重角色，它既是 通过 JavaScript 访问浏览器窗口的一个接口 ，又是 ECMAScript 规定的 Global 对象 。这意味着 在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象 ，因此有权访问 parseInt() 等方法。 全局作用域由于 window 对象同时扮演着 ECMAScript中 Global 对象的角色，因此 所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法 。来看下面的例子。 12345678var age = 29;function sayAge()&#123;alert(this.age);&#125;alert(window.age); //29sayAge(); //29window.sayAge(); //29 我们在 全局作用域 中定义了一个 变量 age 和一个 函数 sayAge() ，它们被自动归在了 window 对象名下。于是，可以通过 window.age 访问变量 age ，可以通过 window.sayAge() 访问函数 sayAge() 。 由于 sayAge() 存在于全局作用域中 ，因此 this.age 被映射到 window.age ，最终显示的仍然是正确的结果。 抛开全局变量会成为 window 对象的属性不谈，定义全局变量与在 window 对象上直接定义属性还是有一点差别：全局变量不能通过 delete 操作符删除 ，而 直接在 window 对象上的定义的属性可以 。例如： 1234567891011var age = 29;window.color = "red";//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 falsedelete window.age;//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 truedelete window.color; //returns truealert(window.age); //29alert(window.color); //undefined 刚才使用 var 语句 添加的 window 属性 有一个名为 [[Configurable]] 的特性 ，这个特性的 值被设置为 false ，因此 这样定义的属性不可以通过 delete 操作符删除。IE8 及更早版本在遇到使用 delete 删除 window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。 另外，还要记住一件事：尝试访问未声明的变量会抛出错误 ，但是 通过查询 window 对象，可以知道某个可能未声明的变量是否存在 。例如： 123456//这里会抛出错误，因为 oldValue 未定义var newValue = oldValue;//这里不会抛出错误，因为这是一次属性查询//newValue 的值是 undefinedvar newValue = window.oldValue; 本章后面将要讨论的很多全局 JavaScript 对象（如 location 和 navigator ）实际上都是 window对象的属性。 Windows Mobile 平台的 IE 浏览器 不允许通过 window.property = value 之类的形式 ，直接 在 window 对象上创建新的属性或方法 。可是，在全局作用域中声明的所有变量和函数，照样 会变成 window 对象的成员 。 窗口关系及框架如果 页面中包含框架 ，则 每个框架都拥有自己的 window 对象 ，并且 保存在 frames 集合中 。在 frames 集合 中，可以 通过数值索引（从 0 开始，从左至右，从上到下）或者框架名称来访问相应的 window 对象 。每个 window 对象都有一个 name 属性 ，其中 包含框架的名称 。下面是一个包含框架的页面： 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Frameset Example&lt;/title&gt; &lt;/head&gt; &lt;frameset rows="160,*"&gt; &lt;frame src="frame.htm" name="topFrame"&gt; &lt;frameset cols="50%,50%"&gt; &lt;frame src="anotherframe.htm" name="leftFrame"&gt; &lt;frame src="yetanotherframe.htm" name="rightFrame"&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt; 以上代码创建了一个 框架集 ，其中一个框架居上，两个框架居下。对这个例子而言，可以通过 window.frames[0] 或者 window.frames[“topFrame”] 来引用上方的框架。不过，恐怕你 最好使用 top 而非 window 来引用这些框架（例如，通过 top.frames[0] ）。 我们知道，top 对象始终指向最高（最外）层的框架 ，也就是 浏览器窗口 。使用它可以确保在一个框架中正确地访问另一个框架 。因为对于在一个框架中编写的任何代码来说，其中的 window 对象指向的都是那个框架的特定实例 ，而非最高层的框架。下图展示了在最高层窗口中，通过代码来访问前面例子中每个框架的不同方式。 与 top 相对的另一个 window 对象是 parent 。顾名思义， parent （父）对象 始终 指向当前框架的直接上层框架 。在某些情况下， parent 有可能等于 top ；但在 没有框架 的情况下， parent 一定等于 top（此时它们都等于 window ）。再看下面的例子。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Frameset Example&lt;/title&gt; &lt;/head&gt; &lt;frameset rows="100,*"&gt; &lt;frame src="frame.htm" name="topFrame"&gt; &lt;frameset cols="50%,50%"&gt; &lt;frame src="anotherframe.htm" name="leftFrame"&gt; &lt;frame src="anotherframeset.htm" name="rightFrame"&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt; 这个框架集中的一个框架包含了另一个框架集，该框架集的代码如下所示。 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;Frameset Example&lt;/title&gt; &lt;/head&gt; &lt;frameset cols="50%,50%"&gt; &lt;frame src="red.htm" name="redFrame"&gt; &lt;frame src="blue.htm" name="blueFrame"&gt; &lt;/frameset&gt;&lt;/html&gt; 浏览器在加载完第一个框架集以后，会继续将第二个框架集加载到 rightFrame 中。如果代码位于 redFrame （或 blueFrame ）中，那么 parent 对象指向的就是 rightFrame 。可是，如果代码位于 topFrame 中，则 parent 指向的是 top ，因为 topFrame 的直接上层框架就是最外层框架 。图 8-2展示了在将前面例子加载到浏览器之后，不同 window 对象的值。 注意，除非最高层窗口是通过 window.open() 打开的（本章后面将会讨论），否则其 window 对象的 name 属性不会包含任何值 。与框架有关的最后一个对象是 self ，它始终指向 window ；实际上， self 和 window 对象可以互换使用 。引入 self 对象的目的 只是为了与 top 和 parent 对象对应起来 ，因此 它不格外包含其他值 。所有 这些对象都是 window 对象的属性 ，可以通过 window.parent 、 window.top 等形式来访问。同时，这也意味着 可以将不同层次的 window 对象连缀起来，例如 window.parent.parent.frames[0] 。 在 使用框架 的情况下，浏览器中会存在多个 Global 对象 。在 每个框架中定义的全局变量会自动成为框架中 window 对象的属性 。由于 每个 window 对象都包含原生类型的构造函数 ，因此 每个框架都有一套自己的构造函数 ，这些构造函数一一对应，但并不相等。例如，top.Object 并不等于 top.frames[0].Object 。这个问题会影响到对跨框架传递的对象使用 instanceof 操作符 。 窗口位置用来 确定和修改 window 对象位置 的属性和方法有很多。IE、Safari、Opera 和 Chrome 都提供了screenLeft 和 screenTop 属性 ，分别用于表示窗口相对于屏幕左边和上边的位置 。Firefox 则在 screenX 和 screenY 属性 中提供相同的窗口位置信息，Safari 和 Chrome 也同时支持这两个属性。Opera 虽然也支持 screenX 和 screenY 属性，但与 screenLeft 和 screenTop 属性并不对应，因此建议大家不要在 Opera 中使用它们。使用下列代码可以 跨浏览器取得窗口左边和上边的位置 。 1234var leftPos = (typeof window.screenLeft == "number") ?window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == "number") ?window.screenTop : window.screenY; 这个例子运用二元操作符首先确定 screenLeft 和 screenTop 属性是否存在，如果是（在 IE、Safari、Opera 和 Chrome 中），则取得这两个属性的值。如果不存在（在 Firefox 中），则取得 screenX 和 screenY 的值。 在使用这些值的过程中，还必须注意一些小问题。在 IE、Opera 中，screenLeft 和 screenTop 中 保存的是从屏幕左边和上边到由 window 对象表示的页面可见区域的距离 。换句话说，如果 window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即 y 轴坐标为 0，那么 screenTop 的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在 Chrome 、Firefox 和 Safari 中， screenY 或 screenTop 中保存的是 整个浏览器窗口相对于屏幕的坐标值 ，即在窗口的 y 轴坐标为 0 时返回 0。 更让人捉摸不透是，Firefox、Safari 和 Chrome 始终 返回页面中每个框架的 top.screenX 和 top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下 ，相对于 window 对象使用 screenX 和 screenY 每次也都会返回相同的值。而 IE 和 Opera 则 会给出框架相对于屏幕边界的精确坐标值 。最终结果，就是 无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值 。然而，使用 moveTo() 和 moveBy() 方法倒是 有可能将窗口精确地移动到一个新位置 。这两个方法都接收两个参数，其中 moveTo() 接收的是 新位置的 x 和 y 坐标值，而 moveBy() 接收的是 在水平和垂直方向上移动的像素数 。下面来看几个例子： 1234567891011//将窗口移动到屏幕左上角window.moveTo(0,0);//将窗向下移动 100 像素window.moveBy(0,100);//将窗口移动到(200,300)window.moveTo(200,300);//将窗口向左移动 50 像素window.moveBy(-50,0); 需要注意 的是，这两个方法可能会被浏览器禁用 ；而且，在 Opera 和 IE 7（及更高版本）中 默认就是禁用的 。另外，这两个方法都不适用于框架 ，只能对最外层的 window 对象使用 。 窗口大小跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera 和 Chrome 均为此 提供了 4 个属性： innerWidth 、 innerHeight 、 outerWidth 和 outerHeight 。在 IE9+、Safari 和 Firefox 中， outerWidth 和 outerHeight 返回 浏览器窗口本身的尺寸 （无论是从最外层的 window 对象还是从某个框架访问）。在 Opera 中，这两个属性的值 表示页面视图容器 （这里所谓的“页面视图容器 ”指的是 Opera 中单个标签页对应的浏览器窗口 。）的大小。而 innerWidth 和 innerHeight 则表示 该容器中页面视图区的大小（减去边框宽度）。在Chrome 中，outerWidth 、 outerHeight 与 innerWidth 、innerHeight 返回 相同的值 ，即 视口（viewport）大小 而非浏览器窗口大小。 IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性 ；不过，它通过 DOM 提供了页面可见区域的相关信息 。 在 IE、Firefox、Safari、Opera 和 Chrome 中， document.documentElement.clientWidth 和document.documentElement.clientHeight 中 保存了页面视口的信息 。在 IE6 中，这些属性 必须在标准模式下才有效 ；如果是 混杂模式 ，就必须通过document.body.clientWidth 和 document.body.clientHeight 取得相同信息 。而对于 混杂模式 下的 Chrome ，则无论通过 document.documentElement 还是 document.body 中的 clientWidth 和 clientHeight 属性，都可以取得视口的大小 。 虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小 ，如下所示。 123456789101112var pageWidth = window.innerWidth,pageHeight = window.innerHeight;if (typeof pageWidth != "number")&#123; if (document.compatMode == "CSS1Compat")&#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 在以上代码中，我们首先将 window.innerWidth 和 window.innerHeight 的值分别赋给了 pageWidth 和 pageHeight 。然后检查 pageWidth 中保存的是不是一个数值；如果不是，则通过检查 document.compatMode （这个属性将在第 10 章全面讨论）来确定页面是否处于标准模式。如果是，则分别使用 document.documentElement.clientWidth 和document.documentElement.clientHeight 的值。否则，就使用 document.body.clientWidth 和 document.body.clientHeight 的值。 对于 移动设备， window.innerWidth 和 window.innerHeight 保存着可见视口 ，也就是 屏幕上可见页面区域的大小 。移动 IE 浏览器不支持这些属性，但通过 document.documentElement.clientWidth 和document.documentElement.clientHeihgt 提供了相同的信息。随着页面的缩放，这些值也会相应变化。 在 其他移动浏览器 中，document.documentElement 度量的是 布局视口 ，即 渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动 IE 浏览器把布局视口的信息保存在 document.body.clientWidth 和 document.body.clientHeight 中。这些值不会随着页面缩放变化。 由于与桌面浏览器间存在这些差异，最好是 先检测一下用户是否在使用移动设备 ，然后 再决定使用哪个属性 。 有关移动设备视口的话题比较复杂，有很多非常规的情形，也有各种各样的建议。移动开发咨询师 Peter-Paul Koch 记述了他对这个问题的研究：http://t.cn/zOZs0Tz 。如果你在做 移动 Web 开发 ，推荐你读一读这篇文章。 另外，使用 resizeTo() 和 resizeBy() 方法 可以调整浏览器窗口的大小 。这两个方法都接收两个参数，其中 resizeTo() 接收 浏览器窗口的新宽度和新高度 ，而 resizeBy() 接收 新窗口与原窗口的宽度和高度之差 。来看下面的例子。 12345678//调整到 100×100window.resizeTo(100, 100);//调整到 200×150window.resizeBy(100, 50);//调整到 300×300window.resizeTo(300, 300); 需要注意的是，这两个方法与移动窗口位置的方法类似，也有 可能被浏览器禁用 ；而且，在 Opera 和 IE7（及更高版本）中 默认就是禁用的 。另外，这两个方法同样 不适用于框架 ，而 只能对最外层的 window 对象使用 。 导航和打开窗口使用 window.open() 方法既可以 导航到一个特定的 URL ，也可以 打开一个新的浏览器窗口 。这个方法可以 接收 4 个参数 ：要加载的 URL 、窗口目标 、一个 特性字符串 以及一个表示 新页面是否取代浏览器历史记录中当前加载页面的布尔值 。通常只须传递第一个参数 ，最后一个参数只在不打开新窗口的情况下使用 。如果为 window.open() 传递了 第二个参数 ，而且该参数是 已有窗口 或 框架 的名称，那么就会 在具有该名称的窗口或框架中加载第一个参数指定的 URL 。看下面的例子。 12//等同于&lt; a href=&quot;http://www.wrox.com&quot; target=&quot;topFrame&quot;&gt;&lt;/a&gt;window.open(&quot;http://www.wrox.com/&quot;, &quot;topFrame&quot;); 调用这行代码，就如同用户单击了 href 属性为 http://www.wrox.com/， target 属性为 “topFrame” 的链接。如果 有一个名叫 “topFrame” 的窗口或者框架 ，就会 在该窗口或框架加载这个 URL ；否则，就会 创建一个新窗口 并 将其命名为 “topFrame” 。此外，第二个参数 也可以是下列 任何一个特殊的窗口名称 ： _self 、 _parent 、 _top 或 _blank 。 弹出窗口如果给 window.open() 传递的 第二个参数并不是一个已经存在的窗口或框架 ，那么该方法就会 根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页 。如果 没有传入第三个参数 ，那么就会 打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在 不打开新窗口 的情况下，会忽略第三个参数 。第三个参数 是 一个逗号分隔的设置字符串 ，表示 在新窗口中都显示哪些特性 。下表列出了可以出现在这个字符串中的设置选项。 表中所列的部分或全部设置选项，都可以 通过逗号分隔的名值对列表来指定 。其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格），如下面的例子所示。 12window.open("http://www.wrox.com/","wroxWindow", "height=400,width=400,top=10,left=10,resizable=yes"); 这行代码会 打开一个新的可以调整大小的窗口 ，窗口 初始大小为 400×400 像素 ，并且 距屏幕上沿和左边各 10 像素 。 window.open() 方法会 返回一个指向新窗口的引用 。引用的对象与其他 window 对象大致相似 ，但 我们可以对其进行更多控制 。例如，有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大小或移动位置，但却 允许我们针对通过 window.open() 创建的窗口调整大小或移动位置 。通过这个返回的对象，可以像操作其他窗口一样操作新打开的窗口 ，如下所示。 12345678var wroxWin = window.open("http://www.wrox.com/","wroxWindow", "height=400,width=400,top=10,left=10,resizable=yes"); //调整大小wroxWin.resizeTo(500,500);//移动位置wroxWin.moveTo(100,100); 调用 close() 方法还可以 关闭新打开的窗口 。 1wroxWin.close(); 但是，这个方法仅适用于通过 window.open() 打开的弹出窗口 。对于 浏览器的主窗口 ，如果 没有得到用户的允许是不能关闭它的 。不过，弹出窗口 倒是 可以调用 top.close() 在不经用户允许的情况下关闭自己 。弹出窗口关闭之后 ，窗口的引用仍然还在 ，但除了像下面这样检测其 closed 属性之外，已经没有其他用处了。 12wroxWin.close();alert(wroxWin.closed); //true 新创建的 window 对象 有一个 opener 属性 ，其中 保存着打开它的原始窗口对象 。这个属性 只在弹出窗口中的最外层 window 对象（ top ）中有定义 ，而且 指向调用 window.open() 的窗口或框架 。例如： 1234var wroxWin = window.open("http://www.wrox.com/","wroxWindow", "height=400,width=400,top=10,left=10,resizable=yes"); alert(wroxWin.opener == window); //true 虽然 弹出窗口 中 有一个指针指向打开它的原始窗口 ，但 原始窗口中并没有这样的指针指向弹出窗口 。窗口并不跟踪记录它们打开的弹出窗口 ，因此我们只能在必要的时候自己来手动实现跟踪。有些浏览器（如 IE8 和 Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个 window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在 Chrome 中，将 新创建的标签页的 opener 属性设置为 null ，即 表示在单独的进程中运行新标签页 ，如下所示。 1234var wroxWin = window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;, &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); wroxWin.opener = null; 将 opener 属性设置为 null 就是 告诉浏览器新创建的标签页不需要与打开它的标签页通信 ，因此 可以在独立的进程中运行 。标签页之间的 联系一旦切断 ，将 没有办法恢复 。 安全限制曾经有一段时间，广告商在网上使用弹出窗口达到了肆无忌惮的程度。他们经常把弹出窗口打扮成系统对话框的模样，引诱用户去点击其中的广告。由于看起来像是系统对话框，一般用户很难分辨是真是假。为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。 Windows XP SP2 中的 IE6 对弹出窗口施加了多方面的安全限制，包括不允许在屏幕之外创建弹出窗口、不允许将弹出窗口移动到屏幕以外、不允许关闭状态栏等。IE7 则增加了更多的安全限制，如不允许关闭地址栏、默认情况下不允许移动弹出窗口或调整其大小。Firefox 1 从一开始就不支持修改状态栏，因此无论给 window.open() 传入什么样的特性字符串，弹出窗口中都会无一例外地显示状态栏。后来的 Firefox 3 又强制始终在弹出窗口中显示地址栏。Opera 只会在主浏览器窗口中打开弹出窗口，但不允许它们出现在可能与系统对话框混淆的地方。 此外，有的浏览器只根据用户操作来创建弹出窗口。这样一来，在页面尚未加载完成时调用window.open() 的语句根本不会执行，而且还可能会将错误消息显示给用户。换句话说，只能通过单击或者击键来打开弹出窗口。对于那些不是用户有意打开的弹出窗口，Chrome 采取了不同的处理方式。它不会像其他浏览器那样简单地屏蔽这些弹出窗口，而是只显示它们的标题栏，并把它们放在浏览器窗口的右下角。 在打开计算机硬盘中的网页时，IE 会解除对弹出窗口的某些限制。但是在服务器上执行这些代码会受到对弹出窗口的限制。 弹出窗口屏蔽程序大多数浏览器都 内置有弹出窗口屏蔽程序 ，而没有内置此类程序的浏览器，也可以安装 Yahoo! Toolbar 等带有内置屏蔽程序的实用工具。结果就是用户可以将绝大多数不想看到弹出窗口屏蔽掉。于是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是 浏览器内置的屏蔽程序阻止的弹出窗口 ，那么 window.open() 很可能会返回 null 。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了 ，如下面的例子所示。 1234var wroxWin = window.open("http://www.wrox.com", "_blank");if (wroxWin == null)&#123; alert("The popup was blocked!");&#125; 如果是 浏览器扩展或其他程序阻止的弹出窗口 ，那么 window.open() 通常会抛出一个错误 。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在 检测返回值 的同时，将 window.open() 的调用封装在一个 try-catch 块中 ，如下所示。 1234567891011121314var blocked = false;try &#123; var wroxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if (wroxWin == null)&#123; blocked = true; &#125;&#125; catch (ex)&#123; blocked = true;&#125;if (blocked)&#123; alert(&quot;The popup was blocked!&quot;);&#125; 在 任何情况 下，以上代码 都可以检测出调用 window.open() 打开的弹出窗口是不是被屏蔽了 。但要注意的是，检测弹出窗口是否被屏蔽只是一方面，它 并不会阻止浏览器显示与被屏蔽的弹出窗口有关的消息。 间歇调用和超时调用JavaScript 是单线程语言 ，但它 允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行 。前者是 在指定的时间过后执行代码 ，而后者则是 每隔指定的时间就执行一次代码 。超时调用 需要使用 window 对象的 setTimeout() 方法 ，它接受两个参数：要执行的代码 和 以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是 一个包含 JavaScript 代码的字符串（就和在 eval() 函数中使用的字符串一样），也可以是 一个函数 。例如，下面对 setTimeout() 的两次调用都会在一秒钟后显示一个警告框。 1234567//不建议传递字符串！setTimeout("alert('Hello world!') ", 1000);//推荐的调用方式setTimeout(function() &#123; alert("Hello world!");&#125;, 1000); 虽然这两种调用方式都没有问题，但由于 传递字符串可能导致性能损失 ，因此 不建议以字符串作为第一个参数 。第二个参数 是一个 表示等待多长时间的毫秒数 ，但 经过该时间后指定的代码不一定会执行 。JavaScript 是一个单线程序的解释器 ，因此 一定时间内只能执行一段代码 。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。 setTimeout() 的 第二个参数告诉JavaScript 再过多长时间把当前任务添加到队列中 。如果 队列是空的 ，那么添加的代码会 立即执行 ；如果队列 不是空的 ，那么它就要 等前面的代码执行完了以后再执行 。调用 setTimeout() 之后，该方法会 返回一个数值 ID ，表示 超时调用 。这个超时调用 ID 是 计划执行代码的唯一标识符 ，可以通过它来取消超时调用 。要 取消尚未执行的超时调用计划 ，可以调用 clearTimeout() 方法并将相应的 超时调用 ID 作为参数 传递给它，如下所示。 1234567//设置超时调用var timeoutId = setTimeout(function() &#123; alert("Hello world!");&#125;, 1000);//注意：把它取消clearTimeout(timeoutId); 只要是在指定的时间尚未过去之前调用 clearTimeout() ，就可以完全取消超时调用。前面的代码在设置超时调用之后马上又调用了 clearTimeout() ，结果就跟什么也没有发生一样。 超时调用的代码都是在全局作用域中执行的，因此函数中 this 的值在 非严格模式 下 指向 window 对象 ，在 严格模式 下是 undefined 。 间歇调用 与 超时调用 类似，只不过它 会按照指定的时间间隔重复执行代码 ，直至间歇调用被取消或者页面被卸载 。设置间歇调用的方法是 setInterval() ，它接受的参数与 setTimeout() 相同：要执行的代码（字符串或函数）和 每次执行之前需要等待的毫秒数 。下面来看一个例子。 1234567//不建议传递字符串！setInterval ("alert('Hello world!') ", 10000);//推荐的调用方式setInterval (function() &#123; alert("Hello world!");&#125;, 10000); 调用 setInterval() 方法同样也会 返回一个间歇调用 ID ，该 ID 可用于在将来某个时刻取消间歇调用 。要 取消尚未执行的间歇调用 ，可以使用 clearInterval() 方法并传入相应的 间歇调用 ID 。取消间歇调用的 重要性要远远高于取消超时调用 ，因为在 不加干涉 的情况下，间歇调用将会一直执行到页面卸载 。以下是一个常见的使用间歇调用的例子。 123456789101112131415var num = 0;var max = 10;var intervalId = null;function incrementNumber() &#123; num++; //如果执行次数达到了 max 设定的值，则取消后续尚未执行的调用 if (num == max) &#123; clearInterval(intervalId); alert("Done"); &#125;&#125;intervalId = setInterval(incrementNumber, 500); 在这个例子中，变量 num 每半秒钟递增一次，当递增到最大值时就会取消先前设定的间歇调用 。这个模式也可以使用超时调用来实现，如下所示。 123456789101112131415var num = 0;var max = 10;function incrementNumber() &#123; num++; // 如果执行次数未达到 max 设定的值，则设置另一次超时调用 if (num &lt; max) &#123; setTimeout(incrementNumber, 500); &#125; else &#123; alert("Done"); &#125;&#125;setTimeout(incrementNumber, 500); 可见，在使用 超时调用 时，没有必要跟踪超时调用 ID ，因为每次执行代码之后，如果不再设置另一次超时调用 ，调用就会自行停止 。一般认为，使用 超时调用来模拟间歇调用的是一种最佳模式 。在 开发环境 下，很少使用真正的间歇调用 ，原因是 后一个间歇调用可能会在前一个间歇调用结束之前启动 。而像前面示例中那样使用 超时调用 ，则 完全可以避免这一点 。所以，最好不要使用间歇调用 。 系统对话框浏览器通过 alert() 、 confirm() 和 prompt() 方法 可以调用系统对话框向用户显示消息 。系统对话框与在浏览器中显示的网页没有关系 ，也不包含 HTML。它们的外观由操作系统及（或）浏览器设置决定 ，而不是由 CSS 决定。此外，通过这几个方法 打开的对话框 都是 同步 和 模态 的。也就是说，显示这些对话框的时候代码会停止执行 ，而 关掉这些对话框后代码又会恢复执行 。 本书各章经常会用到 alert() 方法，这个方法 接受一个字符串 并将其 显示给用户。具体来说，调用 alert() 方法的结果就是 向用户显示一个系统对话框 ，其中 包含指定的文本 和 一个 OK（“确定”）按钮 。例如， alert(“Hello world!”) 会在 Windows XP 系统的 IE 中生成如图 8-3 所示的对话框。 通常使用 alert() 生成的 “警告”对话框 向用户显示一些他们无法控制的消息，例如错误消息。而用户只能在看完消息后关闭对话框。 第二种对话框是调用 confirm() 方法生成的。从向用户显示消息的方面来看，这种“确认”对话框很像是一个 “警告”对话框 。但二者的主要区别在于“确认”对话框 除了显示 OK 按钮外 ，还会 显示一个 Cancel（“取消”）按钮 ，两个按钮可以让用户决定是否执行给定的操作 。例如， confirm(“Are you sure?”) 会显示如图 8-4 所示的确认对话框。 为了确定用户是单击了 OK 还是 Cancel，可以检查 confirm() 方法返回的布尔值 ： true 表示 单击了 OK ， false 表示 单击了 Cancel 或 单击了右上角的 X 按钮** 。确认对话框的典型用法如下。 12345if (confirm("Are you sure?")) &#123; alert("I'm so glad you're sure! ");&#125; else &#123; alert("I'm sorry to hear you're not sure. ");&#125; 在这个例子中，第一行代码（if 条件语句）会向用户显示一个确认对话框。如果用户单击了 OK，则通过一个警告框向用户显示消息 I’m so glad you’ re sure! 。如果用户单击的是 Cancel 按钮，则通过警告框显示 I’m sorry to hear you’re not sure.。这种模式经常在用户想要执行删除操作的时候使用 ，例如删除电子邮件。 最后一种对话框是通过调用 prompt() 方法生成的，这是一个“提示”框 ，用于提示用户输入一些文本 。提示框中 除了显示 OK 和 Cancel 按钮之外 ，还会 显示一个文本输入域 ，以供用户在其中输入内容 。 prompt() 方法接受两个参数：要显示给用户的文本提示 和 文本输入域的默认值（可以是一个空字符串）。调用 prompt(“What’s your name?”,”Michael”) 会得到如图 8-5 所示的对话框。 如果 用户单击了 OK 按钮 ，则 prompt() 返回文本输入域的值 ；如果 用户单击了 Cancel 或 没有单击 OK 而是 通过其他方式关闭了对话框 ，则 该方法返回 null 。下面是一个例子。 1234var result = prompt("What is your name? ", "");if (result !== null) &#123; alert("Welcome, " + result);&#125; 综上所述，这些系统对话框很适合向用户显示消息并请用户作出决定。由于不涉及 HTML、CSS 或JavaScript，因此 它们是增强 Web 应用程序的一种便捷方式 。 除了上述三种对话框之外，Google Chrome浏览器 还 引入了一种新特性 。如果 当前脚本在执行过程中会打开两个或多个对话框 ，那么 从第二个对话框开始 ，每个对话框中都会显示一个复选框 ，以便用户阻止后续的对话框显示 ，除非用户刷新页面（见图 8-6）。 如果 用户勾选了其中的复选框 ，并且 关闭了对话框 ，那么 除非用户刷新页面 ，所有 后续的系统对话框（包括警告框、确认框和提示框）都会被屏蔽 。Chrome 没有就对话框是否显示向开发人员提供任何信息。由于 浏览器会在空闲时重置对话框计数器 ，因此如果两次独立的用户操作分别打开两个警告框 ，那么 这两个警告框中都不会显示复选框 。而如果是 同一次用户操作会生成两个警告框 ，那么 第二个警告框中就会显示复选框。这个新特性出现以后，IE9 和 Firefox 4 也实现了它。还有两个可以 通过 JavaScript 打开的对话框 ，即“查找”和“打印”。这两个对话框都是异步显示的 ，能够将控制权立即交还给脚本 。这两个对话框 与用户通过浏览器菜单的“查找”和“打印”命令打开的对话框相同 。而在 JavaScript 中则可以像下面这样 通过 window 对象 的 find() 和 print() 方法打开它们。 12345//显示“打印”对话框window.print();//显示“查找”对话框window.find(); 这两个方法同样 不会就用户在对话框中的操作给出任何信息 ，因此它们的用处有限。另外，既然 这两个对话框是异步显示的 ，那么 Chrome 的 对话框计数器就不会将它们计算在内 ，所以 它们也不会受用户禁用后续对话框显示的影响 。 location 对象location 是最有用的 BOM对象之一，它提供了 与当前窗口中加载的文档有关的信息 ，还提供了 一些导航功能。事实上， location 对象是很特别的一个对象，因为它既是 window 对象的属性 ，也是 document 对象的属性 ；换句话说， window.location 和 document.location 引用的是同一个对象。location 对象 的用处不只表现在 它保存着当前文档的信息 ，还表现在 它将 URL 解析为独立的片段 ，让开发人员 可以通过不同的属性访问这些片段 。下表列出了 location 对象的所有属性（注：省略了每个属性前面的 location 前缀）。 查询字符串参数虽然通过上面的属性可以访问到 location 对象的大多数信息，但其中访问 URL 包含的查询字符串的属性并不方便。尽管 location.search 返回 从问号到 URL 末尾的所有内容 ，但 却没有办法逐个访问其中的每个查询字符串参数 。为此，可以像下面这样创建一个函数，用以解析查询字符串 ，然后 返回包含所有参数的一个对象 ： 12345678910111213141516171819202122232425262728293031function getQueryStringArgs()&#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : ""), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split("&amp;") : [], item = null, name = null, value = null, //在 for 循环中使用 i = 0, len = items.length; //逐个将每一项添加到 args 对象中 for (i=0; i &lt; len; i++)&#123; item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 这个函数的第一步是 先去掉查询字符串开头的问号 。当然，前提是 location.search 中必须要包含一或多个字符。然后，所有参数将被保存在 args 对象 中，该对象以字面量形式创建。接下来，根据和号（&amp;）来分割查询字符串 ，并 返回 name=value 格式的字符串数组 。下面的 for 循环会迭代这个数组 ，然后 再根据等于号分割每一项 ，从而返回 第一项为参数名，第二项为参数值的数组 。再使用 decodeURIComponent() 分别 解码 name 和 value （因为查询字符串应该是被编码过的）。最后，将 name 作为 args 对象的属性，将 value 作为相应属性的值 。下面给出了使用这个函数的示例。 123456//假设查询字符串是?q=javascript&amp;num=10var args = getQueryStringArgs();alert(args["q"]); //"javascript"alert(args["num"]); //"10" 可见，每个查询字符串参数都成了返回对象的属性 。这样就极大地方便了对每个参数的访问。 位置操作使用 location 对象 可以 通过很多方式来改变浏览器的位置 。首先，也是最常用的方式，就是使用 assign() 方法 并为其传递一个 URL ，如下所示。 1location.assign("http://www.wrox.com"); 这样，就 可以立即打开新 URL 并在浏览器的历史记录中生成一条记录 。如果是 将 location.href 或 window.location 设置为一个 URL 值 ，也会以该值调用 assign() 方法 。例如，下列两行代码与显式调用 assign() 方法的效果完全一样。 12window.location = "http://www.wrox.com"; location.href = "http://www.wrox.com"; 在这些改变浏览器位置的方法中，最常用 的是设置 location.href 属性。 另外，修改 location 对象的其他属性也可以改变当前加载的页面。下面的例子展示了通过将 hash 、search 、 hostname 、 pathname 和 port 属性设置为新值来改变 URL。 12345678910111213141516//假设初始 URL 为 http://www.wrox.com/WileyCDA///将 URL 修改为"http://www.wrox.com/WileyCDA/#section1"location.hash = "#section1";//将 URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"location.search = "?q=javascript";//将 URL 修改为"http://www.yahoo.com/WileyCDA/"location.hostname = "www.yahoo.com";//将 URL 修改为"http://www.yahoo.com/mydir/"location.pathname = "mydir";//将 URL 修改为"http://www.yahoo.com:8080/WileyCDA/"location.port = 8080; 每次修改 location 的属性（ hash 除外），页面都会以新 URL 重新加载 。 在 IE8、Firefox 1、Safari 2+、Opera 9+和 Chrome 中，修改 hash 的值会在浏览器的历史记录中生成一条新记录 。在 IE 的早期版本中， hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含 hash 的 URL 时才会被更新。 当通过 上述任何一种方式修改 URL 之后 ，浏览器的历史记录中就会生成一条新记录 ，因此 用户通过单击“后退”按钮都会导航到前一个页面 。要 禁用这种行为 ，可以使用 replace() 方法。这个方法只接受一个参数，即 要导航到的 URL ；结果虽然 会导致浏览器位置改变 ，但 不会在历史记录中生成新记录 。在调用 replace() 方法之后，用户不能回到前一个页面，来看下面的例子： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;You won't be able to get back here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Enjoy this page for a second, because you won't be coming back here.&lt;/p&gt; &lt;script type="text/javascript"&gt; setTimeout(function () &#123; location.replace("http://www.wrox.com/"); &#125;, 1000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如果将这个页面加载到浏览器中，浏览器就会在 1 秒钟后重新定向到 www.wrox.com。然后，“后退”按钮将处于禁用状态，如果不重新输入完整的 URL，则无法返回示例页面。 与位置有关的最后一个方法是 reload() ，作用是重新加载当前显示的页面 。如果调用 reload() 时 不传递任何参数 ，页面就会以最有效的方式重新加载 。也就是说，如果 页面自上次请求以来并没有改变过 ，页面就会 从浏览器缓存中重新加载 。如果 要强制从服务器重新加载 ，则需要像下面这样 为该方法传递参数 true 。 12location.reload(); //重新加载（有可能从缓存中加载）location.reload(true); //重新加载（从服务器重新加载） 位于 reload() 调用之后的代码可能会也可能不会执行 ，这要 取决于网络延迟或系统资源等因素 。为此，最好将 reload() 放在代码的最后一行 。 navigator 对象最早由 Netscape Navigator 2.0 引入的 navigator 对象，现在已经成为识别客户端浏览器的事实标准。虽然其他浏览器也通过其他方式提供了相同或相似的信息（例如，IE 中的window.clientInformation 和 Opera 中的 window.opera ），但 navigator 对象却 是所有支持 JavaScript 的浏览器所共有的 。与其他 BOM 对象的情况一样，每个浏览器中的 navigator 对象也都有一套自己的属性。下表列出了存在于所有浏览器中的属性和方法，以及支持它们的浏览器版本。 表中的这些 navigator 对象的属性 通常 用于检测显示网页的浏览器类型（第 9 章会详细讨论）。 检测插件检测浏览器中是否安装了特定的插件 是一种最常见的检测例程。对于 非 IE 浏览器 ，可以使用 plugins 数组 来达到这个目的。该数组中的每一项都包含下列属性。 name ：插件的名字。 description ：插件的描述。 filename ：插件的文件名。 length ：插件所处理的 MIME 类型数量。 一般来说， name 属性 中会 包含检测插件必需的所有信息 ，但有时候也不完全如此。在检测插件时，需要像下面这样 循环迭代每个插件并将插件的 name 与给定的名字进行比较 。 12345678910111213141516//检测插件（在 IE 中无效）function hasPlugin(name)&#123; name = name.toLowerCase(); for (var i=0; i &lt; navigator.plugins.length; i++)&#123; if (navigator. plugins [i].name.toLowerCase().indexOf(name) &gt; -1)&#123; return true; &#125; &#125; return false;&#125;//检测 Flashalert(hasPlugin("Flash"));//检测 QuickTimealert(hasPlugin("QuickTime")); 这个 hasPlugin() 函数 接受一个参数：要检测的插件名 。第一步是 将传入的名称转换为小写形式 ，以便于比较 。然后，迭代 plugins 数组 ，通过 indexOf() 检测每个 name 属性 ，以确定传入的名称是否出现在字符串的某个地方 。比较的字符串都 使用小写形式可以避免因大小写不一致导致的错误 。而传入的参数应该尽可能具体，以避免混淆。应该说，像 Flash 和 QuickTime 这样的字符串就比较具体了，不容易导致混淆。在 Firefox、Safari、Opera 和 Chrome 中可以使用这种方法来检测插件。 每个插件对象 身也是一个 MimeType 对象的数组，这些对象 可以通过方括号语法来访问 。每个 MimeType 对象有 4 个属性：包含 MIME 类型描述 的 description 、回指插件对象 的 enabledPlugin 、表示 与 MIME 类型对应的文件扩展名 的 字符串suffixes （以逗号分隔）和表示 完整 MIME 类型字符串 的 type 。 检测 IE 中的插件比较麻烦，因为 IE 不支持 Netscape 式的插件 。在 IE 中检测插件的唯一方式就是 使用专有的 ActiveXObject 类型 ，并尝试创建一个特定插件的实例 。 IE 是以 COM对象的方式实现插件的 ，而 COM对象使用唯一标识符来标识 。因此，要想检查特定的插件，就 必须知道其 COM 标识符 。例如，Flash 的标识符是ShockwaveFlash.ShockwaveFlash 。知道唯一标识符之后，就可以编写类似下面的函数来检测 IE 中是否安装相应插件了。 1234567891011121314//检测 IE 中的插件function hasIEPlugin(name)&#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex)&#123; return false; &#125;&#125;//检测 Flashalert(hasIEPlugin("ShockwaveFlash.ShockwaveFlash"));//检测 QuickTimealert(hasIEPlugin("QuickTime.QuickTime")); 在这个例子中，函数 hasIEPlugin() 只接收一个 COM 标识符作为参数 。在函数内部，首先会尝试 创建一个 COM对象的实例 。之所以 要在 try-catch 语句中进行实例化 ，是因为 创建未知 COM 对象会导致抛出错误 。这样，如果 实例化成功 ，则 函数返回 true ；否则，如果 抛出了错误 ，则 执行 catch 块 ，结果就会返回 false 。例子最后检测 IE 中是否安装了 Flash 和 QuickTime 插件。 鉴于检测这两种插件的方法差别太大，因此 典型的做法 是 针对每个插件分别创建检测函数 ，而不是使用前面介绍的通用检测方法。来看下面的例子。 123456789101112131415161718192021222324//检测所有浏览器中的 Flashfunction hasFlash()&#123; var result = hasPlugin("Flash"); if (!result)&#123; result = hasIEPlugin("ShockwaveFlash.ShockwaveFlash"); &#125; return result;&#125;//检测所有浏览器中的 QuickTimefunction hasQuickTime()&#123; var result = hasPlugin("QuickTime"); if (!result)&#123; result = hasIEPlugin("QuickTime.QuickTime"); &#125; return result;&#125;//检测 Flashalert(hasFlash());//检测 QuickTimealert(hasQuickTime()); 上面代码中定义了两个函数： hasFlash() 和 hasQuickTime() 。每个函数都是 先尝试使用不针对 IE 的插件检测方法 。如果 返回了 false （在 IE 中会这样），那么 再使用针对 IE 的插件检测方法 。如果 IE 的插件检测方法再返回 false ，则 整个方法也将返回 false 。只要任何一次检测返回 true ，整个方法都会返回 true 。 plugins 集合 有一个名叫 refresh() 的方法 ，用于刷新 plugins 以反映最新安装的插件 。这个方法接收一个参数：表示 是否应该重新加载页面的一个布尔值 。如果将 这个值设置为 true ，则会 重新加载包含插件的所有页面 ；否则，只更新 plugins 集合 ，不重新加载页面 。 注册处理程序Firefox 2 为 navigator 对象 新增了 registerContentHandler() 和 registerProtocolHandler() 方法（这两个方法是 在 HTML5 中定义的 ，相关内容将在第 22 章讨论）。这两个方法 可以让一个站点指明它可以处理特定类型的信息 。随着 RSS 阅读器和在线电子邮件程序的兴起，注册处理程序 就 为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式 。 其中， registerContentHandler()方法 接收三个参数：要处理的 MIME 类型 、可以处理该 MIME 类型的页面的 URL 以及 应用程序的名称 。举个例子，要将一个站点注册为处理 RSS 源的处理程序 ，可以使用如下代码。 12navigator.registerContentHandler("application/rss+xml", "http://www.somereader.com?feed=%s", "Some Reader"); 第一个参数是 RSS 源的 MIME 类型 。第二个参数是应该 接收 RSS源 URL的 URL ，其中的 %s 表示 RSS 源 URL ，由浏览器自动插入。当下一次请求 RSS 源时，浏览器就会打开指定的 URL，而相应的 Web 应用程序 将以适当方式来处理该请求。 Firefox 4 及之前版本只允许在 registerContentHandler() 方法中使用三个 MIME 类型： application/rss+xml 、 application/atom+xml 和 application/vnd.mozilla.maybe. feed 。这三个 MIME类型的作用都一样，即 为 RSS 或 ATOM 新闻源（feed）注册处理程序 。 类似的调用方式也适用于 registerProtocolHandler() 方法 ，它也接收三个参数：要处理的协议（例如， mailto 或 ftp ）、处理该协议的页面的 URL 和 应用程序的名称 。例如，要想将一个应用程序注册为默认的邮件客户端 ，可以使用如下代码。 12navigator.registerProtocolHandler("mailto", "http://www.somemailclient.com?cmd=%s", "Some Mail Client"); 这个例子注册了一个 mailto 协议的处理程序 ，该程序指向 一个基于 Web 的电子邮件客户端 。同样，第二个参数仍然是 处理相应请求的 URL，而 %s 则表示 原始的请求 。 Firefox 2 虽然实现了 registerProtocolHandler() ，但该方法还不能用。Firefox 3 完整实现这个方法。 screen 对象JavaScript 中有几个对象在编程中用处不大，而 screen 对象就是其中之一。 screen 对象 基本上只 用来表明客户端的能力 ，其中 包括浏览器窗口外部的显示器的信息 ，如像素宽度和高度等。每个浏览器中的 screen 对象都包含着各不相同的属性 ，下表列出了所有属性及支持相应属性的浏览器。 这些信息经常集中出现在 测定客户端能力的站点跟踪工具中 ，但通常不会用于影响功能。不过，有时候也可能会用到其中的信息来 调整浏览器窗口大小 ，使其占据屏幕的可用空间 ，例如： 1window.resizeTo(screen.availWidth, screen.availHeight); 前面曾经提到过，许多浏览器都会禁用调整浏览器窗口大小的能力 ，因此上面这行代码不一定在所有环境下都有效。 涉及移动设备的屏幕大小 时，情况有点不一样 。运行 iOS 的设备始终会像是把设备竖着拿在手里一样，因此返回的值是 768×1024。而 Android设备则会相应调用 screen.width 和 screen.height 的值。 history 对象history 对象 保存着 用户上网的历史记录 ，从窗口被打开的那一刻算起。因为 history 是 window 对象的属性，因此 每个浏览器窗口 、每个标签页 乃至 每个框架 ，都有自己的 history 对象与特定的 window 对象关联 。出于安全方面的考虑，开发人员无法得知用户浏览过的 URL。不过，借由用户访问过的页面列表，同样可以在不知道实际 URL 的情况下实现后退和前进。使用 go() 方法 可以 在用户的历史记录中任意跳转 ，可以向后也 可以向前 。这个方法接受一个参数，表示 向后或向前跳转的页面数 的 一个整数值 。负数 表示 向后跳转（类似于单击浏览器的“后退”按钮），正数 表示 向前跳转（类似于单击浏览器的“前进”按钮）。来看下面的例子。 12345678//后退一页history.go(-1);//前进一页history.go(1);//前进两页history.go(2); 也可以给 go() 方法 传递 一个字符串参数 ，此时 浏览器会跳转到历史记录中包含该字符串的第一个位置 —— 可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串 ，那么 这个方法什么也不做 ，例如： 12345//跳转到最近的 wrox.com 页面history.go("wrox.com");//跳转到最近的 nczonline.net 页面history.go("nczonline.net"); 另外，还可以使用两个简写方法 back() 和 forward() 来代替 go() 。顾名思义，这两个方法 可以模仿浏览器的“后退”和“前进”按钮 。 12345//后退一页history.back();//前进一页history.forward(); 除了上述几个方法外， history 对象 还有一个 length 属性 ，保存着 历史记录的数量 。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的 第一个页面 而言，history.length 等于 0 。通过像下面这样测试该属性的值，可以确定用户是否一开始就打开了你的页面 。 123if (history.length == 0)&#123; //这应该是用户打开窗口后的第一个页面&#125; 虽然 history 并不常用，但 在创建自定义的“后退”和“前进”按钮 ，以及 检测当前页面是不是用户历史记录中的第一个页面时 ，还是必须使用它。 当页面的 URL 改变时，就会生成一条历史记录 。在 IE8 及更高版本、Opera、Firefox、Safari 3 及更高版本以及 Chrome 中，这里所说的改变 包括 URL 中 hash 的变化（因此，设置 location.hash 会在这些浏览器中生成一条新的历史记录）。 小结浏览器对象模型 （BOM）以 window 对象为依托 ，表示 浏览器窗口 以及 页面可见区域 。同时， window 对象 还是 ECMAScript 中的 Global 对象 ，因而 ** 所有全局变量和函数都是它的属性 ，且 所有原生的构造函数及其他函数 也都 存在于它的命名空间下 。本章讨论了下列 BOM 的组成部分。 在使用框架时，每个框架 都有自己的 window 对象 以及 所有原生构造函数及其他函数的副本 。每个框架 都 保存在 frames 集合 中，可以通过位置或通过名称来访问。 有一些窗口指针，可以用来引用其他框架，包括父框架。 top 对象 始终指向 最外围的框架 ，也就是 整个浏览器窗口 。 parent 对象 表示 包含当前框架的框架 ，而 self 对象 则 回指 window 。 使用 location 对象 可以 通过编程方式来访问浏览器的导航系统 。设置相应的属性，可以逐段或整体性地修改浏览器的 URL 。 调用 replace() 方法 可以 导航到一个新 URL ，同时 该 URL 会替换浏览器历史记录中当前显示的页面 。 navigator 对象 提供了 与浏览器有关的信息 。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如 userAgent ）存在于所有浏览器中。 BOM 中还有两个对象： screen 和 history ，但它们的功能有限。 screen 对象 中保存着与客户端显示器有关的信息 ，这些信息一般 只用于站点分析 。 history 对象 为 访问浏览器的历史记录开了一个小缝隙 ，开发人员可以据此 判断历史记录的数量 ，也可以 在历史记录中向后或向前导航到任意页面 。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-函数表达式]]></title>
    <url>%2F2018%2F08%2F17%2FJavaScript-function-expression%2F</url>
    <content type="text"><![CDATA[函数表达式函数表达式是 JavaScript 中的一个既强又容易令人困惑的特性。定义函数的方式有两种：一种是 函数声明 ，另一种就是 函数表达式 。函数声明 的语法是这样的。 123function functionName(arg0, arg1, arg2) &#123; // 函数体&#125; 首先是 function 关键字，然后是函数的名字，这就是指定函数名的方式。Firefox、Safari、Chrome 和 Opera 都给函数定义了一个非标准的 name 属性，通过这个属性可以访问到给函数指定的名字。这个属性的值永远等于跟在 function 关键字后面的标识符。 12// 只是 Firefox、Safari、Chrome 和 Opera 有效alert(functionName.name); // "fcuntionName" 关于函数声明，它的一个重复特征就是 函数提升（function declaration hoisting），意思是在 执行代码之前会读取函数声明 。这意味着可以把函数声明放在调用它的语句后面 。 1234sayHi();function sayHi() &#123; alert("Hi!");&#125; 这个例子不会抛出错误，因为代码执行之前会先读取函数声明。第二种创建函数的方式是使用 函数表达式 。函数表达式有几种不同的形式。下面是最常见的一个形式。 123var functionName = function(arg0, arg1, arg2) &#123; // 函数体&#125; 这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量 functionName 。这种情况下创的函数叫做 匿名函数（anonymous function）,因为 function 关键字后面没有标识符 。（匿名函数有时候也叫拉姆达函数。）匿名函数的 name 属性是空字符串。函数表达式与其他表达式一样 ，在使用前必须先赋值 。以下代码会导致错误。 1234sayHi(); //错误；函数还不存在var sayHi = function() &#123; alert("Hi!");&#125; 理解函数提升的关键，就是 理解函数声明与函数表达式之间的区别 。例如，执行以下代码的结果可能会让人意想不到。 12345678910// 不要这样做！if(condition)&#123; function sayHi() &#123; alert("Hi!"); &#125;&#125; else &#123; function sayHi() &#123; alert("Yo!"); &#125;&#125; 表面上看，以上代码表示 conditionn 为 true 时，使用一个 sayHi() 的定义；否则，就使用另一个定义。实际上，这 在 ECMAScript 中属于无效语法 ，JavaScript引擎会尝试修正错误，将其转换为合理的状态 。但问题是 浏览器尝试修正错误的做法并不一致 。大多数浏览器会返回第二个声明，忽略 condition ; Firefox 会在 condition 为 ture 时返回第一个声明。因此这种使用方式很危险，不应该出现在你的代码中。不过，如果是使用函数表达式，那就没有什么问题了 。 123456789101112// 可以这样做var sayHi;if (condition) &#123; sayHi = function() &#123; alert("Hi!"); &#125;&#125; else &#123; sayHi = function() &#123; alert("Yo!"); &#125;&#125; 这个例子不会有什么意外，不同函数会根据 condition 被赋值 sayHi。 能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回。下面是 createComparisonFunction() 函数： 1234567891011121314function createCompariseFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else i f (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; createComparisonFunction() 就返回了一个匿名函数。返回的函数可能会被赋值给一个变量，或者以其他方式被调用；不过，在 createComparisonFunction() 函数内部，它是匿名的 。在把函数当成值来使用的情况下，都可以使用匿名函数。不过，这并不是匿名函数唯一的用途。 递归递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num -1); &#125;&#125; 这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。 123var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); //出错！ 以上代码先把 factorial() 函数保存在变量 anotherFactorial 中，然后将 factorial 变量设置为 null, 结果 指向原始函数的引用只剩下一个 。但在接下来调用 anotherFactorial() 时，由于 必须执行 factorial() ，而 factorial 已经不再是函数，所以就会导致错误。在这种情况下，使用 arguments.callee 可以解决这个问题。 我们知道，arguments.callee 是一个指向正在执行的函数的指针 ，，因此可以用它来实现对函数的递归调用，例如： 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num -1); &#125;&#125; 加粗的代码显示，通过使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归函数时，使用 arguments.callee 总比使用函数名更保险。 但在 严格模式 下，不能通过脚本访问 arguments.callee ，访问这个属性会导致错误。不过，可以使用命名函数表达式达成相同的结果 。例如： 1234567var factorial (function f(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num -1); &#125;&#125;); 以上代码创建了一个 名为 f() 的命名函数表达式 ，然后 将它赋值给变量 factorial 。即使把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。 闭包有不少开发人员总是搞不清 匿名函数 和 闭包 这两个概念。因此经常混用。闭包 是指 有权访问另一个函数作用域中变量的函数 。创建闭包的常见方式 ，就是 在一个函数内部创建另一个函数 ，仍以前面的 createComparisonFuncton() 函数为例，请注意加粗的代码。 1234567891011121314functioon createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else i f (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 在这个例子中，突出的那两行代码是 内部函数（一个匿名函数）中的代码 ，这两行代码访问了外部函数中的变量 propertyName 。即使这个内部函数被返回了，而且是在其他地方被调用了 ，但它仍然可以访问变量 propertyName。之所以还能够访问这个变量 ，是因为 内部函数的作用域链中包含 createComparisonFunction() 的作用域 。要彻底搞清楚其中的细节，必须从理解函数被调用的时候都会发生什么入手。 前面作用域链的概念。而 有关如何创建作用域链以及作用域链有什么作用的细 节，对彻底理解闭包至关重要。当 某个函数被调用 时，会创建 一个 执行环境（execution contect）及 相应的作用域链 。然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象 （ activation object）。但 在作用域链中 ，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位 ，……直至作为作用域链终点的全局执行环境 。 在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。来看下面的例子。 1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &lt;value2) &#123; return 1 &#125; else &#123; return 0; &#125;&#125;var result = compare(5, 10); 以上代码先定义了 compare() 函数，然后又在全局作用域中调用它。当调用 compare() 时，会创建一个包含 arguments、value1 和 value2 的活动对象。全局执行环境的变量对象（包含 result 和 compare）在 compare() 执行环境的作用域链中则处于第二位。下图展示了包含上述关系的 compare() 函数执行时的作用域链。 后台的每个执行环境都有一个表示变量的对象 —— 变量对象。全局环境的变量对象始终存在，而像 compare() 函数这样的局部变量的对象，则只是函数执行的过程中存在。在创建 compare() 函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的 [[Scope]] 属性中。当调用 compare() 函数时，会为函数创建一个执行环境，然后通过复制函数的 [[Scope]] 属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被堆入执行环境作用域链的前端。对于这个例子中 compare() 函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只是引用但不实际包含变量对象。 无论什么时候在函数中访问一个变量时， 就会从作用域链中搜索具有相应的名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。 在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。此，在 createComprisonFunction() 函数内部定义的匿名函数的作用域链中，实际上将包含外部函数 createComprisonFunction() 的活动对象。下图展示了当下代码执行时，包含函数与内部匿名函数的作用域链。 12var compare = createComparisonFunction("name");var result = compare(&#123;name: "Nicholas"&#125;, &#123;name: "Greg"&#125;); 在匿名函数从 createComparisonFunction() 中返回后，它的作用域链被初始化为包含 createComparisonFunction() 函数活动对象和全局变量对象。这样，匿名函数就可以访问在 createComparisonFunction() 中定义的所有变量。更为重要的是， createComparisonFunction() 函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当 createComparisonFunction() 函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后， createComparisonFunction() 的活动对象才会被销毁，例如： 12345678// 创建函数var compareNames = createComparisonFunction("name");// 调用函数var result = compareNames(&#123; name: "Nicholas"&#125;, &#123;name, "Greg"&#125;);//解除对匿名函数的引用（以便释放内存）compareNames = null; 首先，创建的比较函数被保存在变量 compareNames 中。而通过将 compareNames 设置为等于 null 解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域（除了全局作用域）也都可以安全地销毁了。下图展示了调用 compareNames() 的过程中产生的作用域链之间的关系。 由于 闭包会携带包含他的函数的作用域 ，因此 会比其他函数占用更多的内存 。过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家还是 慎重使用闭包 。 闭包和变量 作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。下面这个例子可以清晰地说明这个问题。 1234567891011function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 0; i++) &#123; result[i] = function() &#123; return i; &#125; &#125; return result;&#125; 这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返回自己的索引值，即位置 0 的函数返回 0，位置 1 的函数返回1，以此内推。但实际上，每个函数都返回 10。因为每个函数的作用域链中都保存着 createFunctions() 函数的活动对象，所以它们引用的都是同一个变量 i。当对象，所以在每个函数内部 i 的值都是 10。但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。 12345678910111213function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125; &#125; &#125; return result;&#125; 在重写了前面的 createFunctions() 函数后，每个函数就会返回各自不同索引值了。在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的值赋值给数组。这里的匿名函数有一个参数 num, 也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量 i.由于函数参数是按值传递的，所以就会将变量 i 的当前值复制给参数 num。而在这个匿名的内部，又创建并返回了一个返回 num 的闭包。这样一来，result 数组中的每个函数都有自己 num 变量的一个副本，因此就可以返回各自不同的数组了。 关于 this 对象 在闭包中使用 this 对象也可能会导致一些问题。我们知道，this 对象是在运行时基于函数的执行环境绑定的；在全局函数中，this 等于 windo，而当函数被作为某个对象的方法调用时，this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window 。但有时候由于编写闭包的方式不同，这一点可能不会那么明显。下面来看一个例子。 12345678910111213var name = "The window";var object = &#123; name: "My Object"; getNameFunc: function() &#123; return function() &#123; return this.name; &#125; &#125;&#125;;alert(object.getNameFunc()()); // "The window" （在非严格模式下） 以上代码先创建了一个全局变量 name，又创建了一个包含 name 属性的对象。这个对象还包含一个方法 —— getNameFunc()，它返回一个匿名函数，而匿名函数又返回 this.name。由于 getNameFunc() 返回一个函数，因此调用 object.getNameFunc() 就会立即调用它返回的函数，结果就是返回一个字符串。然而，这个例子返回的字符串是“The Window”，即全局 name 变量的值。为什么匿名函数没有取得其包含作用域（或外部作用域）的 this 对象呢？ 前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。内部 函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量（这一点通过上图可以看得很清楚）。不过，把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了，如下所示。 12345678910111213141516var name = "The window";var object = &#123; name: "My Object"; getNameFunc: function() &#123; var that = this; return function() &#123; return that.name; &#125; &#125;&#125;;alert(object.getNameFunc()()); // "My Object" 代码突出的行展示了这个例子与前面例子之间的不同之处。在定义匿名函数之前，我们把 this 对象赋值给了一个名叫 that 的变量。而定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。即使在函数返回之后， that 也仍然引用着 object，所以调用 obect.getNameFunc() 就返回了 “My Object”。 this 和 arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象，必须将该对象的引用保存到另一个闭包能够访问的变量中。 在几种特殊情况下，this 的值可能会意外地改变。比如，下面的代码是修改前面例子的结果。 123456789var name = "The window";var object = &#123; name: "My Object"; getName: function() &#123; return this.name; &#125;&#125;; 这里的 getName() 方法只简单地返回 this.name 的值。以下是几种调用 object.geetName() 的方式以及各自的结果。 123object.getName()； // "My Object"(object.getName)(); //"My Object"(object.getName = object.getName)(); // "The window" 在非严格模式下 第一行代码跟平常一样调用了 object.getName()，返回的是“My Object”，因为 this.name 就是 object.name 。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只是在引用一个函数，但 this 的值是得到了维持，结果就返回了“The Window”。 当然，你不大可能会像第二行和第三行代码一样调用这个方法。不过，这个例子 有助于说明即使是语法的细微变化 ，都有可能意外改变 this 的值。 内存泄漏由于 IE9 之前的版本对 JScript 对象和 COM 对象使用不同的垃圾收集例程，因此闭包在 IE 的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个 HTML 元素，那么意味着该元素将无法被销毁。来看下面的例子。 123456function assignHandler() &#123; var element = document.getElementBYId("someElement"); element.onclick = function() &#123; alert(element.id); &#125;&#125; 以上代码创建了一个作为 element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对 assignHandler() 的活动对象的引用，因此就会导致无法减少 element 的引用数。只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，这个问题可以通过稍微改写一下代码来解决，如下所示。 12345678910function assignHandler() &#123; var element = document.getElementById("someElement"); var id = element.id; element.onclick = function() &#123; alert(id); &#125; element = null;&#125; 在上面的代码中，通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含 element。即使闭包不直接引用 element，包含函数的活动对象中也仍然会保存一个引用。。因此，有必要把 element 变量设置为 null。这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。 模仿块级作用域如前所述，JavaScript 没有块级作用域的概念。。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的，来看下面是例子。 123456function outputNumbers(count) &#123; for(var i =0; i &lt; count; i++) &#123; alert(i); &#125; alert(i); // 计数&#125; 这个函数中定义了一个 for 循环，而变量 i 的初始值被设置为 0。在 Java、C++等语言 中，变量 i 只会在 for 循环的语句块中有定义，循环一旦结束，变量 i 就会被销毁。可是在 JavaScript 中，变量 i 是定义在 outputNumbers() 的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。即使像下面这样错误地重新声明同一个变量，也不会改变它的值。 12345678function outputNumbers(count) &#123; for(var i =0; i &lt; count; i++) &#123; alert(i); &#125; var i; // 重新声明的变量 alert(i); // 计数&#125; JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用模仿块级作用域并避免这个问题 。用作块级作用域（通常称为私有作用域）的匿名函数的语法如下所示。 123(function() &#123; // 这里是块级作用域&#125;)(); 以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对括号会立即调用这个函数。如果有读者感觉这种语法不太好理解，可以再看看下面这个例子。 12var count = 5;outputNumbers(count); 这里初始化了变量 count ，将其值设置为 5。当然，这里的变量是没有必要的，因为可以把值直接传给函数。为了让代码更简洁，我们在调用函数时用 5 来代替变量 count，如下所示。 1outputNumbers(5); 这样做之所以可行，是因为变量只不过是值的另一种形式，因此用实际的值替换变量没有问题。再看 下面的例子。 1234var someFunction = function() &#123; // 这里是块级佐作用域&#125;;someFunction(); 这个例子先定义了一个函数，然后立即调用了它。定义函数的方式是创建一个匿名函数，并把匿名函数赋值给变量 someFunction 。而调用函数的方式是在函数名称后面添加一对圆括号，即 someFunction() 。通过前面的例子我们知道，可以使用实际的值来取代变量 count，那在这里是不是也可以用函数的值直接取代函数名呢？然而，下面的代码却会导致错误。 123function() &#123; // 这里是块级作用域&#125;(); // 出错！ 这段代码会导致语法错误，是因为 JavaScript 将 function 关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换函数表达式，只要像下面这样给它加上一对圆括号即可。 123(function() &#123; // 这里是块级作用域&#125;)(); 无论什么地方，只要临时需要这些变量，就可以使用私有作用域，例如： 123456789function putputNumbers(count) &#123; (function() &#123; for (var i = 0; i &lt; count; i++) &#123; alert(i); &#125; &#125;)(); alert(i); // 导致一个错误！&#125; 在这个重写的 outputNumbers() 函数中，我们在 for 循环外部插入了一个私有作用域。在匿名函数中定义的任何变量，都会在执行结束时被销毁。因此，变量 i 只能在循环中使用，使用后即被销毁。而在私有作用域中能够访问变量 count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致致命的命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。例如： 123456(function() &#123; var now = new Date(); if (now.getMonth() === 0 &amp;&amp; now.getDate() == 1) &#123; alert("Happy new year!"); &#125;&#125;)(); 把上面这段代码放在全局作用域中，可以用来确定哪一天是 1 月 1 日；如果到了这一天，就会向用户显示一条祝贺新年的消息。其中的变量 now 现在是匿名函数中的局部变量，而我们不必在全局作用域中创建它。 这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数阅读引用。只要函数执行完毕，就可以立即销毁其作用域链了。 私有变量严格来讲，JavaScript 中没有私有成员的概念；所有对象属性都是公有的。不过，到是有一个私有变量的概念。任何函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括 函数的参数、局部变量和在函数内部定义的其他函数。来看下面的例子： 1234function add(num1, num2) &#123; var sum = num1 + num2; return sum;&#125; 在这个函数内部，有三个私有变量：num1、num2 和 sum。在函数内部可以访问这几个变量，但在函数外则 不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。我们把有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）。两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。 1234567891011121314function MyObject() &#123; // 私有变量和私有函数 var privateVariale == 10; function privateFunction() &#123; return false; &#125; //特权方法 this.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;&#125; 这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包特权方法作为闭包有访问在构造函数中定义的所有变量和函数。对这个例子而言，变量 privateVariable 和函数 pirvateFunction() 只能通过特权方法 publicMethod() 来访问。在创建 MyObject 的实例后，出来使用 publicMethod() 这一个途径外，没有任何办法可以直接访问 privateVariable 和 privateFunction() 。利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如： 1234567891011121314function Person(name) &#123; this.getName == function() &#123; return name; &#125;; this.setName = function(value) &#123; name = value; &#125;&#125;var person = new Person("Nicholas");alert(person.getName()); // "Nichaolas"person.setName("Greg");alert(person.getName); // "Greg" 以上代码的构造函数中定义了两个特权方法：getName() 和 setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量 name。但在 Person 构造函数外部，没有任何办法访问 name。由于这两个方法是在构造函数内部定义的，它们作为闭包能够通过作用域链访问 name。私有变量 name 在 Person 的每个实例中都不相同，因为每次调用构造函数都会重新创建这两个方法。不过，在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。 静态私有变量通过在私有作用域中定义有变量或函数，同样也可以创建特权方法，其基本模式如下所示。 123456789101112131415161718(function() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 构造函数 MyObject = function() &#123; &#125;; // 公有/特权方法 MyObject.prototype.publicMethod = function () &#123; privateVariable++; return privateFunction(); &#125;&#125;)(); 这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明 MyObject 时使用 var 关键字。记住：初始化为经声明的变量，总是会创建一个全局变量。因此，MyObject 就成了一个全局变量，能够在私有作用域之外被访问到。但也要知道，在严格模式下给未经声明的变量赋值会导致错误。这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都是使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用 。来看一看下面的代码。 12345678(function() &#123; var name = ""; Person = function(value) &#123; name = value; &#125;; &#125;)(); 这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明MyObject 时使用 var 关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject 就成了一个全局变量，能够在私有作用域之外被访问到。但也要知道，在严格模式下给未经声明的变量赋值会导致错误。 这个模式与构造函数中定义特权的方法的主要区别，就在于私有变量和函数数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都是使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。来看一看下面的代码。 123456789101112131415161718192021222324(function()&#123; var name = ""; Person = function(value) &#123; name = value; &#125;; Person.prototype.getName = function() &#123; return name; &#125;; Perso.propertotype.setName = function(value) &#123; name = value; &#125;;&#125;)();var peroson1 = new Person("Nicholas");alert(person1.getName()); // "Nicholas"person1.setName("Greg");alert(person1.getName()); "Greg"var person2 = new Person("Michael");alert(person1.getName()); //"Michael"alert(person2.getName()); // "Michael" 这个例子中的 Person 构造函数与 getName() 和 setName() 方法一样，都有权访问私有变量 name。在这种模式下，变量 name 就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用 setName() 会影响所有实例。而调用 setName() 或新键一个 Person 实例都会赋予 name 属性一个新值。结果就是所有实例都会返回相同的值。 以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。 多查找作用域链中的一个层次，就会在一定程度上影响查找速度。而这正是使用闭包和私有变量的一个明显的不足之处。 模块模式前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript 是以对象字面量的方式来创建单例对象的。 1234567891011121314151617181920212223242526272829var singleton = &#123; name: value, method: function() &#123; // 这里是方法的代码 &#125;&#125;；模块模式通过为单例加私有变量和特权方法能够使其得到增强，其语法形式如下：```jsvar singleton = function() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 特权、公有方法和属性 return &#123; publicProperty: true, publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125; &#125;&#125;(); 这模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是匿名函数的内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如： 12345678910111213141516171819var application = function() &#123; // 私有变量和函数 var components = new Array(); // 初始化 components.push(new BaseComponent()); // 公共 return &#123; getComponentCount: function() &#123; return components.length; &#125;, registerComponent: function(component) &#123; if (typeof component == "object") &#123; components.push(component); &#125; &#125; &#125;&#125; 在 Web 应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的 application 对象。在创建这个对象的过程中，首先声明了一个私有的 components 数组，并想数组中添加一个 BaseComponent 是新实例（在 这里不需要关心 BaseComponent()）方法，都是有权访问数组 components 的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。 简而言之，如果必须创建一个对象并以某种数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式 。以这种模式创建的每个单例都是 Object 的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用 instanceof 操作符来检查对象的类型了。 增强的模块模式有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。来看下面的例子。 123456789101112131415161718192021var singleton = function () &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 创建对象 var object = new CustomType(); object.publicProperty = true; object.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125; // 返回这个对象 return object;&#125; 如果前面演示模块模式的例子中的 application 对象必须是 BaseComponent 的实例，那么就可以使用以下代码。 12345678910111213141516171819202122232425var application = function() &#123; // 私有变量和函数 var components = new Array(); // 初始化 components.push(new BaseComponent()); // 创建 application 的一个局部副本 var app = new BaseComponent(); // 公共接口 app.getComponent = function(component) &#123; return compnents.length; &#125;; app.registerComponent = function(component) &#123; if (typeof component == &quot;object&quot;) &#123; components.push(component); &#125; &#125;; // 返回这个副本 return app;&#125; 在这个重写后的应用程序（application）单例中，首先也是像前面例子中一样定义了私有变量。主要的不同是 application 对象的局部变量版。此后，我们又为 app 对象添加了能够访问私有变量的公有方法。最后一步是返回 app 对象，结果仍然是将它赋值给全局变量 application。 小结在 JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结了函数表达式的特点。 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂。 递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名 —— 函数名可能会发生变化。 当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。 在后台执行环境中，闭包的作用域链包含它自己的作用域、包含函数的作用域和全局作用域。 通常，函数作用域及其所有变量都会在函数执行结束后被销毁。 但是，当函数返回一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。 使用闭包可以在 JavaScript 中模块块级作用域（JavaScript 本身没有块级作用域的概念），要点如下。 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。 结果就是函数内部的所有变量都会立即销毁 —— 除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。 闭包还可以用于在对象中创建私有变量，相关概念和要点如下。 即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫做特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。 JavaScript 中函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为 创建闭包必须维护额外的作用域 ，所以过度使用它们可能会占用大量内存。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-面向对象程序设计]]></title>
    <url>%2F2018%2F08%2F14%2FJavaScript-object-oriented%2F</url>
    <content type="text"><![CDATA[面向对象的程序设计面向对象（Object-Oriented, OO）的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念 ，因此 它的对象也与基于类的语言中的对象有所不同 。 ECMA-262 把对象定义为：“无序属性集合，其属性可以包含基本值、对象或者函数。 ”严格来讲，这就是相当于说 对象是一组没有特定顺序的值 。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因）， 我们可以把 ECMAScript 的对象想象成散列表 ：无非就是一组名值对 ，其中值可以是数据和函数 。 每个对象 都是 基于一个引用类型创建的，这个 引用类型 可以是 原生类型 ，也可以是 开发人员定义的类型。 理解对象 创建自定义对象 的最简单方式就是 创建一个 Object 的实例 ，然后 再为它添加属性和方法 ，如下所示。 12345678var person = new Object();person.name = "Nicholas";person.age = 29;person.jop = "Software Engineer";person.sayName = function() &#123; alert(this.name);&#125; 上面的例子创建了一个名为 person 的对象，并为它添加了三个属性（name、age 和 job）和一个方法（sayName()）。其中，sayName() 方法用于显示 this.name（将被解析为 person.name）的值。早期的 JavaScript 开发人员经常使用这个模式创建新对象。几年后， 对象字面量语法 可以写成这样： 123456789var person = &#123; name: "Nicholas", age: 29, job: "Software Engineer", sayName: function() &#123; alert(this.name); &#125;&#125;; 这个例子中的 person 对象与前面例子中的 person 对象是一样的，都是相同是属性和方法。这些 属性在创建时带有一些特征值（characteristc），JavaScript 通过这些特征值来定义它们的行为 。 属性类型 ECMA-262 第 5 版在定义 只有内部才用的特性（attribute）时 ，描述了 属性（property）的各种特征 。ECMA-262 定义这些特征是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如 [[ Enumberable]] 。尽管 ECMA-262 第 3 版的定义有些不同，但本书只参考第 5 版的描述。 ECMAScript 中有两种属性： 数据属性 和 访问器属性 。 数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性 有 4 个 描述其行为的特性 。 [[Configurable]]：表示 能否通过 delete 删除属性从而重新定义属性 ，能否修改属性的特性，或者 能否把属性修改为访问器属性 。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Enumberable]]：表示 能否通过 for-in 循环返回属性 。像前面的例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Writable]]：表示 能否修改属性的值 。像前面的例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Value]]: 包含这个属性的 数据值 。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 对于像前面例子中那样直接在对象上定义的属性，它们的 [[Configurable]]、[[Enumerable]] 和 [[Writable]] 特性都被设置为 true，而 [[Value]] 特性被设置为指定的值。例如： 123var person = &#123; name: "Nicholas"&#125;; 这里创建了一个名为 name 的属性，为它指定的值是“Nicholas”。也就是说，[[Value]]特性将被设置为“Nicholas”，而对这个值的任何修改都将反映在这个位置。 要 修改属性默认的特性 ，必须使用 ECMAScript 5 的 Object.defineProperty() 方法。这个方法接受三个参数：属性所在的对象 、属性的名字 和 一个描述符对象 。其中，描述符（desccriptor）对象的属性必须是：configurable、enumberable、writable 和 value。 设置其中的一或多个值，可以修改对应的特性值。例如： 123456789var personn = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: falase, value: "Nicholas"&#125;);alert(person.name); //"Nicholas"person.name = "Greg";alert(person.name); //"Nicholas" 这个例子创建了一个名为 name 的属性，它的值“Nicholas”是只读的。这个属性的值是不可以修改的，如果尝试为它指定新值，则在 非严格模式 下，赋值操作将被忽略；严格模式 下，赋值操作将会导致抛出错误 。 类似的规则也适用于不可配置的属性。例如： 123456789var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; configurable: false; value: "Nicholas"&#125;);alert(person.name); //"Nicholas"delete person.name;alert(person.name); //"Nicholas" 把 configurable 设置为 false，表示不能从对象周刊删除属性。如果对这个属性调用 delete ，则在 非严格模式 下 什么也不会发生 ，而在 严格模式 下 会导致错误 。而且，一旦把属性定义为不可配置的就不能把它变回可配置了 。此时，再调用 Object.defineProperty() 方法修改 除 writable 之外的特性都会导致错误 ： 1234567891011var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; configurable: false; value: "Nicholas"&#125;);//抛出错误Object.defineProperty(person, "name", &#123; configurable: true; value: "Nicholas"&#125;); 也就是说，可以多次调用 Object.defineProperty() 方法修改同一个属性，但在把 configurable 特性设置为 false 之后就会有限制了 。 在调用 Object.defineProperty() 方法时 ，如果 不指定 ， configurable 、enumberable 和 writable 特性的 默认值都是 false 。多数情况下，可能没必要利用 Object.defineProperty() 方法提供的这些高级功能。不过，理解这些概念对理解 JavaScript 对象却非常有用。 IE8 是第一个实现 Object.defineProperty() 方法的浏览器版本。然而，这个版本实现存在诸多限制：只能在 DOM 对象上使用这个方法，而且只能创建访问器属性。由于实现不彻底，建议读者不要在 IE8 中使用 Object.defineProperty() 方法 。 访问器属性访问器属性不包含数据值，它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的 ）。在 读取访问器属性 时，会调用 getter 函数 ，这个函数 负责返回有效的值 ；在 写入访问器属 时，会调用 setter 函数并传入新值 ，这个函数 负责决定如何处理数据 。访问器属性有如下 4 个特性。 [[Configurable]]：表示 能否通过 delete 删除属性从而重新定义属性 ，能否修改属性的特性 ，或者 能否把属性修改为数据属性 。对于直接在对象上定义的属性，这个特性的默认值为 true。 [[Enumerable]]： 表示 能否通过 for-in 循环返回属性 。对于直接在对象上定义的属性，这个特性的默认值为 true。 [[Get]]: 在读取属性时调用的函数 。默认值为 undefined。 [[Set]]: 在写入属性时调用的函数 。默认值为 undefined。 访问器属性不能直接定义 ，必须使用 Object.defineProperty() 来定义 。请看下面的例子。 12345678910111213141516171819var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, "_year", &#123; get: function() &#123; return this._year; &#125; set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition。_year 前面的 下划线 是一种常用的记号，用于 表示只能通过对象方法访问的属性 。而 访问器属性 year 则包含一个 getter 函数 和一个 setter 函数 。getter 函数返回 _year 的值，setter 函数通过计算来确定正确的版本。因此，把 year 属性修改为 2005 会导致 _year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方式 ，即 设置一个属性的值会导致其他属性发生变化 。 不一定非要同时指定 getter 和 setter 。 只指定 getter 意味着属性是不能写 ，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也不能读 ，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。 支持 ECMAScript 5 的这个方法的浏览器有 IE9+ （IE8 只是部分实现）、Firefox 4+、Opera 12+ 和 Chrome。在这个方法之前，要创建访问器属性 ，一般都使用两个非标准的方法：defineGetter() 和defineSettrer() 。这两个方法最初是由 Firefox 引入的，后来 Sarfari 3 、Chrome 1、Opera 9.5 也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子。 123456789101112131415161718var book = &#123; _year: 2004; edition: 1&#125;;//定义访问器的旧方法book._defineGetter_("year", function() &#123; return this._year;&#125;);book._defineSetter_("year", function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125;&#125;);book.year = 2005;alert(book.edition); //2 在 不支持 Object.defineProperty() 方法的浏览器 中 不能修改 [[Configurable]] 和 [[Enumberable]] 。 定义多个属性 由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个 Object.defineProperties() 方法。利用这个方法 可以通过描述符一次定义多个属性 。这个方法接收两个对象参数：第一个对象是 要添加和修改其属性的对象 ，第二个对象属性 与第一个对象中要添加或修改的属性一一对应 。例如： 1234567891011121314151617181920212223var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2004 &#125;, edition: &#123; writable：true, value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;); 以上代码在 book 对象上定义了两个数据属性（_year 和 edition）和 一个访问器属性（year）。最终对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。 支持 Object.defineProperties() 方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+ 和 Chrome。 读取属性的特性使用ECMAScript 5 的Object.getOwnPropertyDescriptor() 方法，可以取得给定属性描述符 。这个方法接收两个参数：属性所在的对象 和 要读取其他描述符的属性名称 。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumberable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerale、writable 和 value。例如： 12345678910111213141516171819202122232425262728293031var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2014 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;);var descritoion = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //"undefined"var descriptor = Object.getOwnPropertyDescriptor(book，"year");alert(descrptor.value); //undefinedalert(descriptor.enumberable); //falsealert(typeof descriptor.get); // "function" 对于数据属性 _year，value 等于最初的值，configurable 是 false，而 get 等于 undefined。对于访问器属性 year、value 等于 undefined, enumberable 是 flase，而 get 是一个指向 getter 函数的指针。 在 JavaScript 中，可以针对任何对象 ——包括 DOM 和 BOM 对象，使用 Object.getOwnPropertyDescriptor() 方法。支持这个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、opera 12+ 和 Chrome。 创建对象虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多个对象 ，会产生大量重复代码 。为解决这个问题，人们开始使用工厂模式的一种变体 。 工厂模式 工厂模式是软件工程领域 一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用这种函数来封装以特定接口创建对象的细节 ，如下面的例子所示。 12345678910111213function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = jon; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var person1 = createPerson("Nicholas", 29, "Software Engineer");var person2 = createPerson("Greg", 27, "Doctor"); 函数 createPerson() 能够接受的参数来构建一个包含所有必要信息的Person对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然 解决了创建多个相似对象的问题 ，但却 没有解决对象识别的问题 （即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。 构造函数模式 ECMAScript 中的构造函数可以用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下。 1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;&#125;var person1 = new Peron("Nicholas", 29,, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 在这个例子中，Person() 函数取代了 createPerson() 函数。我们注意到，Person() 中的代码除了与 createPerson() 中相同的部分外，还 存在以下不同之处 ： 没有显式地创建对象； 直接将属性和方法赋给了 this 对象； 没有 return 语句。 此外，还应该注意到函数名 Person 使用的是大写字母 P。 按照惯例 ，构造函数始终应该以一个大写字母开头 ，而 非构造函数则应该以小写字母开头 。这个做法借鉴自其他 OO 语言，主要是Wie了区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。 要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 在前面例子的最后，person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 constructor （构造函数）属性，该属性指向 Person，如下所示。 12alert(person1.constructor == Person); //truealert(person2.constructor == Person); //true 对象的 constructor 属性最初是 用来标识对象类型的 。但是，提到 检查对象类型 ，还是 instanceof 操作符 更可靠一些。我们在这个例子中创建的所有对象既是 Object 实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。 1234alert(person1 instanceof Object); //truealert(person1 instanceof Person); //truealert(person2 instanceof Object); //truealert(person2 instanceof Person); //true 创建自定义的构造函数意味着 将来可以将它的实例标识为一种特定的类型 ；而这正是构造函数模式胜过工厂模式的地方。在这个例子中，person1 和 person2 之所以同时是 Object 的实例，是因为 所有对象均继承自 Object 。 以这种方式定义的构造函数是定义在 Global 对象（在浏览器中是 window 对象）中的。 将构造函数当作函数构造函数 与 其他函数 的 唯一区别，就在于 调用它们的方式不同。 不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数 ，只要 通过 new 操作符来调用 ，那 它就可以作为构造函数 ；而 任何函数 ，如果 不通过 new 操作符来调用 ，那 它就跟普通函数也不会有什么两样 。例如，前面例子中定义的 Person() 函数可以通过下列任何一种方式来调用。 1234567891011121314// 当作构造函数使用var person = new Person("Nicholas", 29, "Software Engineer");person.sayName(); // "Nicholas"// 作为普通函数使用Person("Greg", 27, "Doctor"); //添加到 windowwindow.sayName(); // "Greg"//在另一个对象的作用域中调用var o = new Object();Person.call(o, "Krosten", 25, "Nurse");o.sayName(); // "Kristen" 这个例子中的前面两行代码展示了构造函数的典型用法，即使用 new 操作符来创建一个新对象。接下来的两行代码展示了不使用 new 操作符调用 Person() 会出现什么结果：属性和方法被添加给 window 对象了 。有读者可能还记得，当在全局作用域周刊调用一个函数时，this 对象总是指向 Global 对象 （在浏览器中就是 window 对象）。因此，在调用完函数之后，通过 window 对象来调用 sayName() 方法，并且还返回了 “Greg”。 最后，也可以 使用 call() (或者 apply() ) 在某个特殊对象的作用域中调用 Person() 函数 。这里是在对象 o 的作用域中调用的，因此 调用后 o 拥有了所有属性和 sayName() 方法 。 构造函数的问题构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是 每个方法都要在每个实例上重新创建一遍 。在前面的例子中，person1 和 person2 都有一个名为 sayName() 的方法，但那两个方法不是同一个 Function 的实例。不要忘了—— ECMAScript 中的 函数是对象 ，因此每定义一个函数，也就实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。 123456function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = new Function("alert(this.name)"); //与声明函数在逻辑上是等价的&#125; 从这个角度上来构造函数，更容易明白每个 Person 实例都是包含一个不同的 Function 实例（以显示 name 属性）的本质。说明白些，以这种方式创建函数，会导致不同作用域链和标识符解析 ，但 创建 Function 新实例的机制仍然是相同的 。因此，不同实例上的同名函数是不相等的 ，以下代码可以证明这一点。 1alert("person1.sayName == person2.sayName"); // false 然而，创建两个完成同样任务的 Function 实例的确没有必要；况且有 this 对象在 ，根本不用在执行代码之前就把函数绑定到特定对象上面 。因此，大可像下面这样，通过 把函数定义转移到构造函数外部 来解决这个问题。 12345678910111213function Person(name, age, job) &#123; this.name = name; this. age = age; this.job = job; this.sayName = sayName;&#125;function sayName() &#123; alert(this.name);&#125;var person1 = new Person ("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 在这个例子中，我们把 sayName() 函数定义转移到了构造函数外部。而在构造函数内部，我们将 sayName() 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数的指针 ，因此 person1 和 person2 对象共享了在全局作用域中定义的同一个 sayName() 函数 。这样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上 只能被某个对象调用 ，这让全局作用域有点名不副实。而让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们 这个定义的引用类型就丝毫没有封装可言了 。好在，这些问题可以 通过使用原型模式来解决 。 原型模式我们创建的 每个函数都有一个 prototype （原型）属性 ，这个属性是 一个指针 ，指向一个对象 ，而这个对象的用途是 包含可以由特定类型的所有实例共享的属性和方法 。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象 。使用原型对象的好处是 可以让所有对象实例共享它所包含的属性和方法 。换句话说，不必在构造函数中定义对象实例的信息 ，而是可以 将这些信息直接添加到原型对象中 ，如下面的例子所示。 1234567891011121314151617function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;var person1 = new Person();person1.sayName(); // "Nicholas"var person2 = new Person();person2.sayName(); // "Nicholas"alert(person1.sayName == person2.sayName); //true 在此，我们将 sayName() 方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说， person1 和 person2 访问的都是同一组属性和同一个 sayName() 函数 。要理解原型模式的工作原理，必须先 理解 ECMAScript 中原型对象的性质 。 理解原型对象无论什么时候，只要 创建一个新的函数 ，就会根据一组特定的规则为该函数创建一个 prototype 属性 ，这个属性 指向函数的原型对象 。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性 ，这个属性是 指向 prototype 属性所在函数的的指针 。就拿前面的例子来说， Peron.prototype.constructor 指向 Person 。而 通过这个构造函数 ，我们还可继续为原型对象添加其他属性和方法 。 创建了自定义的构造函数 之后，其 原型对象默认只会取得 constructor 属性 ；至于其他方法，则都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的 内部将包含一个指针（内部属性） ，指向构造函数的原型对象 。 ECMAScript-262 第 5 版中管这个指针叫 [[Prototype]] 。 虽然在脚本中没有标准的仿古式访问 [[Prototype]] ,但 Firefox 、Sofari 和 Chrome 在每个对象上都支持一个属性 proto; 而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个 连接存在于实例和构造函数的原型对象之间 ，而不是存在于实例和构造函数之间。 以前面使用 Person 构造函数和 Person.prototype 创建实例代码为例，下图展示了各个对象之间的关系。 上图展示了 Person 构造函数、Person 的原型属性以及 Person 现有的两个实例之间的关系。prototype 指向了原型对象 ，而 Person.prototype.contructor 又指回了 Person 。原型对象中除了包含 constructor 属性之外，还包括后来添加的其他属性。Person 的每个实例—— person1 和 person2 都包含一个 内部属性 ，该属性仅仅指向了 Person.prototype ；换句话说，它们与构造函数没有直接的关系 。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName() 。这是 通过查找对象属性的过程来实现的 。 虽然在所有实现中都无法访问到 [[Prototype]],但是可以通过 isPrototypeOf() 方法来确定对象之间是否存在这种关系。从本质上讲，如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象（Person.prototype）,那么这方法就返回 true，如下所示： 12alert(Person.prototype.isPrototypeOf(person1)); //truealert(Person.prototype.isPrototypeOf(person2)); //true 这里，我们用原型对象的 isPrototypeOf() 方法测试了 person1 和 person2。因为它们内部都有一个指向 Person.prototype 的指针，因此都返回了 true。 ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf(), 在所有支持的实现中，这个方法返回 [[Prototype]] 的值。例如： 12alert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); // "Nicholas" 这里的第一行代码只是确定 Object.getPrototypeOf() 返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中 name 属性值，也就是 “Nicholas”。使用 Object.getPrototypeOf() 可以 方便地取得一个对象的原型 ，而这个利用原型实现继承的情况下是非常重要的。 支持这方法的浏览器有 IE9+、 Firefox 3.5+、Safari 5+、Opera 12+ 和 Chrome。 每当代码读取某个对象属性时 ，都 会执行一次搜索 ，目标是具有给定名字的属性 。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用 person1.sayName() 的时候，会先后执行两次搜索。首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”然后，它继续搜索，再问：“person1 的原型有 sayName() 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。 当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。而正是多个对象实例共享原型所保存的属性和方法的基本原理。 原型最初只包含 constructor 属性 ，而该属性也是 共享的，因此可以通过对象实例访问。 虽然 可以通过对象实例访问保存在原型中的值 ，但却 不能通过对象实例重写原型中的值 。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。 12345678910111213141516function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;var person1 = new Person();var person2 = new Person();person1.name = "Greg";alert("person1.name"); // "Greg" —— 来自实例alert("person2.name"); //“Nicholas” —— 来自原型 在这个实例中，person1 的 name 被一个新值给屏蔽了。但无论访问 person1.name 还是访问 person2.name 都能够正常地返回值，即分别是“Greg”（来自对象实例）和“Nicholas”（来自原型）。当在 alert() 中访问 person1.name 时，需要读取它的值，因此就会在这个实例上搜索一个名为 name 的属性。这个属性确实存在，于是就返回它的值不必在搜索原型了。当以同样的方式访问 person2.name 时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 name 属性。 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为 null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。 12345678910111213141516171819function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;var person1 = new Person();var person2 = new Person();person1.name = "Greg";alert("person1.name"); // "Greg" —— 来自实例alert("person2.name"); //“Nicholas” —— 来自原型delete person1.name ;alert(person1.name); // "Nicholas" —— 来自原型 在这个修改后的例子中，我们使用 delete 操作符 删除了 person1.name，之前它保存的 “Greg”值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。因此，接下来再调用 person1.name 时，返回的就是原型中的 name 属性的值了。 使用 hasOwnPropertoty() 方法 可以检测一个属性是存在与实例中 ，还是 存在于原型中 。这个方法（不要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。来看下面这个例子。 12345678910111213141516171819202122232425function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;var person1 = new Person();var person2 = new Person();alert(person1.hasOwnProperty("name")); // falseperson1.name = "Greg";alert("person1.name"); // "Greg" —— 来自实例alert(person1.hasOwnProperty("name")); // truealert("person2.name"); //“Nicholas” —— 来自原型alert(person2.hasOwnProperty("name")); // falsedelete person1.name ;alert(person1.name); // "Nicholas" —— 来自原型alert(person1.hasOwnProperty("name")); // false 通过使用 hasOwnProperty() 方法，，什么时候访问的是实例属性，什么时候访问的是原型属性就一清二楚了。调用 person1.hasOwnProperty(“name”) 时，只有当 person1 重写 name 属性后才会返回 true，因为只有这时候 name 才是一个实例属性，而非原型属性。下图展示了上面例子在不同情况下的实现与原型的关系（为了简单起见，图中省略了与 Person 构造函数的关系）。 ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法只能 用于实例属性 ，要取得原型属性的的描述符，必须直接在 原型对象 上调用 Object.getOwnPropertyDescriptor() 方法。 原型与 in 操作符有两种方式使用 in 操作符：单独使用 和 在 for-in 循环中使用 。在单独使用时，in 操作符会在通过对象能够访问给的属性时返回 true ，无论该属性存在于实例中还是原型中。看一看下面的例子。 123456789101112131415161718192021222324252627282930function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;var person1 = new Person();var person2 = new Person();alert(person1.hasOwnProperty("name")); // falsealert("name" in person1); // trueperson1.name = "Greg";alert("person1.name"); // "Greg" —— 来自实例alert(person1.hasOwnProperty("name")); // truealert("name" in person1); // truealert("person2.name"); //“Nicholas” —— 来自原型alert(person2.hasOwnProperty("name")); // falsealert("name" in person2); // truedelete person1.name ;alert(person1.name); // "Nicholas" —— 来自原型alert(person1.hasOwnProperty("name")); // falsealert("name" in person1); // true 在以上代码执行的整个过程中， name 属性要么是直接在对象上访问到的，要么是通过原型访问到的。因此，调用 “name” in person1 始终都返回 true，无论该属性存在于实例中还是存在于原型中。同时使用 hasOwnProperty() 方法和 in 操作符 ，就可以 确定该属性到底是存在于对象中 ，还是 存在于原型中 ，如下所示。 123function hasProperty(object, name) &#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; 由于 in 操作符只要通过对象能够访问属性就返回 true，hasOwnProperty() 只在属性存在于实例中时才返回 true，因此只要 in 操作符返回 true 而 hasOwnProperty() 返回 false，就可以确定属性是原型中的属性。下面来看一看上面定义的函数 hasPrototypeProperty() 的用法。 123456789101112131415function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;var person = new Person();alert(hasPrototypeProperty(person, "name")); // trueperson.name = "Greg";alert(hasPrototyProperty(person, "name")); //false 在这里， name 属性先是存在于原型中，因此 hasPrototypeProperty() 返回 true 。当在实例中重写 name 属性后，该属性就存在于实例中了，因此 hasPrototypeProperty() 返回 false。即使原型中仍然有 name 属性，但由于现在实例中也有了这个属性，因此原型中的 name 属性就用不到了。 在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中的不可枚举的属性（即将 [[Enumberable]] 标记为 flase 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在 iE8 及更早的版本中例外。 IE 早期版本的实现中存在一个 bug ，即 屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中 。例如： 1234567891011var o = &#123; toString: function() &#123; return "My Object"; &#125; &#125;;for (var prop in o) &#123; if (prop == "toString") &#123; alert(Found toString); // 在 IE 中不会显示 &#125;&#125; 当以上代码运行时， 应该会显示一个警告框，表明找到了 toString() 方法。这里的对象 o 定义了一个名为 toString() 的方法，该方法屏蔽了原型中（不可枚举）的 toString() 方法。在 IE 中，由于其实现认为原型的 toString() 方法被打上了值 false 的 [[Enumerable]] 标记，因此应该跳过该属性，结果我们就不会看到警示框。该 bug 会影响默认不可枚举的所有你属性和方法，包括：hasOwnProperty()、propertyIsEnumberable()、toLacaleString()、toString() 和 valueOf()。ECMAScript 5 也将 constructor 和 prototype 属性的 [[Enumerable]] 特性设置为 false，但并不是所有浏览器都照此实现。 要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys() 方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如： 123456789101112131415161718function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; alert(this.name);&#125;var keys = Object.keys(Person, prototype);alert(keys); // "name, age, job, sayName"var p1 = new Person();p1.name = "Rob";p1.age = 31;var p1keys = Object.keys(p1);alert(p1keys); // "name, age" 这里，变量 keys 中将保存一个数组，数组中是字符串“name”、“age”、“job” 和 “sayName”。这个顺序也是它们在 for-in 循环中出现的顺序 。如果是通过 Person 的实例调用，则 Object.keys() 返回的数组只包含 “name” 和 “age”这两个实例属性。 如果你想要得到所有实例属性，无理论它是否可枚举，都可以使用 Object.getOwnPropertyNames() 方法。 12var keys = Objects.getOwnPropertyNames(Person.proptotype);alert(keys); // "constructor、name、age、job、sayName" 注意结果中包含了不可枚举的 constructor 属性。Object.keys() 和 Object.getOwnPropertyNames() 方法都可以用来替代 for0in 循环。支持这两个方法的浏览器有 IE9+、Firefox4+、Safari5+、Opera12+ 和 Chrome。 更简单的原型语法读者大概注意到了，前面的例子中每添加一个属性和方法就哟啊敲一遍 Person.prototype 。为减少不必要的输入，也为了从视觉上更好的封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。 1234567891011function Person() &#123;&#125;Person.prototype = &#123; name: "Nicholas", age: 9, job: "Software Engineer", sayName: function() &#123; alert(this.name); &#125;&#125;; 在上面的代码中，我们将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：constructor 属性不再指向 Person 了 。前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们子在这里使用的语法，本质上完全重写了默认的 prototype 对象 ，因此 constructor 属性也就变成了新对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了，如下所示。 123456var friend = new Person();alert(friend instanceof Object); //truealert(friend instanceif Person); //truealert(friend.constructor == Person); //falsealert(friend.constructor == Object); //true 在此，用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但 constructor 属性则等于 Object 而不等于 Person 了。如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。 123456789101112function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: "Nicholas", age: 9, job: "Software Engineer", sayName: function() &#123; alert(this.name); &#125;&#125;; 以上代码特意包含了一个 constructor 属性，并 将它的值设置为 Person ，从而确保了通过该属性能访问到适当的值 。 注意，以上 这种方式重设 constructoe 属性会导致它的 [[Enumberable]] 特性被设置为 true 。默认情况下，原生的 constructor 属性是不可枚举的 ，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.definePeoperty()。 1234567891011121314151617function Person() &#123;&#125;Person.prototype = &#123; name: "Nicholas", age: 9, job: "Software Engineer", sayName: function() &#123; alert(this.name); &#125;&#125;;// 重设构造函数，只适用与于 ECMAScript 5 兼容的浏览器Object.definePeoperty(Person.prototype, "constructor", &#123; enumerable: false, value: Person&#125;); 原型的动态性由于原型中查找值的过程是一次搜索 ，因此我们 对原型对象所做的任何修改都能够立即从实例上反映出来 ——即使是 先创建了实例后修改原型也照样如此 。请看下面的例子。 1234567var friend = new Person();Person.prototype.saiHi = function() &#123; alert("hi");&#125;friend.sayHi(); //"hi"（没有问题！） 以上代码先创建了 Person 的一个实例，并将其保存在 friend 。然后，下一条语句在 Person.prototype 中添加了一个方法 sayHi()。即使 friend 实例是在添加新方法之前创建的，但它仍然可u一访问这个新方法。其原因可以归结为 实例与原型之间的松散连接关系 。当我们调用 friend.sayHi() 时，首先会在实例中搜索名为 sayHi 的属性，在没有找到的情况下，会继续搜索原型。因为 实例与原型之间的连接只不过是一个指针 ，而非副本，因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象 ，那么情况就不一样了。我们知道，调用构造函数时 ，会为实例添加一个指向最初原型的 [[Prototype]] 指针 ，而 把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系 。请记住： 实例中的指针仅指向原型 ，而 不指向构造函数 。看下面的例子。 1234567891011121314151617function Person() &#123;&#125;var friend = new Person();Person.prototype = &#123; constructor: Person, name: "Nicholas", age: 29, job: "Software Engineer", sayName : function () &#123; alert(this.name); &#125;&#125;;friend.sayName(); // error 在这个例子中，我们先创建了 Person 的一个实例，然后又重写了其原型对象，然后在调用 friend.sayName() 时发生错误，因为 friend 指向原型中不包含以该名字命名的属性。下图展示了这个过程的内幕。 从上图可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系 ；它们 引用的仍然是最初的原型 。 原生对象的原型原型模式的重要性 不仅体现在创建自定义类型方面 ，就连 所有原生的引用类型 ， 都采用这种模式创建的 。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。例如，在 Array.prototype 中可以找到 sort() 方法，而在 String.prototype 中可以找到 substring() 方法，如下所示。 12alert(typeof Array.prototype.sort); // "function"alert(typeof String.prototype.substring()); // "function" 通过原生对象的原型，不仅 可以取得所有默认方法的引用 ，而且也 可以定义新方法 。可以像修改自定义对象的原型一样修改原生对象的原型 ，因此 可以随时添加方法 。下面的代码就给基本包装类型 String 添加了一个名为 startsWith() 的方法。 123456String.prototype.startsWith = function (text) &#123; return this.indexOf(text) == 0;&#125;var msg = "Hello world!";alert(msg.startsWith("Hello")); //true 这里新定义的 startsWith() 方法会在传入的文本位于一个字符串开始时返回 true。既然 方法被天添加给了 String.prototype ，那么 当前环境中的所有字符串都可以调用它 。由于 msg 是字符串，而且后台会调用 Sttring 基本包装函数创建这个字符串，因此通过 msg 就可以调用 sartsWith() 方法。 尽管可以这样做，但我们 不推荐在产品化的程序中修改原生对象的原型 。如果因为某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就 可能会导致命名冲突 。而且，这样做也 可能会意外重写原生方法 。 原型对象问题原型模式也不是没有缺点。首先，它 省略了为构造函数传递初始化参数这一环节 ，结果所有实例在 默认情况下都将取得相同的属性值 。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是 由其共享的本性所导致的 。 原型中所有属性是被很多实例共享的，这种共享 对于函数非常适合 。 对于那些包含基本值的属性倒也说得过去 ，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说 ，问题就比较突出了 。来看下面的例子。 1234567891011121314151617181920212223function Person() &#123;&#125; Person.prototype = &#123; constructor: Person, name: "Nicholas", age: 29, job: "Software Engineer", friends: ["Shelby", "Court"], sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push("Van");alert(person1.friends); // "Shelby, Court, Van"alert(person2.friends); // "Shelby, Court, Van"alert(person1.friends == person2.friends); // ture 在此，Person.prototype 对象有一个名为 friends 的属性，该属性包含一个字符串数组。然后，创建了 Person 的两个实例。接着，修改了 person1.friends 引用的数组，向数组中添加了一个字符串。由于 friends 数组存在于 Person.prototype 而非 person1 中 ，所以刚刚提到的 修改也会通过 person2.frends（与 person21.friends 指向同一个数组）反映出来 。假如我们的 初衷就是像这样在所有实例共享一个数组（静态方法或属性） ，那么这个结果我没话可说。可是，实例一般都是需要有属于自己的全部属性的 。而这个问题正是我们 很少看到有人单独使用原型模式的原因所在 。 组合使用构造函数模式和原型模式创建自定义类型的最常见方式，就是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。 12345678910111213141516171819202122function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this. friends = ["Shelby", "Court"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor");person1.friends.push("Van");alert(person1.friends); // "Shelby, Count, Van"alert(person2.friends); // "Shelby, Count"alert(person1.friends == person2.friends); // falsealert(person1.sayName == person2.sayName); //true 在这个例子中，实例属性都是在构造函数中定义的 ，而由 所有实例共享的属性 constructor 和 方法 sayName() 则是在原型中定义的 。而修改了 person1.friends（向其中添加一个新字符串）， 并不会影响到 person2.friends, 因为它们分别 引用了不同的数组 。 这种 构造函数与原型模式混成的模式 ，是目前在 ECMAScript 中使用 最广泛 、认同度最高的 一个创建自定义类型的方法 。可以说，这是 用来定义引用类型的一种默认模式 。 动态原型模式有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它 把所有信息都封装在了构造函数中 ，而 通过构造函数中初始化原型 （仅在必要的情况下），又 保持了同时使用构造函数和原型的优点 。换句话说，可以通过检查某个应该存在的方法是否有效 ，来决定是否需要初始化原型 。来看一个例子。 1234567891011121314151617function Person(name, age,, job) &#123; // 属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person("Nicholas", 29, "Software Engineer");friend.sayName(); 注意构造函数代码中加粗的部分。这里 只在 sayName() 方法不存在的情况下，才会将它添加到原型中 。这段代码只会在初次调用构造函数时才会执行 。此后，原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法—— 不必用一大堆 if 语句检查每个属性和每个方法 ；只要检查其中一个即可 。对于采用这种模式创建的对象，还 可以用 instanceof 操作符确定它的类型 。 使用动态原型模式时，不能使用对象字面量重写原型 。前面解释过了，如果在 已创建了实例的情况下 重写原型，那么就 会切断现有实例与原型之间的联系 。 寄生构造函数模式 通常，在前述的几种模式都不适用的情况下，可以使用 寄生（parasitic）构造函数模式 。这种模式的基本思想是 创建一个函数 ，该函数的作用 仅仅是封装创建对象的代码 ，然后 再返回新创建的对象 ；但 从表面上看，这个函数又很像是典型的构造函数 。下面是一个例子。 123456789101112function Person(name, age, job) &#123; var o = new Object(); o.name = name; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var friend = new Person("NIcholas", 29, "Software Engineer");friend.sayName(); // "Nicholas" 在这个例子中， Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。除了 使用 new 操作符并把使用的包装函数叫做构造函数之外 ，这个模式跟工厂模式其实是一摸一样的 。构造函数在不返回值的情况下 ，默认会返回新对象的实例 。而通过 在构造函数的末尾添加一个 return 语句 ，可以重写调用构造函数时返回的值 。 这个模式 可以在特殊的情况用来为对象创建构造函数 。假设我们想 创建一个具有额外方法的特殊数组 。由于 不能直接修改 Array 构造函数 ，因此可以使用这个模式。 123456789101112131415161718function SpecialArray() &#123; // 创建数组 var values = new Array(); // 添加值 values.push.apply(values, arguments); values.toPipedString = function () &#123; return this.join("|"); &#125;; //返回值 return values;&#125;var colors = new SpecialArray("red", "blue", "green");alert(colors.toPipedString()); // "red|blue|green" 在这个例子中，我们创建了一个名叫 SpecialArray 的构造函数。在这个函数内部，首先创建了一个数组，然后 push() 方法（用构造函数接收到的所有参数） 初始化了数组的值 。随后，又给数组实例添加了一个 toPipedString() 方法，该方法返回以竖线分隔的数组值。最后 ，将数组以函数值的形式返回。接着，我们调用了 SpecialArray 构造函数，向其中传入了用于初始化数组的值，此后又调用了 toPipedString() 方法。 关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系 ；也就是说，构造函数返回的对象与构造函数外部创建的对象没有什么不同 。为此，不能依赖 instanceof 操作符来确定对象类型 。由于 存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式 。 稳妥构造函数模式 道格拉斯。格罗克福德（Douglas Crockford）发明了 JavaScript 中的 稳妥对象 （durable objects ）这个概念。所谓稳妥对象，指的是 没有公共属性 ，而且 其他方法也不引用 this 的对象 。妥对象最适合在一些安全的环境中 （这些环境中会禁止使用 this 和 new）,或者 防止数据被其他应用程序（如 Mashup 程序）改动时使用 。稳妥构造函数遵循与寄生构造函数类似的模式 ，但有两点不同：一是 新创建对象的实例方法不引用 this ; 二是 不使用 new 操作符调用构造函数 。按照稳妥构造函数的要求，可以将前面的 Person 构造函数重写如下。 123456789101112131415function Person(name, age, job) &#123; // 创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function () &#123; alert(name); &#125;; // 返回对象 return o;&#125; 注意，在以这种模式创建的对象中，除了使用 sayName() 方法之外没有其他方法可以访问 name 的值 。可以像下面使用稳妥 Person 构造函数。 12var friend = Person("Nicholas", 29, "Software Engineer");friend.sayName(); // "Nicholas" 这样，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName() 之外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入构造函数中的原始数据。稳妥构造函数模式提供的这种安全性 ，使得 它非常适合在某些安全执行环境 —— 例如，ADsafe （www.adsafe.org）和 Caja（ http://code.google.com/p/google-caja/ ）提供的环境——下使用。 与寄生构造函数模式类似，使用 稳妥构造函数模式创建的对象与构造函数之间也没有什么关系 ，因此 instanceof 操作符对这种对象也没有意义 。 继承继承是 oo 语言中的一个最为人津津乐道的概念。许多 oo 语言都支持两种继承方式：接口继承 和 实现继承 。接口继承 只是 继承方法签名 ，而 实现继承 则是 继承实际的方法 。如前所述，由于函数没有签名，在 ECMAScript 中无法实现接口继承。ECMAScript 只支持实现继承 ，而其实 实现继承主要依靠原型链来实现 。 原型链 ECMAScript 中描述了原型链的概念，并 将原型链作为实现继承的主要方法 。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法 。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象 ，原型对象都包含一个指向构造函数的指针 ，而 实例都包含一个指向原型对象的内部指针 。那么，假如我们 让原型对象等于另一个类型的实例 ，结果会怎样呢？显然，此时的 原型对象将包含指向另一个原型的指针 ，相应地，另一个原型中也包含着一个指向另一个构造函数的指针 。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进 ，就构成了实例与原型的链条 。这就是所谓 原型链 的基本概念。 实现原型链有一种基本模式，其代码大致如下。 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;function SubType() &#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;var instance = new SubType();alert(instance.getSuperValue()); // true 以上代码定义了两个类型： SuperType 和 SubType。每个类型分别有一个属性和一个方法。它们的主要区别是 SubType 继承了 SuperType，而继承是 通过创建 SuperType 的实例 ，并 将该实例赋给 SubType.prototype 实现的 。实现的 本质 是 重写原型对象，代。以一个新类型实例。换句话说，原来存在于 SuperType 的实例中的所有属性和方法 ，现在也存在于 SubType.prototype 中了。在确立了继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上又添加了一个新方法，这样就 在继承了 SuperType 的属性和方法的基础上又添加了一个新方法 。这个例子中的实例以及构造函数和原型之间的关系下图所示。 在上面的代码中，我们 没有使用 SubType 默认提供原型 ，而是给它 换了一个新原型 ；这个 新原型就是 SuperType 的实例 。于是，新原型不仅 具有作为一个 SuperType 的实例所拥有的全部属性和方法 ，而且其 内部还有一个指针 ，指向了 SuperType 的原型 。最终结果就是这样的：instance 指向 SubType 的原型 ，SubType 的原型又指向 SuperType 的原型 。getSuperValue() 方法仍然还在 SuperType.prototype 中，但 property 则位于 SubType.prototype 中。这是因为 property 是一个实例属性，而 getSuperValue() 则是一个原型方法。既然 SubType.prototype 现在是 SuperType 的实例，那么 property 当然就位于该实例中了。此外，要注意 instance.constructor 现在指向的是 SuperType ,这是因为 原来 SubType.prototype 中的 constructor 被重写了的缘故 。 实际上，不是 SubType的原型的 constructor 属性被重写了，而是 SubType 的原型指向了另一个对象 —— SuperType 的原型，而 这个原型对象的 constructor 属性指向的是 SuperType 。 通过实现原型链，本质上 扩展了本章前面介绍的原型搜索机制 。读者大概还记得，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得沿着原型链继续向上。 就拿上面的例子来说，调用 instance.getSuperValue()会经历三个搜索步骤： 1)搜索实例；2)搜索 SubType.prototype ;3) 搜索 SuperType.prototype ，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一 地前行到原型链的末端才会停下来 。 别忘记默认的原型事实上，前面例子中展示的原型链还少了一环。我们知道，所有引用类型默认都继承了 Object ,而 这个继承也是通过原型链实现的 。大家要记住，所有函数的默认原型都是 Object 的实例 ，因此 默认原型都会包含一个内部指针 ，指向 Object.prototype 。这也正是 所有自定义类型都会继承 toString()、vauleOf() 等默认方法 的根本原因。所以，我们要说上面例子展示的原型链中还应该包括另一个继承层级。下图为我们展示了该例子中完整的原型链。 一句话，SubType 继承了SuperType ，而 SuperType 继承了 Object 。当 调用 instance.toString() 时，实际上 调用的是保存在 Object.prototype 中的那个方法 。 确定原型和实例的关系可以通过两种方式来确定原型和实例之间的关系。第一种方式是 使用 instanceof 操作符 ，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。以下几行代码说明了这一点。 123alert(instance instanceof Object); //truealert(instance instanceof SuperType); //truealert(isntance instanceof SubType); //true 由于 原型链的关系 ，我们 可以说 instance 是 Object、SuperType 或 SubType 中任何一个类型的实例 。因此，测试这三个构造函数的结果都返回了 true。 第二种方式是 使用 isPrototypeOf() 方式 。同样，只要是原型链中出现过的原型 ，都可以说是该原型链所派生的实例的原型 ，因此 isPrototypeOf() 方法会返回 true，如下所示。 123alert(Object.prototype.isPrototypeOf(instance)); //truealert(SuperType.prototype.isPrototype(instance)); //truealert(SubType.prototype.isPrototype(instance)); //true 谨慎地定义方法子类型有时候需要覆盖超类型中的某个方法 ，或者 需要添加超类型中不存在的某个方法 。但不管怎样，给原型添加方法代码一定要放在替换原型的语句之后 。来看下面的例子。 123456789101112131415161718192021222324252627function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;function SubType() &#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();// 添加新方法SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;// 重写超类型中方法SubType.prototype.getSuperValue = function() &#123; return false;&#125;var instance = new SubType();alert(instance.getSuperValue()); // false 在以上代码中，加粗部分是两个方法的定义。第一个方法 getSubValue() 被添加到了SubType 中。第二个方法 getSuperValue() 是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当 通过 SubType 的实例调用 getSuperValue() 时 ，调用的就是这个重新定义的方法 ；但 通过 SuperType 的实例调用 getSuperValue() 时 ，还会继续调用原来的那个方法 。这里要格外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法 。 还有一点需要提醒读者，即在 通过原型链实现继承时 ，不能使用对象字面量创建原型方法 。因为 这样做就会重写原型链 ，如下面的例子所示。 123456789101112131415161718192021222324function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;function SubType() &#123; this.subproperty = false;&#125;SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty; &#125;, someSotherMethod: function () &#123; return false; &#125;&#125;;var instance = new SubType();alert(instance.getSuperValue()); // error 以上代码展示了刚刚把 SuperType 的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于 现在的原型包含的是一个 Object 实例 ，而 非 SuperType 的实例 ，因此 我们设想中的原型链已经被切断 —— SubType 和 SuperType 之间已经没有关系了。 原型链的问题原型链虽然很强大，可以用它来实现继承，但它也存在这些问题。其中，最主要的问题来自包含引用类型值的原型。想必大家还记得，我们介绍过 包含引用类型值的原型属性会被所有实例共享 ；而 这也是为什么要在构造函数中，而不是在原型对象中定义属性的原因 。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。下列代码可以用来说明这个问题。 12345678910111213141516function SuperType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); // "red、blue、green、black"var instance2 = new SubType();alert(instance2.colors); // "red、blue、green、black" 这个例子中的 SuperType 构造函数定义了一个 colors 属性，该属性包含了一个数组（引用类型值）。SuperType 的每个实例都会各自包含自己数组的 colors属性。当 SubType 通过原型链继承了 SuperType 之后，SubType.prototype 就变成了 SuperType 的实例，因此它也拥有了一个它自己的 colors 属性 —— 就跟专门创建一个 SubType.prototype.colors 属性一样。但结果是什么呢？结果是 SubType 的所有实例都会共享这个 colors 属性 而我们对 instance1.colors 的修改能够通过 instance2.colors 反映出来，就已经充分证实了这一点。 原型链的第二个问题是 ： 在创建子类型的实例时，不能向超类型的构造函数中传递参数 实际上，应该说是没有办法在不影响所有对象的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面讨论过由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链 。 借用构造函数 在解决原型中包含引用类型值所带来问题的过程中，开发人人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是时在特定环境中执行代码的对象，因此通过使用 apply() 和 call() 方法也可以在（将来）新创建的对象上执行构造函数，如下所示： 123456789101112131415function SubType() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; // 继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push("blackk");alert(instance1.colors); // "red, blue, green, black"var istance2 = new SubType();alert(instance2.colors); // "red，blue,green" 代码中加粗的那一行代码“借调”了超类型的构造函数。 通过使用 call() 方法（或 apply() 方法也可以），我们实际上是在（未来将要）新创建的 SubType 实例的环境下调用了 SuperType 构造函数。这样一来，就会在新 SubType 对象上执行 SuperType() 函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会有自己的 colors 属性的副本了 。 传递参数相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。看下面的例子。 123456789101112131415function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; // 继承了 SuperType，同时还传递了参数 SuperType.call(this, "Nicholas"); // 实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); // "Nicholas"alert(instance.age); //29 以上代码中的 SuperType 只接收一个参数 name, 该参数会直接赋给一个属性。在 SubType 构造函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保 SuperType 构造函数不会重写子类型的属性，可以调用超类型构造函数后，再添加应该在子类型中定义的属性。 借用构造函数的问题如果仅仅借用构造函数，那么也将无法避免构造函数模式存在的问题 —— 方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型只能构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的 。 组合继承 组合继承（combination inheritance），有时候也叫做 伪经典继承 ，指的是 将原型链和借用构造函数技术组合到一块 ，从而发挥二者之长的一种继承模式。其背后的思路是 使用原型链实现对原型属性和方法的继承 ，而 通过借用构造函数来实现对实例属性的继承 。这样，既通过在原型上定义方法实现了函数复用 。 123456789101112131415161718192021222324252627282930313233function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; // 继承属性 SuperType.call(this，name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.name);&#125;var instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");alert(instance1.colors); // "red, blue, green, black"instance1.sayName(); // "Nicholas"instance1.sayAge(); //29var instance2 = new SubType("Greg", 27);alert(instance2.colors); // "red, blue, green"instance2.sayName(); //"Greg"instance2.sayAge()； // 27 在这个例子中，SuperType 构造函数定义了两个属性：name 和 colors。SuperType 的原型定义了一个方法 sayName() 。SubType 构造函数在调用 SuperType 构造函数时传入了 name 参数，紧接着又定义了它自己的属性 age。然后，将 SuperType 的实例赋值给 SubType 的原型，然后又该新原型上定义了方法 sayAge() 。这样一来，就可以 让两个不同的 SubType 实例既分别拥有自己属性 —— 包括 colors 属性，又可以 使用相同的方法了 。 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript中最常用的继承模式 。而且，instanceof 和 isPrototypeOf() 也 能够用于识别基于组合继承创建的对象 。 原型式继承道格拉斯.克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript（JavaScript 中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是 借助原型可以基于已有对象创建新对象 ，同时 还不必因此创建自定义类型 。为了达到这个目的，他给出了如下函数。 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 在 object() 函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object() 对传入其中的对象执行了一次浅复制.来看下面的例子。 1234567891011121314var person = &#123; name: "Nicholas", friends: ["Shrlby", "Court", "Van"]&#125;;var anotherPeron = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson object(person);yetAnotherPerson.name = "Linda";yetAntherPerson.friends.push("Barbie");alert(person.friends); //"Shelby, Court, Van, Rob, Barbie" 克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给 object() 函数，然后再根据具体需要对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是 Person 对象，于是我们把它传入到 object() 函数中，然后该函数会返回一个新对象。这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。实际上，这相当于又创建了一个 person 对象的两个副本。 ECMAScript 5 通过新增 Object.create() 方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和 （可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create() 与 object() 方法的行为相同。 1234567891011121314var person = &#123; name: "Nicholas", friends: ["Shrlby", "Court", "Van"]&#125;;var anotherPeron = object.create(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson object.create(person);yetAnotherPerson.name = "Linda";yetAntherPerson.friends.push("Barbie");alert(person.friends); //"Shelby, Court, Van, Rob, Barbie" Object.creat() 方法的第二个参数与 Object.defineProperties() 方法的第二个参数格式相同：每个属性都是通过自己描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如： 123456789101112var person = &#123; name: "Nicholas", friends: ["Shrlby", "Court", "Van"]&#125;;var anotherPeron = object.create(person, &#123; name: &#123; value: "Greg" &#125;&#125;);alert(anotherPerson.name); //"Greg" 支持 Object.creat() 方法的浏览器有 IE9+、Firfox 4+、Safari 5+、Opera 12+ 和 Chrome。在没有必要兴师动众地创建构造函数，而 只是让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的 。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。 寄生式继承寄生式（parasitic）继承是与原型式继承密切相关的一种思路，并且同样也是由格罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数之内以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生继承模式。 1234567function createAnother(original) &#123; var name = object(original); //通过调用函数创建一个新对象 clone.sayHi = function() &#123; //以某种方式来增强这个对象 alert("Hi"); &#125;; return clone; //返回这个对象&#125; 在这个例子中，createAnother() 函数接收了一个参数，也就是将要作为新对象基础的对象。然后，把这个对象（original）传递给 object() 函数，将返回的结果赋值给 clone.再为 clone 对象添加一个新方法 sayHi()，最后返回 clone 对象。可以像下面这样来使用 createAnother() 函数： 1234567var person = &#123; name: "Nicholas", friends: ["Shrlby", "Court", "Van"]&#125;;var anotherPeron = object.createAnother(person);anotherPeson.sayHi(); //"hi" 这个例子中的代码基于 person 返回了一个新对象 —— anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object() 函数不是必需的；任何能够返回新对象的函数都适用于此模式。 使用寄生式继承来为对象添加函数，会由于 不能做到函数复用而降低效率 ；这一点与构造函数模式类似。 寄生组合式继承前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数；一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造时重写这些属性。再来看一看下面组合继承的例子。 1234567891011121314151617181920function superType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function () &#123; alert(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); // 第二次调用 SuperType() this.age = age;&#125;SubType.prototype = new SuperType(); //第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.name);&#125; 加粗字体的行中是调用 SuperType 构造函数的代码。在第一次调用 SuperType 构造函数时，SubType.prototype 会得到两个属性：name 和 colors;它们都是 SuperType 的实例属性，只不过现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次SuperType 构造函数，这一次又在新对象上创建了实例属性 name 和 colors. 于是， 这两个属性就屏蔽了原型中两个同名属性。下图展示了上述过程。 上图所示，有两组 name 和 colors 属性：一组在实例上，一组在 SubType 原型中。这就是调用两次 SuperType 构造函数的结果。好在我们已经找到解决这个问题的方法 —— 寄生组合式继承。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式继承方法。其背后的基本思路是：不必为自定类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。 12345function inheritPrototype(subType, superType) &#123; var prototype = Object(superType.prototype); //创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125; 这个实例中的 inheritPrototype() 函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二个是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，我们就可以用调用 inheritPrototype() 函数的语句，去替换前面例子中为子类型原型赋值语句了，例如： 1234567891011121314151617181920function superType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function () &#123; alert(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.name);&#125; 这个例子的高效率体现在它只调用一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf() 。开发人与普遍认为寄生组合式继承是引用类型最理想的继承范式。 YUI 的 YAHOO.lang.extend() 方法采用了寄生组合继承，从而让这种模式首次出现在了一个应用非常广泛的 JavaScript 库中。要了解有关 YUI 的更多信息，请访问 http://developer.yahoo.com/yui/ 。 小结ECMAScript 支持面向对象（oo）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。 原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。此外，还存在下列可供选择的继承模式。 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。 寄生组合式继承，集寄生式继承和组合继承优点与一身，，是实现基于类型继承的最有效方式。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery教程]]></title>
    <url>%2F2018%2F08%2F14%2FjQuery%2F</url>
    <content type="text"><![CDATA[jQuery 简介 jQuery 库可以通过一行简单的标记被添加到网页中。 什么是 jQuery ？jQuery是一个JavaScript函数库。 jQuery是一个轻量级的”写的少，做的多”的JavaScript库。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 提示： 除此之外，Jquery还提供了大量的插件。 为什么使用 jQuery ？目前网络上有大量开源的 JS 框架, 但是 jQuery 是目前最流行的 JS 框架，而且提供了大量的扩展。 jQuery 语法 通过 jQuery，您可以选取（查询，query） HTML 元素，并对它们执行”操作”（actions）。 jQuery 语法jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）”查询”和”查找” HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 &lt;p&gt; 元素 $(“p.test”).hide() - 隐藏所有 class=”test” 的 &lt;p&gt; 元素 $(“#test”).hide() - 隐藏所有 id=”test” 的元素 文档就绪事件您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中： 12345$(document).ready(function()&#123; // 开始写 jQuery 代码... &#125;); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 提示：简洁写法（与以上写法效果相同）: 12345$(function()&#123; // 开始写 jQuery 代码... &#125;); 以上两种方式你可以选择你喜欢的方式实现文档就绪后执行 jQuery 方法。 jQuery 选择器 jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头：$()。 元素选择器 jQuery 元素选择器基于元素名选取元素。 在页面中选取所有 &lt;p&gt; 元素: 1$("p") 用户点击按钮后，所有 &lt;p&gt; 元素都隐藏： 12345$(document).ready(function()&#123; $("button").click(function()&#123; $("p").hide(); &#125;);&#125;); #id 选择器 jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。 页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。 通过 id 选取元素语法如下： 1$("#test") 当用户点击按钮后，有 id=”test” 属性的元素将被隐藏： 12345$(document).ready(function()&#123; $("button").click(function()&#123; $("#test").hide(); &#125;);&#125;); .class 选择器 jQuery 类选择器可以通过指定的 class 查找元素。 语法如下： 1$(".test") 用户点击按钮后所有带有 class=”test” 属性的元素都隐藏： 12345$(document).ready(function()&#123; $("button").click(function()&#123; $(".test").hide(); &#125;);&#125;); 更多实例 jQuery 事件什么是事件？ 页面对不同访问者的响应叫做事件。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。 实例： 在元素上移动鼠标。 选取单选按钮 点击元素 在事件中经常使用术语”触发”（或”激发”）例如： “当您按下按键时触发 keypress 事件”。 常见 DOM 事件： jQuery 事件方法语法在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。 页面中指定一个点击事件： 1$("p").click(); 下一步是定义什么时间触发事件。您可以通过一个事件函数实现： 123$("p").click(function()&#123; // 动作触发后执行常用的 jQuery 事件方法的代码!!&#125;); 常用的 jQuery 事件方法 $(document).ready()$(document).ready() 方法允许我们在文档完全加载完后执行函数。 click()click() 方法是当按钮点击事件被触发时会调用一个函数。 该函数在用户点击 HTML 元素时执行。 在下面的实例中，当点击事件在某个 &lt;p&gt;元素上触发时，隐藏当前的 元素： 123$("p").click(function()&#123; $(this).hide();&#125;); dblclick()当双击元素时，会发生 dblclick 事件。 dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数： 123$("p").dblclick(function()&#123; $(this).hide();&#125;); mouseenter()当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseenter() 方法触发 mouseenter 事件，或规定当发生 mouseenter 事件时运行的函数： 123$("#p1").mouseenter(function()&#123; alert('您的鼠标移到了 id="p1" 的元素上!');&#125;); mouseleave()当鼠标指针离开元素时，会发生 mouseleave 事件。 mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数： 123$("#p1").mouseleave(function()&#123; alert("再见，您的鼠标离开了该段落。");&#125;); mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。 mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数： 123$("#p1").mousedown(function()&#123; alert("鼠标在该段落上按下！");&#125;); mouseup()当在元素上松开鼠标按钮时，会发生 mouseup 事件。 mouseup() 方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数： 123$("#p1").mouseup(function()&#123; alert("鼠标在段落上松开。");&#125;); hover()hover()方法用于模拟光标悬停事件。 当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 12345678$("#p1").hover( function()&#123; alert("你进入了 p1!"); &#125;, function()&#123; alert("拜拜! 现在你离开了 p1!"); &#125;); focus()当元素获得焦点时，发生 focus 事件。 当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。 focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数： 123$("input").focus(function()&#123; $(this).css("background-color","#cccccc");&#125;); blur()当元素失去焦点时，发生 blur 事件。 blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数： 123$("input").blur(function()&#123; $(this).css("background-color","#ffffff");&#125;); jQuery 效果 隐藏、显示、切换，滑动，淡入淡出，以及动画，哇哦！ 隐藏和显示 jQuery hide() 和 show()通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： 123$("#hide").click(function()&#123; $("p").hide();&#125;); 123$("#show").click(function()&#123; $("p").show();&#125;); 语法: 1$(selector).hide(speed,callback); 1$(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 下面的例子演示了带有 speed 参数的 hide() 方法： 123$("button").click(function()&#123; $("p").hide(1000);&#125;); jQuery toggle()通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。 显示被隐藏的元素，并隐藏已显示的元素： 123$("button").click(function()&#123; $("p").toggle();&#125;); 语法: 1$(selector).toggle(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 淡入淡出jQuery Fading 方法，通过 jQuery，您可以实现元素的淡入淡出效果。 jQuery 拥有下面四种 fade 方法： 1234fadeIn()fadeOut()fadeToggle()fadeTo() jQuery fadeIn()jQuery fadeIn() 用于淡入已隐藏的元素。 语法: 1$(selector).fadeIn(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。. 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeIn() 方法： 12345$("button").click(function()&#123; $("#div1").fadeIn(); $("#div2").fadeIn("slow"); $("#div3").fadeIn(3000);&#125;); jQuery fadeOut()jQuery fadeOut() 方法用于淡出可见元素。 语法: 1$(selector).fadeOut(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeOut() 方法： 12345$("button").click(function()&#123; $("#div1").fadeOut(); $("#div2").fadeOut("slow"); $("#div3").fadeOut(3000);&#125;); jQuery fadeToggle()jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。 如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。 如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。 语法: 12$(selector).fadeToggle(speed,callback);` 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeToggle() 方法： 12345$("button").click(function()&#123; $("#div1").fadeToggle(); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle(3000);&#125;); jQuery fadeTo()jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。 语法: 1$(selector).fadeTo(speed,opacity,callback); 必需的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。 可选的 callback 参数是该函数完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeTo() 方法： 12345$("button").click(function()&#123; $("#div1").fadeTo("slow",0.15); $("#div2").fadeTo("slow",0.4); $("#div3").fadeTo("slow",0.7);&#125;); 滑动jQuery 滑动方法，通过 jQuery，您可以在元素上创建滑动效果。 jQuery 拥有以下滑动方法： 123slideDown()slideUp()slideToggle() jQuery slideDown()jQuery slideDown() 方法用于向下滑动元素。 语法: 1$(selector).slideDown(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideDown() 方法： 123$("#flip").click(function()&#123; $("#panel").slideDown();&#125;); jQuery slideUp()jQuery slideUp() 方法用于向上滑动元素。 语法: 1$(selector).slideUp(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideUp() 方法： 123$("#flip").click(function()&#123; $("#panel").slideUp();&#125;); jQuery slideToggle()jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。 如果元素向下滑动，则 slideToggle() 可向上滑动它们。 如果元素向上滑动，则 slideToggle() 可向下滑动它们。 1$(selector).slideToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideToggle() 方法： 123$("#flip").click(function()&#123; $("#panel").slideToggle();&#125;); 动画 animate()jQuery animate() 方法用于创建自定义动画。 语法： 1$(selector).animate(&#123;params&#125;,speed,callback); 必需的 params 参数定义形成动画的 CSS 属性。 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是动画完成后所执行的函数名称。 下面的例子演示 animate() 方法的简单应用。它把 元素往右边移动了 250 像素： 123$("button").click(function()&#123; $("div").animate(&#123;left:'250px'&#125;);&#125;); 默认情况下，所有 HTML 元素都有一个静态位置，且无法移动。如需对位置进行操作，要记得首先把元素的 CSS position 属性设置为 relative、fixed 或 absolute！ 操作多个属性请注意，生成动画的过程中可同时使用多个属性： 12345678$("button").click(function()&#123; $("div").animate(&#123; left:'250px', opacity:'0.5', height:'150px', width:'150px' &#125;);&#125;); 如果需要生成颜色动画，您需要从 jquery.com 下载 颜色动画 插件。 使用相对值也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=： 1234567$("button").click(function()&#123; $("div").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;);&#125;); 使用预定义的值您甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”： 12345$("button").click(function()&#123; $("div").animate(&#123; height:'toggle' &#125;);&#125;); 使用队列功能默认地，jQuery 提供针对动画的队列功能。 这意味着如果您在彼此之后编写多个 animate() 调用，jQuery 会创建包含这些方法调用的”内部”队列。然后逐一运行这些 animate 调用。 1234567$("button").click(function()&#123; var div=$("div"); div.animate(&#123;height:'300px',opacity:'0.4'&#125;,"slow"); div.animate(&#123;width:'300px',opacity:'0.8'&#125;,"slow"); div.animate(&#123;height:'100px',opacity:'0.4'&#125;,"slow"); div.animate(&#123;width:'100px',opacity:'0.8'&#125;,"slow");&#125;); 下面的例子把 &lt;div&gt; 元素往右边移动了 100 像素，然后增加文本的字号： 12345$("button").click(function()&#123; var div=$("div"); div.animate(&#123;left:'100px'&#125;,"slow"); div.animate(&#123;fontSize:'3em'&#125;,"slow");&#125;); 停止动画 jQuery stop()jQuery stop() 方法用于停止动画或效果，在它们完成之前。 stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。 语法: 1$(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 下面的例子演示 stop() 方法，不带参数： 123$("#stop").click(function()&#123; $("#panel").stop();&#125;); Callback 方法 jQuery 动画的问题许多 jQuery 函数涉及动画。这些函数也许会将 speed 或 duration 作为可选参数。 1$("p").hide("slow") speed 或 duration 参数可以设置许多不同的值，比如 “slow”, “fast”, “normal” 或毫秒。 以下实例在隐藏效果完全实现后回调函数: 123456// 使用 callback 实例$("button").click(function()&#123; $("p").hide("slow",function()&#123; alert("段落现在被隐藏了"); &#125;);&#125;); 以下实例没有回调函数，警告框会在隐藏效果完成前弹出： 12345// 没有 callback(回调)$("button").click(function()&#123; $("p").hide(1000); alert("段落现在被隐藏了");&#125;); 链(Chaining)通过 jQuery，可以把动作/方法链接在一起。 Chaining 允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上）。 jQuery 方法链接直到现在，我们都是一次写一条 jQuery 语句（一条接着另一条）。 不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。 提示： 这样的话，浏览器就不必多次查找相同的元素。 如需链接一个动作，您只需简单地把该动作追加到之前的动作上。 下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，再然后向下滑动： 1$("#p1").css("color","red").slideUp(2000).slideDown(2000); 如果需要，我们也可以添加多个方法调用。 提示：当进行链接时，代码行会变得很长。不过，jQuery 语法不是很严格；您可以按照希望的格式来写，包含换行和缩进。 如下书写也可以很好地运行： 123$("#p1").css("color","red") .slideUp(2000) .slideDown(2000); jQuery 会抛掉多余的空格，并当成一行长代码来执行上面的代码行。 jQuery HTML获取内容和属性jQuery 拥有可操作 HTML 元素和属性的强大方法。 DOM 操作jQuery 中非常重要的部分，就是操作 DOM 的能力。 jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 DOM = Document Object Model（文档对象模型） DOM 定义访问 HTML 和 XML 文档的标准：“W3C 文档对象模型独立于平台和语言的界面，允许程序和脚本动态访问和更新文档的内容、结构以及样式。” 获得内容 - text()、html() 以及 val()三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 下面的例子演示如何通过 jQuery text() 和 html() 方法来获得内容： 123456$("#btn1").click(function()&#123; alert("Text: " + $("#test").text());&#125;);$("#btn2").click(function()&#123; alert("HTML: " + $("#test").html());&#125;); 下面的例子演示如何通过 jQuery val() 方法获得输入字段的值： 123$(&quot;#btn1&quot;).click(function()&#123; alert(&quot;值为: &quot; + $(&quot;#test&quot;).val());&#125;); 获取属性 - attr()jQuery attr() 方法用于获取属性值。 下面的例子演示如何获得链接中 href 属性的值： 123$(&quot;button&quot;).click(function()&#123; alert($(&quot;#runoob&quot;).attr(&quot;href&quot;));&#125;); 设置内容和属性 设置内容 - text()、html() 以及 val()我们将使用前一章中的三个相同的方法来设置内容： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 下面的例子演示如何通过 text()、html() 以及 val() 方法来设置内容： 123456789$("#btn1").click(function()&#123; $("#test1").text("Hello world!");&#125;);$("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");&#125;);$("#btn3").click(function()&#123; $("#test3").val("RUNOOB");&#125;); text()、html() 以及 val() 的回调函数上面的三个 jQuery 方法：text()、html() 以及 val()，同样拥有回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 text() 和 html()： 1234567891011$("#btn1").click(function()&#123; $("#test1").text(function(i,origText)&#123; return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; &#125;);&#125;);$("#btn2").click(function()&#123; $("#test2").html(function(i,origText)&#123; return "旧 html: " + origText + " 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: " + i + ")"; &#125;);&#125;); 设置属性 - attr()jQuery attr() 方法也用于设置/改变属性值。 下面的例子演示如何改变（设置）链接中 href 属性的值： 123$("button").click(function()&#123; $("#runoob").attr("href","http://www.runoob.com/jquery");&#125;); attr() 方法也允许您同时设置多个属性。 下面的例子演示如何同时设置 href 和 title 属性： 123456$("button").click(function()&#123; $("#runoob").attr(&#123; "href" : "http://www.runoob.com/jquery", "title" : "jQuery 教程" &#125;);&#125;); attr() 的回调函数jQuery 方法 attr()，也提供回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 attr() 方法： 12345$("button").click(function()&#123; $("#runoob").attr("href", function(i,origValue)&#123; return origValue + "/jquery"; &#125;);&#125;); 添加元素 添加新的 HTML 内容我们将学习用于添加新内容的四个 jQuery 方法： append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 jQuery append() 方法jQuery append() 方法在被选元素的结尾插入内容（仍然该元素的内部）。 1$("p").append("追加文本"); jQuery prepend() 方法jQuery prepend() 方法在被选元素的开头插入内容。 1$("p").prepend("在开头追加文本"); 通过 append() 和 prepend() 方法添加若干新元素在上面的例子中，我们只在被选元素的开头/结尾插入文本/HTML。 不过，append() 和 prepend() 方法能够通过参数接收无限数量的新元素。可以通过 jQuery 来生成文本/HTML（就像上面的例子那样），或者通过 JavaScript 代码和 DOM 元素。 在下面的例子中，我们创建若干个新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 append() 方法把这些新元素追加到文本中（对 prepend() 同样有效）： 12345678function appendText()&#123; var txt1="&lt;p&gt;文本。&lt;/p&gt;"; // 使用 HTML 标签创建文本 var txt2=$("&lt;p&gt;&lt;/p&gt;").text("文本。"); // 使用 jQuery 创建文本 var txt3=document.createElement("p"); txt3.innerHTML="文本。"; // 使用 DOM 创建文本 text with DOM $("body").append(txt1,txt2,txt3); // 追加新元素&#125; jQuery after() 和 before() 方法jQuery after() 方法在被选元素之后插入内容。 jQuery before() 方法在被选元素之前插入内容。 123$("img").after("在后面添加文本");$("img").before("在前面添加文本"); 通过 after() 和 before() 方法添加若干新元素after() 和 before() 方法能够通过参数接收无限数量的新元素。可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建新元素。 在下面的例子中，我们创建若干新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 after() 方法把这些新元素插到文本中（对 before() 同样有效）： 12345678function afterText()&#123; var txt1="&lt;b&gt;I &lt;/b&gt;"; // 使用 HTML 创建元素 var txt2=$("&lt;i&gt;&lt;/i&gt;").text("love "); // 使用 jQuery 创建元素 var txt3=document.createElement("big"); // 使用 DOM 创建元素 txt3.innerHTML="jQuery!"; $("img").after(txt1,txt2,txt3); // 在图片后添加文本&#125; 删除元素 删除元素/内容如需删除元素和内容，一般可使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 jQuery remove() 方法jQuery remove() 方法删除被选元素及其子元素。 1$("#div1").remove(); jQuery empty() 方法jQuery empty() 方法删除被选元素的子元素。 1$("#div1").empty(); 过滤被删除的元素jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。 该参数可以是任何 jQuery 选择器的语法。 下面的例子删除 class=”italic” 的所有 &lt;p&gt; 元素： 1$("p").remove(".italic"); 获取并设置 CSS 类 jQuery 操作 CSSjQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些： addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 实例样式表下面的样式表将用于本页的所有例子： 12345678910.important&#123; font-weight:bold; font-size:xx-large;&#125;.blue&#123; color:blue;&#125; jQuery addClass() 方法下面的例子展示如何向不同的元素添加 class 属性。当然，在添加类时，您也可以选取多个元素： 1234$("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important");&#125;); 您也可以在 addClass() 方法中规定多个类： 123$("button").click(function()&#123; $("body div:first").addClass("important blue");&#125;); jQuery removeClass() 方法下面的例子演示如何在不同的元素中删除指定的 class 属性： 123$("button").click(function()&#123; $("h1,h2,p").removeClass("blue");&#125;); jQuery toggleClass() 方法下面的例子将展示如何使用 jQuery toggleClass() 方法。该方法对被选元素进行添加/删除类的切换操作： 123$("button").click(function()&#123; $("h1,h2,p").toggleClass("blue");&#125;); css() 方法 jQuery css() 方法css() 方法设置或返回被选元素的一个或多个样式属性。 返回 CSS 属性如需返回指定的 CSS 属性的值，请使用如下语法： 1css("propertyname"); 下面的例子将返回首个匹配元素的 background-color 值： 1$("p").css("background-color"); 设置 CSS 属性如需设置指定的 CSS 属性，请使用如下语法： 1css("propertyname","value"); 下面的例子将为所有匹配元素设置 background-color 值： 1$("p").css("background-color","yellow"); 设置多个 CSS 属性如需设置多个 CSS 属性，请使用如下语法： 1css(&#123;"propertyname":"value","propertyname":"value",...&#125;); 下面的例子将为所有匹配元素设置 background-color 和 font-size： 1$("p").css(&#123;"background-color":"yellow","font-size":"200%"&#125;); 尺寸通过 jQuery，很容易处理元素和浏览器窗口的尺寸。 jQuery 尺寸方法jQuery 提供多个处理尺寸的重要方法： width() height() innerWidth() innerHeight() outerWidth() outerHeight() jQuery 尺寸 jQuery width() 和 height() 方法width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。 height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 下面的例子返回指定的 &lt;div&gt; 元素的宽度和高度： 123456$("button").click(function()&#123; var txt=""; txt+="div 的宽度是: " + $("#div1").width() + "&lt;/br&gt;"; txt+="div 的高度是: " + $("#div1").height(); $("#div1").html(txt);&#125;); jQuery innerWidth() 和 innerHeight() 方法innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 下面的例子返回指定的 &lt;div&gt; 元素的 inner-width/height： 123456$("button").click(function()&#123; var txt=""; txt+="div 宽度，包含内边距: " + $("#div1").innerWidth() + "&lt;/br&gt;"; txt+="div 高度，包含内边距: " + $("#div1").innerHeight(); $("#div1").html(txt);&#125;); jQuery outerWidth() 和 outerHeight() 方法outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 下面的例子返回指定的 &lt;div&gt; 元素的 outer-width/height： 123456$("button").click(function()&#123; var txt=""; txt+="div 宽度，包含内边距和边框: " + $("#div1").outerWidth() + "&lt;/br&gt;"; txt+="div 高度，包含内边距和边框: " + $("#div1").outerHeight(); $("#div1").html(txt);&#125;); jQuery 遍历遍历 什么是遍历？jQuery 遍历，意为”移动”，用于根据其相对于其他元素的关系来”查找”（或选取）HTML 元素。以某项选择开始，并沿着这个选择移动，直到抵达您期望的元素为止。 下图展示了一个家族树。通过 jQuery 遍历，您能够从被选（当前的）元素开始，轻松地在家族树中向上移动（祖先），向下移动（子孙），水平移动（同胞）。这种移动被称为对 DOM 进行遍历。 图示解析： &lt;div&gt; 元素是 &lt;ul&gt; 的父元素，同时是其中所有内容的祖先。 &lt;ul&gt; 元素是 &lt;li&gt; 元素的父元素，同时是 &lt;div&gt; 的子元素。 左边的 &lt;li&gt; 元素是 &lt;span&gt; 的父元素，&lt;ul&gt; 的子元素，同时是 &lt;div&gt; 的后代。 &lt;span&gt; 元素是 &lt;li&gt; 的子元素，同时是 &lt;ul&gt; 和 &lt;div&gt; 的后代。 两个 &lt;li&gt; 元素是同胞（拥有相同的父元素）。 右边的 &lt;li&gt; 元素是 &lt;b&gt; 的父元素，&lt;ul&gt; 的子元素，同时是 &lt;div&gt; 的后代。 &lt;b&gt; 元素是右边的 &lt;li&gt; 的子元素，同时是 &lt;ul&gt; 和 &lt;div&gt; 的后代。 祖先是父、祖父、曾祖父等等。后代是子、孙、曾孙等等。同胞拥有相同的父。 遍历 DOMjQuery 提供了多种遍历 DOM 的方法。 遍历方法中最大的种类是树遍历（tree-traversal）。 祖先祖先是父、祖父或曾祖父等等。 通过 jQuery，您能够向上遍历 DOM 树，以查找元素的祖先。 向上遍历 DOM 树这些 jQuery 方法很有用，它们用于向上遍历 DOM 树： parent() parents() parentsUntil() jQuery parent() 方法parent() 方法返回被选元素的直接父元素。 该方法只会向上一级对 DOM 树进行遍历。 下面的例子返回每个 &lt;span&gt; 元素的的直接父元素： 123$(document).ready(function()&#123; $("span").parent();&#125;); jQuery parents() 方法parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)。 下面的例子返回所有 &lt;span&gt; 元素的所有祖先： 123$(document).ready(function()&#123; $("span").parents();&#125;); 您也可以使用可选参数来过滤对祖先元素的搜索。 下面的例子返回所有 &lt;span&gt; 元素的所有祖先，并且它是 &lt;ul&gt; 元素： 123$(document).ready(function()&#123; $("span").parents("ul");&#125;); jQuery parentsUntil() 方法parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。 下面的例子返回介于 &lt;span&gt; 与 &lt;div&gt; 元素之间的所有祖先元素： 123$(document).ready(function()&#123; $("span").parentsUntil("div");&#125;); 后代后代是子、孙、曾孙等等。 通过 jQuery，您能够向下遍历 DOM 树，以查找元素的后代。 向下遍历 DOM 树下面是两个用于向下遍历 DOM 树的 jQuery 方法： children() find() jQuery children() 方法children() 方法返回被选元素的所有直接子元素。 该方法只会向下一级对 DOM 树进行遍历。 下面的例子返回每个 &lt;div&gt; 元素的所有直接子元素： 123$(document).ready(function()&#123; $("div").children();&#125;); 您也可以使用可选参数来过滤对子元素的搜索。 下面的例子返回类名为 “1” 的所有 &lt;p&gt; 元素，并且它们是 &lt;div&gt; 的直接子元素： 123$(document).ready(function()&#123; $(&quot;div&quot;).children(&quot;p.1&quot;);&#125;); jQuery find() 方法find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。 下面的例子返回属于 &lt;div&gt; 后代的所有 &lt;span&gt; 元素： 123$(document).ready(function()&#123; $("div").find("span");&#125;); 下面的例子返回 &lt;div&gt; 的所有后代： 123$(document).ready(function()&#123; $("div").find("*");&#125;); 同胞(siblings)同胞拥有相同的父元素。 通过 jQuery，您能够在 DOM 树中遍历元素的同胞元素。 在 DOM 树中水平遍历有许多有用的方法让我们在 DOM 树进行水平遍历： siblings()-next() nextAll() nextUntil() prev() prevAll() prevUntil() jQuery siblings() 方法siblings() 方法返回被选元素的所有同胞元素。 下面的例子返回 &lt;h2&gt; 的所有同胞元素： 123$(document).ready(function()&#123; $("h2").siblings();&#125;); 您也可以使用可选参数来过滤对同胞元素的搜索。 下面的例子返回属于 &lt;h2&gt; 的同胞元素的所有 &lt;p&gt; 元素： 123$(document).ready(function()&#123; $("h2").siblings("p");&#125;); jQuery next() 方法next() 方法返回被选元素的下一个同胞元素。 该方法只返回一个元素。 下面的例子返回 &lt;h2&gt; 的下一个同胞元素： 123$(document).ready(function()&#123; $("h2").next();&#125;); jQuery nextAll() 方法nextAll() 方法返回被选元素的所有跟随的同胞元素。 下面的例子返回 &lt;h2&gt; 的所有跟随的同胞元素： 123$(document).ready(function()&#123; $("h2").nextAll();&#125;); jQuery nextUntil() 方法nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。 下面的例子返回介于 &lt;h2&gt; 与 &lt;h6&gt; 元素之间的所有同胞元素： 123$(document).ready(function()&#123; $("h2").nextUntil("h6");&#125;); jQuery prev(), prevAll() &amp; prevUntil() 方法prev(), prevAll() 以及 prevUntil() 方法的工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历）。 过滤 缩小搜索元素的范围三个最基本的过滤方法是：first(), last() 和 eq()，它们允许您基于其在一组元素中的位置来选择一个特定的元素。 其他过滤方法，比如 filter() 和 not() 允许您选取匹配或不匹配某项指定标准的元素。 jQuery first() 方法first() 方法返回被选元素的首个元素。 下面的例子选取首个 &lt;div&gt; 元素内部的第一个 &lt;p&gt; 元素： 123$(document).ready(function()&#123; $("div p").first();&#125;); jQuery last() 方法last() 方法返回被选元素的最后一个元素。 下面的例子选择最后一个 &lt;div&gt; 元素中的最后一个 &lt;p&gt; 元素： 123$(document).ready(function()&#123; $("div p").last();&#125;); jQuery eq() 方法eq() 方法返回被选元素中带有指定索引号的元素。 索引号从 0 开始，因此首个元素的索引号是 0 而不是 1。下面的例子选取第二个 元素（索引号 1）： 123$(document).ready(function()&#123; $("p").eq(1);&#125;); jQuery filter() 方法filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 下面的例子返回带有类名 “url” 的所有 &lt;p&gt; 元素： 123$(document).ready(function()&#123; $("p").filter(".url");&#125;); jQuery not() 方法not() 方法返回不匹配标准的所有元素。 提示：not() 方法与 filter() 相反。 下面的例子返回不带有类名 “url” 的所有 &lt;p&gt; 元素： 123$(document).ready(function()&#123; $("p").not(".url");&#125;); jQuery AjaxAJAX 简介AJAX 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。 什么是 AJAX？AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。 使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。 您可以在我们的 jQuery Ajax 参考手册学会 jQuery Ajax 的具体应用。 您可以在我们的 AJAX 教程中学到更多有关 AJAX 的知识。 关于 jQuery 与 AJAXjQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。 如果没有 jQuery，AJAX 编程还是有些难度的。编写常规的 AJAX 代码并不容易，因为不同的浏览器对 AJAX 的实现并不相同。这意味着您必须编写额外的代码对浏览器进行测试。不过，jQuery 团队为我们解决了这个难题，我们只需要一行简单的代码，就可以实现 AJAX 功能。 AJAX load() 方法 jQuery load() 方法jQuery load() 方法是简单但强大的 AJAX 方法。 load() 方法从服务器加载数据，并把返回的数据放入被选元素中。 语法: 1$(selector).load(URL,data,callback); 必需的 URL 参数规定您希望加载的 URL。 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。 可选的 callback 参数是 load() 方法完成后所执行的函数名称。 这是示例文件（”demo_test.txt”）的内容： 12&lt;h2&gt;jQuery AJAX 是个非常棒的功能！&lt;/h2&gt;&lt;p id="p1"&gt;这是段落的一些文本。&lt;/p&gt; 下面的例子会把文件 “demo_test.txt” 的内容加载到指定的 &lt;div&gt; 元素中： 1$("#div1").load("demo_test.txt"); 也可以把 jQuery 选择器添加到 URL 参数。 下面的例子把 &quot;demo_test.txt&quot; 文件中 id=&quot;p1&quot; 的元素的内容，加载到指定的 `&lt;div&gt;` 元素中： 1$("#div1").load("demo_test.txt #p1"); 可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数： responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示”外部内容加载成功！”，而如果失败，则显示错误消息： 12345678$("button").click(function()&#123; $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr)&#123; if(statusTxt=="success") alert("外部内容加载成功!"); if(statusTxt=="error") alert("Error: "+xhr.status+": "+xhr.statusText); &#125;);&#125;); AJAX get() 和 post() 方法 jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。 HTTP 请求：GET vs. POST两种在客户端和服务器端进行请求-响应的常用方法是：GET 和 POST。 GET - 从指定的资源请求数据 POST - 向指定的资源提交要处理的数据 GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。 POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。 如需学习更多有关 GET 和 POST 以及两方法差异的知识，请阅读我们的 HTTP 方法 - GET 对比 POST。 jQuery $.get() 方法$.get() 方法通过 HTTP GET 请求从服务器上请求数据。 语法： 1$.get(URL,callback); 必需的 URL 参数规定您希望请求的 URL。 可选的 callback 参数是请求成功后所执行的函数名。 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据： 12345$("button").click(function()&#123; $.get("demo_test.php",function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;);&#125;); $.get() 的第一个参数是我们希望请求的 URL（”demo_test.php”）。 第二个参数是回调函数。第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。 提示： 这个 PHP 文件 (“demo_test.php”) 类似这样： demo_test.php 文件代码: 123&lt;?phpecho '这是个从PHP文件中读取的数据。';?&gt; jQuery $.post() 方法$.post() 方法通过 HTTP POST 请求向服务器提交数据。 语法: 1$.post(URL,data,callback); 必需的 URL 参数规定您希望请求的 URL。 可选的 data 参数规定连同请求发送的数据。 可选的 callback 参数是请求成功后所执行的函数名。 下面的例子使用 $.post() 连同请求一起发送数据： 12345678910$("button").click(function()&#123; $.post("/try/ajax/demo_test_post.php", &#123; name:"菜鸟教程", url:"http://www.runoob.com" &#125;, function(data,status)&#123; alert("数据: \n" + data + "\n状态: " + status); &#125;);&#125;); $.post() 的第一个参数是我们希望请求的 URL (“demo_test_post.php”)。 然后我们连同请求（name 和 url）一起发送数据。 “demo_test_post.php” 中的 PHP 脚本读取这些参数，对它们进行处理，然后返回结果。 第三个参数是回调函数。第一个回调参数存有被请求页面的内容，而第二个参数存有请求的状态。 提示： 这个 PHP 文件 (“demo_test_post.php”) 类似这样： demo_test_post.php 文件代码: 1234567&lt;?php$name = isset($_POST['name']) ? htmlspecialchars($_POST['name']) : '';$url = isset($_POST['url']) ? htmlspecialchars($_POST['url']) : '';echo '网站名: ' . $name;echo "\n";echo 'URL 地址: ' .$url;?&gt; jQuery 其他noConflict() 方法 jQuery 和其他 JavaScript 框架正如您已经了解到的，jQuery 使用 $ 符号作为 jQuery 的简写。 如果其他 JavaScript 框架也使用 $ 符号作为简写怎么办？ 其他一些 JavaScript 框架包括：MooTools、Backbone、Sammy、Cappuccino、Knockout、JavaScript MVC、Google Web Toolkit、Google Closure、Ember、Batman 以及 Ext JS。 其中某些框架也使用 $ 符号作为简写（就像 jQuery），如果您在用的两种不同的框架正在使用相同的简写符号，有可能导致脚本停止运行。 jQuery 的团队考虑到了这个问题，并实现了 noConflict() 方法。 jQuery noConflict() 方法noConflict() 方法会释放对 $ 标识符的控制，这样其他脚本就可以使用它了。 当然，您仍然可以通过全名替代简写的方式来使用 jQuery： 123456$.noConflict();jQuery(document).ready(function()&#123; jQuery("button").click(function()&#123; jQuery("p").text("jQuery 仍然在工作!"); &#125;);&#125;); 您也可以创建自己的简写。noConflict() 可返回对 jQuery 的引用，您可以把它存入变量，以供稍后使用。请看这个例子： 123456var jq = $.noConflict();jq(document).ready(function()&#123; jq("button").click(function()&#123; jq("p").text("jQuery 仍然在工作!"); &#125;);&#125;); 如果你的 jQuery 代码块使用 $ 简写，并且您不愿意改变这个快捷方式，那么您可以把 $ 符号作为变量传递给 ready 方法。这样就可以在函数内使用 $ 符号了 - 而在函数外，依旧不得不使用 “jQuery”： 123456$.noConflict();jQuery(document).ready(function($)&#123; $("button").click(function()&#123; $("p").text("jQuery 仍然在工作!"); &#125;);&#125;); JSONP 教程 本章节我们将向大家介绍 JSONP 的知识。 Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 为什么我们从不同的域（网站）访问数据需要一个特殊的技术(JSONP )呢？这是因为同源策略。 同源策略，它是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。 JSONP 应用 服务端JSONP格式数据 如客户想访问 : http://www.runoob.com/try/ajax/jsonp.php?jsonp=callbackFunction。 假设客户期望返回JSON数据：[“customername1”,”customername2”]。 真正返回到客户端的数据显示为: callbackFunction([“customername1”,”customername2”])。 服务端文件jsonp.php代码为： 1234567891011// jsonp.php 文件代码&lt;?phpheader('Content-type: application/json');//获取回调函数名$jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);//json数据$json_data = '["customername1","customername2"]';//输出jsonp格式的数据echo $jsoncallback . "(" . $json_data . ")";?&gt; 客户端实现 callbackFunction 函数 123456789101112&lt;script type=&quot;text/javascript&quot;&gt;function callbackFunction(result, methodName)&#123; var html = &apos;&lt;ul&gt;&apos;; for(var i = 0; i &lt; result.length; i++) &#123; html += &apos;&lt;li&gt;&apos; + result[i] + &apos;&lt;/li&gt;&apos;; &#125; html += &apos;&lt;/ul&gt;&apos;; document.getElementById(&apos;divCustomers&apos;).innerHTML = html;&#125;&lt;/script&gt; 页面展示 1&lt;div id="divCustomers"&gt;&lt;/div&gt; 客户端页面完整代码 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;JSONP 实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="divCustomers"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt;function callbackFunction(result, methodName) &#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; result.length; i++) &#123; html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; document.getElementById('divCustomers').innerHTML = html; &#125;&lt;/script&gt;&lt;script type="text/javascript" src="http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery 使用 JSONP以上代码可以使用 jQuery 代码实例： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JSONP 实例&lt;/title&gt; &lt;script src="http://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id="divCustomers"&gt;&lt;/div&gt;&lt;script&gt;$.getJSON("http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?", function(data) &#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; $('#divCustomers').html(html); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》学习笔记-引用类型]]></title>
    <url>%2F2018%2F08%2F13%2FJavaScript-reference-type%2F</url>
    <content type="text"><![CDATA[引用类型引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构 ，用于 将数据和功能组织在一起 。它也常被称为 类 ，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 虽然 引用类型与类看起来相似 ，但 它们并不是相同的概念 。为避免混淆，本书将不使用类这个概念。 如前所述，对象是某个特定引用类型的实例。新对象是 使用 new 操作符后跟一个构造函数来创建的 。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码： 1var person = new Object(); 这行代码创建了 Object 引用类型的一个新实例，然后把该实例保存在了变量 person 中。使用的构造函数是 Object ，它只为新对象定义了默认的属性和方法。ECMAScript 提供了很多 原生引用类型（例如 Object ），以便开发人员用以实现常见的计算任务。 Object 类型到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且， Object 也是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。 创建 Object 实例 的方式有两种。第一种是 使用 new 操作符后跟 Object 构造函数 ，如下所示： 123var person = new Object();person.name = &quot;Nicholas&quot;;person.age = 29; 另一种方式是 使用对象字面量表示法 。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的 person 对象： 1234var person = &#123; name : "Nicholas", age : 29&#125;; 在这个例子中，左边的花括号（ { ）表示对象字面量的开始，因为它出现在了表达式上下文（expression context）中。ECMAScript 中的表达式上下文指的是能够返回一个值（表达式）。赋值操作符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文（statement context）中，例如跟在 if 语句条件的后面，则表示一个语句块的开始。 然后，我们定义了 name 属性，之后是一个冒号，再后面是这个属性的值。在对象字面量中，使用逗号来分隔不同的属性，因此 “Nicholas” 后面是一个逗号。但是，在 age 属性的值 29 的后面不能添加逗号，因为 age 是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在 IE7 及更早版本和 Opera 中导致错误。 在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示。 12345var person = &#123; "name" : "Nicholas", "age" : 29, 5 : true&#125;; 这个例子会创建一个对象，包含三个属性： name 、 age 和 5 。但 这里的数值属性名会自动转换为字符串 。 另外，使用对象字面量语法时，如果 留空其花括号 ，则 可以定义只包含默认属性和方法的对象 ，如下所示： 123var person = &#123;&#125;; //与 与 new Object() 相同person.name = "Nicholas";person.age = 29; 这个例子与本节前面的例子是等价的，只不过看起来似乎有点奇怪。关于对象字面量语法，我们推荐只在考虑对象属性名的可读性时使用。 在通过对象字面量定义对象时，实际上不会调用 Object 构造函数（Firefox 2 及更早版本会调用 Object 构造函数；但 Firefox 3 之后就不会了）。 虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式 ，例如： 1234567891011121314151617function displayInfo(args) &#123; var output = &quot;&quot;; if (typeof args.name == &quot;string&quot;)&#123; output += &quot;Name: &quot; + args.name + &quot;\n&quot;; &#125; if (typeof args.age == &quot;number&quot;) &#123; output += &quot;Age: &quot; + args.age + &quot;\n&quot;; &#125; alert(output);&#125;displayInfo(&#123; name: &quot;Nicholas&quot;, age: 29&#125;);displayInfo(&#123; name: &quot;Greg&quot;&#125;); 在这个例子中，函数 displayInfo() 接受一个名为 args 的参数。这个参数可能带有一个名为 name 或 age 的属性，也可能这两个属性都有或者都没有。在这个函数内部，我们通过 typeof 操作符来检测每个属性是否存在，然后再基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，每次都使用一个对象字面量来指定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。 这种传递参数的模式最适合需要 向函数传入大量可选参数的情形 。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数 。 一般来说，访问对象属性时使用的都是 点表示法 ，这也是很多面向对象语言中通用的语法。不过，在 JavaScript 也可以使用 方括号表示法 来访问对象的属性。在使用方括号语法时，应该 将要访问的属性以字符串的形式放在方括号中 ，如下面的例子所示。 12alert(person["name"]); //"Nicholas"alert(person.name); //"Nicholas" 从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是 可以通过变量来访问属性 ，例如： 12var propertyName = "name";alert(person[propertyName]); //"Nicholas" 如果属性名中包含会导致语法错误的字符，或者 属性名使用的是关键字或保留字 ，也可以 使用方括号表示法 。例如：1person["first name"] = "Nicholas"; 由于 “first name” 中包含一个空格，所以不能使用点表示法来访问它。然而，属性名中是可以包含非字母非数字的 ，这时候就可以 使用方括号表示法来 访问它们。 通常，除非必须使用变量来访问属性，否则我们建议使用点表示法 。 Array 类型除了 Object 之外， Array 类型恐怕是 ECMAScript 中最常用的类型了。而且，ECMAScript 中的数组与其他多数语言中的数组有着相当大的区别。虽然 ECMAScript 数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript 数组 的每一项可以保存 任何类型的数据 。也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。而且，ECMAScript 数组的大小是可以动态调整的 ，即 可以随着数据的添加自动增长以容纳新增数据 。 创建数组 的基本方式有两种。第一种是 使用 Array 构造函数 ，如下面的代码所示。 1var colors = new Array(); 如果预先知道数组要保存的项目数量，也可以 给构造函数传递该数量 ，而该数量会自动变成 length 属性的值。例如，下面的代码将创建 length 值为 20 的数组。 1var colors = new Array(20); 也可以 向 Array 构造函数传递数组中应该包含的项 。以下代码创建了一个包含 3个字符串值的数组： 1var colors = new Array("red", "blue", "green"); 当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果 传递的是数值 ，则会 按照该数值创建包含给定项数的数组 ；而如果 传递的是其他类型的参数 ，则会创建 包含那个值的只有一项的数组 。下面就两个例子： 12var colors = new Array(3); // 创建一个包含 3 项的数组var names = new Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组 另外，在使用 Array 构造函数时也可以 省略 new 操作符 。如下面的例子所示，省略 new 操作符的结果相同： 12var colors = Array(3); // 创建一个包含 3 项的数组var names = Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组 创建数组的第二种基本方式是 使用数组字面量表示法 。数组字面量由 一对包含数组项的方括号表示 ，多个数组项之间以逗号隔开 ，如下所示： 1234var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组var names = []; // 创建一个空数组var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组 以上代码的第一行创建了一个包含3个字符串的数组。第二行使用一对空方括号创建了一个空数组。第三行展示了在数组字面量的最后一项添加逗号的结果：在 IE 中， values 会成为一个包含 3 个项且每项的值分别为 1、2 和 undefined 的数组；在其他浏览器中， values 会成为一个包含 2项且值分别为 1 和 2 的数组。原因是 IE8 及之前版本中的 ECMAScript 实现在数组字面量方面存在 bug。由于这个 bug 导致的另一种情况如最后一行代码所示，该行代码可能会创建包含 5 项的数组（在 IE9+、Firefox、Opera、Safari 和 Chrome 中），也可能会创建包含 6 项的数组（在 IE8 及更早版本中）。在像这种省略值的情况下，每一项都将获得 undefined 值；这个结果与调用 Array 构造函数时传递项数在逻辑上是相同的。但是由于 IE 的实现与其他浏览器不一致，因此我们强烈建议不要使用这种语法。 与对象一样，在 使用数组字面量表示法 时，也 不会调用 Array 构造函数 （Firefox 3 及更早版本除外）。 在 读取和设置数组的值 时，要 使用方括号并提供相应值的基于 0 的数字索引 ，如下所示： 1234var colors = ["red", "blue", "green"]; // 定义一个字符串数组alert(colors[0]); // 显示第一项colors[2] = "black"; // 修改第三项colors[3] = "brown"; // 新增第四项 方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值，就像这个例子中的 colors[0] 会显示 “red” 一样。设置数组的值也使用相同的语法，但会替换指定位置的值。如果设置某个值的索引超过了数组现有项数，如这个例子中的 colors[3] 所示，数组就会自动增加到该索引值加 1 的长度（就这个例子而言，索引是 3，因此数组长度就是 4）。 数组的项数 保存在其 length 属性 中，这个属性始终会返回 0 或更大的值，如下面这个例子所示： 1234var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组var names = []; // 创建一个空数组alert(colors.length); //3alert(names.length); //0 数组的 length 属性很有特点——它 不是只读的 。因此，通过 设置这个属性 ，可以从数组的末尾移除项或向数组中添加新项 。请看下面的例子： 123var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组colors.length = 2;alert(colors[2]); //undefined 这个例子中的数组 colors 一开始有 3 个值。将其 length 属性设置为 2 会移除最后一项（位置为 2 的那一项），结果再访问 colors[2] 就会显示 undefined 了。如果将其 length 属性设置为大于数组项数的值，则新增的每一项都会取得 undefined 值，如下所示： 123var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组colors.length = 4;alert(colors[3]); //undefined 在此，虽然 colors 数组包含 3 个项，但把它的 length 属性设置成了 4。这个数组不存在位置 3，所以访问这个位置的值就得到了特殊值 undefined 。 利用 length 属性也可以方便地在数组末尾添加新项 ，如下所示： 123var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组colors[colors.length] = "black"; // （在位置 3 ）添加一种颜色colors[colors.length] = "brown"; // （在位置 4 ）再添加一种颜色 由于数组最后一项的索引始终是 length-1 ，因此下一个新项的位置就是 length 。每当在数组末尾添加一项后，其 length 属性都会自动更新以反应这一变化。换句话说，上面例子第二行中的 colors[colors.length] 为位置 3 添加了一个值，最后一行的 colors[colors.length] 则为位置 4 添加了一个值。当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值 ，即长度值等于最后一项的索引加 1，如下面的例子所示： 123var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组colors[99] = "black"; // （在位置 99 ）添加一种颜色alert(colors.length); // 100 在这个例子中，我们向 colors 数组的位置 99 插入了一个值，结果数组新长度（ length ）就是 100（99+1）。而位置 3 到位置 98 实际上都是不存在的，所以访问它们都将返回 undefined 。 数组最多可以包含 4 294 967 295 个项 ，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。 检测数组自从 ECMAScript 3 做出规定以后，就出现了确定某个对象是不是数组的经典问题。对于一个网页，或者一个全局作用域而言 ，使用 instanceof 操作符就能得到满意的结果 ： 123if (value instanceof Array)&#123; //对数组执行某些操作&#125; instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果 网页中包含多个框架 ，那 实际上就存在两个以上不同的全局执行环境 ，从而存在两个以上不同版本的 Array 构造函数 。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 为了解决这个问题，ECMAScript 5 新增了 Array.isArray() 方法 。这个方法的目的是 最终确定某个值到底是不是数组 ，而 不管它是在哪个全局执行环境中创建的 。这个方法的用法如下。 123if (Array.isArray(value))&#123; //对数组执行某些操作&#125; 支持 Array.isArray() 方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 10.5+和 Chrome。要在尚未实现这个方法中的浏览器中准确检测数组，请参考 22.1.1 节。 转换方法如前所述，所有对象都具有 toLocaleString() 、 toString() 和 valueOf() 方法。其中，调用数组的 toString() 方法 会返回 由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串 。而调用 valueOf() 返回的还是 数组 。实际上，为了创建这个字符串会调用数组每一项的 toString() 方法。来看下面这个例子。 1234var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组alert(colors.toString()); // red,blue,greenalert(colors.valueOf()); // red,blue,greenalert(colors); // red,blue,green 在这里，我们首先显式地调用了 toString() 方法，以便返回数组的字符串表示，每个值的字符串表示拼接成了一个字符串，中间以逗号分隔。接着调用 valueOf() 方法，而最后一行代码直接将数组传递给了 alert() 。由于 alert() 要接收字符串参数，所以它会在后台调用 toString() 方法，由此会得到与直接调用 toString() 方法相同的结果。另外， toLocaleString() 方法经常也会返回与 toString() 和 valueOf() 方法相同的值，但也不总是如此。当调用数组的 toLocaleString() 方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 toLocaleString() 方法 ，而不是 toString() 方法。请看下面这个例子。 12345678910111213141516171819202122var person1 = &#123; toLocaleString : function () &#123; return "Nikolaos"; &#125;, toString : function() &#123; return "Nicholas"; &#125;&#125;;var person2 = &#123; toLocaleString : function () &#123; return "Grigorios"; &#125;, toString : function() &#123; return "Greg"; &#125;&#125;;var people = [person1, person2];alert(people); //Nicholas,Gregalert(people.toString()); //Nicholas,Gregalert(people.toLocaleString()); //Nikolaos,Grigorios 我们在这里定义了两个对象： person1 和 person2 。而且还分别为每个对象定义了一个 toString() 方法和一个 toLocaleString() 方法，这两个方法返回不同的值。然后，创建一个包含前面定义的两个对象的数组。在将数组传递给 alert() 时，输出结果是 “Nicholas,Greg” ，因为调用了数组每一项的 toString() 方法（同样，这与下一行显式调用 toString() 方法得到的结果相同）。而当调用数组的 toLocaleString() 方法时，输出结果是 “Nikolaos,Grigorios” ，原因是调用了数组每一项的 toLocaleString() 方法。 数组继承的 toLocaleString() 、 toString() 和 valueOf() 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 join() 方法 ，则 可以使用不同的分隔符来构建这个字符串 。 join() 方法 只接收一个参数，即 用作分隔符的字符串 ，然后 返回包含所有数组项的字符串 。请看下面的例子： 123var colors = ["red", "green", "blue"];alert(colors.join(",")); //red,green,bluealert(colors.join("||")); //red||green||blue 在这里，我们使用 join() 方法重现了 toString() 方法的输出。在传递逗号的情况下，得到了以逗号分隔的数组值。而在最后一行代码中，我们传递了双竖线符号，结果就得到了字符串 “red|| green||blue” 。如果 不给 join() 方法传入任何值，或者给它传入 undefined ，则 使用逗号作为分隔符 。IE7 及更早版本会错误的使用字符串 “undefined” 作为分隔符。 如果数组中的某一项的值是 null 或者 undefined ，那么该值在 join() 、toLocaleString() 、 toString() 和 valueOf() 方法 返回的结果中以空字符串表示 。 栈方法ECMAScript 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表现得就像 栈 一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 LIFO（Last-In-First-Out，后进先出）的数据结构，也就是 最新添加的项最早被移除 。而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——栈的顶部 。ECMAScript 为数组专门提供了 push() 和 pop() 方法，以便实现类似栈的行为。 push() 方法 可以接收任意数量的参数，把它们 逐个添加到数组末尾 ，并 返回修改后数组的长度 。而 pop() 方法 则 从数组末尾移除最后一项 ，减少数组的 length 值 ，然后 返回移除的项 。请看下面的例子： 12345678910var colors = new Array(); // 创建一个数组var count = colors.push("red", "green"); // 推入两项alert(count); //2count = colors.push("black"); // 推入另一项alert(count); //3var item = colors.pop(); // 取得最后一项alert(item); //"black"alert(colors.length); //2 以上代码中的 数组可以看成是栈（代码本身没有任何区别，而 push() 和 pop() 都是数组默认的方法）。首先，我们使用 push() 将两个字符串 推入数组的末尾 ，并将返回的结果保存在变量 count 中（值为 2）。然后，再推入一个值，而结果仍然保存在 count 中。因为此时数组中包含 3 项，所以 push()返回 3。在调用 pop() 时，它会 返回数组的最后一项 ，即字符串 “black” 。此后，数组中仅剩两项。 可以将栈方法与其他数组方法连用，像下面这个例子一样。 1234567var colors = ["red", "blue"];colors.push("brown"); // 添加另一项colors[3] = "black"; // 添加一项alert(colors.length); // 4var item = colors.pop(); // 取得最后一项alert(item); //"black" 在此，我们首先用两个值来初始化一个数组。然后，使用 push() 添加第三个值，再通过直接在位置 3 上赋值来添加第四个值。而在调用 pop() 时，该方法返回了字符串 “black” ，即最后一个添加到数组的值。 队列方法栈数据结构的访问规则是 LIFO（后进先出），而 队列数据结构 的访问规则是 FIFO（First-In-First-Out，先进先出）。队列在列表的末端添加项，从列表的前端移除项。由于 push() 是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift() ，它能够 移除数组中的第一个项 并 返回该项 ，同时 将数组长度减 1 。结合 使用 shift() 和 push() 方法 ，可以 像使用队列一样使用数组 。 12345678910var colors = new Array(); //创建一个数组var count = colors.push("red", "green"); //推入两项alert(count); //2count = colors.push("black"); //推入另一项alert(count); //3var item = colors.shift(); // 取得第一项alert(item); //"red"alert(colors.length); //2 这个例子首先使用 push() 方法创建了一个包含 3 种颜色名称的数组。代码中加粗的那一行使用 shift() 方法从数组中取得了第一项，即 “red” 。在移除第一项之后， “green” 就变成了第一项，而 “black” 则变成了第二项，数组也只包含两项了。 ECMAScript 还为数组提供了一个 unshift() 方法。顾名思义， unshift() 与 shift() 的用途相反：它能在 数组前端添加任意个项 并 返回新数组的长度 。因此，同时使用 unshift() 和 pop() 方法 ，可以从 相反的方向来模拟队列 ，即在数组的前端添加项，从数组末端移除项，如下面的例子所示。 12345678910var colors = new Array(); //创建一个数组var count = colors.unshift("red", "green"); // 推入两项alert(count); //2count = colors.unshift("black"); // 推入另一项alert(count); //3var item = colors.pop(); // 取得最后一项alert(item); //"green"alert(colors.length); //2 这个例子创建了一个数组并使用 unshift() 方法先后推入了 3 个值。首先是 “red” 和 “green” ，然后是 “black” ，数组中各项的顺序为 “black” 、 “red” 、 “green” 。在调用 pop() 方法时，移除并返回的是最后一项，即 “green” 。 IE7 及更早版本对 JavaScript 的实现中存在一个偏差，其 unshift() 方法总是返回 undefined 而不是数组的新长度。IE8 在非兼容模式下会返回正确的长度值。 重排序方法数组中已经存在两个可以直接用来 重排序的方法 ： reverse() 和 sort() 。有读者可能猜到了， reverse() 方法 会 反转数组项的顺序 。请看下面这个例子。 123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); //5,4,3,2,1 这里数组的初始值及顺序是 1、2、3、4、5。而调用数组的 reverse() 方法后，其值的顺序变成了 5、4、3、2、1。这个方法的作用相当直观明了，但不够灵活，因此才有了 sort() 方法。 在默认情况下， sort() 方法 按 升序排列数组项——即 最小的值位于最前面，最大的值排在最后面 。为了实现排序， sort() 方法 会调用每个数组项的 toString() 转型方法 ，然后 比较得到的字符串 ，以确定如何排序。即使数组中的每一项都是数值， sort() 方法比较的也是字符串 ，如下所示。 123var values = [0, 1, 5, 10, 15];values.sort();alert(values); //0,1,10,15,5 可见，即使例子中值的顺序没有问题，但 sort() 方法也会根据测试字符串的结果改变原来的顺序。因为数值 5 虽然小于 10，但在进行字符串比较时， “10” 则位于 “5” 的前面，于是数组的顺序就被修改了。 不用说，这种排序方式在很多情况下都不是最佳方案。因此 sort() 方法 可以 接收一个比较函数作为参数 ，以便我们指定哪个值位于哪个值的前面。 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数： 123456789function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125; 这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给 sort() 方法即可，如下面这个例子所示。 123var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); //0,1,5,10,15 在将比较函数传递到 sort() 方法之后，数值仍然保持了正确的升序。当然，也可以 通过比较函数产生降序排序的结果 ，只要交换比较函数返回的值即可。 12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 15,10,5,1,0 在这个修改后的例子中，比较函数在第一个值应该位于第二个之后的情况下返回 1，而在第一个值应该在第二个之前的情况下返回-1。交换返回值的意思是让更大的值排位更靠前，也就是对数组按照降序排序。当然，如果 只想反转数组原来的顺序 ，使用 reverse() 方法要更快一些 。 reverse() 和 sort() 方法的返回值是经过排序之后的数组。 对于 数值类型 或者 其 valueOf() 方法会返回数值类型的对象类型 ，可以使用一个 更简单的比较函数 。这个函数只要用第二个值减第一个值即可。 123function compare(value1, value2)&#123; return value2 - value1;&#125; 由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况。 操作方法ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中， concat() 方法 可以 基于当前数组中的所有项创建一个新数组 。具体来说，这个方法会 先创建当前数组一个副本 ，然后 将接收到的参数添加到这个副本的末尾 ，最后 返回新构建的数组 。在 没有给 concat() 方法传递参数 的情况下，它 只是复制当前数组并返回副本 。如果传递给 concat() 方法的是 一或多个数组 ，则该方法会 将这些数组中的每一项都添加到结果数组中 。如果 传递的值不是数组 ，这些值就会被简单地添加到结果数组的末尾 。下面来看一个例子。 1234var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]);alert(colors); //red,green,bluealert(colors2); //red,green,blue,yellow,black,brown 以上代码开始定义了一个包含 3 个值的数组 colors 。然后，基于 colors 调用了 concat() 方法，并传入字符串 “yellow” 和一个包含 “black” 和 “brown” 的数组。最终，结果数组 colors2 中包含了”red” 、 “green” 、 “blue” 、 “yellow” 、 “black” 和 “brown” 。至于原来的数组 colors ，其值仍然保持不变。 下一个方法是 slice() ，它能够 基于当前数组中的一或多个项创建一个新数组 。 slice() 方法可以接受一或两个参数，即要 返回项的起始和结束位置 。在只有一个参数的情况下， slice() 方法 返回 从该参数指定位置开始到当前数组末尾的所有项 。如果有两个参数，该方法 返回起始和结束位置之间的项 ——但 不包括结束位置的项 。注意， slice() 方法不会影响原始数组** 。请看下面的例子。 12345var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow 在这个例子中，开始定义的数组 colors 包含 5 项。调用 slice() 并传入 1 会得到一个包含 4 项的新数组；因为是从位置 1 开始复制，所以会包含 “green” 而不会包含 “red” 。这个新数组 colors2 中包含的是 “green” 、 “blue” 、 “yellow” 和 “purple” 。接着，我们再次调用 slice() 并传入了 1 和 4，表示复制从位置 1 开始，到位置 3 结束。结果数组 colors3 中包含了 “green” 、 “blue” 和 “yellow” 。 如果 slice() 方法的 参数中有一个负数 ，则 用数组长度加上该数来确定相应的位置 。例如，在一个包含 5 项的数组上调用 slice(-2,-1) 与调用 slice(3,4) 得到的结果相同。如果结束位置小于起始位置，则返回空数组。 下面我们来介绍 splice() 方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。splice() 的主要用途是 向数组的中部插入项 ，但使用这种方法的方式则有如下 3 种。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2) 会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”) 会从当前数组的位置 2 开始插入字符串 “red” 和 “green” 。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red” 和 “green” 。 splice() 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述 3 种使用 splice() 方法的方式。 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, "yellow", "orange"); // 从位置 1 开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项 上面的例子首先定义了一个包含 3项的数组 colors 。第一次调用 splice() 方法只是删除了这个数组的第一项，之后 colors 还包含 “green” 和 “blue” 两项。第二次调用 splice() 方法时在位置 1插入了两项，结果 colors 中包含 “green” 、 “yellow” 、 “orange” 和 “blue” 。这一次操作没有删除项，因此返回了一个空数组。最后一次调用 splice() 方法删除了位置 1处的一项，然后又插入了 “red” 和 “purple” 。在完成以上操作之后，数组 colors 中包含的是 “green” 、 “red” 、 “purple” 、 “orange” 和 “blue” 。 位置方法ECMAScript 5 为数组实例添加了两个位置方法： indexOf() 和 lastIndexOf() 。这两个方法都接收两个参数：要查找的项 和（可选的）表示查找起点位置的索引 。其中， indexOf() 方法从数组的开头（位置 0）开始向后查找 ， lastIndexOf() 方法则从数组的末尾开始向前查找 。 这两个方法都返回 要查找的项在数组中的位置 ，或者 在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用 全等操作符 ；也就是说，要求查找的项必须严格相等（就像使用===一样）。以下是几个例子。 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 使用 indexOf() 和 lastIndexOf() 方法查找特定项在数组中的位置非常简单，支持它们的浏览器包括 IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。 迭代方法ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数 和（可选的）运行该函数的作用域对象 —— 影响 this 的值 。传入这些方法中的函数会接收三个参数：数组项的值 、该项在数组中的位置和数组对象本身 。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这 5 个迭代方法的作用。 every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true 。 filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。 map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true 。 以上方法都不会修改数组中的包含的值。 在这些方法中，最相似的是 every() 和 some() ，它们都用于 查询数组中的项是否满足某个条件 。对 every() 来说，传入的函数必须对 每一项都返回 true ，这个方法才 返回 true ；否则，它就返回 false 。而 some() 方法 则是 只要传入的函数对数组中的某一项返回 true ，就会 返回 true 。请看以下例子。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 以上代码调用了 every() 和 some() ，传入的函数只要给定项大于2就会返回 true 。对于 every() ，它返回的是 false ，因为只有部分数组项符合条件。对于 some() ，结果就是 true ，因为至少有一项是大于 2 的。 下面再看一看 filter() 函数 ，它利用指定的函数确定 是否在返回的数组中包含某一项 。例如，要返回一个所有数值都大于 2 的数组，可以使用以下代码。 12345var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3] 这里，通过调用 filter() 方法创建并返回了包含 3、4、5、4、3 的数组，因为传入的函数对它们每一项都返回 true 。这个方法对 查询符合某些条件的所有数组项非常有用 。 map() 也返回一个数组，而这个数组的 每一项都是在原始数组中的对应项上运行传入函数的结果 。例如，可以给数组中的每一项乘以 2，然后 返回这些乘积组成的数组 ，如下所示。 12345var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] 以上代码返回的数组中包含给每个数乘以 2 之后的结果。这个方法适合创建包含的项与另一个数组一一对应的数组。 最后一个方法是 forEach() ，它只是 对数组中的每一项运行传入的函数 。这个方法没有返回值，本质上 与使用 for 循环迭代数组一样 。来看一个例子。 1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;); 这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。支持这些迭代方法的浏览器有 IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。 归并方法ECMAScript 5 还新增了两个归并数组的方法： reduce() 和 reduceRight() 。这两个方法都会 迭代数组的所有项 ，然后 构建一个最终返回的值 。其中， reduce() 方法从数组的第一项开始，逐个遍历到最后 。而 reduceRight() 则从数组的最后一项开始，向前遍历到第一项 。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce() 和 reduceRight() 的函数接收 4 个参数：前一个值 、当前值 、项的索引 和 数组对象 。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 使用 reduce() 方法可以执行 求数组中所有值之和 的操作，比如： 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); //15 第一次执行回调函数， prev 是 1， cur 是 2。第二次， prev 是 3（1 加 2 的结果）， cur 是 3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。 reduceRight() 的作用类似，只不过方向相反而已。来看下面这个例子。 12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); //15 在这个例子中，第一次执行回调函数， prev 是 5， cur 是 4。当然，最终结果相同，因为执行的都是简单相加的操作。 使用 reduce() 还是 reduceRight() ，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。 支持这两个归并函数的浏览器有 IE9+、Firefox 3+、Safari 4+、Opera 10.5 和 Chrome。 Date 类型ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此， Date 类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1月 1 日之前或之后的 285 616 年。 要创建一个日期对象，使用 new 操作符和 Date 构造函数 即可，如下所示。 1var now = new Date(); 在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript 提供了两个方法： Date.parse() 和 Date.UTC() 。 其中， Date.parse() 方法 接收一个表示 日期的字符串 参数，然后 尝试根据这个字符串返回相应日期的毫秒数 。ECMA-262 没有定义 Date.parse() 应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式： “月/日/年”，如 6/13/2004； “英文月名 日,年”，如 January 12,2004； “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700。 ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ（例如 2004-05-25T00:00:00）。只有兼容 ECMAScript 5的实现支持这种格式。 例如，要为 2004 年 5 月 25 日创建一个日期对象，可以使用下面的代码： 1var someDate = new Date(Date.parse("May 25, 2004")); 如果传入 Date.parse() 方法 的 字符串不能表示日期 ，那么它会 返回 NaN 。实际上，如果直接 将表示日期的字符串传递给 Date 构造函数 ，也会在后台调用 Date.parse() 。换句话说，下面的代码与前面的例子是等价的： 1var someDate = new Date("May 25, 2004"); 这行代码将会得到与前面相同的日期对象。 日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超出范围的值替换成当前的值，以便生成输出。例如，在解析 “January 32, 2007”时，有的浏览器会将其解释为 “February 1, 2007” 。而 Opera 则倾向于插入当前月份的当前日期，返回 “January 当前日期， 2007” 。也就是说，如果在 2007 年 9 月 21 日运行前面的代码，将会得到 “January 21, 2007” （都是 21 日）。 Date.UTC() 方法 同样也返回表示 日期的毫秒数 ，但它与 Date.parse() 在构建值时使用不同的信息。 Date.UTC() 的参数分别是 年份 、基于 0 的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（1 到 31）、小时数（0 到 23）、分钟 、秒 以及 毫秒数 。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。以下是两个使用 Date.UTC() 方法的例子： 12345// GMT 时间 2000 年 1 月 1 日午夜零时var y2k = new Date(Date.UTC(2000, 0));// GMT 时间 2005 年 5 月 5 日下午 5:55:55var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); 这个例子创建了两个日期对象。第一个对象表示 GMT 时间 2000 年 1 月 1 日午夜零时，传入的值一个是表示年份的 2000，一个是表示月份的 0（即一月份）。因为其他参数是自动填充的（即月中的天数为 1，其他所有参数均为 0），所以结果就是该月第一天的午夜零时。第二个对象表示 GMT 时间 2005 年 5 月 5 日下午 5:55:55，即使日期和时间中只包含 5，也需要传入不一样的参数：月份必须是 4（因为月份是基于 0 的）、小时必须设置为 17（因为小时以 0 到 23 表示），剩下的参数就很直观了。 如同模仿 Date.parse() 一样， Date 构造函数也会模仿 Date.UTC() ，但有一点明显不同：日期和时间都基于本地时区而非 GMT 来创建。不过， Date 构造函数接收的参数仍然与 Date.UTC() 相同 。 因此，如果第一个参数是数值， Date 构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。据此，可以将前面的例子重写如下。 12345// 本地时间 2000 年 1 月 1 日午夜零时var y2k = new Date(2000, 0);// 本地时间 2005 年 5 月 5 日下午 5:55:55var allFives = new Date(2005, 4, 5, 17, 55, 55); 以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时区创建的。 ECMAScript 5 添加了 Data.now() 方法 ，返回表示 调用这个方法时的日期和时间的毫秒数 。这个方法简化了使用 Data 对象分析代码的工作。例如： 123456789//取得开始时间var start = Date.now();//调用函数doSomething();//取得停止时间var stop = Date.now(),result = stop – start; 支持 Data.now() 方法的浏览器包括 IE9+、Firefox 3+、Safari 3+、Opera 10.5 和 Chrome。在不支持它的浏览器中，使用+操作符把 Data 对象转换成字符串，也可以达到同样的目的。 12345678//取得开始时间var start = +new Date();//调用函数doSomething();//取得停止时间var stop = +new Date(),result = stop - start; 继承的方法与其他引用类型一样， Date 类型也重写了 toLocaleString() 、 toString() 和 valueOf() 方法；但这些方法返回的值与其他类型中的方法不同。 Date 类型的 toLocaleString() 方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含 AM 或 PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而 toString() 方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是 0 到 23）表示。下面给出了在不同浏览器中调用toLocaleString() 和 toString() 方法，输出 PST（Pacific Standard Time，太平洋标准时间）时间 2007 年 2 月 1 日午夜零时的结果。 1234567891011121314151617181920Internet Explorer 8toLocaleString() — Thursday, February 01, 2007 12:00:00 AMtoString() — Thu Feb 1 00:00:00 PST 2007Firefox 3.5toLocaleString() — Thursday, February 01, 2007 12:00:00 AMtoString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)Safari 4toLocaleString() — Thursday, February 01, 2007 00:00:00toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)Chrome 4toLocaleString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)toString() — Thu Feb 01 2007 00:00:00 GMT-0800 (Pacific Standard Time)Opera 10toLocaleString() — 2/1/2007 12:00:00 AMtoString() — Thu, 01 Feb 2007 00:00:00 GMT-0800` 显然，这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，toLocaleString() 和 toString() 的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。 至于 Date 类型的 valueOf() 方法 ，则根本不返回字符串，而是返回 日期的毫秒 表示。因此，可以方便使用比较操作符（小于或大于）来比较日期值 。请看下面的例子。 12345var date1 = new Date(2007, 0, 1); //"January 1, 2007"var date2 = new Date(2007, 1, 1); //"February 1, 2007"alert(date1 &lt; date2); //truealert(date1 &gt; date2); //false 从逻辑上讲，2007 年 1 月 1 日要早于 2007 年 2 月 1 日，此时如果我们说前者小于后者比较符合常理。而表示 2007 年 1 月 1 日的毫秒值小于表示 2007 年 2 月 1日的毫秒值，因此在首先使用小于操作符比较日期时，返回的结果是 true 。这样，就为我们比较日期提供了极大方便。 日期格式化方法Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。 toDateString() ——以特定于实现的格式显示星期几、月、日和年； toTimeString() ——以特定于实现的格式显示时、分、秒和时区； toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年； toLocaleTimeString() ——以特定于实现的格式显示时、分、秒； toUTCString() ——以特定于实现的格式完整的 UTC 日期。 与 toLocaleString() 和 toString() 方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。 除了前面介绍的方法之外，还有一个名叫 toGMTString() 的方法，这是一个与toUTCString() 等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript 推荐现在编写的代码一律使用 toUTCString() 方法。 日期/时间组件方法到目前为止，剩下还未介绍的 Date 类型的方法（如下表所示），都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC 日期指的是在没有时区偏差的情况下（将日期转换为 GMT 时间）的日期值。 RegExp 类型ECMAScript 通过 RegExp 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正则表达式。 1var expression = / pattern / flags ; 其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含 字符类 、 限定符 、分组 、向前查找 以及 反向引用** 。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。 正则表达式的匹配模式支持下列 3 个标志。 g ：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； i ：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写； m ：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。 因此，一个正则表达式就是一个模式与上述 3 个标志的组合体。不同组合产生不同结果 ，如下面的例子所示。 1234567891011121314/** 匹配字符串中所有"at"的实例*/var pattern1 = /at/g;/** 匹配第一个"bat"或"cat"，不区分大小写*/var pattern2 = /[bc]at/i;/** 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写*/var pattern3 = /.at/gi; 与其他语言中的正则表达式类似，模式中使用的 所有元字符都必须转义 。正则表达式中的元字符包括： 1( [ &#123; \ ^ $ | ) ? * + .]&#125; 这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。下面给出几个例子。 12345678910111213141516171819/** 匹配第一个"bat"或"cat"，不区分大小写*/var pattern1 = /[bc]at/i;/** 匹配第一个" [bc]at"，不区分大小写*/var pattern2 = /\[bc\]at/i;/** 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写*/var pattern3 = /.at/gi;/** 匹配所有".at"，不区分大小写*/var pattern4 = /\.at/gi; 在上面的例子中， pattern1 匹配第一个 “bat” 或 “cat” ，不区分大小写。而要想直接匹配 “[bc]at” 的话，就需要像定义 pattern2 一样，对其中的两个方括号进行转义。对于 pattern3 来说，句点表示位于 “at” 之前的任意一个可以构成匹配项的字符。但如果想匹配 “.at” ，则必须对句点本身进行转义，如 pattern4 所示。 前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用 RegExp 构造函数 ，它接收两个参数：一个是要 匹配的字符串模式 ，另一个是可选的 标志字符串 。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示。 123456789/** 匹配第一个"bat"或"cat"，不区分大小写*/var pattern1 = /[bc]at/i;/** 与 pattern1 相同，只不过是使用构造函数创建的*/var pattern2 = new RegExp("[bc]at", "i"); 在此， pattern1 和 pattern2 是两个完全等价的正则表达式。要注意的是，传递给 RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给 RegExp 构造函数）。由于 RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如 \n （字符\在字符串中通常被转义为\，而在正则表达式字符串中就会变成\\）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用 RegExp 构造函数定义相同模式时使用的字符串。 使用正则表达式字面量和使用 RegExp 构造函数创建的正则表达式不一样。在 ECMAScript 3 中，正则表达式字面量始终会共享同一个 RegExp 实例 ，而使用 构造函数创建的每一个新 RegExp 实例都是一个新实例 。来看下面的例子。 123456789101112var re = null, i; for (i=0; i &lt; 10; i++)&#123; re = /cat/g; re.test("catastrophe");&#125;for (i=0; i &lt; 10; i++)&#123; re = new RegExp("cat", "g"); re.test("catastrophe");&#125; 在第一个循环中，即使是循环体中指定的，但实际上只为 /cat/ 创建了一个 RegExp 实例。由于实例属性（下一节介绍实例属性）不会重置，所以在循环中再次调用 test() 方法会失败。这是因为第一次调用 test() 找到了 “cat” ，但第二次调用是从索引为 3 的字符（上一次匹配的末尾）开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用 test() 就又从开头开始了。 第二个循环使用 RegExp 构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的 RegExp 实例，所以每次调用 test() 都会返回 true 。 ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用 RegExp 构造函数一样，每次都创建新的 RegExp 实例。IE9+、Firefox 4+和 Chrome 都据此做出了修改。 RegExp 实例属性RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。 global ：布尔值，表示是否设置了 g 标志。 ignoreCase ：布尔值，表示是否设置了 i 标志。 lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。 multiline ：布尔值，表示是否设置了 m 标志。 source ：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。例如： 123456789101112131415var pattern1 = /\[bc\]at/i;alert(pattern1.global); //falsealert(pattern1.ignoreCase); //truealert(pattern1.multiline); //falsealert(pattern1.lastIndex); //0alert(pattern1.source); //"\[bc\]at"var pattern2 = new RegExp("\\[bc\\]at", "i");alert(pattern2.global); //falsealert(pattern2.ignoreCase); //truealert(pattern2.multiline); //falsealert(pattern2.lastIndex); //0alert(pattern2.source); //"\[bc\]at" 我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了 RegExp 构造函数，但它们的 source 属性是相同的。可见， source 属性保存的是规范形式的字符串，即 字面量形式所用的字符串 。 RegExp 实例方法RegExp 对象的主要方法是 exec() ，该方法是专门为 捕获组 而设计的。 exec() 接受一个参数，即要应用 模式的字符串 ，然后返回 包含第一个匹配项信息的数组 ；或者在 没有匹配项的情况下返回 null 。返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input 。其中， index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。请看下面的例子。 123456789var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);alert(matches.index); // 0alert(matches.input); // "mom and dad and baby"alert(matches[0]); // "mom and dad and baby"alert(matches[1]); // " and dad and baby"alert(matches[2]); // " and baby" 这个例子中的模式包含两个捕获组。最内部的捕获组匹配 “and baby” ，而包含它的捕获组匹配 “and dad” 或者 “and dad and baby” 。当把字符串传入 exec() 方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组 matchs 的 index 属性值为 0。数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。 对于 exec() 方法而言，即使在模式中设置了全局标志（ g ），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新匹配项，如下面的例子所示。 123456789101112131415161718192021222324var text = "cat, bat, sat, fat";var pattern1 = /.at/;var matches = pattern1.exec(text);alert(matches.index); //0alert(matches[0]); //catalert(pattern1.lastIndex); //0matches = pattern1.exec(text);alert(matches.index); //0alert(matches[0]); //catalert(pattern1.lastIndex); //0var pattern2 = /.at/g;var matches = pattern2.exec(text);alert(matches.index); //0alert(matches[0]); //catalert(pattern2.lastIndex); //3matches = pattern2.exec(text);alert(matches.index); //5alert(matches[0]); //batalert(pattern2.lastIndex); //8 这个例子中的第一个模式 pattern1 不是全局模式，因此每次调用 exec() 返回的都是第一个匹配项（ “cat” ）。而第二个模式 pattern2 是全局模式，因此每次调用 exec() 都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的 lastIndex 属性的变化情况。在全局匹配模式下， lastIndex 的值在每次调用 exec() 后都会增加，而在非全局模式下则始终保持不变。 IE 的 JavaScript 实现在 lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex 属性每次也会变化。 正则表达式的第二个方法是 test() ，它接受一个字符串参数。在模式与该参数匹配的情况下返回 true ；否则，返回 false 。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此， test() 方法经常被用在 if 语句中 ，如下面的例子所示。 12345var text = "000-00-0000";var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if (pattern.test(text))&#123; alert("The pattern was matched.");&#125; 在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为什么无效就无关紧要了。 RegExp 实例继承的 toLocaleString() 和 toString() 方法都会返回 正则表达式的字面量 ，与创建正则表达式的方式无关。例如： 123var pattern = new RegExp("\\[bc\\]at", "gi");alert(pattern.toString()); // /\[bc\]at/gialert(pattern.toLocaleString()); // /\[bc\]at/gi 即使上例中的模式是通过调用 RegExp 构造函数创建的，但 toLocaleString() 和 toString()方法仍然会像它是以字面量形式创建的一样显示其字符串表示。 正则表达式的 valueOf() 方法返回正则表达式本身。 RegExp 构造函数属性RegExp 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名（Opera 是例外，它不支持短属性名）。下表列出了 RegExp 构造函数的属性。 使用这些属性可以从 exec() 或 test() 执行的操作中提取出更具体的信息。请看下面的例子。 123456789101112131415var text = "this has been a short summer";var pattern = /(.)hort/g;/** 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性* Internet Explorer 不支持 multiline 属性*/if (pattern.test(text))&#123; alert(RegExp.input); // this has been a short summer alert(RegExp.leftContext); // this has been a alert(RegExp.rightContext); // summer alert(RegExp.lastMatch); // short alert(RegExp.lastParen); // s alert(RegExp.multiline); // false&#125; 以上代码创建了一个模式，匹配任何一个字符后跟 hort ，而且把第一个字符放在了一个捕获组中。RegExp 构造函数的各个属性返回了下列值： input 属性返回了原始字符串； leftContext 属性返回了单词 short 之前的字符串，而 rightContext 属性则返回了 short之后的字符串； lastMatch 属性返回最近一次与整个正则表达式匹配的字符串，即 short ； lastParen 属性返回最近一次匹配的捕获组，即例子中的 s 。 如前所述，例子使用的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都不是有效的 ECMAScript 标识符，因此必须通过 方括号语法 来访问它们，如下所示。 123456789101112131415var text = "this has been a short summer";var pattern = /(.)hort/g;/** 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性* Internet Explorer 不支持 multiline 属性*/if (pattern.test(text))&#123; alert(RegExp.$_); // this has been a short summer alert(RegExp["$`"]); // this has been a alert(RegExp["$'"]); // summer alert(RegExp["$&amp;"]); // short alert(RegExp["$+"]); // s alert(RegExp["$*"]); // false&#125; 除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语法是 RegExp.$1 、 RegExp.$2 … RegExp.$9 ，分别用于存储第一、第二……第九个匹配的捕获组。在调用 exec() 或 test() 方法时，这些属性会被自动填充。然后，我们就可以像下面这样来使用它们。 123456var text = "this has been a short summer";var pattern = /(..)or(.)/g;if (pattern.test(text))&#123; alert(RegExp.$1); //sh alert(RegExp.$2); //t&#125; 这里创建了一个包含两个捕获组的模式，并用该模式测试了一个字符串。即使 test() 方法只返回一个布尔值，但 RegExp 构造函数的属性 $1 和 $2 也会被匹配相应捕获组的字符串自动填充。 模式的局限性尽管 ECMAScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是 Perl）所支持的高级正则表达式特性。下面列出了 ECMAScript 正则表达式不支持的特性（要了解更多相关信息，请访问 www.regular-expressions.info ）。 匹配字符串开始和结尾的 \A 和 \Z 锚（但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。） 向后查找（lookbehind）（但完全支持向前查找（lookahead）。） 并集和交集类 原子组（atomic grouping） Unicode 支持（单个字符除外，如 \uFFFF ） 命名的捕获组（但支持编号的捕获组。） s （single，单行）和 x （free-spacing，无间隔）匹配模式 条件匹配 正则表达式注释 即使存在这些限制，ECMAScript 正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹配任务。 Function 类型说起来 ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数 实际上是 对象 。每个函数都是 Function 类型的实例 ，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此 函数名 实际上也是一个指向函数对象的指针 ，不会与某个函数绑定。函数通常是使用 函数声明 语法定义的，如下面的例子所示。 123function sum (num1, num2) &#123; return num1 + num2;&#125; 这与下面使用 函数表达式 定义函数的方式几乎相差无几。 123var sum = function(num1, num2)&#123; return num1 + num2;&#125;; 以上代码定义了变量 sum 并将其初始化为一个函数。有读者可能会注意到，function 关键字后面没有函数名 。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量 sum 即可以引用函数 。另外，还要注意 函数末尾有一个分号 ，就像 声明其他变量时一样 。 最后一种定义函数的方式是使用 Function 构造函数 。 Function 构造函数可以接收 任意数量的参数 ，但 最后一个参数始终都被看成是函数体 ，而 前面的参数则枚举出了新函数的参数 。来看下面的例子： 1var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐 从技术角度讲，这是一个函数表达式。但是，我们 不推荐 读者使用这种方法定义函数，因为这种语法会 导致解析两次代码（第一次是解析常规 ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。 由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字 ，如下面的例子所示。 12345678910function sum(num1, num2)&#123; return num1 + num2;&#125;alert(sum(10,10)); //20var anotherSum = sum;alert(anotherSum(10,10)); //20sum = null;alert(anotherSum(10,10)); //20 以上代码首先定义了一个名为 sum() 的函数，用于求两个值的和。然后，又声明了变量 anotherSum ，并将其设置为与 sum 相等（将 sum 的值赋给 anotherSum ）。注意，使用不带圆括号的函数名是访问函数指针，而非调用函数。此时， anotherSum 和 sum 就都指向了同一个函数，因此 anotherSum() 也可以被调用并返回结果。即使 将 sum 设置为 null ，让它与函数“断绝关系” ，但仍然可以正常调用 anotherSum() 。 没有重载（深入理解）将函数名想象为指针，也有助于理解为什么 ECMAScript 中 没有函数重载 的概念。以下是曾在第 3章使用过的例子。 123456789function addSomeNumber(num)&#123; return num + 100;&#125;function addSomeNumber(num) &#123; return num + 200;&#125;var result = addSomeNumber(100); //300 显然，这个例子中声明了两个同名函数，而结果则是 后面的函数覆盖了前面的函数 。以上代码实际上与下面的代码没有什么区别。 123456789var addSomeNumber = function (num)&#123; return num + 100;&#125;;addSomeNumber = function (num) &#123; return num + 200;&#125;;var result = addSomeNumber(100); //300 通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——在创建第二个函数时 ，实际上覆盖了引用第一个函数的变量 addSomeNumber 。 函数声明与函数表达式本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率 先读取函数声明 ，并 使其在执行任何代码之前可用（可以访问）；至于 函数表达式 ，则 必须等到解析器执行到它所在的代码行，才会真正被解释执行 。请看下面的例子。 1234alert(sum(10,10));function sum(num1, num2)&#123; return num1 + num2;&#125; 以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为 函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中 。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到 源代码树的顶部 。所以，即使声明函数的代码在调用它的代码后面 ，JavaScript 引擎也能把函数声明提升到顶部 。如果像下面例子所示的，把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误。 1234alert(sum(10,10));var sum = function(num1, num2)&#123; return num1 + num2;&#125;; 以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前 ，变量 sum 中不会保存有对函数的引用 ；而且，由于 第一行代码就会导致“unexpected identifier”（意外标识符）错误 ，实际上也不会执行到下一行。 除了 什么时候可以通过变量访问函数 这一点区别之外，函数声明与函数表达式的语法其实是等价的。 也可以同时使用函数声明和函数表达式，例如 var sum = function sum(){} 。不过，这种语法在 Safari 中会导致错误。 作为值的函数因为 ECMAScript 中的函数名本身就是变量，所以 函数也可以作为值来使用 。也就是说，不仅 可以像传递参数一样把一个函数传递给另一个函数 ，而且 可以将一个函数作为另一个函数的结果返回 。来看一看下面的函数。 123function callSomeFunction(someFunction, someArgument)&#123; return someFunction(someArgument);&#125; 这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。 123456789101112function add10(num)&#123; return num + 10;&#125;var result1 = callSomeFunction(add10, 10);alert(result1); //20function getGreeting(name)&#123; return "Hello, " + name;&#125;var result2 = callSomeFunction(getGreeting, "Nicholas");alert(result2); //"Hello, Nicholas" 这里的 callSomeFunction() 函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给 callSomeFunction() 的是 add10 和 getGreeting ，而不是执行它们之后的结果。 当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 sort() 方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。 1234567891011121314function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个 return 操作符。在内部函数接收到 propertyName 参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。 1234567var data = [&#123;name: "Zachary", age: 28&#125;, &#123;name: "Nicholas", age: 29&#125;];data.sort(createComparisonFunction("name"));alert(data[0].name); //Nicholasdata.sort(createComparisonFunction("age"));alert(data[0].name); //Zachary 这里，我们创建了一个包含两个对象的数组 data 。其中，每个对象都包含一个 name 属性和一个 age 属性。在默认情况下， sort() 方法会调用每个对象的 toString() 方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用 createComparisonFunction(“name”) 方法创建了一个比较函数，以便按照每个对象的 name 属性值进行排序。而结果排在前面的第一项是 name为 “Nicholas” ， age 是 29 的对象。然后，我们又使用了 createComparisonFunction(“age”) 返回的比较函数，这次是按照对象的 age 属性排序。得到的结果是 name 值为 “Zachary” ， age 值是 28的对象排在了第一位。 函数内部属性在函数内部，有两个特殊的对象： arguments 和 this 。其中， arguments 在第 3 章曾经介绍过，它是一个 类数组对象 ，包含着传入函数中的所有参数 。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性 ，该属性是一个指针，指向拥有这个 arguments 对象的函数 。请看下面这个非常经典的阶乘函数。 1234567function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125;&#125; 定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了 消除这种紧密耦合的现象 ，可以像下面这样使用 arguments.callee 。 1234567function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125; 在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial 。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如： 1234567var trueFactorial = factorial;factorial = function()&#123; return 0;&#125;;alert(trueFactorial(5)); //120alert(factorial(5)); //0 在此，变量 trueFactorial 获得了 factorial 的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回 0 的函数赋值给 factorial 变量。如果像原来的 factorial()那样不使用 arguments.callee ，调用 trueFactorial() 就会返回 0。可是，在解除了函数体内的代码与函数名的耦合状态之后， trueFactorial() 仍然能够正常地计算阶乘；至于 factorial() ，它现在只是一个返回 0 的函数。 函数内部的另一个特殊对象是 this ，其行为与 Java 和 C#中的 this 大致类似。换句话说， this 引用的是 函数据以执行的环境对象 ——或者也可以说是 this 值（当在网页的 全局作用域中调用函数 时，this 对象引用的就是 window ）。来看下面的例子。 1234567891011window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //"red"o.sayColor = sayColor;o.sayColor(); //"blue" 上面这个函数 sayColor() 是在全局作用域中定义的，它引用了 this 对象。由于 在调用函数之前 ，this 的值并不确定 ，因此 this 可能会在代码执行过程中引用不同的对象。当 在全局作用域中调用 sayColor() 时， this 引用的是全局对象 window ；换句话说，对 this.color 求值会转换成对 window.color 求值 ，于是结果就返回了 “red” 。而当 把这个函数赋给对象 o 并调用 o.sayColor() 时， this 引用的是对象 o ，因此对 this.color 求值会转换成对 o.color 求值，结果就返回了 “blue” 。 请读者一定要牢记，函数的名字 仅仅是 一个包含指针的变量而已 。因此，即使是在不同的环境中执行，全局的 sayColor() 函数与 o.sayColor() 指向的仍然是同一个函数 。 ECMAScript 5 也规范化了另一个函数对象的属性： caller 。除了 Opera 的早期版本不支持，其他浏览器都支持这个 ECMAScript 3 并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是 在全局作用域中调用当前函数 ，它的 值为 null 。例如： 123456789function outer()&#123; inner();&#125;function inner()&#123; alert(inner.caller);&#125;outer(); 以上代码会导致警告框中显示 outer() 函数的源代码。因为 outer() 调用了 inter() ，所以 inner.caller 就指向 outer() 。为了实现更松散的耦合，也 可以通过 arguments.callee.caller 来访问相同的信息 。 123456789function outer()&#123; inner();&#125;function inner()&#123; alert(arguments.callee.caller);&#125;outer(); IE、Firefox、Chrome 和 Safari 的所有版本以及 Opera 9.6 都支持 caller 属性。当函数在严格模式下运行时，访问 arguments.callee 会导致错误。ECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined 。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。 严格模式还有一个限制：不能为函数的 caller 属性赋值 ，否则会导致错误。 函数属性和方法前面曾经提到过，ECMAScript 中的 函数是对象 ，因此 函数也有属性和方法 。每个函数都包含两个属性： length 和 prototype 。其中， length 属性 表示 函数希望接收的命名参数的个数 ，如下面的例子所示。 12345678910111213function sayName(name)&#123; alert(name);&#125;function sum(num1, num2)&#123; return num1 + num2;&#125;function sayHi()&#123; alert("hi");&#125;alert(sayName.length); //1alert(sum.length); //2alert(sayHi.length); //0 以上代码定义了 3 个函数，但每个函数接收的命名参数个数不同。首先， sayName() 函数定义了一个参数，因此其 length 属性的值为 1。类似地， sum() 函数定义了两个参数，结果其 length 属性中保存的值为 2。而 sayHi() 没有命名参数，所以其 length 值为 0。 在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性 了。对于 ECMAScript 中的引用类型而言， prototype 是保存它们所有实例方法的真正所在 。换句话说，诸如 toString() 和 valueOf() 等方法实际上都保存在 prototype 名下 ，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时， prototype 属性的作用是极为重要的（第 6 章将详细介绍）。在 ECMAScript 5 中， prototype 属性是不可枚举的，因此使用 for-in 无法发现。 每个函数都包含两个非继承而来的方法： apply() 和 call() 。这两个方法的用途都是 在特定的作用域中调用函数 ，实际上等于 设置函数体内 this 对象的值 。首先， apply() 方法 接收两个参数：一个是 在其中运行函数的作用域 ，另一个是 参数数组 。其中，第二个参数可以是 Array 的实例 ，也可以是 arguments 对象 。例如： 1234567891011121314function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); // 传入 arguments 对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); // 传入数组&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20 在上面这个例子中， callSum1() 在执行 sum() 函数时传入了 this 作为 this 值（因为是在全局作用域中调用的，所以传入的就是 window 对象）和 arguments 对象。而 callSum2 同样也调用了 sum() 函数，但它传入的则是 this 和一个参数数组。这两个函数都会正常执行并返回正确的结果。 在 严格模式 下，未指定环境对象而调用函数，则 this 值不会转型为 window 。除非明确把函数添加到某个对象或者调用 apply() 或 call() ，否则 this 值将是 undefined 。 call() 方法 与 apply() 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是 this 值没有变化 ，变化的是 其余参数都直接传递给函数 。换句话说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来 ，如下面的例子所示。 123456789function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125;alert(callSum(10,10)); //20 在使用 call() 方法的情况下， callSum() 必须明确地传入每一个参数。结果与使用 apply() 没有什么不同。至于是使用 apply() 还是 call() ，完全取决于你采取哪种给函数传递参数的方式最方便。 如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply()肯定更方便；否则，选择 call() 可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。） 事实上，传递参数 并非 apply() 和 call() 真正的用武之地；它们真正强大的地方是 能够扩充函数赖以运行的作用域 。下面来看一个例子。 123456789101112window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue 这个例子是在前面说明 this 对象的示例基础上修改而成的。这一次， sayColor() 也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示 “red” ——因为对 this.color 的求值会转换成对 window.color 的求值。而 sayColor.call(this) 和 sayColor.call(window) ，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示 “red” 。但是，当运行 sayColor.call(o) 时，函数的执行环境就不一样了，因为此时函数体内的 this 对象指向了 o ，于是结果显示的是 “blue” 。 使用 call() （或 apply() ）来扩充作用域的最大好处，就是 对象不需要与方法有任何耦合关系 。 在前面例子的第一个版本中，我们是先将 sayColor() 函数放到了对象 o 中，然后再通过 o 来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。 ECMAScript 5 还定义了一个方法： bind() 。这个方法会 创建一个函数的实例 ，其 this 值会被绑定到传给 bind() 函数的值 。例如： 123456789window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 在这里， sayColor() 调用 bind() 并传入对象 o ，创建了 o bjectSayColor() 函数 。 objectSayColor() 函数的 this 值等于 o ，因此 即使是在全局作用域中调用这个函数 ，也会看到 “blue” 。这种技巧的优点请参考第 22 章。 支持 bind() 方法的浏览器有 IE9+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome。 每个函数继承的 toLocaleString() 和 toString() 方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf() 方法同样也只返回函数代码。 基本包装类型为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型： Boolean 、 Number 和 String 。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 实际上，每当读取一个基本类型值的时候 ，后台就会 创建一个对应的基本包装类型的对象 ，从而让我们 能够调用一些方法来操作这些数据 。来看下面的例子。 12var s1 = "some text";var s2 = s1.substring(2); 这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的 substring() 方法 ，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。 (1) 创建 String 类型的一个实例；(2) 在实例上调用指定的方法；(3) 销毁这个实例。 可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。 123var s1 = new String("some text");var s2 = s1.substring(2);s1 = null; 经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。 引用类型 与 基本包装类型 的主要区别就是 对象的生存期 。使用 new 操作符创建的引用类型的实例 在 执行流离开当前作用域之前都一直保存在内存中 。而 自动创建的基本包装类型的对象 ，则 只存在于一行代码的执行瞬间 ，然后 立即被销毁 。这意味着我们 不能在运行时为基本类型值添加属性和方法 。来看下面的例子： 123var s1 = "some text";s1.color = "red";alert(s1.color); //undefined 在此，第二行代码试图为字符串 s1 添加一个 color 属性。但是，当第三行代码再次访问 s1 时，其 color 属性不见了。问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。 第三行代码又创建自己的 String 对象，而该对象没有 color 属性。 当然，可以显式地调用 Boolean 、 Number 和 String 来创建基本包装类型的对象 。不过，应该 在绝对必要的情况下再这样做 ，因为 这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值 。对 基本包装类型的实例 调用 typeof 会返回 “object” ，而且 所有基本包装类型的对象都会被转换为布尔值 true 。 Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如： 12var obj = new Object("some text");alert(obj instanceof String); //true 把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到 Number 的实例，传入布尔值参数就会得到 Boolean 的实例。 要注意的是，使用 new 调用基本包装类型的构造函数 ，与直接 调用同名的转型函数 是不一样的。例如： 123456var value = "25";var number = Number(value); //转型函数alert(typeof number); //"number"var obj = new Number(value); //构造函数alert(typeof obj); //"object" 在这个例子中，变量 number 中保存的是基本类型的值 25 ，而 变量 obj 中保存的是 Number 的实例 。要了解有关转型函数的更多信息，请参考第 3 章。 尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。 Boolean 类型Boolean 类型是与布尔值对应的引用类型。要创建 Boolean 对象，可以像下面这样调用 Boolean 构造函数并传入 true 或 false 值。 1var booleanObject = new Boolean(true); Boolean 类型的实例重写了 valueOf() 方法 ，返回 基本类型值 true 或 false ；重写了 toString() 方法 ，返回字符串 “true” 和 “false” 。可是， Boolean 对象在 ECMAScript 中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象，例如： 1234567var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;alert(result); //truevar falseValue = false;result = falseValue &amp;&amp; true;alert(result); //false 在这个例子中，我们使用 false 值创建了一个 Boolean 对象。然后，将这个对象与基本类型值 true 构成了逻辑与表达式。在布尔运算中， false &amp;&amp; true 等于 false 。可是，示例中的这行代码是对 falseObject 而不是对它的值（ false ）进行求值。前面讨论过，布尔表达式中的所有对象都会被转换为 true ，因此 falseObject 对象在布尔表达式中代表的是 true 。结果， true &amp;&amp; true 当然就等于 true 了。 基本类型与引用类型的布尔值还有两个区别。首先，typeof 操作符对基本类型返回 “boolean” ，而对引用类型返回 “object” 。其次，由于 Boolean 对象是 Boolean 类型的实例，所以 使用 instanceof 操作符测试 Boolean 对象会返回 true ，而测试基本类型的布尔值则返回 false 。例如： 1234alert(typeof falseObject); //objectalert(typeof falseValue); //booleanalert(falseObject instanceof Boolean); //truealert(falseValue instanceof Boolean); //false 理解基本类型的布尔值与 Boolean 对象之间的区别非常重要——当然，我们的建议是 永远不要使用 Boolean 对象 。 Number 类型Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其中传递相应的数值 。下面是一个例子。 1var numberObject = new Number(10); 与 Boolean 类型一样， Number 类型也重写了 valueOf() 、 toLocaleString() 和 toString() 方法。重写后的 valueOf() 方法 返回 对象表示的基本类型的数值 ，另外两个方法则返回 字符串形式的数值 。我们在第 3 章还介绍过，可以为 toString() 方法传递一个表示基数的参数 ，告诉它返回几进制数值的字符串形式，如下面的例子所示。 123456var num = 10;alert(num.toString()); //"10"alert(num.toString(2)); //"1010"alert(num.toString(8)); //"12"alert(num.toString(10)); //"10"alert(num.toString(16)); //"a" 除了继承的方法之外， Number 类型还提供了一些用于将数值格式化为字符串的方法。其中， toFixed() 方法 会 按照指定的小数位返回数值的字符串表示 ，例如： 12var num = 10;alert(num.toFixed(2)); //"10.00" 这里给 toFixed() 方法传入了数值 2 ，意思是显示几位小数。于是，这个方法返回了 “10.00” ，即以 0 填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入，如下面的例子所示。 12var num = 10.005;alert(num.toFixed(2)); //"10.01" 能够自动舍入的特性，使得 toFixed() 方法很适合处理货币值 。但需要注意的是，不同浏览器给这个方法设定的舍入规则可能会有所不同 。在给 toFixed() 传入 0 的情况下，IE8 及之前版本不能正确舍入范围在{(-0.94,-0.5],[ 0.5,0.94)}之间的值。对于这个范围内的值，IE 会返回 0，而不是-1 或 1；其他浏览器都能返回正确的值。IE9 修复了这个问题。 toFixed() 方法可以表示带有 0 到 20 个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数。 另外可用于格式化数值的方法是 toExponential() ，该方法返回 以指数表示法（也称 e 表示法）表示的数值的字符串形式。与 toFixed() 一样， toExponential() 也接收一个参数，而且该参数同样也是 指定输出结果中的小数位数 。看下面的例子。 12var num = 10;alert(num.toExponential(1)); //"1.0e+1" 以上代码输出了 “1.0e+1” ；不过，这么小的数值一般不必使用 e 表示法。如果你想得到表示 某个数值的最合适的格式 ，就应该使用 toPrecision() 方法 。 对于一个数值来说， toPrecision() 方法 可能会返回 固定大小（fixed）格式 ，也可能返回 指数（exponential）格式 ；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示 数值的所有数字的位数（不包括指数部分）。请看下面的例子。 1234var num = 99;alert(num.toPrecision(1)); //"1e+2"alert(num.toPrecision(2)); //"99"alert(num.toPrecision(3)); //"99.0" 以上代码首先完成的任务是以一位数来表示 99，结果是 “1e+2” ，即 100。因为一位数无法准确地表示 99，因此 toPrecision() 就将它向上舍入为 100，这样就可以使用一位数来表示它了。而接下来的用两位数表示 99，当然还是 “99” 。最后，在想以三位数表示 99时， toPrecision() 方法返回了 “99.0” 。 实际上， toPrecision() 会根据要处理的数值决定到底是调用 toFixed() 还是调用 toExponential() 。而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。 toPrecision() 方法可以表现 1 到 21 位小数。某些浏览器支持的范围更大，但这是典型实现的范围。 与 Boolean 对象类似， Number 对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化 Number 类型，而原因与显式创建 Boolean 对象一样。具体来讲，就是在 使用 typeof 和 instanceof 操作符测试基本类型数值与引用类型数值 时，得到的结果完全不同 ，如下面的例子所示。 123456var numberObject = new Number(10);var numberValue = 10;alert(typeof numberObject); //"object"alert(typeof numberValue); //"number"alert(numberObject instanceof Number); //truealert(numberValue instanceof Number); //false 在使用 typeof 操作符测试基本类型数值时，始终会返回 “number” ，而在测试 Number 对象时，则会返回 “object” 。类似地， Number 对象是 Number 类型的实例，而基本类型的数值则不是。 String 类型String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。 1var stringObject = new String("hello world"); String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf() 、 toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。 String 类型的每个实例都有一个 length 属性 ，表示 字符串中包含多个字符 。来看下面的例子。 12var stringValue = "hello world";alert(stringValue.length); //"11" 这个例子输出了字符串 “hello world” 中的字符数量，即 “11” 。应该注意的是，即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符 。 String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。 字符方法两个用于 访问字符串中特定字符 的方法是： charAt() 和 charCodeAt() 。这两个方法都接收一个参数，即 基于 0 的字符位置 。其中， charAt() 方法 以 单字符字符串 的形式返回 给定位置的那个字符（ECMAScript 中没有字符类型）。例如： 12var stringValue = "hello world";alert(stringValue.charAt(1)); //"e" 字符串 “hello world” 位置 1 处的字符是 “e” ，因此调用 charAt(1) 就返回了 “e” 。如果你想得到的不是字符而是 字符编码 ，那么就要像下面这样使用 charCodeAt() 了。 12var stringValue = "hello world";alert(stringValue.charCodeAt(1)); // 输出"101" 这个例子输出的是 “101” ，也就是小写字母 “e” 的字符编码。 ECMAScript 5 还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数字索引 来 访问字符串中的特定字符，如下面的例子所示。 12var stringValue = "hello world";alert(stringValue[1]); //"e" 使用方括号表示法访问个别字符的语法得到了 IE8 及 Firefox、Safari、Chrome 和 Opera 所有版本的支持。如果是在 IE7 及更早版本中使用这种语法，会返回 undefined 值（尽管根本不是特殊的 undefined 值）。 字符串操作方法下面介绍与操作字符串有关的几个方法。第一个就是 concat() ，用于 将一或多个字符串拼接起来 ，返回 拼接得到的新字符串 。先来看一个例子。 1234var stringValue = "hello ";var result = stringValue.concat("world");alert(result); //"hello world"alert(stringValue); //"hello" 在这个例子中，通过 stringValue 调用 concat() 方法返回的结果是 “hello world” ——但 stringValue 的值则保持不变。实际上， concat() 方法 可以接受 任意多个参数 ，也就是说可以通过它 拼接任意多个字符串 。再看一个例子： 1234var stringValue = "hello ";var result = stringValue.concat("world", "!");alert(result); //"hello world!"alert(stringValue); //"hello" 这个例子将 “world” 和 “!” 拼接到了 “hello” 的末尾。虽然 concat() 是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符（+）。而且，使用加号操作符在大多数情况下都比使用 concat()方法要简便易行（特别是在拼接多个字符串的情况下）。 ECMAScript还提供了三个 基于子字符串创建新字符串 的方法： slice() 、 substr() 和 substring() 。这三个方法都会返回 被操作字符串的一个子字符串 ，而且也都接受一或两个参数。第一个参数指定 子字符串的开始位置 ，第二个参数（在指定的情况下）表示 子字符串到哪里结束 。具体来说， slice() 和 substring() 的第二个参数指定的是 子字符串最后一个字符后面的位置 。而 substr() 的第二个参数指定的则是返回的 字符个数 。如果 没有给这些方法传递第二个参数 ，则 将字符串的长度作为结束位置 。与 concat() 方法一样， slice() 、 substr() 和 substring() 也 不会修改字符串本身的值 ——它们只是返回 一个基本类型的字符串值，对原始字符串没有任何影响 。请看下面的例子。 1234567var stringValue = "hello world";alert(stringValue.slice(3)); //"lo world"alert(stringValue.substring(3)); //"lo world"alert(stringValue.substr(3)); //"lo world"alert(stringValue.slice(3, 7)); //"lo w"alert(stringValue.substring(3,7)); //"lo w"alert(stringValue.substr(3, 7)); //"lo worl" 这个例子比较了以相同方式调用 slice() 、 substr() 和 substring() 得到的结果，而且多数情况下的结果是相同的。在只指定一个参数 3 的情况下，这三个方法都返回 “lo world” ，因为 “hello”中的第二个 “l” 处于位置 3。而在指定两个参数 3 和 7 的情况下， slice() 和 substring() 返回 “lo w”（ “world” 中的 “o” 处于位置 7，因此结果中不包含 “o” ），但 substr() 返回 “lo worl” ，因为它的第二个参数指定的是要返回的字符个数。 在传递给这些方法的参数是 负值 的情况下，它们的行为就不尽相同了。其中， slice() 方法 会将 传入的负值与字符串的长度相加 ， substr() 方法 将 负的第一个参数加上字符串的长度 ，而将 负的第二个参数转换为 0 。最后， substring() 方法 会把 所有负值参数都转换为 0 。下面来看例子。 1234567var stringValue = "hello world";alert(stringValue.slice(-3)); //"rld"alert(stringValue.substring(-3)); //"hello world"alert(stringValue.substr(-3)); //"rld"alert(stringValue.slice(3, -4)); //"lo w"alert(stringValue.substring(3, -4)); //"hel"alert(stringValue.substr(3, -4)); //"" （空字符串） 这个例子清晰地展示了上述三个方法之间的不同行为。在给 slice() 和 substr() 传递一个负值参数时，它们的行为相同。这是因为 -3 会被转换为 8 （字符串长度加参数 11+(-3)=8），实际上相当于调用了 slice(8) 和 substr(8) 。但 substring() 方法则返回了全部字符串，因为它将 -3 转换成了 0 。 IE 的 JavaScript 实现在处理向 substr() 方法传递负值的情况时存在问题，它会返回原始的字符串。IE9 修复了这个问题。 当第二个参数是负值时，这三个方法的行为各不相同。 slice() 方法会把第二个参数转换为 7，这就相当于调用了 slice(3,7) ，因此返回 “lo w” 。 substring() 方法会把第二个参数转换为 0，使调用变成了 substring(3,0) ，而由于这个方法会将较小的数作为开始位置，将较大的数作为结束位置，因此最终相当于调用了 substring(0,3) 。substr() 也会将第二个参数转换为 0，这也就意味着返回包含零个字符的字符串，也就是一个空字符串。 字符串位置方法有两个可以从字符串中查找子字符串的方法： indexOf() 和 lastIndexOf() 。这两个方法都是 从一个字符串中搜索给定的子字符串 ，然后 返子字符串的位置（如果没有找到该子字符串，则返回 -1 ）。 这两个方法的区别在于： indexOf() 方法从字符串的开头向后搜索子字符串 ，而 lastIndexOf() 方法是从字符串的末尾向前搜索子字符串 。还是来看一个例子吧。 123var stringValue = "hello world";alert(stringValue.indexOf("o")); //4alert(stringValue.lastIndexOf("o")); //7 子字符串 “o” 第一次出现的位置是 4，即 “hello” 中的 “o” ；最后一次出现的位置是 7，即 “world” 中的”o” 。如果 “o” 在这个字符串中仅出现了一次，那么 indexOf() 和 lastIndexOf() 会返回相同的位置值。 这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf() 会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而 lastIndexOf() 则会从指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。 123var stringValue = "hello world";alert(stringValue.indexOf("o", 6)); //7alert(stringValue.lastIndexOf("o", 6)); //4 在将第二个参数 6 传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于 indexOf() 是从位置 6（字母 “w” ）开始向后搜索，结果在位置 7 找到了 “o” ，因此它返回 7。而 lastIndexOf() 是从位置 6 开始向前搜索。结果找到了 “hello” 中的 “o” ，因此它返回 4。在使用第二个参数的情况下，可以通过循环调用 indexOf() 或 lastIndexOf() 来找到所有匹配的子字符串 ，如下面的例子所示： 12345678910var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";var positions = new Array();var pos = stringValue.indexOf("e");while(pos &gt; -1)&#123; positions.push(pos); pos = stringValue.indexOf("e", pos + 1);&#125;alert(positions); //"3,24,32,35,52" 这个例子通过不断增加 indexOf() 方法开始查找的位置，遍历了一个长字符串。在循环之外，首先找到了 “e” 在字符串中的初始位置；而进入循环后，则每次都给 indexOf() 传递上一次的位置加 1。 这样，就确保了 每次新搜索都从上一次找到的子字符串的后面开始 。每次搜索返回的位置依次被保存在数组 positions 中，以便将来使用。 trim() 方法ECMAScript 5 为所有字符串定义了 trim() 方法 。这个方法会 创建一个字符串的副本 ，删除前置及后缀的所有空格 ，然后 返回结果 。例如： 1234var stringValue = " hello world ";var trimmedStringValue = stringValue.trim();alert(stringValue); //" hello world "alert(trimmedStringValue); //"hello world" 由于 trim() 返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个方法的浏览器有 IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和 Chrome。此外，Firefox 3.5+、Safari 5+和 Chrome 8+还支持非标准的 trimLeft() 和 trimRight() 方法，分别 用于删除字符串开头和末尾的空格 。 字符串大小写转换方法接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript 中涉及字符串大小写转换的方法有 4 个： toLowerCase() 、 toLocaleLowerCase() 、 toUpperCase() 和 toLocaleUpperCase() 。 其中， toLowerCase() 和 toUpperCase() 是两个经典的方法，借鉴自 java.lang.String 中的同名方法。而 toLocaleLowerCase() 和 toLocaleUpperCase() 方法则是 针对特定地区的实现 。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。 12345var stringValue = "hello world";alert(stringValue.toLocaleUpperCase()); //"HELLO WORLD"alert(stringValue.toUpperCase()); //"HELLO WORLD"alert(stringValue.toLocaleLowerCase()); //"hello world"alert(stringValue.toLowerCase()); //"hello world" 以上代码调用的 toLocaleUpperCase() 和 toUpperCase() 都返回了 “HELLO WORLD” ，就像调用 toLocaleLowerCase() 和 toLowerCase() 都返回 “hello world” 一样。一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。 字符串的模式匹配方法String 类型定义了几个用于 在字符串中匹配模式 的方法。第一个方法就是 match() ，在字符串上调用这个方法，本质上 与调用 RegExp 的 exec() 方法相同 。 match() 方法 只接受一个参数，要么是一个 正则表达式 ，要么是 一个 RegExp 对象 。来看下面的例子。 12345678var text = "cat, bat, sat, fat";var pattern = /.at/;//与 pattern.exec(text)相同var matches = text.match(pattern);alert(matches.index); //0alert(matches[0]); //"cat"alert(pattern.lastIndex); //0 本例中的 match() 方法返回了一个数组；如果是调用 RegExp 对象的 exec() 方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串 ，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串 。 另一个用于查找模式的方法是 search() 。这个方法的唯一参数与 match() 方法的参数相同：由字符串或 RegExp 对象指定的一个 正则表达式 。 search() 方法返回字符串中第一个匹配项的索引 ；如果 没有找到匹配项 ，则 返回 -1 。而且， search() 方法始终是 从字符串开头向后查找模式 。看下面的例子。 123var text = "cat, bat, sat, fat";var pos = text.search(/at/);alert(pos); //1 这个例子中的 search() 方法返回 1 ，即 “at” 在字符串中第一次出现的位置。 为了简化 替换子字符串 的操作，ECMAScript 提供了 replace() 方法 。这个方法接受两个参数：第一个参数可以是一个 RegExp 对象 或者 一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个 字符串 或者一个 函数 。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（ g ）标志 ，如下所示。 123456var text = "cat, bat, sat, fat";var result = text.replace("at", "ond");alert(result); //"cond, bat, sat, fat"result = text.replace(/at/g, "ond");alert(result); //"cond, bond, sond, fond" 在这个例子中，首先传入 replace() 方法的是字符串 “at” 和替换用的字符串 “ond” 。替换的结果是把 “cat” 变成了 “cond” ，但字符串中的其他字符并没有受到影响。然后，通过将第一个参数修改为带有全局标志的正则表达式，就将全部 “at” 都替换成了 “ond” 。 如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中 。下表列出了 ECMAScript 提供的这些特殊的字符序列。 通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容，如下面的例子所示。 123var text = "cat, bat, sat, fat";result = text.replace(/(.at)/g, "word ($1)");alert(result); //word (cat), word (bat), word (sat), word (fat) 在此，每个以 “at” 结尾的单词都被替换了，替换结果是 “word” 后跟一对圆括号，而圆括号中是被字符序列 $1 所替换的单词。 replace() 方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace() 方法的第二个参数可以实现更加精细的替换操作，请看下面这个例子。 12345678910111213141516function htmlEscape(text)&#123; return text.replace(/[&lt;&gt;"&amp;]/g, function(match, pos, originalText)&#123; switch(match)&#123; case "&lt;": return "&amp;lt;"; case "&gt;": return "&amp;gt;"; case "&amp;": return "&amp;amp;"; case "\"": return "&amp;quot;"; &#125; &#125;);&#125;alert(htmlEscape("&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"));//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt; 这里，我们为插入 HTML 代码定义了函数 htmlEscape() ，这个函数能够转义 4 个字符：小于号、大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定义一个能够针对每个匹配的字符返回特定 HTML 实体的函数。 最后一个与模式匹配有关的方法是 split() ，这个方法可以 基于指定的分隔符将一个字符串分割成多个子字符串 ，并 将结果放在一个数组中 。分隔符可以是 字符串，也可以是一个 RegExp 对象（这个方法不会将字符串看成正则表达式）。 split() 方法可以接受可选的第二个参数，用于 指定数组的大小 ，以便确保返回的数组不会超过既定大小 。请看下面的例子。 1234var colorText = "red,blue,green,yellow";var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]var colors2 = colorText.split(",", 2); //["red", "blue"]var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""] 在这个例子中， colorText 是逗号分隔的颜色名字符串。基于该字符串调用 split(“,”) 会得到一个包含其中颜色名的数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可以为 split() 方法传递第二个参数 2。最后，通过使用正则表达式，还可以取得包含逗号字符的数组。 需要注意的是，在最后一次调用 split() 返回的数组中，第一项和最后一项是两个空字符串。之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头（即子字符串 “red” ）和末尾（即子字符串 “yellow” ）。 对 split() 中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。 IE8 及之前版本会忽略捕获组。ECMA-262 规定应该把捕获组拼接到结果数组中。IE9 能正确地在结果中包含捕获组。 Firefox 3.6 及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262 规定没有匹配项的捕获组在结果数组中应该用 undefined 表示。 在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览器下多做一些测试。 要了解关于 split() 方法以及捕获组的跨浏览器问题的更多讨论，请参考 Steven Levithan 的文章“JavaScript split bugs： Fixed!”（ http://blog.stevenlevithan.com/archives/cross-browser-split ）。 localeCompare() 方法与操作字符串有关的最后一个方法是 localeCompare() ，这个方法 比较两个字符串 ，并返回下列值中的一个： 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是 -1 ，具体的值要视实现而定）； 如果字符串等于字符串参数，则返回 0 ； 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1 ，具体的值同样要视实现而定）。 下面是几个例子。 1234var stringValue = "yellow";alert(stringValue.localeCompare("brick")); //1alert(stringValue.localeCompare("yellow")); //0alert(stringValue.localeCompare("zoo")); //-1 这个例子比较了字符串 “yellow” 和另外几个值： “brick” 、 “yellow” 和 “zoo” 。因为 “brick” 在字母表中排在 “yellow” 之前，所以 localeCompare() 返回了 1 ；而 “yellow” 等于 “yellow” ，所以 localeCompare() 返回了 0 ；最后， “zoo” 在字母表中排在 “yellow” 后面，所以 localeCompare() 返回了 -1 。再强调一次，因为 localeCompare() 返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。 1234567891011121314function determineOrder(value) &#123; var result = stringValue.localeCompare(value); if (result &lt; 0)&#123; alert("The string 'yellow' comes before the string '" + value + "'."); &#125; else if (result &gt; 0) &#123; alert("The string 'yellow' comes after the string '" + value + "'."); &#125; else &#123; alert("The string 'yellow' is equal to the string '" + value + "'."); &#125;&#125;determineOrder("brick");determineOrder("yellow");determineOrder("zoo"); 使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。 localeCompare() 方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。比如，美国以英语作为 ECMAScript 实现的标准语言，因此 localeCompare() 就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他地区恐怕就不是这种情况了。 fromCharCode() 方法另外， String 构造函数本身还有一个静态方法： fromCharCode() 。这个方法的任务是 接收一或多个字符编码 ，然后 将它们转换成一个字符串 。从本质上来看，这个方法 与实例方法 charCodeAt() 执行的是相反的操作 。来看一个例子： 1alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello" 在这里，我们给 fromCharCode() 传递的是字符串 “hello” 中每个字母的字符编码。 HTML 方法早期的 Web 浏览器提供商觉察到了使用 JavaScript 动态格式化 HTML 的需求。于是，这些提供商就扩展了标准，实现了一些专门用于简化常见 HTML 格式化任务的方法。下表列出了这些 HTML 方法。不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。 单体内置对象ECMA-262 对 内置对象 的定义是：“ 由 ECMAScript 实现提供的、不依赖于宿主环境的对象 ，这些对象 在 ECMAScript 程序执行之前就已经存在了 。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 Object 、 Array 和 String 。ECMA-262 还定义了两个单体内置对象： Global 和 Math 。 Global 对象Global （全局）对象可以说是 ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。本书前面介绍过的那些函数，诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ，实际上全都是 Global对象的方法。除此之外， Global 对象还包含其他一些方法。 URI 编码方法Global 对象的 encodeURI() 和 encodeURIComponent() 方法可以 对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码 ，以便发送给浏览器 。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们 用特殊的 UTF-8 编码替换所有无效的字符 ，从而让浏览器能够接受和理解。 其中， encodeURI() 主要用于 整个 URI（例如， http://www.wrox.com/illegal value.htm ），而 encodeURIComponent() 主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.htm ）进行编码。 它们的主要区别在于， encodeURI() 不会对本身属于 URI 的特殊字符进行编码 ，例如冒号、正斜杠、问号和井字号；而 encodeURIComponent() 则会对它发现的任何非标准字符进行编码 。来看下面的例子。 1234567var uri = "http://www.wrox.com/illegal value.htm#start";//"http://www.wrox.com/illegal%20value.htm#start"alert(encodeURI(uri));//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"alert(encodeURIComponent(uri)); 使用 encodeURI() 编码 后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了 %20 。而 encodeURIComponent() 方法 则会 使用对应的编码替换所有非字母数字字符 。这也正是可以对整个 URI使用 encodeURI() ，而只能对附加在现有 URI后面的字符串使用 encodeURIComponent()的原因所在。 一般来说 ，我们使用 encodeURIComponent() 方法的时候要比使用 encodeURI() 更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。 与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 decodeURI() 和 decodeURIComponent() 。其中， decodeURI() 只能对使用 encodeURI() 替换的字符进行解码 。例如，它可将 %20 替换成一个空格，但不会对 %23 作任何处理，因为 %23 表示井字号（ # ），而井字号不是使用 encodeURI() 替换的。同样地， decodeURIComponent() 能够解码使用 encodeURIComponent() 编码的所有字符 ，即 它可以解码任何特殊字符的编码 。来看下面的例子： 1234567var uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23startalert(decodeURI(uri));//http://www.wrox.com/illegal value.htm#startalert(decodeURIComponent(uri)); 这里，变量 uri 包含着一个由 encodeURIComponent() 编码的字符串。在第一次调用 decodeURI()输出的结果中，只有 %20 被替换成了空格。而在第二次调用 decodeURIComponent() 输出的结果中，所有特殊字符的编码都被替换成了原来的字符，得到了一个未经转义的字符串（但这个字符串并不是一个有效的 URI）。 URI 方法 encodeURI() 、 encodeURIComponent() 、 decodeURI() 和 decodeURIComponent() 用于替代已经被ECMA-262第3版废弃的 escape() 和 unescape()方法。URI方法能够编码所有 Unicode字符，而原来的方法只能正确地编码 ASCII字符。因此在开发实践中，特别是在产品级的代码中，一定要使用URI方法，不要使用 escape()和 unescape() 方法。 eval() 方法 整个 ECMAScript 语言中 最强大的一个方法 ： eval() 。 eval() 方法就像一个完整的 ECMAScript 解析器 ，它只接受一个参数，即要 执行的 ECMAScript（或 JavaScript）字符串 。看下面的例子： 1eval("alert('hi')"); 这行代码的作用等价于下面这行代码： 1alert("hi"); 当解析器发现代码中调用 eval() 方法时，它会 将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置 。 通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链 。这意味着 通过 eval() 执行代码可以引用在包含环境中定义的变量 ，举个例子： 12var msg = "hello world";eval("alert(msg)"); //"hello world" 可见，变量 msg 是在 eval() 调用环境之外定义的，但其调用的 alert() 仍然能够显示 “hello world”。 这是因为上面的第二行代码最终被替换成了一行真正的代码。同样地，我们 可以在 eval() 调用中定义一个函数，然后在调用的外部代码中引用这个函数 ： 12eval("function sayHIi() &#123; alert ('hi'); &#125;");sayHi(); 显然，函数 sayHi() 是在 eval() 内部定义的。但由于对 eval() 的调用最终会被替换成定义的实际代码，因此可以在下一行调用 sayHi()。对于变量也一样 ： 12eval("var msg = 'hello world'");alert(msg); 在 eval() 中创建的 变量或函数都不会被提升 ，因为在解析代码的时候，他们被包含在一个字符串中；它们 只在 eval() 执行的时候创建 。 严格模式 下，在外部访问不到 eval() 中创建的任何变量或函数 ，因此前面两个例子都会导致错误。同样，严格模式 下，为 eval 赋值也会导致错误 ： 12"use strict"evval = "hi"; //causes error 能够解释代码字符串的能力非常强大，但也非常危险 。因此在使用 eval() 时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序的安全的代码（即所谓的 代码注入 ）。 Global 对象属性下表列出了 Global 对象的所有属性。 ECMAScript 5 明确禁止给 undefined 、NaN 和 Infinity 赋值，这样做即使在非严格模式下也会导致错误。 window 对象ECMAaScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是 将这个全局对象作为 window 对象的一部分加以实现的 。因此，在全局作用域中声明的所有变量和函数，就都 成为了 window 对象的属性 。来看一个例子。 1234567var color = "red"; function sayColor() &#123; alert(window.color);&#125;window.sayColor(); // "red" 这里定义了一个名为 color 的全局变量和一个名为 sayColor() 的全局函数。在 sayColor() 内部我们通过 window.color 来访问 color 变量，以说明全局变量是 window 对象的属性。然后，又使用 window.sayColor() 来直接通过 window 对象调用这个函数，结果显示在了警告框中。 JavaScript 中的 window 对象除了扮演 ECMAScript 规定的 Global 对象的角色外，还承担的了很多别的任务。 另一种 取得 Global 对象的方法 是使用以下代码： 123var global = function() &#123; return this;&#125; 以上代码创建了一个立即调用的函数表达式，返回 this 的值。如前所述，在没有给函数明确指定 this 值的情况下 （无论是通过 将函数添加为对象的方法 ，还是通过 call() 或 apply() ）, this 值等于 Global 对象 。而像这样通过简单的返回 this 来取得 Global 对象，在任何执行环境下都是可行的 。 Math 对象 ECMAScript 还为保存数学公式和信息提供了一个公共位置，即 Math 对象 。与我们在 JavaScript 直接编写的计算功能相比， Math 对象提供的计算功能执行起来要快得多 。Math 对象中还 提供了辅助完成这些计算的属性和方法 。 Math 对象的属性Math 对象包含的 属性大多数是 数学计算中可能会用到的一些 特殊值 。下表列出了这些属性。 min() 和 max() 方法 min() 和 max() 方法 用于确定一组数值中的最小值和最大值 。这两个方法都可以 接受任意多个数值参数 ，如下面的例子所示。 12345var max = Math.max(3, 54, 32, 16);alert(max); //54var min = Math.min(3, 54, 32, 16);alert(min); //3 对于 3、34、32 和 16， Math.max() 返回 54， 而 Math.min() 返回 3。 这两个方法经常被用于避免多余的循环和在 if 语句中确定一组数的最大值。 要找到数值中的最大或最小值 ，可以像下面这样使用 apply() 方法。 12var values = [1, 2, 3, 4, 5, 6, 7, 8];var max = Math.max.apply(Math, values); 这个技巧的关键是把 Math 对象 作为 apply() 的第一个参数 ，从而 正确地设置 this 值 。然后，可以将 任何数值 作为 第二个参数。 舍入方法下面将介绍 将小数值舍入为整数 的几个方法： Math.ceil() 、 Math.floor() 和 Math.round() 。这三个方法分别遵循下列舍入规则： Math.ceil() 执行 向上舍入 ，即它总是 将数值向上舍入为最接近的整数 。 Math.floor() 执行 向下舍入，即它总是 将数值向下舍入为最接近的整数 。 Math.round() 执行 标准舍入 ，即它总是 将数值四舍五入为最接近的整数 （这也是我我们在数学课上学到的舍入规则）。 下面是使用这些方法的示例： 1234567891011alert(Math.ceil(25.9)); //26alert(Math.ceil(25.5)); //26alert(Math.ceil(25.1)); //26alert(Math.round(25.9)); //26alert(Math.round(25.5)); //26alert(Math.round(25.1)); //25alert(Math.floor(25.9)); //25alert(Math.floor(25.5)); //25alert(Math.floor(25.1)); //25 对于介于 25 和 26 之间的数值， Math.ceil() 始终返回 26，因为它执行的是向上舍入。Math.round() 方法只在大于等于 25.5 时返回 26；否则返回 25。最后， Math.floor() 对介于25 和 26 之间的数值都返回 25。 random() 方法Math.random() 方法 返回大于等于 0 小于 1 的一个随机数 。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示名人名言和新闻事件。套用下面的公式，就 可以利用 Math.random() 从某个整数范围内随机选择一个值 。 1值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) 公式中用到了 Math.floor() 方法，这是因为 Math.random() 总是返回一个小数值。而用这个小数值乘以一个整数，然后在加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想 选择一个 1 到 10 之间的数值 ，可以像下面这样编写代码： 1var num = Math.floor(Math.random() * 10 + 1); 总共 10 个可能的值（1 到 10）， 而第一个可能的值是 1.如果想要选择一个介于 2 到 10 之间的值，就应该将上面的代码改成这样： 1var num = Math.floor(Math.random() * 9 + 2); 从 2 数到 10 要数 9 个数，因此可能值的总数就是 9，而第一个可能的值就是 2.多数情况下，其实都 可以通过一个函数来计算可能的总数和第一个可能的值 ，例如： 1234567function selectFrom(lowerValue, upperValue) &#123; var choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue);&#125; var num = selectFrom(2, 10);alert(num); //介于 2 和 10 之间（包括 2 和 10）的一个数值 函数 seclectFrom() 接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加上 1 得到了可能的总数，然后它又把这些数值套用到了前面的公式中。这样，通过调用 selectFrom(2, 10) 就可以得到一个介于 2 和 10 之间（包括 2 和 10）的数值了。利用这个函数，可以方便 从数值中随机取出一项 ，例如： 123var colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];var color = colors[selectFrom(0, colors.length - 1)];alert(color); //可能是数组中包含的任何一个字符串 在这个例子中，传递给 selectFrom() 的第二个参数是数组的长度减 1，也就是数组中最后一项的位置。 其他方法下面我们给出一个表格，其中列出了这些没有介绍到的 Math 对象的方法。 虽然 ECMA-262 规定了这些方法，但不同实现可能会对方法采用不同的算法。毕竟，计算某个值的正弦、余弦和正切的方式多种多样。也正是因为如此，这些方法在不同的实现中可能会有不同的精度 。 小结 对象 在 JavaScript 中被称为 引用类型的值 ，而且 有一些内置的引用类型可以用来创建特定的对象 ，现简要总结如下： 引用类型与传统面向对象程序设计中的类 相似 ，但 实现不同 ； Object 是一个基础类型，其他 所有类型都从 Object 继承了基本的行为 ； Array 类型是 一组值的有序列表 ，同时提供了 操作 和 转换这些值的功能** ； Date 类型提供了有关 日期 和 时间 信息，包括 当前日期和时间 以及 相关的计算功能 ； RegExp 类型是 ECMAScript 支持正则表达式的一个接口 ，提供了 最基本的和一些高级的正则表达式功能 ； 函数实际上是 Function 类型的实例，因此 函数也是对象 ；而这一点正是 JavaScript 最有特色的地方。由于函数是对象，所以 函数也拥有方法 ，可以用来增强其行为 。 因为有了 基本包装类型 ，所以 JavaScript 中 基本类型值可以被当作对象来访问 。三种基本包装类型分别是： Boolean 、 Number 和 String 。以下是它们共同的特征： 每个包装类型都映射到 同名的基本类型 ； 在 读取模式 下访问 基本类型值 时，就 会创建对应的基本包装类型的一个对象 ，从而方便了数据操作； 操作基本数据类型值的语句一经执行完毕，就会 立即销毁新创建的包装对象 。 在 所有代码执行之前 ，作用域中已经存在两个内置对象：Global 和 Math 。在大多数 ECMAScript 实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 Window 对象 。全局变量和函数 都是 Global 对象属性 。Math 对象提供了很多属性和方法，用来完成复杂的数学计算任务。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试题目及详解汇总 -jQuery部分]]></title>
    <url>%2F2018%2F08%2F13%2Fweb-front-end-interview-jQuery%2F</url>
    <content type="text"><![CDATA[jQuery 库中的 $() 是什么？如何找到所有 HTML select 标签的选中项？$(this) 和 this 关键字在 jQuery 中有何不同？jquery怎么移除标签onclick属性？jquery中addClass,removeClass,toggleClass的使用。JQuery有几种选择器?jQuery中的Delegate()函数有什么作用？$(document).ready()方法和window.onload有什么区别？如何用jQuery禁用浏览器的前进后退按钮？jquery中$.get()提交和$.post()提交有区别吗？写出一个简单的$.ajax()的请求方式？jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？]]></content>
      <categories>
        <category>找工作</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式导航]]></title>
    <url>%2F2018%2F08%2F12%2FNavigation%2F</url>
    <content type="text"><![CDATA[单层导航HTML结构12345678&lt;div role="navigation" id="nav" class="opened"&gt; &lt;ul&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;项目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;博客&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果： 实例中导航菜单的 HTML 结构中元素 &lt;ul&gt; 用来定位导航菜单，.active 表示当前活动的导航项。 简单的菜单样式1234567891011121314151617181920212223242526272829303132333435363738394041424344#nav &#123; position: absolute; width: 24%; top: 2em; left: 0&#125;#nav ul &#123; display: block; width: 100%; list-style: none&#125;#nav li &#123; width: 100%; display: block&#125;#nav a &#123; color: #aaa; font-weight: 700; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; -webkit-transition: background .3s ease; -moz-transition: background .3s ease; transition: background .3s ease; text-shadow: 0 -1px rgba(0,0,0,.5); border-bottom: 1px solid rgba(0,0,0,.2); border-top: 1px solid rgba(255,255,255,.1); display: block; padding: .6em 2em; width: 100%&#125;#nav a:hover &#123; background: rgba(255,255,255,.1)&#125;#nav .active a &#123; color: #fff; background: rgba(0,0,0,.3)&#125;#nav li:first-child a &#123; border-top: 0&#125;#nav li:last-child a &#123; border-bottom: 0&#125; 效果; 媒体查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@media screen and (max-width: 40em) &#123; .js #nav &#123; clip:rect(0 0 0 0); max-height: 0; position: absolute; display: block; overflow: hidden &#125; #nav &#123; top: 0; width: 100%; position: relative &#125; #nav.opened &#123; max-height: 9999px &#125; #nav a:hover &#123; background: transparent &#125; #nav .active a:hover &#123; color: #fff; background: rgba(0,0,0,.3) &#125; #toggle &#123; -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; display: block; width: 70px; height: 55px; float: right; margin: 0 -2em 1em 0; text-indent: -9999px; overflow: hidden; background: #444 url("hamburger.gif") no-repeat 50% 33% &#125; .main &#123; -webkit-overflow-scrolling: auto; padding: 0 2em 2em; border-radius: 0; box-shadow: none; position: relative; width: 100%; overflow: hidden &#125; .main::-webkit-scrollbar &#123; background-color: transparent &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio:1.3),screen and (min--moz-device-pixel-ratio:1.3),screen and (-o-min-device-pixel-ratio:2 / 1),screen and (min-device-pixel-ratio:1.3),screen and (min-resolution: 192dpi),screen and (min-resolution:2dppx) &#123; body &#123; -webkit-background-size: 200px 200px; -moz-background-size: 200px 200px; -o-background-size: 200px 200px; background-size: 200px 200px &#125; #toggle &#123; background-image: url("hamburger-retina.gif"); -webkit-background-size: 100px 100px; -moz-background-size: 100px 100px; -o-background-size: 100px 100px; background-size: 100px 100px &#125;&#125;@media screen and (min-width: 76em) &#123; #nav &#123; width:18em &#125; .main &#123; width: auto; left: 18em &#125;&#125; 基础样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112body,div,h1,h2,p,ol,ul,li &#123; margin: 0; padding: 0; border: 0&#125; @-webkit-viewport &#123; width: device-width&#125; @-moz-viewport &#123; width: device-width&#125; @-ms-viewport &#123; width: device-width&#125; @-o-viewport &#123; width: device-width&#125; @viewport &#123; width: device-width&#125; html,body &#123; min-height: 100%&#125; body &#123; min-width: 290px; -webkit-font-smoothing: antialiased; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%; background: #444; color: #666; font: 400 100%/1.5 "Helvetica Neue",Helvetica,Arial,sans-serif&#125; h1 &#123; font-size: 3em; line-height: 1; color: #222; margin-bottom: .5em; float: left; width: 100%&#125; h2 &#123; float: left; width: 100%; font-size: 1.5em; color: #222; margin: 1em 0 .5em&#125; p &#123; float: left; width: 100%; margin-bottom: 1em&#125; p.intro &#123; font-size: 1.25em; color: #555; font-weight: 700&#125; a &#123; color: #f4f4f4; text-decoration: none&#125; a:active,a:hover &#123; outline: 0&#125; .main &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; -webkit-overflow-scrolling: touch; padding: 3em 4em; position: fixed; overflow: hidden; overflow-y: scroll; border-top-left-radius: 5px; box-shadow: 0 0 15px rgba(0,0,0,.6); top: .8em; right: 0; bottom: 0; width: 76%; background: #fff&#125; .main::-webkit-scrollbar &#123; -webkit-appearance: none; background-color: rgba(0,0,0,.15); width: 8px; height: 8px&#125; .main::-webkit-scrollbar-thumb &#123; border-radius: 0; background-color: rgba(0,0,0,.4)&#125; #toggle &#123; display: none&#125; 效果： 多层导航HTML 结构1234567891011121314151617181920212223242526272829303132333435363738&lt;div class="subNavBox"&gt; &lt;div class="subNav currentDd currentDt"&gt; 新闻中心 &lt;/div&gt; &lt;ul class="navContent " style="display:block"&gt; &lt;li&gt;&lt;a href="#"&gt;添加新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;添加新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="subNav"&gt; 关于我们 &lt;/div&gt; &lt;ul class="navContent"&gt; &lt;li&gt;&lt;a href="#"&gt;添加新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;添加新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="subNav"&gt; 业务系统 &lt;/div&gt; &lt;ul class="navContent"&gt; &lt;li&gt;&lt;a href="#"&gt;添加新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;我的关注&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="subNav"&gt; 招商联盟 &lt;/div&gt; &lt;ul class="navContent"&gt; &lt;li&gt;&lt;a href="#"&gt;添加新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;添加新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;添加新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新闻管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果： 多层导航样式123456789101112131415161718192021222324252627282930313233343536373839404142.subNavBox &#123; width: 200px; border: solid 1px #e5e3da; margin: 100px auto;&#125;.subNav &#123; border-bottom: solid 1px #e5e3da; cursor: pointer; font-weight: bold; font-size: 14px; color: #999; line-height: 28px; padding-left: 10px; background: url(../images/jiantou1.jpg) no-repeat; background-position: 95% 50%&#125;.subNav:hover &#123; color: #277fc2;&#125;.currentDd &#123; color: #277fc2&#125;.currentDt &#123; background-image: url(../images/jiantou.jpg);&#125;.navContent &#123; display: none; border-bottom: solid 1px #e5e3da;&#125;.navContent li a &#123; display: block; width: 200px; heighr: 28px; text-align: center; font-size: 14px; line-height: 28px; color: #333&#125;.navContent li a:hover &#123; color: #fff; background-color: #277fc2&#125; 效果： 重置默认样式1234567891011121314151617181920212223242526/*reset*/body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, code, form, fieldset, legend, input, textarea, p, blockquote, th, td &#123; margin: 0; padding: 0; font-family:"Î¢ÈíÑÅºÚ"&#125;table &#123; border-collapse: collapse; border-spacing: 0; &#125;fieldset, img &#123; border: 0; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style: normal; font-weight: normal; &#125;ol, ul &#123; list-style: none; &#125;caption, th &#123; text-align: left; &#125;h1, h2, h3, h4, h5, h6 &#123; font-size: 100%; font-weight: normal; &#125;q:before, q:after &#123; content: ''; &#125;abbr, acronym &#123; border: 0; font-variant: normal; &#125;sup &#123; vertical-align: text-top; &#125;sub &#123; vertical-align: text-bottom; &#125;input:focus, textarea:focus, select:focus &#123; outline: none; &#125;select, input &#123; vertical-align: middle; &#125;legend &#123; color: #000; &#125;.clean:before, .clean:after, .clearfix:before, .clearfix:after &#123; content: ""; display: table; &#125;.clean:after, .clearfix:after &#123; clear: both; &#125;.clean, .clearfix &#123; zoom: 1; &#125;.clear &#123; clear: both; &#125;.fl &#123; float: left; &#125;.fr &#123; float: right; &#125;.break &#123; word-wrap: break-word; width: inherit; &#125;.linkhidden &#123; text-indent: -9999em; overflow: hidden; &#125;.hidden &#123; display: none; &#125;a&#123; text-decoration:none;&#125;/*reset*/ 效果： 添加动态效果123456789$(function() &#123; $(".subNav").click(function() &#123; $(this).toggleClass("currentDd").siblings(".subNav").removeClass("currentDd") $(this).toggleClass("currentDt").siblings(".subNav").removeClass("currentDt") $(this).next(".navContent").slideToggle(500).siblings(".navContent").slideUp(500); &#125;);&#125;); 效果： 导航效果效果展示]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 属性]]></title>
    <url>%2F2018%2F08%2F12%2FCSS3-attribute%2F</url>
    <content type="text"><![CDATA[transform 属性transform 属性 @mediaHTML 标签的 media 属性、@media 查询]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行常用命令]]></title>
    <url>%2F2018%2F08%2F12%2Fcommand-line-command%2F</url>
    <content type="text"><![CDATA[touch 创建文件]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[作品展示 background-attachment]]></title>
    <url>%2F2018%2F08%2F12%2Fworks-background-attachment%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户、组织以及项目页面]]></title>
    <url>%2F2018%2F08%2F12%2Fuser-org-project-pages%2F</url>
    <content type="text"><![CDATA[写在前面该文章用于介绍 GitHub Pages 的相关内容，帮助了解 GitHub Pages ，也可以查看 GitHub 帮助文档 、GitHub Pages 基础知识 。 用户，组织和项目页面GitHub Pages 有两种基本类型：项目页面 ，用户和组织页面 。它们几乎相同，但有一些重要的区别。 项目页面关联到特定的项目，页面文件位于项目仓库中的分支上。用户和组织页面不依赖于特定项目，页面文件位于专门用于存储 GitHub 页面文件的 特殊仓库 中。 提示： GitHub Pages 网站在发布时始终可公开访问，即使其存储库是私有的，也不应该用于发送密码或信用卡号等敏感事务。更多有关信息，请参阅 “ 什么是GitHub页面？ ”。 警告： 如果您的 GitHub 页面站点的 URL 包含以短划线开头或结尾的用户名或组织名称，或包含连续破折号，那么使用 Linux 浏览的用户在访问该站点时将收到服务器错误。要解决此问题，请更改您的 GitHub 用户名以删除非字母数字字符。有关如何执行此操作的说明，请参阅 “ 更改GitHub用户名 ”。 项目页面网站Project Pages 站点的源文件与其项目位于同一个存储库中，并从以下位置之一发布： master分支。 gh-pages分支。 位于 master 分支上的名为“docs”的文件夹。 有关更多信息，请参阅“ 为GitHub页面配置发布源 ”。 构建项目页面站点个人和组织帐户都可以创建项目页面站点，并且创建项目页面站点的步骤对于两者都是相同的。 项目页面网站在构建后可在以下位置使用： 个人帐户的项目页面站点位于 http(s)://&lt;username&gt;.github.io/&lt;projectname&gt; 。 组织帐户的项目页面站点位于 http(s)://&lt;orgname&gt;.github.io/&lt;projectname&gt; 。 如果您使用的是自定义域名，请参阅“ GitHub页面站点的自定义域名重定向 ”。 在项目页面站点中使用自定义域名如果您使用具有用户或组织页面网站的自定义域名，则自定义域名将替换 username.github.io 该帐户下托管的所有项目页面网站的URL。使用自定义域的项目页面站点也可 username.github.io/projectname 用于个人帐户和orgname.github.io/projectname 组织。有关详细信息，请参阅“ 将自定义域名与GitHub页面一起使用 ”。 自定义 404 错误页面仅在使用自定义域名时才有效。否则，使用默认用户页面 404 。有关详细信息，请参阅“ 为 GitHub 页面站点创建自定义 404 ”。 用户和组织页面站点用户和组织页面站点的源文件 master 位于以 GitHub 帐户名称命名的专用存储库中的分支上： 要创建用户页面站点，请使用命名方案命名存储库 &lt;username&gt;.github.io 。 要创建组织页面站点，请使用命名方案命名存储库 &lt;orgname&gt;.github.io 。 构建用户和组织页面站点用户和组织页面网站在构建后可在以下位置使用： 用户页面站点位于 http(s)://&lt;username&gt;.github.io 。 组织页面站点位于 http(s)://&lt;orgname&gt;.github.io 。 如果您使用的是自定义域，请参阅“ GitHub 页面站点的自定义域名重定向 ”。 用户页面网站可以由具有经过验证的电子邮件地址的任何用户帐户构建。他们还可以使用部署密钥自动执行该过程。有关更多信息，请参阅 GitHub Developer 文档中的“ 管理部署密钥 ”。 组织页面站点可以由具有对存储库的推送访问权限和经过验证的电子邮件地址的任何成员构建。要自动化构建，您可以将计算机用户设置为组织的成员。有关更多信息，请参阅“ 管理部署密钥 ”。组织页面站点不支持部署密钥。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 GitHub Pages 配置发布源]]></title>
    <url>%2F2018%2F08%2F12%2FGitHub-Pages%2F</url>
    <content type="text"><![CDATA[写在前面 在 GitHub Pages 的 帮助文档 中已经给我们详细说明了，GitHub Pages 的发布资源的 3 种方式的不同，以及发布的方法。而作为英语文盲的我，只有通过百度翻译才能勉强看懂，而下面我要做的就是将 GitHub Pages 的 3 中方式给出一个中文的说明，供以后需要的时候就不用再翻译了。 发布站点 GitHub Pages 允许我们从 master 分支、gh-pages 分支 或 master分支下的 /docs 目录来发布我们的资源。 而如果仓库名称为 &lt;username&gt;.github.io 或 &lt;orgname&gt;.github.io 就只能从 master 分支发布。 没有用户名命名仓库的默认源设置发布源文件的默认设置取决于仓库的类型以及仓库中的分支。 如果仓库中没有 master 或没有 gh-pages 分支，则您的 GitHub Pages 发布源将设置为“ 无”，并且不会发布。 创建了 master 分支 或 gh-pages 分支，可以将其中一个设置为发布源，以便发布站点。 如果只有 master 或 gh-pages 分支，则将该分支设置为默认发布源。 从 master 或 gh-pages 发布资源 在GitHub上，进入到代码仓库。 点击仓库设置按钮。 选择 master 或 gh-pages 作为 GitHub Pages 发布源。 点击保存按钮，保存发布源。 从 master 分支 /docs 目录中发布资源要从 master 分支上的 /docs 目录发布站点的源文件，您必须有 master 分支，并且您的仓库必须： 在根目录中有一个 /docs 文件夹。 不遵循存储库命名方案 &lt;username&gt;.github.io 或 &lt;orgname&gt;.github.io 。 GitHub Pages 将从该 /docs 目录中读取发布您网站的所有内容，包括 CNAME 文件。例如，当您通过 GitHub 页面设置编辑自定义域时，自定义域将写入 /docs/CNAME 。 提示： 如果在启用后 /docs 从 master 分支中删除该文件夹，则您的站点将无法构建，并且您将收到丢失 /docs 文件夹的页面构建错误消息。 在GitHub上，进入到代码仓库。 在仓库 master 分支的根目录中创建一个名为 /docs 文件夹。 点击仓库设置按钮。 选择 master 分支的 / docs 目录 作为 GitHub Pages 发布源。 提示： 如果分支 /docs 上不存在该文件夹，则 master 分支 / docs 文件夹源设置将不会显示为选项 master。 点击保存，选择单击保存主分支的文档文件夹。 问题及解决]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztopic 主题更改]]></title>
    <url>%2F2018%2F08%2F11%2Fztopic%2F</url>
    <content type="text"><![CDATA[添加文章总条数显示 效果展示 代码展示 123456789101112131415161718192021222324252627282930313233343536&lt;div class=&quot;archives-container tags-container&quot;&gt; &lt;!-- 我是新增的 --&gt; &lt;!-- 我是新增的 --&gt; &lt;div class=&quot;tags-title&quot;&gt; &lt;%- _p(&apos;counter.archive&apos;, site.posts.length) %&gt; &lt;/div&gt; &lt;!-- 我是新增的 --&gt; &lt;div class=&quot;archive-body&quot;&gt; &lt;!-- 我是新增的 --&gt; &lt;% var last; %&gt; &lt;% page.posts.each(function(post, i)&#123; %&gt; &lt;% var year = post.date.year(); %&gt; &lt;% if (last != year)&#123; %&gt; &lt;% if (last != null)&#123; %&gt; &lt;/div&gt;&lt;/section&gt; &lt;% &#125; %&gt; &lt;% last = year; %&gt; &lt;section class=&quot;archive-wrap&quot;&gt; &lt;div class=&quot;archive-year&quot;&gt; &lt;!-- &lt;a href=&quot;&lt;%- url_for(config.archive_dir + &apos;/&apos; + year) %&gt;&quot; class=&quot;archive-year&quot;&gt;&lt;%= year %&gt;&lt;/a&gt; --&gt; &lt;%= year %&gt; &lt;/div&gt; &lt;div class=&quot;archives&quot;&gt; &lt;% &#125; %&gt; &lt;div class=&quot;archive-content&quot;&gt; &lt;a class=&quot;archive-article&quot; href=&quot;&lt;%= url_for(post.path) %&gt;&quot;&gt; &lt;span class=&quot;archive-meta&quot;&gt;&lt;%= date(post.date, &quot;MM-DD&quot;) %&gt;&lt;/span&gt; &lt;span class=&quot;archive-title&quot;&gt;&lt;%= post.title %&gt;&lt;/span&gt; &lt;/a&gt; &lt;/article&gt; &lt;% &#125;) %&gt; &lt;% if (page.posts.length)&#123; %&gt; &lt;/div&gt;&lt;/section&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/div&gt; 上面 ejs 代码中添加了 tags-title 中的代码, 其中 site.posts 为博客变量，想了解更多可以查看 Hexo 文档中的 变量 。 1234567891011121314151617181920212223242526272829303132333435363738394041 .archives-container&#123; min-height: 400px; padding: 30px 40px; margin-bottom: 10px; background: #fff; box-shadow: 0 0 3px rgba(0,0,0,.15); .archive-year&#123; line-height: 1; font-size: 30px; margin: 10px 10px 15px; color: $main-font-color; &#125; .archive-body &#123; // 我是新增的 margin-top: 25px; &#125; .archive-article&#123; display: block; text-decoration: none; padding: 10px; transition: all .3s; border-right: 3px solid transparent; border-left: 3px solid transparent; cursor: pointer; .archive-meta&#123; color: #8a8a8a; &#125; .archive-title&#123; color: $main-font-color; font-size: 20px; padding-left: 20px; &#125; &amp;:hover&#123; transform: translateY(-5px); box-shadow: 0 5px 10px #eaeaea; border-color: $main-red; .archive-title&#123; color: $main-red; &#125; &#125; &#125;&#125; .archive-body 为新增的类，用于设置与标题部分的距离。 12345678910111213counter: category: zero: "暂无分类" one: 共计一个分类 other: "共计 %d 个分类" tagcloud: zero: "暂无标签" one: 共计1个标签 other: "共计 %d 个标签" archive: # 我是新增的 zero: "暂无文章" one: 共计一篇文章 other: "共计 %d 篇文章" archive 为新增的国际化标识。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztopic 主题添加导航 “作品”]]></title>
    <url>%2F2018%2F08%2F11%2Fztopic-add-nav%2F</url>
    <content type="text"><![CDATA[写在前面 ztopic 是 Hexo 的主题之一，该主题的 github 地址为：https://github.com/wa-ri/hexo-theme-ztopic 。 添加导航 添加导航一共分为 4 个步骤，它们分别是： 修改配置文件 修改标题和图标 修改布局文件 新建 Markdown 文件 修改配置文件 Hexo 博客的配置文件分为 博客配置 和 主题配置，而添加导航 两个配置文件都需要修改 。 修改博客配置 打开文件：/_config.yml。 只需要在文件的 Directory 下添加 works_dir:works ，具体修改如下图所示： 修改主题配置 打开文件： /themes/ztopic/_config.yml 只需要在文件的 menu 下添加一个 works: /works ，具体修改如下图所示： 修改标题和图标 上面的修改之后导航中已经多出了一栏，但是这并不是我们想要的，因为它显示的是 menu.works ，而且 没有图标 ，就像下面一样，所以我们需要 修改标题和图标 。 修改标题 打开文件：/themes/ztopic/languages/zh-CN.yml 需要在文件的 menu 下添加一个 works:作品，具体修改如下图所示： 修改图标 打开文件：/themes/ztopic/source/css/partials/_icon.scss 修改图标是相对来说比较复杂的，因为它需要借助 阿里云图标库 生成 图标代码 ，然后 将代码拷贝到文件中 。使用阿里图标库生成图标代码可以查看 使用帮助。具体修改如下图所示： 添加的代码： 12345678@font-face &#123; font-family: 'iconfont'; /* project id 788043 */ src: url('//at.alicdn.com/t/font_788043_i0wkv787ma.eot'); src: url('//at.alicdn.com/t/font_788043_i0wkv787ma.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_788043_i0wkv787ma.woff') format('woff'), url('//at.alicdn.com/t/font_788043_i0wkv787ma.ttf') format('truetype'), url('//at.alicdn.com/t/font_788043_i0wkv787ma.svg#iconfont') format('svg');&#125; 1.icon-works:before &#123; content: "\e693"; &#125; 下面就是导航修改后的效果： 修改布局文件 当以为一切都万事大吉的时候，点击了一下导航才发现，导航只是虚有其表，还没有实现导航与之对应的布局，所以下面的任务就是 修改布局文件 。 布局文件分为 2 个部分，分别是 标题 和 内容 ，所以我们要做的就是找到这两个部分的文件并修改它们。 修改标题布局文件 打开文件：/themes/ztopic/layout/_partials/banner.ejs 添加的代码： 1234&lt;%&#125;else if(page.type &amp;&amp; page.type === &apos;works&apos;)&#123;%&gt;&lt;div class=&quot;about-title&quot;&gt; &lt;%= &quot;作品展示&quot; %&gt;&lt;/div&gt; 修改内容布局文件 打开文件：/themes/ztopic/layout/page.ejs 添加的代码： 1234567891011121314&lt;%if(page.type &amp;&amp; page.type===&quot;works&quot;)&#123;%&gt; &lt;div id=&quot;works&quot;&gt; &lt;article class=&quot;post&quot;&gt; &lt;header&gt; &lt;div class=&quot;post-title mobile-post-title&quot;&gt; &lt;h1&gt;&lt;%= page.title %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;div class=&quot;post-content&quot;&gt; &lt;%- page.content %&gt; &lt;/div&gt; &lt;/article&gt; &lt;/div&gt;&lt;%&#125;%&gt; 新建 Markdown 文件 进入 /source 目录， 新建一个目录 works ,并在 /source/works 目录下， 新建 一个 index.md 文件。 注意： 新建的 index.md 文件的 type 必须是 works ，上面定义的布局文件才才能生效。 下面是 /source/works/index.md 文件的内容： 代码： 12345678910title: 作品type: works&lt;!-- comments: false --&gt;date: 2018-06-02 10:23:12---### 我的作品- [微信小程序](https://works.songxingguo.com/)- [静态网页](https://works.songxingguo.com/) 写在最后最后导航的效果就是这样了：]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公司及校园招聘流程]]></title>
    <url>%2F2018%2F08%2F07%2Fcompany-and-campus-recruitment%2F</url>
    <content type="text"><![CDATA[公司及校园招聘流程好未来 校园招聘流程 猿辅导校园招聘流程 知乎校园招聘流程 唯品会 校园招聘流程 京东 校园招聘流程 360 校园招聘流程 网易 校园招聘流程 百度 校园招聘流程 已投递公司及其状态 顺丰 内推；暂无状态； 秋招：已投递； 校园招聘 腾讯 秋招；等待笔试； 校园招聘 网易 内推；已经笔试； 校园招聘 小米 内推：已投递； 秋招；等待笔试； 校园招聘 好未来 内推；等待笔试； 秋招；等待笔试； 校园招聘 爱奇艺 内推；暂无状态； 校园招聘 京东 秋招；等待笔试； 校园招聘 猿辅导 内推；暂无状态； ThoughtWorks 内推：已投递； 校园招聘 字节跳动 内推：已笔试； 校园招聘 迅雷 内推： 已投递； 校园招聘 拼多多 内推：已投递； 校园招聘 蘑菇街 秋招：已投递； 校园招聘 饿了么 秋招：已投递； 校园招聘 百度 秋招：已投递； 校园招聘 知乎 秋招：以投递； 校园招聘]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试题目及详解汇总-HTML/CSS部分]]></title>
    <url>%2F2018%2F08%2F06%2Fweb-front-end-interview-html-css%2F</url>
    <content type="text"><![CDATA[HTML/CSS部分什么是盒模型 在网页中，一个元素占有空间的大小构成，采用盒子作一个比喻来理解。 盒模型的组成： 由里向外由 content 、padding、 border 、margin 四部分组成。 盒模型的两种标准： 标准模型，IE模型。 两种标准的区别： 在标准模型中，盒模型的 宽高 只是 内容（content）的宽高 。 在IE模型中盒模型的 宽高 是 内容(content)+填充(padding)+边框(border)的总宽高 。 CSS如何设置两种模型 设置CSS3 的属性 box-sizing 12345678/* 标准模型 */box-sizing: content-box;/*IE模型*/box-sizing: border-box;/*继承父元素 box-sizing 属性的值*/box-sizing: inherit; 边距重叠： 块级元素 的 垂直相邻外边距会合并 ，并且将 使用较大的外边距作为最终的边距 。 避免方式：只设置 margin-top 或 margin-bottom ，而不是将两者混合使用。 来自—— 深入理解CSS盒模型 HTML元素 元素分类 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素、块级元素、空(void)元素 行内元素： a、b、span、img、input、strong、select、label、em、button、textarea 。 块级元素： div、ul、li、dl、dt、dd、p、h1-h6、blockquote 。 空元素： 即没有内容的HTML元素，例如：br、meta、hr、link、input、img 。 行内元素和块元素 两者的区别 块级元素 独占一行, 垂直方向排列；默认情况下，其 宽度自动填满其父元素宽度 ；块级元素 可以设置 width 、height 属性 ；可以设置 margin 和padding 属性 。 注意，块级元素即使设置了宽度，仍然是独占一行。 行内元素 不会独占一行 ，水平方向排列，相邻元素排列在同一行，直到排不下才会换行；其宽度 随元素的内容而变化 ；行内元素 设置width、height属性无效（可以设置 line-height ） ；行内元素的 margin 和 padding 属性，水平方向 的 padding-left 、padding-right 、margin-left 、margin-right 都 产生效果 ，但 竖直方向 的 padding-top 、padding-bottom 、margin-top 、margin-bottom 却 不会产生边距效果 。 CSS相关属性display 12345678/*块级元素*/display: block;/*行内元素*/display: inline;/*行内的块级元素,集块元素和行内元素的特点于一身*/display: inline-block; 为兼容 IE，真正能用的 display 类型只有 block 、inline 和 none 三种。可以使用一种 hack - 触发 行内元素 的 hasLayout （触发hasLayout，就会让行内元素拥有块级元素的特性），来支持 display: inline-block ，然后通过 vertical-aligin 解决竖直对齐问题。 123display:inline-block;*display:inline;vertical-aligin: middle; 只能对行内元素实现 display:inline-block,而块级元素就不行。 来自—— 曹刘阳.编写高质量代码：Web前端开发修炼之道[M].机械工业出版社，2016.6.（4.7.6 块级元素和行内元素的区别，4.7.7 display:inlne-block和hasLayout） CSS实现居中 CSS的居中会遇到很多种情况，不同的情况使用的方法不同。 水平居中 文本、图片等 行内元素 的水平居中 给 父元素 设置 text-align：center 。 12345.parent &#123; text-align：center;&#125;img &#123;&#125; 确定宽度 的 块级元素 的水平居中 确定宽度的块级元素本身 通过设置 margin-left:auto 和 margin-right: auto 来实现。 12345.self &#123; width: 200px; margin-left: auto; margin-right: auto；&#125; 或 1234.self &#123; width: 200px; margin: 0 auto;&#125; 不确定宽度 的 块级元素 的水平居中 不确定宽度的块级元素有三种方式可以实现居中。 方法一： 使用 table 标签来实现不确定宽度的块级元素的水平居中 table 它本身并 不是块级元素 ，如果不给它设定宽度的话，它的宽度由内部元素的宽度“撑起” ，但即使不设定它的宽度，仅 对 table设置margin-left:auto 和 margin-right: auto就可以使 table 水平居中 ， 间接实现 table 内部元素的居中 。 123table &#123; margin: 0 auto;&#125; 这种做法很巧妙，但 缺点 是 增加了无语义标签 ，加深了标签的嵌套层数 。 方法二： 改变块级元素的 display 为 inline类型，然后使用 text-aligin:center 来实现居中。 1234567.parent &#123; text-aligin: center;&#125;.self &#123; display: inline;&#125; 它也 存在一定问题 ：它将块级元素变成可行内元素，而 行内元素比起块级元素少一些功能 ，比如设定长宽值，在某些特殊需求设置CSS设置中，这种方法可能会有一些限制。 方法三：通过给 父元素 设置 float ，然后 父元素 设置position：relative 和 left:50% , 子元素 设置 positionrelative 和 left:-50% ;来实现水平居中。 123456789.parent &#123; position: relative; left: 50%;&#125;.self &#123; position: relattive; left: -50%&#125; 保留了块级元素，而且不会添加无语义标签，不增加嵌套深度，但它的 缺点 是设置了 position:relative ,带来了 一定副作用 。 Flex 可查看站内文章—— Flex布局 竖直居中 父元素高度不确定 的 文本 、图片 、块级元素 的竖直居中 通过给 父容器 设置 相同的上下边距 实现的。 1234.parent &#123; padding-top: 20px; padding-bottom: 20px;&#125; 或 123.parent &#123; padding: 20px 0;&#125; 父元素高度确定 的 单行文本 的竖直居中 通过给 父元素 设置 line-height 来实现的，line-height值和父元素的高度值相同 。 1234parent &#123; height: 100px; line-height: 100px;&#125; 父元素高度确定 的 多行文本 、图片 、块级元素的竖直居中 父元素高度确定的的多行文本、图片、块级元素的竖直居中有两种方法。 方法一：使用用于垂直居中的 属性vertical-align ,但只有当 父元素为td或th 时，这个 vertical-align属性才会生效 。 Fire和IE8及以上版本可以 设置块级元素的 display 类型为 table-cell ， 激活vertical-align属性 ，但是IE6和IE7并不支持dispaly:table-cell。 虽然可以设置display:table-cell来模拟表格，但没办法跨浏览器兼容，那么就 直接使用表格 来实现。 12345table &#123;&#125;.self &#123; vertical-align: middle;&#125; 方法一可以很好地实现竖直居中效果，且不会带来任何样式上副作用，但是它 添加了无语义标签 ，并 增加了嵌套深度 。 方法二： 对支持display: table-cell的IE8和Firefox用dispaly:table-cell和vertical-align: middle来实现居中，对不支持display:table-cell的IE6和IE7，使用特定格式的hack。 给不支持display:table-cell的IE6和IE7，通过给 父子两层元素 分别设置 top:50% 和 top:-50%来实现居中。 123456789101112131415.parent &#123; display: table-cell; vertival-align: middle; *position: relative;&#125;.vertical-parent &#123; *position: absolute; *top:50%;&#125;.vertical-self &#123; *position: relative; *top:-50%;&#125; 这种方法的好处是没有增加额外的标签，但它的 缺点 也很明显，一方面它 使用了hack ，不利于维护 ，另一方面，它 需要设置position：relative和posion：absolute , 带来了副作用 。 Flex 可查看站内文章—— Flex布局 来自—— 曹刘阳.编写高质量代码：Web前端开发修炼之道[M].机械工业出版社，2016.6.（4.7.9 居中） 简述一下 href、src、rel、url 的区别 href href 是 Hypertext Reference 的缩写，表示 超文本引用 。用来建立 当前元素 和 文档 之间的链接，指向 网络资源所在位置 。 常用的有：link、a。例如： 1&lt;link href=&quot;reset.css&quot; rel=”stylesheet“/&gt; 浏览器会识别该文档为css文档，并行下载该文档 ，并且 不会停止对当前文档的处理 。这也是建议使用link，而不采用@import加载css的原因。 src src 是 source 的缩写，src 的内容是页面必不可少的一部分，是 引入 。src 指向的 内容会嵌入到文档中当前标签所在的位置 ,指向 外部资源的位置 。 常用的有：img、script、iframe。例如； 1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 当浏览器解析到该元素时，会 暂停浏览器的渲染 ， 直到该资源加载完毕 。这也是将js脚本放在底部而不是头部得原因。 简而言之，src 用于 替换当前元素 ；href 用于 在当前文档和引用资源之间建立联系 。也就是说src引用的路径是 img自己的路径 ，href引用的路径是要 跳转到的地方 。 rel rel 是 relationship 的缩写。用于 定义链接的文件和HTML文档之间的关系 。StyleSheet 的意思就是 样式调用 。设置或检索对象之间的链接目标的关系 。如果没有值指出，rel属性的 默认关系 是一个 空字符串 。使用此属性 仅当 href属性 应用。 url 统一资源定位符 是 对可以从互联网上得到的 资源的位置 和 访问方法 的一种简洁的表示，是 互联网上标准资源的地址 。互联网上的每个文件都有一个 唯一 的 URL ，它包含的信息指出 文件的位置 以及 浏览器应该怎么处理它 。 基本URL包含 模式（或称 协议 ）、 服务器名称（或 IP地址 ）、 路径 和文件名 。 来自—— HTML中href、src区别、rel、href、src、url的区别 什么是CSS Hack? 针对不同的浏览器 /不同版本写相应的 CSS 的过程,就是 CSS Hack 。 CSS Hack常见的有三种形式： CSS属性Hack 、 CSS选择符Hack 以及 IE条件注释Hack ， Hack主要针对IE浏览器。 CSS属性Hack 1234567#test&#123; color:#c30; /* For Firefox */ color:red\0; /* For Opera */ color:yellow\9; /* For IE8+ */ *color:blue; /* For IE7 */ _color:#ccc; /* For IE6 */&#125; CSS选择符Hack 1234* html .test&#123;color:#090;&#125; /* For IE6 and earlier */* + html .test&#123;color:#ff0;&#125; /* For IE7 */.test:lang(zh-cn)&#123;color:#f00;&#125; /* For IE8+ and not IE */.test:nth-child(1)&#123;color:#0ff;&#125; /* For IE9+ and not IE */ IE条件注释Hack123&lt;!--[if &lt;keywords&gt;? IE &lt;version&gt;?]&gt; HTML代码块&lt;![endif]--&gt; 来自—— 史上最全的CSS hack方式一览、CSS hack大全、今天才知道css hack是什么、CSS Hack是什么意思？css hack有什么用？、你想知道的css hack知识全都帮你整理好了、CSS参考手册 px、em和rem的区别 px px 又称 像素 （Pixel），相对长度单位 。像素 px 是 相对于显示屏幕分辨率 而言的。 em em，相对长度单位 。em 相对于 当前对象内文本的字体尺寸 。如当前对行内文本的 字体尺寸未被人为设置 ，则 相对于 浏览器的 默认字体尺寸（16px）。 任意浏览器的默认字体高都是16px。所有未经调整的浏览器豆腐额：1em=16px 。但 em 的 值并不是固定的 ；em 会 继承父级元素 的 字体大小 。 rem rem 是 root em 的缩写（即 根em），CSS3 新增的一个 相对单位。区别在于使用 rem 为元素设定字体大小时，仍然是相对大小，但 相对的是 HTML 根元素 （ HTML文档的根元素是 html 元素 ）。 这个单位可谓集 相对大小 和 绝对大小 的 优点 于一身，通过它既可以做到 只修改根元素 就 成比例地调整所有字体大小 ，又 可以避免字体大小逐层复合的连锁反应 。 目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于 不支持 它的 浏览器 ，应对方法也很简单，就是 多写一个绝对单位的声明 。 1234p &#123; font-size: 14px; font-size: 875rem;&#125; 如果你的用户群都是用 最新版的浏览器 ，那 推荐使用rem ，如果要 考虑兼容性，那就 使用px ，或者 两者同时使用 。 px,em,rem单位转换工具 来自—— 彻底弄懂px,em和rem的区别 在HTML中，position取值有哪几种，默认值是什么？ position 的 5 种属性值：relative 、absolute 、fixed 、static（默认值） 、inherit 。 简述 详细描述 position: relative 和 position:absolute 可改变元素在 文档流 中的 位置 。可以让元素激活 left 、top 、right 、bottom 和 z-index（默认在 z-index:0 这一层） 属性（默认情况下，这些属性未激活，设置了也无效）。 普通流 默认情况下，所有元素 都是在 z-index:0 这一层。元素根据自己的 dispaly类型 、长宽 、内外边距 等属性 顺序排列 在 z-index:0 这一层里，这就是 文档流 。设置 position:relative 或 position: absolute 会让元素“ 浮 ”起来，也就是 z-index 值 大于 0 ，它会 改变 正常情况下的 文档流 。 CSS 有三种基本的定位机制，分别是 普通流 、浮动 以及 绝对定位 。除非特殊定义 ，不然 任何框 都应该 遵循文档流的定位规则 ，换而言之，普通流的元素的位置 由其 在HTML文档中的位置 决定。 position:relative 不同的是 position:relative 会 保留 自己在 z-index:0 层 的 占位 ，left 、top 、right 、bottom 值是 相对于 自己在 z-index:0 层 的 位置 。虽然它的实际位置可能因为设置了 left 、top 、right 、bottom 值而 偏离原来在文档流中的位置 ，但 对其他仍然在z-index:0层的元素位置不会造成影响 。 position:absolute 而 position:absolute 会 完全脱离文档流 ，不再在z-index:0层保留占位符 ，其 left 、top 、right 、bottom 值是 相对于 自己 最近的 一个设置了 position:relative 或 position: absolute 的 祖先元素的 , 如果 祖先元素全都没有设置 position:relative 或 position: absolute ，那么就 相对于 body 元素 。 float float 属性也能 改变文档流 ，不同的是，float 属性 不会让元素“上浮”到另一个 z-index 层，它仍然 让元素在 z-index:0 层排列 ，float 不像 position:relative 和 position:absolute 那样，它 不能 通过 left 、top 、right 、bottom 属性 精确地控制元素的坐标 ，它只能通过 float:left 和 float:right 来控制元素 在同层里“左浮”和“右浮” 。float 会改变正常的文档流排列 ，影响到周围元素 。 隐式改变display类型 position:absolute和 float 会 隐式地改变display类型 ，不论之前是什么类型的元素（ display:none 除外），只要设置了 position:absolute 、float:lef 或 float:right 中任意一个，都会让元素以 display：inline-block 的方式显示：可以设置长宽 ，默认宽度并不占满父元素 。就算我们 显式地 设置 display:inline 或者 display：block ，也 仍然无效 （ float 在 IE 6 下的 双倍边距bug 就是利用 添加 display:inline 来解决的 ）。值得注意的是，position:relative 却 不会隐式改变display的类型 。 来自—— 曹刘阳.编写高质量代码：Web前端开发修炼之道[M].机械工业出版社，2016.6.（4.7.8 relative、absolute 和 float） 清除浮动有哪些方式？比较好的方式是哪一种？ 浮动的定义 定义了 浮动属性的框 可以 左右移动 ， 直到它的外边缘 与 包含框 或 另一个浮动元素的框的边框 相碰为止。浮动框 是 不存在文档的普通流中 ，因此 文档的普通流中的块框 表现的就 如同浮动框不存在一般 。如果 包含框宽度不够 ，即 无法同时容纳几个浮动元素 ，那么浮动块 将 向下移动 ，直到有充足的空间 ，可以 放下浮动框 为止。如果 浮动元素的高度不同 ，那么它们向下移动时 可能 会被其他浮动元素“卡住” 。 float 属性 float 的 4 种属性值：left 、right 、none（默认值） 、inherit 。 浮动的“副作用” 背景无法显示。 如果对 父级元素 设置了 CSS背景颜色（background）或是 CSS背景图片（background-image）,由于 浮动的产生 ，父级元素不能被撑开，所以导致 CSS背景无法显示 。 边框不能撑开。 如果 父级元素 设置了 CSS边框属性（border）,由于 子级里使用了 float 属性 而 产生了浮动 。而 父级不能被撑开 ，因此 导致边框不能随内容而被撑开 。 margin、padding 属性的值不能正确显示。 浮动 会导致 父级子级之间 设置的 padding 、margin 属性值 不能正确显示 。特别是 上下边的 padding 和 margin 值 。 清除浮动 对父级设置合适的CSS高度。 浮动 导致 父级元素不能被撑开 。 使用 clear: both 清除浮动。 clear属性规定元素的哪一侧不允许其他的浮动元素。如果声明左侧或者右侧不允许浮动，会使元素的上下边框边界刚好在该边上浮动元素的下外边距边距之下。 父级 div 定义： overflow： hidden 。 在浮动元素后面增加 &lt;br/&gt; 标签。 在父级元素加上 .clearfix 类（常用） 其 原理 就是 使用 CSS 伪类 ，在 元素末尾 加 一个带有浮动功能的标签 。 1234567891011121314151617181920.clearfix:after &#123; visibility: hidden; display: block; font-size: 0; content: &quot;&quot;; clear: both; height: 0;&#125;.clearfix &#123; display: inline-table;&#125;/* Hides from IE-mac \*/*html .clearfix &#123; height: 1%;&#125;.clearfix &#123; dispaly: block;&#125;/* End hide from IE-mac */ 来自—— Web 前端开发实战教程（2014版）V1.8[M].教材用书，2014.（3.9.4 浮动与清除浮动）、CSS float 属性、CSS样式—-浮动（图文详解） 文档类型声明（DOCTYPE）作用？ 文档类型声明 用于 宣告后面的文档标记遵循哪个标准 。 *声明构成** html + 顶级元素可用性 + “ 注册 // 组织 // 类型标签 // 定义语言 “ + “URL“。 12&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot;&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Strict//EN&quot;&gt; 文档定义类型 HTML 4.01 规定的 3 种主要文档定义类型： 严格型（Strict）: 所有标记必须符合 XHTML标准。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 过渡型（Transitional）: 能兼容之前的HTML代码。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 框架型（Frameset）: 能兼容XHTML不推荐的框架。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org//TR/html4/frameset.dtd&quot;&gt; XHTML 1.0 规定的 3 种主要文档定义类型： 严格型（Strict）：文档中不允许使用任何表现样式的标识和属性，例如 &lt;br&gt; 。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 过渡型（Transitional）：允许你继续使用HTML4.01的标识(但是要符合xhtml的写法) 。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 框架型（Frameset）：框架页类型。网页使用框架结构时，声明此类型。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; HTML5文档定义类型： 1&lt;! DOCTYPE html&gt; 来自—— Web 前端开发实战教程（2014版）V1.8[M].教材用书，2014.（2.2.1 文档定义） 、&lt;!DOCTYPE html PUBLIC……&gt;的组成解释、HTML文档类型 DTD 标准模式与兼容模式各有什么区别? DOCTYPE 不存在 或 格式不正确 会导致文档以 兼容模式 呈现 。 两种模式 标准模式（Standards, 也就是严格呈现模式） 用于呈现遵循最新标准的网页。 标准模式的排版 和 JS运作模式都是以该浏览器支持的最高标准运行。 兼容模式（Quirks, 也就是松散呈现模式或者怪异模式） 用于呈现为传统浏览器而设计的网页。 兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。简单来说就是尽可能的显示能显示的东西给用户看。 具体区别 盒模型。 在 严格模式 中 ：width 是内容宽度 ，元素真正的宽度 = width ;在 兼容模式 中 ：width = width + padding + border。 兼容模式 下可设置 百分比的高度 和 行内元素的高宽。 在 标准模式 下，给 span 等行内元素设置 wdith 和 height 都 不会生效 ，而在 兼容模式 下，则 会生效 。 在标准模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。 用 margin:0 auto 设置水平居中在 IE 下会失效。 使用 margin:0 auto 在 标准模式 下 可以使元素水平居中 ，但在 兼容模式 下却 会失效（用 text-align 属性解决）。 123456body&#123; text-align:center;&#125;#content&#123; text-align:left;&#125; 兼容模式 下 Table 中的 字体属性不能继承上层的设置 ，white-space:pre会失效，设置图片的 padding 会失效。 来自—— Doctype作用？标准模式与兼容模式各有什么区别? HTML5 为什么只需要写&lt;!DOCTYPE html&gt; ？ HTML 4.01 基于 SGML ，需要 对 DTD 进行引用，才能 告知浏览器文档所使用的文档类型 。HTML 5 不基于 SGML ，因此 不需要 对 DTD 进行引用，但是需要 DOCTYPE 来 规范浏览器的行为 。 HTML5 文档类型声明 不包含官方规范版本号 （即HTML5中的5）。事实上，这声明 仅仅表示当前页面是HTML页面 。只要有 新功能 添加到 HTML 语言中，在页面中就 可以使用 它们，而 不必 为此 修改文档类型声明 。 文档类型定义是什么？ 文档类型定义（ DTD: Document Type Definition ）是 W3C 所发布的，用于描述文档的内容和结构和验证文档的合法性。告诉浏览器你的这个 HTML，是根据那个标准写的，解析的时候用哪个标准解析。DTD教程 SGML是什么？ SGML 是标准通用标记语言，简单的说，就是比 HTML , XML 更老的标准，这两者都是由SGML 发展而来的。但是，HTML5 不是的。 保留文档类型声明的原因： 要求 保留文档类型声明 ，主要是由于 历史原因 。如果 没有文档类型声明 ，那 大多数浏览器 （包括Internet Explorer 和 Firefox）将转换到一种 混杂模式（quirk mode）。在这种模式下，浏览器会尝试根据有点不那么正常的规则呈现网页 （那些规则是在浏览器的老版本中使用的），并且 不同浏览器的混杂模式也不一样 。 而 添加了文档类型声明 后，浏览器就知道你想要使用更严格的 标准模式（standard mode）,在这种模式下，所有浏览器 都会 以一致的格式和布局来显示网页 。浏览器不关心你使用的是哪种文档类型（个别情况下还是有些例外），只要它检查到你有某种文档类型声明就好 。HTML5的文档类型声明是 最短的有效文档类型声明 ，因此它 总能触发标准模式 。 来自—— （美）麦克唐纳（Matthew MacDonald，M.）著；李松峰，朱魏，刘帅译.HTML5秘籍[M].人民邮电出版社，2017.10.（1.3.1 HTML5文档类型） CSS层叠是什么？CSS定义的权重CSS设置的样式 是可以 层叠 的，如代码下代码所示： 123456789&lt;style type=&quot;text/CSS&quot;&gt;span&#123; font-size: 40px;&#125;.test&#123; color: red;&#125;&lt;/style&gt;&lt;span class=&quot;test&quot;&gt;1234567890&lt;/sapn&gt; “ 1234567890 ”既 可得到“ font-size:40px ”的样式，又可以得到“ color:red ”的样式。 CSS层叠样式冲突 的情况： 12345678910&lt;style type=&quot;text/CSS&quot;&gt;span&#123; font-size: 40px; color: green;&#125;.test&#123; color: red;&#125;&lt;/style&gt;&lt;span class=&quot;test&quot;&gt;1234567890&lt;/sapn&gt; “ 1234567890 ”的颜色会是什么呢？这就涉及 CSS的选择符的权重 问题了。 CSS的选择符 是 有权重的 ，当 不同选择符的样式 设置 有冲突 时，会采用 权重高的选择符 设置的样式。 权重规则 通配符 的权重是 0 ，HTML 标签 和 伪对象 的权重是 1 ，class、 伪类、属性 的权重都是 10 ，id 的权重是 100, important 的权重是 1000 。（该部分内容还有待证实） 所以从样式选择器看权重优先级是（由高到低排列）：important &gt; 内嵌样式 &gt; id &gt; class &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符。（该部分内容还有待证实） 例如 p 的权重是 1 ，“ div em ”的权重是 1+1=2 ，“ strong .demo ”的权重是 1+10=11 ,“ #test .red ”的权重是 100+10=110 。 如果 选择符权重相同 ，那么样式会遵循 就近原则 ，哪个选择符 最后定义 ，就采用哪个选择符的样式 。 注意： 使用 子选择器 ，会 增加 CSS 选择符的权重 ，CSS选择符的 权重越高 ，样式 越不易被覆盖 ，越容易对其他选择符产生影响 。所以，除非确定HTML结构非常稳定，一定不会再修改了，否则 尽量不要使用子选择器 。为了保证样式容易被覆盖，提高可维护性， CSS选择符权重需要尽可能低 。新添加class比使用子选择器更利于维护。 来自—— 曹刘阳.编写高质量代码：Web前端开发修炼之道[M].机械工业出版社，2016.6.（4.5 低权重原则— 避免滥用子选择器）、CSS 选择器权重计算规则 解释css sprite，如何使用？ 图片翻转技术 将 多张图片合并为一张 ，然后利用 background-position 属性 来 展示我们需要的部分 。按照这种思路，后来衍生出的另一种技术将这种思路发挥到了极致 — 将网站的多张背景图片合并到一张大图片上 ，这便是 CSS sprite 。 不仅是 解决滑过状态时背景图片出现空白的问题 ，而且将多张图片合并成一张大图，会大大减少网页的HTTP请求数 ，减小服务器压力 。 CSS sprite技术 看似简单，其实 不容易掌握，主要有如下原因： 它能合并的 只能是用于背景的图片 ，对于 &lt;img src=&quot;&quot; /&gt; 设置的图片 ，是 不能 合并到CSS sprite大图中的，如果合并这些图片会影响到页面的可读性。 对于 横向和纵向都平铺的图片 ，也 不能使用CSS sprite ；如果是 横向平的 ，只能 将所有横向平铺的图合成一张大图 ，只能 竖直排列，不能水平排列；如果是 纵向平铺的 ，我们只能 将所有纵向平铺的图合并成一张大图 ，只能 水平排列 ，不能竖直排列。 图片如何排列能够尽量紧凑，同时保证不会影响扩展性。这点是CSS sprite技术最困难也是最具挑战性的地方。 CSS sprite技术 通过 position 进行定位，这对于图片的位置精确程度要求非常高，一方面 在制作网页时 ，我们 需要精确测量坐标 ，还 需要考虑如何让图案尽可能密集的排列 ，这 影响开发速度 ；另一方面，大图中每个小图的坐标值都不可轻易改动 ，因为 每改动一个小图 ，都 可能影响到周边的其他图片 ，这 大大降低了可维护性 。 注意： CSS sprite 的最大好处是 减少了HTTP请求次数 ，减轻服务器的压力 ，但它却需要付出“ 降低开发效率 ”和“ 增大维护难度 ”的代价。对于 流量不大的网站 来说，CSS sprite 带来的 好处并不明显 ，而它付出的 代价却很大 ，其实并不划算。所以，是否使用CSS sprite主要取决于网站流量 。 来自—— 曹刘阳.编写高质量代码：Web前端开发修炼之道[M].机械工业出版社，2016.6.（4.6 CSS sprite） 描述css reset的作用和用途？什么 CSS reset 呢？ HTML 标签 在浏览器里 有默认的样式 ，例如 p 标签有上下边距，strong 标签有字体加粗样式，em 标签有字体倾斜样式。不同的浏览器的默认样式之间会有差别 ，例如 ul 默认带有缩进的样式，在 IE 下，它的缩进是通过 margin 实现的，而在 Firefox 下，它的缩进却是由 padding 实现的。在切换页面的时候，浏览器的默认样式往往会给我们带来麻烦 ，影响开发效率 。现在流行的 解决办法是 一开始就 将浏览器的默认样式全部去掉 ，更确切的说，应该 通过重新定义标签的样式 ，“ 覆盖 ”掉浏览器提供的 默认样式 ，这就是 CSS ret 。 CSS reset 的使用 将常用的标签显式地罗列出来，避免使用 “ * ”。 YUI（雅虎的前端框架,详见：http://developer.yahoo.com/yui/ ）CSS reset12345678910111213141516171819202122232425262728293031323334/*CSS ret*/body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre, form,fieldset,input,textarea,p,blockquote,th,td &#123; padding: 0; margin: 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125; fieldset,img &#123; border: 0; &#125; address,caption,cite,code,dfn,em,strong,th,var &#123; font-weight: normal; font-style: normal; &#125; ol,ul &#123; list-style: none; &#125; caption,th &#123; text-align: left; &#125; h1,h2,h3,h4,h5,h6 &#123; font-weight: normal; font-size: 100%; &#125; q:before,q:after &#123; content:”; &#125; abbr,acronym &#123; border: 0; &#125; 来自—— 曹刘阳.编写高质量代码：Web前端开发修炼之道[M].机械工业出版社，2016.6.（4.3 推荐的base.css） 简述一下你对HTML语义化的理解？什么是语义化的HTML？ 使用 语义化元素 书写网页，让网页传达出额外的 结构化信息 。 什么是语义元素呢？ 语义元素 为它们标注的内容赋予额外的含义 ，让网页的结构更加清晰 ，语义元素都有一个显著的特点： 不真正做任何事 。 为什么要使用语义化元素呢？ 容易修改和维护 通过 HTML5的语义元素 ，通过标记就可以传达出 额外的结构化信息 。 无障碍性 现代Web设计的一个重要主题，就是 让任何人都能无障碍的访问网页 。换句话说，要让使用屏幕阅读器和其他辅助工具的人都能够在页面中自由导航。兼容HTML5的无障碍工具可以为残疾人士提供更好的上网体验。（仅举一个例子，有了 &lt;nav&gt; 元素，屏幕阅读器就能迅速返回导航区，进而找到网页链接。） Web无障碍性的最佳实践，可以访问WAI（Web Accessibility Initiative, Web无障碍倡议）的网站：www.w3.org/WAI 。或者，要了解通过屏幕阅读器上网是一种什么样的的感觉（同时理解为什么标题要排列适当），可以看看YouTube的这段视频：http://tinyurl.com/6bu4pe 。 搜索引擎优化 如果搜索引擎能更好的理解你的站点，那 搜索者的查询就会越容易与你的内容匹配 ，因而你的网站列在搜索结果中的可能性也就越大。 未来功能 新浏览器和 Web编辑器工具 一定会 利用语义元素 。比如，浏览器可以提供一个页面内容的纲要，以方便跳转到页面适当的区块。类似地，网页设计工具也能包含一些方便你构建或编辑菜单的功能，而方法就是组织你放在 &lt;nav&gt; 区块中的内容。 最关键的问题在于，如果正确地使用了语义元素，就能够 创建更加清晰的页面结构 ，就能 适应未来的浏览器和Web设计工具的发展趋势 。 来自—— （美）麦克唐纳（Matthew MacDonald，M.）著；李松峰，朱魏，刘帅译.HTML5秘籍[M].人民邮电出版社，2017.10.（2.1 语义元素） 说说你对HTML5认识? 什么是HTML5 HTML5 是下一代的 HTML。HTML5 将成为 HTML、XHTML 以及 HTML DOM 的新标准。HTML 的上一个版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。HTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。 HTML5 添加了许多新的语法特征 ，其中包括 &lt;video&gt; 、&lt;audio&gt; ，和 &lt;canvas&gt; 元素，同时集成了 SVG 内容。这些元素是 为了更容易的在网页中添加和处理多媒体和图片内容而添加的 ，其它新的元素包括 &lt;section&gt;，&lt;article&gt; , &lt;header&gt;, 和 &lt;nav&gt;,是 为了丰富文档的数据内容 。新的属性的添加也是为了同样的目的。同时也 有一些属性和元素被移除掉了 。一些元素，像 &lt;a&gt;, 和 &lt;menu&gt; 被修改，重新定义或标准化了 。同属 APIs 和 DOM 已经成为 HTML 中的 基础部分 了。HTML5 还定义了 处理非法文档的具体细节 ，使得 所有浏览器和客户端程序 能够 一致地 处理语法错误。 HTML5三个主要原理 不破坏Web 标准不该引入导致已有网页无法工作的改变。 HTML5规范 包括 两部分 。第一部分，面向Web开人员 ，要求 摒弃过去的那些坏习惯和被摒弃的元素 。第二部分,针对的是 浏览器开发商 ，它们需要 支持HTML中存在的一切 ，以做到 向后兼容 。 修补牛蹄子路 牛蹄子路 指的是 高低不平 但 使用频率很高的路 ，通过它可以从一个地方到另一个地方。 HTML5标准化了这些非官方（但广泛应用）的技术。 实用至上 改变应该以实用为目的。改变越多，代价也就越大。 HTML标准加入官方的支持 ，让 功能 在 所有浏览器 中 都能一致的工作 。 让网站 不依赖插件 也能够提供 视频 、丰富的交互功能 以及 各种漂亮的效果 。 HTML5的规则 新特性应该基于 HTML、CSS、DOM 以及 JavaScript。 减少对外部插件的需求（比如 Adobe Flash、Microsoft Silverlight, 与 Oracle JavaFX 的需求）。 更优秀的错误处理。 更多取代脚本的标记。 HTML5 应该独立于设备。 开发进程应对公众透明。 HTML5的新特性 用于绘画的 canvas 元素。 用于媒介回放的 video 和 audio 元素。 对本地离线存储的更好的支持。 新的特殊内容元素，比如 article、footer、header、nav、section。 新的表单控件，比如 calendar、date、time、email、url、search。 详细内容可查看站内文章—— HTML5的新特性 来自—— Web 前端开发实战教程（2014版）V1.8[M].教材用书，2014.（8.1 什么是HTML5）、（美）麦克唐纳（Matthew MacDonald，M.）著；李松峰，朱魏，刘帅译.HTML5秘籍[M].人民邮电出版社，2017.10.（1.2 HTML5的三个主要原理）、HTML 5 简介 列出display的值，说明他们的作用？ display 属性规定元素应该生成的框的类型。 说明 这个属性用于定义建立布局时元素生成的显示框类型。对于 HTML 等文档类型，如果使用 display 不谨慎会很危险，因为可能违反 HTML 中已经定义的显示层次结构。对于 XML，由于 XML 没有内置的这种层次结构，所有 display 是绝对必要的。 注释：CSS2 中有值 compact 和 marker，不过由于缺乏广泛的支持，已经从 CSS2.1 中去除了。 可能的值 来自—— CSS display 属性 CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先级高？ 为文档应用样式的 3 种方式 内联样式（Inline Style） 只需直接在HTML元素里加入style参数，在style的内容就是需要设置是CSS的属性和值。并且内联样式只对所在的标签有效。 123&lt;p style=&quot;font-family:&apos;宋体&apos;;color:#000;font-size；12px;&quot;&gt; 内联样式只对P标签有效&lt;/p&gt; style 参数虽然可以 使用于任意 body 内的元素（包括 body 本身），但是却 不能 使用在 basefont 、param 和 script 中。 内联样式 虽然使用起来非常的 方便 、直观 ，但是因为它是在 HTML 中直接使用，与 HTML 文档结构有强耦合 ，所以使得 页面的样式调整和页面的结构无法分离开 ，因此也给维护人员 修改页面样式带来了极大的不方便 。 内部样式（Embedding Style） 通常 定义在HTML文档中 &lt;head&gt;`` 标签中 ，或者 定义在 &lt;head&gt;与&lt;body&gt;标签之间 。其实，style 元素和 script 元素相同，是可以定义在HTML文档中的任意位置。但碍于规范，最后还是定义在head元素内，便于统一的管理。内部样式和内联样式一样，均是使用 style 参数实现，不同之处，内部样式 使用在 &lt;style&gt; 与 &lt;/style&gt; 标签之间 ，HTML 的各种元素样式规则均定义在 style 标签间。 123456789101112131415&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; p &#123; font-family: &quot;宋体&quot;; font-size: 12px; color: #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;内部样式&lt;/p&gt; &lt;p&gt;内部样式&lt;/p&gt; &lt;p&gt;内部样式&lt;/p&gt; &lt;p&gt;所有p元素的样式均相同&lt;/p&gt;&lt;/body&gt; 上面的 type=”text/css” 是用来指明 文档属性为 CSS 样式表 ，也可以省略不写。HTML 文档中的 所有 p 元素的样式全部统一 ，均为 12 像素黑色字体。这就是 内联样式与内部样式最大的区别 。 内部样式实际上是 将 CSS 样式写在了 HTML 中 ，与 HTML 有强耦合，那么就需要一个文档一个文档的修改，增加了维护人员的工作量。所以 对于较大较复杂的网页，最好还是不要使用内部样式 。但 相较于简单的网页 ，使用内部样式就显得更加的 方便 、直观 。而且，对于网页进行调试 ，查看效果时，我们也可以使用内部样式。因为这样更加的 快捷 。 外部样式（Link Style） 外部样式表，是 一种保存在外部的 CSS 样式表文件 ，是扩展名为 .css 的外部文件。外部样式方式同导入样式表的方式相似。它们都是 单独存放在外的 ，使用时 ，只需 在 HTML 文档中引入该样式表 。要在 HTML 文档中引入外部样式表，只需在 head 元素中使用 link 元素 ， link 元素的值为要引入的样式表的名称。 123&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;/&gt;&lt;/head&gt; 可选的 type 属性用来指定媒体类型为 text/css, text-css 是一个 层叠样式表 ，它允许浏览器忽略它们不支持的样式表类型 。 rel 属性 用来 定义外部的文件与 HTML 文档之间的关系 ，这里的 rel=”stylesheet” 定义一个固定的或者首选的样式。需要注意的是，外部样式表不能包含任何的 HTML 元素，外部样式表只能 由样式规则或声明组成 。 层叠顺序：(优先级由高到低） 内联样式 &gt; 内部样式 &gt; 外部样式表 &gt; 浏览器中的样式声明（缺省值） 来自—— Web 前端开发实战教程（2014版）V1.8[M].教材用书，2014.（3.3 为文档应用样式的 3 种方式） IE6的双倍边距BUG指的是什么？怎么解决？ 在 IE6 下，如果对元素 设置了浮动 ，同时 又设置了 margin-left 或者 margin-right ，margin值会加倍 。 解决方法： 解决这个 Bug 的方法就是设置 display:inline 。 来自—— 曹刘阳.编写高质量代码：Web前端开发修炼之道[M].机械工业出版社，2016.6.（4.3 推荐的base.css） 前端页面由哪三层构成，分别是什么？作用是什么？ 最权威、最详细的关于Web标准的信息，可以访问官方网站：https://www.w3.org/ Web 标准由 一系列标准组合而成 ，其核心理念就是将网页的 结构 （HTML 或 XHTML）、样式 （CSS）和 行为（JavaScript） 分离开来，所以它可以分为三大部分：结构标准 、样式标准 和 行为标准 。结构标准 包括 XML 标准 、XHTML 标准、HTML 标准；样式标准 主要是指 CSS 标准；行为标准 主要包括 DOM 标准 和 ECMAScript 标准 。 一个符合标准的网页 ，标签中的 标签名 应该 全部都是小写的 ，属性 要 加上引号，样式和行为不再夹杂在标签中 ，而应该分别单独存放在样式文件和脚本文件中。理想状态下，网页源代码由三部分组成 ：html文件 、.css文件 和 .js文件 。标签中混有样式和行为的写法是不推荐的 。 来自—— 曹刘阳.编写高质量代码：Web前端开发修炼之道[M].机械工业出版社，2016.6.（1.2 Web标准— 结构、样式和行为的分离） CSS中margin和padding的区别 内边距（padding） 元素的内边距在边框和内容区之间，控制该区域最简单的属性是 padding 属性。padding 属性允许接受 长度值 或 百分比值 ，但 不允许 使用 负值 。可以按照上、右、下、左的顺序（顺时针）分别设置各边的内边距 ，各边均可以使用不同的单位或百分比： 123h1 &#123; padding: 8px 20% 0.5em 8pt;&#125; 也可以通过使用 padding-top、padding-right、padding-bottom、padding-left四个单独的属性，分别设置上、右、下、左内边距 ： 123456h1 &#123; padding-top: 8px; padding-right: 20%; padding-bottom: 0.5em; padding-left: 8pt;&#125; 可以为元素的内边距设置百分数值。而百分数值是 相对于其父元素的 width 计算的 。所以，如果父元素的 width 改变，它们也会改变。 特别注意：上下内边距与左右内边距一致；即 上下内边距的百分数 会相对于 父元素宽度设置 ，而 不是相对于高度 。 边框（border） 元素的边框是 围绕元素内容和内边距 的 一条或多条线 。使用 border 属性来定义。在HTML中，使用表格来创建文本周围的边框，但是通过使用 border 属性，可以创建出效果出色的边框，并且 可以应用于任何元素 。每个边框有 3 个方面：宽度、样式以及颜色。 CSS 规范指出，边框绘制在“元素的背景之上” 。这很重要，因为有些边框是“间断的”（例如点线边框或虚线边框），元素的背景应当出现在边框的可见部分之间。CSS2指出背景只延伸到内边距，而不是边框。后来CSS2.1进行了更正：元素背景是内容、内边距和边框区的背景 。大多数浏览器都遵循 CSS2.1 定义，不过一些较老的浏览器可能会有不同的表现。 边框样式 使用 border-style 属性用于 设置元素所有边框样式 ，或者 单独地为各边设置边框样式 。只有当这个值不是 none 时边框才可能出现 。 为一个边框定义多个样式： 123.aside &#123; border-style: solid dotted dashed double;&#125; 为元素框的某一个边设置边框样式： 123456.aside &#123; border-top-style: solid; border-right-style； dotted; border-bottom-style: ddashed; border-left-style: double;&#125; 可能的值 最不可预测的边框样式是 double。它定义为两条线的宽度再加上这两条线之间的空间等于 border-width 值。不过，CSS 规范并没有说其中一条线是否比另一条粗或者两条线是否应该是一样的粗，也没有指出线之间的空间是否应当比线粗。所有这些都有用户代理决定，创作人员对这个决定没有任何影响。 特别注意： 所有主流的浏览器都支持 border-style 属性，但任何版本的 Internet Explorer（包括 IE8）都不支持属性值“inherit” 或 “hidden”。 边框的宽度 通过设置 border-width 属性为边框指定宽度，border-width 简写属性 为元素所有边框设置 ，或者 单独地为各边框设置宽度 ，但 只有当边框样式不是 none 时才起作用 ，如果边框样式是 none ，边框宽度 实际上 会被重置为 0 ，不允许指定负长度值 。 为边框指定宽度有两种方法：可以指定 长度值 ，比如 2px 或 0.1em；或者 使用 3 个关键字之一 ，它们分别是 thin 、 medium（默认值）和 thick 。 特别注意： CSS 没有定义 3 个关键字的具体宽度，所以一个用户代理可能把 thin 、medium 和 thick 分别设置为等于 5px、3px 和 2px, 而另一个用户代理则分别设置为 3px、 2px 和 1px。 按照 top-right-bottom-left的顺序设置元素的各边边框： 1234p &#123; border-style: solid; border-width: 15px 5px 15px 5px;&#125; 也可以简写为（这种写法称为 值复制 ）： 1234p &#123; border-style: solid; border-width: 15px 5px;&#125; 可以分别设置边框各边的宽度： 1234567p &#123; border-style: solid; border-top-width: 15px; border-right-width: 5px; border-bottom-width: 15px; border-left-width: 5px;&#125; 边框的颜色 设置边框的颜色非常简单，CSS使用一个简单的 border-color 属性，它一次可以最多接受 4 个颜色值。border-color 属性是一个简写属性，可以 设置一个元素的所有边框中可见部分的颜色 ，或者 为 4 个边分别设置不同的颜色 。但要记住，边框的样式不能为 none 或 hidden ，否则边框不会出现 。 特别注意： 请始终 把 border-style 属性声明到 border-color 属性之前 ，元素必须在改变其颜色之前获的边框。 可以使用任何类型的颜色值，例如可以是 命名颜色 ，也可以是 十六进制 和 RGB 值 ： 1234p &#123; border-style: solid; border-color: blue rgb(25%，35%， 45%) #909090 red;&#125; 如果 颜色值少于 4 个 ，值复制就会起作用 。例如下面的规则声明了段落的上边框是蓝色，左右边框是红色。 1234p &#123; border-style: solid; border-color: blue red;&#125; 另外还有一些单边边框颜色属性，它们的原理与单边样式和宽度属性相同： 1234567p &#123; border-style: solid; border-top-color: blue; border-right-color: rgb(25%, 35%, 45%); border-bottom-color: #909090; borer-left-color: red;&#125; 外边距（margin） 围绕在元素边框的空白区域是外边距 ，设置外边距会 在元素外创建额外的“空白” 。而设置外边距最简单的方法就是使用 margin 属性，这个属性接受 任何长度单位 、百分数值 甚至 负值 ，可以是 像素 、英寸 、毫米 或 em 。这个简写属性可以设置为 auto，但更常见的做法是设置一个元素所有边距的宽度，或者各边上外边距的宽度。 边距重叠： 块级元素 的 垂直相邻外边距会合并 ，并且将 使用较大的外边距作为最终的边距 。而 行内元素实际上不占上下外边距 。行内元素的左右边距不会合并 。同样地，浮动元素的外边距也不会合并 。允许 指定负的外边距值 ，不过使用时要小心。 为 h1 元素的四个边分别定义了不同你的外边距： 123h1 &#123; margin: 10px 20px 30px 40px;&#125; 外边距的设置与内边距的设置相同，这些值的顺序是从上外边距（top）开始围着元素顺时针旋转的： top -&gt; right -&gt; bottom -&gt; left 另外，还可以为margin设置一个百分比数值： 123h1 &#123; margin: 10%;&#125; 百分数是 相对于父元素的 width 计算的 ，上面这个例子为 h1 元素 设置的外边距是其父元素 width 的 10% 。 margin 的默认值是 0 ， 所以如果没有为 margin 声明一个值，就不会出现外边距。但是，在实际中，浏览器许多元素已经提供了预定样式，外边距也不例外。例如，在支持 CSS 的浏览器中，外边距会为每个段落元素的上面和下面生成“空行”。因此，如果没有为 h1 元素声明外边距，浏览器可能会自己应用一个外边距。当然，只要你特别做了声明 ，就会覆盖默认样式 。 下面将讲解 如何使用值复制 。有时，会输入一些重复的值： 123p &#123; margin: 10px 15px 10px 15px;&#125; 通过值复制，可以不必重复的输入这对数字 ，上面的规则可以简写如下： 123p &#123; margin: 10px 15px;&#125; 这两个值可以 取代 前面 4 个值。这是如何做到的呢？CSS定义了一些规则，允许为外边距指定少于 4 个值。规则如下 ： 如果缺少左外边距的值，则使用右外边距的值。 如果缺少下外边距的值，则使用上外边距的值。 如果缺少右外边距是值，则使用上外边距的值。 利用这个简单的机制，只需要指定必要的值，而不必全部应用 4 个值 。但如果只是希望控制元素的单边上的外边距，就得使用如下单外边距属性： 123456p &#123; margin-top: 10px; margin-right: 15px; margin-bottom: 10px; margin-left: 15px;&#125; NetScape 和 IE 对 body 标签定义的默认边距（margin）值是 8px,因此 Opera 不是这样。相反地，OPera 将内部填充（padding）的默认值定义为 8px，因此如果希望对整个网站的边缘部分进行调整，并将之正确显示于 Opera 中，那么必须对 body 的 padding 进行自定义。 来自—— Web 前端开发实战教程（2014版）V1.8[M].教材用书，2014.（3.7 理解盒模型） &lt;img&gt; 标签上title与alt属性的区别是什么？ alt属性 在你的 图片 因为某种原因 不能加载时 在 页面显示的提示信息 ，它会直接输出在原本加载图片的地方。 title属性 在 鼠标悬停在该图片上时显的小提示 ，鼠标离开就没有了，有点类似 jQuery 的 hover ，另外，HTML 的绝大多数标签都支持 title 属性 ，title 属性就是 专门做提示信息的 。 虽然 alt 也有 title 的功能，但是只是在低版本的ie浏览器才支持，高版本及标准浏览器不支持这个功能了。 来自—— HTML语言中img标签的alt属性和title属性的作用与区别 页面导入样式时，使用link和@import有什么区别？ link 和 @import 是导入外部样式的两种方式。 link 语法 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件&quot; media=&quot;all&quot;&gt; 这个代码中有一个media，是用来制作响应式网页的，media=“all” 是用于所有设备， media=“screen” 用于电脑屏幕，平板电脑、智能手机场景，举个例子： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;title&gt;Examples&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;&lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt;&lt;style&gt; @media screen and (max-width:800px)&#123; body&#123; background-color: yellow; &#125; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt; hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 这段代码表示当屏幕的宽度小于等于800像素的时候，页面背景是黄色。 @import 语法 123&lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; @import url(&quot;css文件&quot;);&lt;/style&gt; 两者的区别： 从属关系 link 是 XHTML 标签，除了 可以引用css样式外还可以定义RSS等事物 ，但 @import 是 css 标签，只能引用 css 样式 。 加载的顺序 link 在页面加载的 同时加载 （需要等待），而 @import 是 在页面内容加载完成之后加载的 。 兼容性的区别 link 是 XHTML标签，没有兼容问题 ，而 @import 是在 css2.1 提出来的，低版本的浏览器不支持 。 DOM可控性的区别 link 支持使用JavaScript 控制 DOM去 改变样式 ，@import 不支持 。 权重的区别 link 引入的样式权重大于 @import 引入的样式。 换句话说就是在 link 标签中引入的 css 文件中使用 @import 时，相同样式将被该 css 文件本身的样式覆盖。 建议最好不要使用 @improt，如果 @import 加载的样式比较大，出现加载延迟，就可能会发生闪屏的问题。 来自—— link和@import区别、link 与@import的区别、link 和 @import区别 如何居中一个浮动元素？ 宽度不固定的浮动元素 下面是 HTML 代码： 123&lt;div class=&quot;outerbox&quot;&gt; &lt;div class=&quot;innerbox&quot;&gt;我是浮动的&lt;/div&gt;&lt;/div&gt; CSS 代码： 12345678910.outerbox&#123; float:left; position:relative; left:50%; &#125; .innerbox&#123; float:left; position:relative; right:50%; &#125; 宽度固定的浮动元素 在浮动元素外部包裹一层 div，将外层的 div 居中，浮动元素也就居中了。 下面是 HTML 代码： 123&lt;div class=&quot;outerbox&quot;&gt; &lt;div&gt;我是浮动的&lt;/div&gt;&lt;/div&gt; CSS 代码： 123456789.outerbox&#123; background-color:pink; /*方便看效果 */ width:500px ; height:300px; /*高度可以不设*/ margin: -150px 0 0 -250px; /*使用marin向左移动250px，保证元素居中*/ position:relative; /*相对定位*/ left:50%; top:50%;&#125; 让绝对定位的元素水平居中对齐 123456789.center&#123; position: absolute; /*绝对定位*/ width: 500px; height:300px; background: red; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0; /*此处不能省略，且为0*/&#125; 水平居中的主要属性有: text-alin:center; margin:0 auto; position:relative|absolute; left:50%; 来自—— Web前端面试指导(十四)：如何居中一个元素（正常、绝对定位、浮动元素）? 利用@media screen实现网页布局的自适应。 了解 Media Queries Media Queries ，其作用就是 允许添加表达式用以媒体查询 ，以此来选择不同的样式表 ，从而自动适应不同的屏幕分辨率 。 CSS2 里面虽然支持 @media 属性，但是能实现的 功能比较少 ，一般 只用做打印的时候做特殊定义的CSS ，我们不去讨论。 CSS3 的 @media 属性在 CSS3 里面已经演变成一种 media queries（媒体查询/匹配）了,在 CSS3 里面，可以用查询语句来匹配各种类型的屏幕 。 @media 与 @media screen 区别 @media screen 的 CSS 在打印设备里是无效的，而 @media 在打印设备里是有效的，如果css需要用在打印设备里，那么就用 @media ，否则，就用@media screen。 不过这只是笼统的做法，其实如果把“screen”换为“print”，写为@media print，那么该css就可用到打印设备上了，但要注意，@media print声明的css只能在打印设备上有效。 Media Queries工作方式: 在media属性里： screen 是媒体类型里的一种，CSS2.1定义了10种媒体类型。 and 被称为关键字，其他关键字还包括 not (排除某种设备)，only (限定某种设备)。 (min-width: 400px) 就是 媒体特性 ，其被放置在一对圆括号中。完整的特性参看相关的Media features部分。 一种是直接在link中判断设备的尺寸，然后引用不同的css文件： 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleA.css&quot; media=&quot;screen and (min-width: 400px)&quot;&gt; 意思是当屏幕的宽度大于等于 400px 的时候，应用 styleA.css。 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB.css&quot; media=&quot;screen and (min-width: 600px) and (max-width: 800px)&quot;&gt; 意思是当屏幕的宽度大于 600 小于 800 时，应用 styleB.css。 另一种方式，即是直接写在 style 标签里： 12345@media screen and (max-width: 600px) &#123; /*当屏幕尺寸小于600px时，应用下面的CSS样式*/ .class &#123; background: #ccc; &#125;&#125; 写法是前面加 @media，其它跟 link 里的 media 属性相同。 来自—— 利用@media与@media screen进行响应式布局、CSS3 @media 查询、利用@media screen实现网页布局的自适应 对BFC规范的理解 常见定位方案 常见的定位方案，定位方案是控制元素的布局，有三种常见方案。 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 BFC 概念 Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。BFC 和 IFC 都是常见的 FC。分别叫做 Block Fomatting Context 和 Inline Formatting Context。 那么 BFC 是什么呢？ BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 触发 BFC 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) BFC 特性及应用 同一个 BFC 下外边距会发生折叠； 这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠； BFC 可以包含浮动的元素（清除浮动）； 浮动的元素会脱离普通文档流，由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 BFC 可以阻止元素被浮动元素覆盖； 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 BFC的区域不会与float重叠。 内部的盒子会在垂直方向，一个个地放置； 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此； BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此； 计算BFC的高度时，浮动元素也参与计算。 来自—— 10 分钟理解 BFC 原理、浅谈BFC和IFC、前端精选文摘：BFC 神奇背后的原理、什么是BFC 说说你对SVG理解? SVG 是使用 XML 来描述二维图形和绘图程序的语言。 什么是SVG？ SVG 指可伸缩矢量图形 (Scalable Vector Graphics)。 SVG 用来定义用于网络的基于矢量的图形。 SVG 使用 XML 格式定义图形。 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失。 SVG 是万维网联盟的标准。 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体。 在 2003 年一月，SVG 1.1 被确立为 W3C 标准。参与定义 SVG 的组织有：太阳微系统、Adobe、苹果公司、IBM 以及柯达。 与其他图像格式相比，使用 SVG 的优势在于： SVG 可被非常多的工具读取和修改（比如记事本） SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图） SVG 可以与 Java 技术一起运行 SVG 是开放的标准 SVG 文件是纯粹的 XML SVG 的主要竞争者是 Flash。 与 Flash 相比，SVG 最大的优势是与其他标准（比如 XSL 和 DOM）相兼容。而 Flash 则是未开源的私有技术。 查看 SVG 文件 今天，所有浏览器均支持 SVG 文件 ，不过需要安装插件的 Internet Explorer 除外 。插件是免费的，比如 Adobe SVG Viewer。 来自—— SVG 简介、深入理解 SVG 系列（一） —— SVG 基础、SVG入门理解、svg文档 请简述HTML和XHTML最重要的4点不同？ XHTML 是更严谨更纯净的 HTML 版本。XHTML 是 HTML 与 XML（扩展标记语言）的结合物。XHTML 包含了所有与 XML 语法结合的 HTML 4.01 元素。 XHTML 是什么？ XHTML 指可扩展超文本标签语言（EXtensible HyperText Markup Language）。 XHTML 的目标是取代 HTML。 XHTML 与 HTML 4.01 几乎是相同的。 XHTML 是更严格更纯净的 HTML 版本。 XHTML 是作为一种 XML 应用被重新定义的 HTML。 XHTML 是一个 W3C 标准。 XHTML 于2000年的1月26日成为 W3C 标准。W3C 将 XHTML 定义为最新的HTML版本。XHTML 将逐渐取代 HTML。 所有新的浏览器都支持 XHTML XHTML 与 HTML 4.01 兼容。所有新的浏览器都支持 XHTML。 为什么要使用XHTML？ 我们认为万维网上的许多页面都包含着糟糕的 HTML 代码。 下面的 HTML 代码仍然可以工作得很好，即使它没有遵守 HTML 规则： 123456&lt;html&gt;&lt;head&gt;&lt;title&gt;This is bad HTML&lt;/title&gt;&lt;body&gt;&lt;h1&gt;Bad HTML&lt;/body&gt; 今天的市场中存在着不同的浏览器技术，某些浏览器运行在计算机中，某些浏览器则运行在移动电话和手持设备上。而后者没有能力和手段来解释糟糕的标记语言。 XML 是一种标记化语言，其中所有的东西都要被正确的标记，以产生形式良好的文档。XML 用来描述数据，而 HTML 则用来显示数据。因此，通过把 HTML 和 XML 各自的长处加以结合，我们得到了在现在和未来都能派上用场的标记语言 - XHTML。 XHTML 可以被所有的支持 XML 的设备读取，同时在其余的浏览器升级至支持 XML 之前，XHTML 使我们有能力编写出拥有良好结构的文档，这些文档可以很好地工作于所有的浏览器，并且可以向后兼容。 XHTML 与 HTML 之间的差异 最主要的不同： XHTML 元素必须被正确地嵌套。 在 HTML 中，某些元素可以像这样彼此不正确地嵌套： 1&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt; 在 XHTML 中，所有的元素必须像这样彼此正确地嵌套： 1&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt; 提示： 在嵌套列表中一个容易犯的错误，是忘记内部列表必须位于 li 元 素中，就像下面这样： 这是错误的： 123456789&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea &lt;ul&gt; &lt;li&gt;Black tea&lt;/li&gt; &lt;li&gt;Green tea&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 这是正确的： 12345678910&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea &lt;ul&gt; &lt;li&gt;Black tea&lt;/li&gt; &lt;li&gt;Green tea&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 注意：在正确代码的例子中，我们在 &lt;/ul&gt; 之后插入了一个 &lt;/li&gt; 标签。 XHTML 元素必须被关闭。 非空标签必须使用结束标签 这是错误的： 12&lt;p&gt;This is a paragraph&lt;p&gt;This is another paragraph 这是正确的： 12&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;p&gt;This is another paragraph&lt;/p&gt; 空标签也必须被关闭 空标签也必须使用结束标签，或者其开始标签必须使用/&gt;结尾。 这是错误的： 123A break: &lt;br&gt;A horizontal rule: &lt;hr&gt;An image: &lt;img src=&quot;happy.gif&quot; alt=&quot;Happy face&quot;&gt; 这是正确的： 123A break: &lt;br /&gt;A horizontal rule: &lt;hr /&gt;An image: &lt;img src=&quot;happy.gif&quot; alt=&quot;Happy face&quot; /&gt; 标签名必须用小写字母。 XHTML 规范定义：标签名和属性对大小写敏感。 这是错误的： 123&lt;BODY&gt;&lt;P&gt;This is a paragraph&lt;/P&gt;&lt;/BODY&gt; 这是正确的： 123&lt;body&gt;&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;/body&gt; XHTML 文档必须拥有根元素。 所有的 XHTML 元素必须被嵌套于 &lt;html&gt; 根元素中。其余所有的元素均可有子元素。子元素必须是成对的且被嵌套在其父元素之中。基本的文档结构如下： 1234&lt;html&gt;&lt;head&gt; ... &lt;/head&gt;&lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 更多的 XHTML 语法规则： 属性名称必须小写。 属性值必须加引号。 属性不能简写。 用 Id 属性代替 name 属性。 XHTML DTD 定义了强制使用的 HTML 元素。 来自—— XHTML 教程 什么是WebGL,它有什么优点? WebGL 是一项用来在网页上绘制和渲染三维图形并允许用户与之交互的技术。同时，WebGL ( Web 图形库)是一种 JavaScript API，用于在任何兼容的 Web 浏览器中呈现交互式 3D 和 2D 图形，而无需使用插件。WebGL 通过引入一个与 OpenGL ES2.0 紧密相符合的 API，可以在 HTML5 &lt;canvas&gt; 元素中使用。 WebGL有什么优势？ webGL内嵌在浏览器中，不需要安装其他插件就可以直接在浏览器中使用。 webGL不需要搭建开发环境，文本编辑器就可以开发。 轻松跨平台。 webGL基于并继承开源openGL。 测试当前浏览器是否支持WebGL 12345678// 创建一个canvas节点&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;// 判断canvas对象中是否有WebGL上下文var canvas = document.getElementById(&apos;canvas&apos;);var gl = canvas.getContext(&apos;webgl&apos;);if(!gl) &#123; console.log(&apos;当前浏览器版本不支持webgl，请升级或切换浏览器&apos;);&#125; 来自—— WebGL学习(1) — 浏览器支持测试、WebGL中文网、WebGL技术学习之路 CSS3新增伪类]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试题目及详解汇总-JavaScript部分]]></title>
    <url>%2F2018%2F08%2F06%2Fweb-front-end-interview-javascript%2F</url>
    <content type="text"><![CDATA[请指出document load和document ready的区别？ 共同点：这两种事件都代表的是页面文档加载时触发。 异同点： ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。 onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。 JavaScript中如何检测一个变量是一个String类型？请写出函数实现。方法一：typeof 1234function isString(obj)&#123; return typeof(obj) === "string"? true: false; // returntypeof obj === "string"? true: false;&#125; 方法二：constructor 123function isString(obj)&#123; return obj.constructor === String? true: false;&#125; 方法三：call()123456function isString(obj)&#123; return Object.prototype.toString.call(obj) === "[object String]"?true:false;&#125;如：var isstring = isString('xiaoming');console.log(isstring); // true 请用js去除字符串空格？方法一：使用replace正则匹配的方法 去除所有空格: str = str.replace(/\s*/g,””); 去除两头空格: str = str.replace(/^\s|\s$/g,””); 去除左空格： str = str.replace( /^\s*/, “”); 去除右空格： str = str.replace(/(\s*$)/g, “”); str为要去除空格的字符串，实例如下： 123var str = " 23 23 ";var str2 = str.replace(/\s*/g,"");console.log(str2); // 2323 来自—— 2018年web前端经典面试题及答案 你如何获取浏览器URL中查询字符串中的参数？js 字符串操作函数怎样添加、移除、移动、复制、创建和查找节点？写出3个使用this的典型应用比较typeof与instanceof？如何理解闭包？什么是跨域？跨域请求资源的方法有哪些？谈谈垃圾回收机制方式及内存管理开发过程中遇到的内存泄露情况，如何解决的？javascript面向对象中继承实现？JS继承与原型问题JavaScript 数组(Array)对象模块化编程一个页面从URL到加载显示完成，都发生了什么？队列、堆、栈的区别？]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试题目及详解汇总-网络部分]]></title>
    <url>%2F2018%2F08%2F06%2Fweb-front-end-interview-network%2F</url>
    <content type="text"><![CDATA[简述同步和异步的区别 同步是阻塞模式，异步是非阻塞模式。 同步 使用者通过 单个线程 调用服务；该线程发送请求，在服务 运行时阻塞，并且 等待响应 。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个 进程将会一直等待 下去，直到收到 返回信息才继续执行下去 。 异步 使用者通过 两个线程 调用服务；一个线程 发送请求 ，而另一个单独的线程 接收响应 。 异步是指 进程不需要一直等下去 ，而是 继续执行下面的操作 ，不管其他进程的状态。当有 消息返回时系统会通知进程进行处理 ，这样可以提高执行的效率。 来自—— 同步请求和异步请求的区别、简述同步和异步的区别、阻塞与非阻塞的区别 sessionStorage 、localStorage 和 cookie 之间的区别 sessionStorage 、localStorage 和 cookie 都用于浏览器本地存储。 sessionStorage HTML5 Web Storage API 提供；可以方便的在 Web 请求之间 保存数据 ；将数据保存在 session 对象中。所谓 session ，是指用户在 浏览某个网站 时，从 进入网站 到 浏览器关闭 所 经过的这段时间 ，也就是用户 浏览这个网站所花费的时间 。session 对象可以用来 保存在这段时间内所要求保存的任何数据 。sessionStorage 为 临时保存 。 sessionStorage 的 生命周期 是在仅在 当前会话 下有效。sessionStorage 的概念很特别，引入了一个 “浏览器窗口”的概念。sessionStorage 是在 同源的同窗口（或 tab ）中，始终存在的数据 。也就是说只要这个 浏览器窗口没有关闭 ，即使 刷新页面 或 进入同源另一页面 ，数据仍然存在 。关闭窗口 后，sessionStorage 即 被销毁 。同时 “独立” 打开的 不同窗口，即使是 同一页面 ，sessionStorage 对象也是 不同的 。 localStorage 将数据保存在 客户端本地的硬件设备 (通常指 硬盘 ，也可以是 其他硬件设备 )中，即使 浏览器被关闭 了，该 数据仍然存在 ，下次打开浏览器 访问网站时 仍然可以继续使用 。localStorage 为 永久保存 。localStorage 的 生命周期是 永久的 ，关闭页面或浏览器 之后localStorage 中的数据也 不会消失 。localStorage 除非 主动删除数据 ，否则 数据永远不会消失 。 cookie HTML5之前的本地存储 ;浏览器的 缓存机制 提供了可以将 用户数据 存储在 客户端上的方式 ，可以利用 cookie , session 等跟 服务端 进行 数据交互 。 session 共同点：都是 保存在浏览器端 ，且 同源的 。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。 来自—— cookies、sessionStorage和localStorage解释及区别 session和cookie之间的区别Web Storage与Cookie相比存在的优势 存储空间更大：cookie为4KB，而WebStorage是5MB； 节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量； 对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便； 快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快； 安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题； WebStorage提供了一些方法，数据操作比cookie方便； setItem (key, value) —— 保存数据，以键值对的方式储存信息。 getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。 removeItem (key) —— 删除单个数据，根据键值移除对应的信息。 clear () —— 删除所有的数据 key (index) —— 获取某个索引的key 独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。 来自—— cookies、sessionStorage和localStorage解释及区别 Ajax的优缺点及工作原理？ Ajax 是 Asynchronous Javascript And XML （异步 JavaScript 和 XML）的缩写，是指一种创建交互式网页应用的网页开发技术。 Ajax = 异步 JavaScript 和 XML（标准通用标记语言的子集）。 Ajax 是一种用于创建快速动态网页的技术。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 注意：Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 传统的Web应用交互由用户触发一个HTTP请求到服务器,服务器对其进行处理后再返回一个新的HTHL页到客户端, 每当服务器处理客户端提交的请求时,客户都只能空闲等待,并且哪怕只是一次很小的交互、只需从服务器端得到很简单的一个数据,都要返回一个完整的HTML页,而用户每次都要浪费时间和带宽去重新读取整个页面。这个做法浪费了许多带宽，由于每次应用的交互都需要向服务器发送请求，应用的响应时间就依赖于服务器的响应时间。这导致了用户界面的响应比本地应用慢得多。 与此不同，AJAX应用可以仅向服务器发送并取回必需的数据，它使用SOAP或其它一些基于XML的Web Service接口，并在客户端采用JavaScript处理来自服务器的响应。因为在服务器和浏览器之间交换的数据大量减少，结果我们就能看到响应更快的应用。同时很多的处理工作可以在发出请求的客户端机器上完成，所以Web服务器的处理时间也减少了。 优点：1.减轻服务器的负担,按需取数据,最大程度的减少冗余请求 2.局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验 3.基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离 缺点：1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性. 2.AJAX只是局部刷新,所以页面的后退按钮是没有用的. 3.对流媒体还有移动设备的支持不是太好等 1.创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)） 2.判断数据传输方式(GET/POST) 3.打开链接 open() 4.发送 send() 5.当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数。 AJAX的工作原理Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。(1).XMLHTTPRequest对象Ajax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。XMLHttpRequest 对象方法描述 (2).JavaScriptJavaScript是一在浏览器中大量使用的编程语言。 (3).DOM Document Object ModelDOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。(4).XML可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。 来自—— AJAX 简介、Ajax的优缺点及工作原理？、AJAX工作原理及其优缺点 28、http和tcp有什么区别？]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试题目及详解汇总-前端安全]]></title>
    <url>%2F2018%2F08%2F06%2Fweb-front-end-interview-security%2F</url>
    <content type="text"><![CDATA[如何避免XSS？22、前端安全方面有没有了解？XSS和CSRF如何攻防？]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试题目及详解汇总-前端相关]]></title>
    <url>%2F2018%2F08%2F06%2Fweb-front-end-interview-relevant%2F</url>
    <content type="text"><![CDATA[什么叫优雅降级和渐进增强？ 渐进增强（progressive enhancement）： 针对 低版本浏览器 进行 构建页面 ，保证 最基本 的功能，然后再针对 高级浏览器 进行 效果 、交互 等 改进 和 追加功能 达到 更好的用户体验 。 优雅降级（graceful degradation）： 一开始就构建 完整 的 功能 ，然后再针对 低版本浏览器 进行 兼容 。 渐进增强和优雅降级的区别： 优雅降级 是从 复杂 的现状 开始 ，并试图 减少用户体验 的供给。 渐进增强 则是从一个 非常基础 的，能够起作用 的 版本 开始，并 不断扩充 ，以 适应 未来环境的 需要 。 降级（功能衰减）意味着 往回看 ；而 渐进增强 则意味着 朝前看 ，同时 保证其根基处于安全地带 。 来自—— 什么叫优雅降级和渐进增强？ 浏览器的内核分别是什么? 浏览器的内核是分为两个部分的，一是 渲染引擎 (layout engineer或Rendering Engine)，另一个是 JS引擎 。现在JS引擎比较独立，内核更加倾向于说 渲染引擎 。 渲染引擎 负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则 解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 主流浏览器内核及其内核 五大流浏览器内核及其代表 Trident内核 代表作品是 IE ，因 IE捆绑在Windows中 ，所以占有极高的份额，又称为IE内核 或 MSHTML ，此内核 只能用于 Windows 平台 ，且 不是开源的 。代表作品还有 腾讯、Maxthon（遨游）、360浏览器 等。存在很多的兼容性问题。 Gecko内核 代表作品是 Firefox （即火狐浏览器）。因火狐是最多的用户，故常被称为 firefox 内核,它是 开源的 ，最大优势是 跨平台，在 Microsoft Windows 、Linux 、MacOs X 等主要操作系统中使用。 Webkit内核 代表作品是 Safari、曾经的 Chrome。开源的项目。 Presto内核： 代表作品是 Opera ，Presto 是由 Opera Software 开发的 浏览器排版引擎 ，它是世界公认 最快的渲染速度的引擎 。在13年之后，Opera宣布加入谷歌阵营，弃用了 Presto 。 Blink内核 由 Google 和 Opera Software 开发的 浏览器排版引擎 ，2013年4月发布。现在 Chrome 内核是 Blink 。谷歌还开发了自己的 JS引擎 ，V8 ，使JS运行速度极大地提高了 。 来自—— 浏览器的内核分别是什么？、五大流浏览器内核及其代表 常见调试方法16、什么是线程？进程和线程的关系是什么？怎么样从web前端方面优化性能？至少列举5点？如果制作一个访问量很大的网站，对css，js和图片应该怎么处理?31.写出几种IE6 BUG的解决方法？浏览器标准模式和怪异模式之间的区别是什么？你如何对网站的文件和资源进行优化？期待的解决方案包括：经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧？6、前台兼容性问题有哪些？平时如何管理项目？工作中用过什么构建工具？谈谈你对模块化的理解？平时都用什么第三方框架？10、谈谈你对预加载的理解？11、缓存和预加载的区别是什么？9、如何使用缓存？ 12、图片如何压缩？13、压缩文件有哪些方法？14、如何区分静态页面和动态页面？18、内存泄漏怎么理解？19、微格式到底是做啥用？、如何缓存整个页面，在没有网络的时候可以来回的跳转？（访问缓存）22、CDN是啥？23、浏览器一次可以从一个域名下请求多少资源？24、什么是垃圾回收机制（GC）？36、请描述你熟悉的语言的垃圾回收(GC)机制，他们对循环引用是如何处理的？如何查找内存泄漏(MemoryLeak)? 25、image和canvas在处理图片的时候有什么区别？image是通过对象的形式描述图片的 canvas通过专门的API将图片绘制在画布上 26、简述移动开发的注意点,如何做好不同手机的适配,你以前的项目是怎么做的?35、设计模式有哪些？列举你在前端开发工作中自己应用到或者了解到其他框架所用到的设计模式？单例、工厂、观察者、适配器、代理模式 19、什么是MVVM框架？来源 调试按钮F9 在你需要停下的地方设置断点F5 进入调试F10 单步运行F11 进入函数]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码]]></title>
    <url>%2F2018%2F08%2F06%2Fhttp-state-code%2F</url>
    <content type="text"><![CDATA[写在前面下面只是对常用的状态码进行罗列，具体可以参看 HTTP状态码 百度百科。 HTTP 状态码 HTTP 状态码共分为 消息 、成功 、重定向 、请求错误 以及 服务器错误 这五大类，下面将罗列出常用的状态码以及含义。 消息 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。 100Continue：继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息。 成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受 。 200OK：正常返回信息。 201Created：请求成功并且服务器创建了新的资源。 202Accepted：服务器已接受请求，但尚未处理。 重定向 这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。 301Moved Permanently：请求的网页已永久移动到新位置。 302Found：临时性重定向。 303See Other：临时性重定向，且总是使用 GET 请求新的 URI。 304Not Modified：自从上次请求后，请求的网页未修改过。 请求错误 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。 400Bad Request：服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401Unauthorized：请求未授权。 403Forbidden：禁止访问。 404Not Found：找不到如何与 URI 相匹配的资源。 服务器错误 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理 （5、6字头）。 500Internal Server Error：最常见的服务器端错误。 503Service Unavailable：服务器端暂时无法处理请求（可能是过载或维护）。 写在后面HTTP状态码知道哪些？ HTTP状态码-百度百科]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试]]></title>
    <url>%2F2018%2F08%2F06%2FWeb-interview%2F</url>
    <content type="text"><![CDATA[Web前端面试题分类基础试题 对于 Web 前端来说，那就是 HTML 、CSS 、JavaScript ，有的公司还要问一些 移动前端 的技能。 试题内容不外乎 padding 、 margin 的区别，谈谈 网页的性能优化 ，CSS3的新特性 ，使用 JavaScript 如何 添加 、删除 节点，或者给一段 HTML 代码、CSS 代码进行面试。 基础试题是 Web 前端岗位面试 必不可少 的内容，这是考察一个求职者 是否能够完成本职工作 的一个 核心指标 。 JavaScript 原生试题 通常是 JavaScript 中的 闭包 、面向对象 、原型链 、作用域 、this关键词 的用法等等。 只要你把 JavaScript原生 技能掌握的 扎扎实实的 ，任何框架 在你面前那 都不是难事 ，学习任何一个 JS 框架，只要花个几天的工夫，就能够从内到外的理解透彻，用时也会得心应手。就象一个掌握 C 语言的人，再学习 Java 等其他语言，那都是手到擒来的事，根本难不倒人家。 新技术试题 ES6，主流浏览器对 ES6 还只是部分支持，所有没有几家公司应用这个技术。 他面试你这类题，并 不是希望你多精通 ，掌握的多好 。主要是看你对 前沿技术 的 关注度 和对 新技术 的 求知欲 。 对于Web 前端来说，是一个更新特别快的行业，几乎每年都有不少的新技术面试。作为一个Web前端开发人员，如果对新技术不敏感，对新技术没有学习的欲望，那么可能很快会被行业淘汰。 技术面试 一定要凸显出自己有 很强的求知欲 ，对 新技术 是 非常感兴趣 且 愿意去不断学习 ，公司一般都 不会拒绝爱学习 的人。所以这就需要我们 提前去了解一些新技术 ，ES6 必问，不用面面俱到，基本的了解一下 let、const、promise、箭头函数 就差不多了。 Web前端技术学习分析 Web 前端中 HTML、CSS3、JavaScript 、移动前端 这几部分是 基础内容 ，也是前端开发工程师 必须掌握的技能 。 那么针对这一部分技能，就要学习的 扎扎实实，达到 精通 的程度。特别是 面向对象、闭包 、变量 和 对象的存储式 等，都要理解的 透彻，并且 能够条理清晰的表达出来 。 JS框架要 学习 透彻 一两个，其他的 框架 也要 了解。新技术 要 时时关注 ，不要求达到会用的程度，但是也要 了解 ，面试时 能够应付自如即可。 基础技能 占比是 最大 的，其中 JavaScript 占到 71％ ，可见 JavaScript 在前端中的地位。各个常用框架 的要求也都在 18％ 以上，其他 新技术 都在企业要求中占有 一定的比例 。 原文阅读]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[作品展示搭建]]></title>
    <url>%2F2018%2F08%2F02%2Fworks%2F</url>
    <content type="text"><![CDATA[作品展示搭建生成项目12npm install koa-generator -gkoa2 works 系统架构前端： HTML5、CSS3、JavaScript后端： Koa 写在前面系统中已经安装了 node.js 。 node.js 应用组成 引入required模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求。 接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 初始化项目1npm init 生成 package.json 文件 123456789101112131415161718&#123; &quot;name&quot;: &quot;works&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;作品展示&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git@git.coding.net:songxingguo/works.git&quot; &#125;, &quot;keywords&quot;: [ &quot;sxg&quot; ], &quot;author&quot;: &quot;songxingguo&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 创建服务器 思路 使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http ； 使用http.creatServer() 方法创建服务器 ； 使用 listen() 方法绑定8080端口； 函数通过 request , response 参数来接收和响应数据。 新建 server.js 文件 1234567891011121314var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); // 发送响应数据 &quot;Hello World&quot; response.end(&apos;Hello World\n&apos;);&#125;).listen(8080);// 终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:8080/&apos;); 启动服务1node server.js 新建文件 index.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[《Angular 2开发实战》学习笔记-Angular应用程序的TypeScript]]></title>
    <url>%2F2018%2F07%2F30%2FAngular-2-TypeScript%2F</url>
    <content type="text"><![CDATA[作为Angular应用程序语言的TypeScript 不使用JavaScript为什么不使用JavaScript进行开发 JavaScript是宽容的，因为它是一种动态类型语言。JavaScript类型错误只能在运行时被捕获，而在编译的时候不会进行类型匹配。 JavaScript不支持静态类型。使得重构困难。 目前有几十种语言可以编译成JavaScript（请参阅可编译为JavaScript的语言列表，网址为 http://mng.bz/vjzi ）。最受欢迎的是TypeScript(详见 www.typescriptlang.org )、CoffeeScript（详见 http://coffeescript.org ）和 Dart(详见 www.dartlang.org ） 为什么使用Dart语言 与第三方JavaScript库的互操作性不是很好。 Dart中的开发只能在附带了Dart VM的Chrome浏览器的专用版本（Dartium）中完成。其他浏览器没有Dart VM。 生成的JavaScript不易阅读。 Dart开发社区相当小。 Angular框架是用TypeScript编写的。 使用TypeScript为什么使用TypeScript编写Angular应用程序 可以使用ES6(甚至ES5)编写应用程序，但将TypeScipt作为编写JavaScript的一种更有成效的方法。以下是其原因： TypeScript支持类型。 这就允许TypeScript编译器在开发过程中帮你找到并修复许多错误，甚至是在运行应用程序之前。 极好的IDE支持。 IDE 提供了很好的上下文相关帮助 。TypeScript代码可以 由IDE重构 ，而JavaScript代码必须手动重构。IDE会 提示可用的API 。 Angular和类型定义文件被打包到一起，所以当使用Angular API时，IDE会执行 类型检查 并 提供开箱即用的上下文相关帮助 。 TypeScript 遵循ECMAScript 6和7规范 ，并向它们添加了 类型 、接口 、装饰器 、 类成员变量 （字段）、 泛型 以及 关键字 public 和 private 。将来的TypeScript版本将支持缺少的ES6特性并实现ES7的特性（请参阅TypeScript的Roadmap, 在GitHub上，网址为 http://mng.bz/Ri29 ） TypeScript接口允许声明将会在应用程序中用到的 自定义类型 。接口有助于避免在应用程序中使用错误类型的对象而引起的编译时错误。 生成的JavaScript代码易于阅读，而且看起来像手写的代码。 Angular文档、文章和博客中的大多数代码示例都以TypeScript给出（详见http://angular.io/docs ）。 转码器的角色除了JavaScript语言，Web浏览器不懂任何语言。如果源代码用TypeScript编写，那么在能够在浏览器或独立的JavaScript引擎中运行它们之前，它们必须转码为JavaScript。 转码意味着 将某种语言的源代码转换成另一种语言的源代码 。许多开发者喜欢使用单词“编译”（compiling）来描述，所以诸如“TypeScript编译器”和“将TypeScript编译成JavaScript”也是有效的。 Angular与静态类型的TypeScript的结合 简化了大中型Web应用程序的开发 。良好的工具 及 静态类型分析器 会大幅度 减少运行时的错误数 ，并将缩短上市时间。当完成时，Angular应用程序将会有大量的JavaScript代码；而且虽然用TypeScript进行开发需要编写更多的代码，但将通过 节省测试和重构时间 以及 运行时的错误数量来获益 。 TypeScript入门微软 开放了 TypeScript源代码 ，它把TypeScript的代码仓库托管在GitHUub上（详见 http://mng.bz/Ri29 ）。可以使用 npm安装TypeScript编译器 ，或者 从 www.typescriptlang.org 下载它 。TypeScript网站还有 一个托管在Web上的TypeScript编译器 （一个Palyground,详见 http://www.typescriptlang.org/play/index.html ），可以在那里输入TypeScript代码并通过交互将其编译成JavaScript。 TypeScript编译器安装并使用TypeScript编译器 TypeScript编译器本身就是用TypeScript编写的。可以使用Node.js的npm包管理器安装此编译器。 全局安装TypeScript编译器 ，在命名窗口或终端窗口中运行以下npm命令： 1npm install -g typescript 检查TypeScript编译器的版本 ，请运行以下命令： 1tsc --version TypeScript代码被保存在带有 .ts扩展名 的文件中。可以使用以下命令将TypeScript脚本文件 main.ts转码成main.js : 1tsc main.ts 还可以 生成source map文件 ， 将TypeScript源代码映射到生成的JavaScript中 。 使用source map ,当浏览器中运行时， 可以在TypeScript中设置断点 ，即使执行的是JavaScript。要 将main.ts编译成main.js ，同时还 生成source map文件main.map ,运行以下命令： 1tsc --sourcemap main.ts 在编译期间，TypeScript编译器会 从代码中删除所有的TypeScript类型、接口和关键字 ，以 生成有效的JavaScript 。通过提供编译器选项，可以生成与ES3、ES5或ES6语法兼容的JavaScript。目前默认是ES3。以下是 将代码转码成兼容ES5语法命令 ： 1tsc --t ES5 main.ts 在Web浏览器中转码TypeScript在开发过程中，我们使用本地安装的tsc。但转码也可以（在服务器上） 在部署过程中完成 ，或者 当Web浏览器加载应用程序时即时完成 。使用SystemJS库，它 内部使用tsc转码并动态加载应用程序模块 。请记住，在浏览器中即时转码，可能导致在用户设备上显示应用程序内容的延迟。如果使用SystemJS加载并在浏览器中将代码转码，默认会生成source map 。 在内存中编译代码 ，而 不生成输出.js文件 ，可使用–noEmit选项运行tsc: 1tsc --noEmit mian.ts 可以通过提供-w选项，以监控（watch）模式启动TypeScript编译器。在此模式下，无论何时修改并保存代码，都会将其自动转码到相应的JavaScript文件中。 要编译并监控全部的.ts文件 ，运行以下命令： 1tsc -w *.ts 编译器将会编译所有的TypeScript文件，在控制台打印错误消息（如果有的话），并继续监控改动的文件。一旦文件改动了，tsc将立即重新编译它。 注意通常，我们 不使用IDE来编译TypeScript 。我们用 SystemJS及其浏览器内置（in-browser)的编译器 ，或者使用 bundler(Webpack) ,它会使用一个特殊的用于编译的TypeScript加载器。我们使用由IDE提供的 TypeScript代码分析器来高亮显示错误 ，并使用 浏览器来调试TypeScript 。 TypeScrpt编译器允许配置编译的过程（指定源目录和目标目录、source map生成等待）。项目目录中配置文件tsconfig.json的存在，意味着可以 在命令行中输入tsc ,而编译器将从tsconfig.json中读取所有的选项。下面显示了一个示例的tsconfig.json文件。 12345678910&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es5&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;emitDecoratorMetadata&quot;: true, &quot;experimentaldecorators&quot;: true, &quot;rootDir&quot;: &quot;.&quot;, &quot;outDir&quot;:&quot;./js&quot; &#125;&#125; 该配置文件指示tsc将代码转码为ES5语法。生成的JavaScript文件将位于js目录中。tsconfig.json文件 可能包含files部分 ，它 列出了必须由TypeScript编译的文件 。因为使用rootDir选项，要求从项目的根目录开始所有文件的编译。 如果要将项目的某些文件从编译中排除，请将exclude属性添加到tsconfig.json中。以下演示了如排除node_modules目录的全部内容： 123&quot;exclude&quot; : [ &quot;node_modules&quot; ] 可以在TypeScript文档（详见 http://mng.bz/rf14 ）中阅读有关 配置编译过程 以及 TypeScript编译器选项的更多信息 。 JavaScript的超集TypeScript作为JavaScript的超集 Typescript完全支持ES5和大多数ES6语法。只要将JavaScript代码文件的 扩展名从.js改为.ts ，它们就将变为有效的TypeScript代码。到目前为止，见过的仅有两个例外是 处理可选的函数参数 ，以及 将一个值赋给一个对象字面量 。 在JavaScript中，即使一个 函数被声明具有两个参数 ，也 可以通过提供仅提供一个参数来调用它 ；而在TypeScript中，需要为 参数名称附加一个问号 ，以 使其成为可选的 。在JavaScript中，可以 使用空的对象字面量来初始化变量 ，并 使用点号立即附加属性 ；而在TypeScript中，需要使用方括号 。 但这些差异很小 。更重要的是，因为是JavaScript的超集，TypeScript为JavaScript添加了许多有用的特性。 提示如果正在 将JavaScript项目转换为TypeScript版本 ，可以 使用tsc编译器的–allowJs选项 。TypeScript编译器将检查输入的.js文件的语法错误，并根据tsc的–target和–module选项发出有效的输出。此输出还可以与其他的.ts文件相结合。就像.ts文件一样，仍会为.js文件生成source map。 可选类型可声明变量，并为它们全部或其中的一些提供类型。以下两行是有效的TypeScript语法： 12var name1 = &apos;John Smith&apos;;var name2: string = &apos;John Smith&apos;; 如果使用类型，TypeScript转码器可以在开发期间 检测不匹配的类型 ，而且IDE将会提供 代码补全 和 重构支持 。在任何大小合适的项目上，这有助于提高生产力。即使不在声明中使用类型，TypeScript也会 根据赋值猜测类型 ，并且之后 仍然会进行类型检查 ，这被称为 类型推断（type inference)。 以下TypeScript代码片段，不能将一个数字赋给本来是一个字符串的变量name1,即使它最初没有类型（JavaScript语法）声明。使用字符串初始化此变量之后，推断类型将不允许把数字值赋给name1。同样的规则适用于带有显式类型声明的变量name2: 1234567var name1 = &apos;John Smith&apos;;//JavaScript中，将类型不同的一个赋值给一个变量是有效的，但由于类型推断，这在TypeScript中是无效的name1 = 123;var name2: string = &apos;John Somith&apos;;//JavaScript中，将类型不同的一个赋值给一个变量是有效的，但由于显示的类型声明，这在TypeScript中是无效的name2 = 123; 在TypeScript中，可以声明有类型的 变量、 函数参数 和 返回值 。有四个关键字用于声明 基本类型 ： number 、 boolean 、 string 和 void 。void 在函数声明中 表示没有返回值 。与JavaScript类似，变量可以有 null 或 undefined 类型的值。 以下是带有显式类型声明变量的示例： 1234var salary： number;var name: string = &apos;Alex&apos;;var isValid: boolean;var customerName: string = null; 所有这些类型都是 any类型的子类型 。如果在 声明一个变量或函数参数时没有指定类型 ，TypeScript编译器将 假设它具有any类型 ，这将 允许给此变量后函数参数赋任何值 。也可以 显示地声明一个变量 ，指定它的类型为any 。这种情况下，不会应用推断类型。这两种声明都是有效的： 12var name2: any = &apos;John Smith&apos;;name2 = 123; 如果使用显式的类型声明变量，编译器将检查他们的值以保证它们与声明相匹配。TypeScript包括用于与Web浏览器交互的其他类型，例如HTMLElement和Document。 如果定义一个类或接口，它可以在变量声明中用作自定义类型。 函数TypeScript函数（及函数表达式）与JavaScript函数类似，但可以显式地声明参数类型和返回值。我们来编写一个计算税款的JavaScript函数，它有三个参数，并将根据州（state）、收入（income）和家属（dependents）数量计算税款。对于每个家属，根据此人居住的州，给予$500或$300的税款减免。 1234567function calcTax(state, income, dependents) &#123; if (state == &apos;NY&apos;) &#123; return income * 0.06 - dependents * 500; &#125;else if (state == &apos;NJ&apos;) &#123; returnn income * 0.05 - dependents * 300; &#125;&#125; 假如一个居住在新泽西（New Jersey）州的人，有￥50000的收入和两个家属。我们调用calcTax()： 1var tax = ccalcTax(&apos;NJ&apos;, 50000, 2); 变量tax得到的值是1900,它是正确的。即使calcTax()没有为函数参数声明任何类型，也 可以根据参数名称来猜测它们 。 现在我们来以错误的方式调用它，传入一个字符串值给家属（dependents）数量： 1var tax = calcTax(&apos;NJ&apos;, 50000, &apos;two&apos;); 直到调用这个函数之后，你才知道问题。变量tax会有一个NaN（Not a Number）值。只是因为没有机会显示地指定参数类型，一个bug就偷偷溜了出来。下面用TypeScript重写这个函数，为参数和返回值声明类型。 1234567function calcTax(state: string, income: number, dependents: number) :number &#123; if (state == &apos;NY&apos;) &#123; return income * 0.06 - dependents * 500; &#125;else if (state == &apos;NJ&apos;) &#123; returnn income * 0.05 - dependents * 300; &#125;&#125; 现在就没办法犯同样的错误了，传一个字符串值给家属（dependents）数量 ： 1var tax: number = calcTax(&apos;NJ&apos;， 50000， &apos;two&apos;); TypeScript编译器将显示一个错误: “Argument of type ‘string’ is not assignable to parameter of type ‘number’。”此外，该函数的返回值被声明为number，这会阻止你犯下另一个错误， 将税款计算的结果赋值给一个非数值的变量 ： 1var tax：string = calcTax(&apos;NJ&apos;， 50000， &apos;two&apos;); 编译器将捕获到这一点，产生错误:“Argument of type ‘string’ is not assignable to type ‘string’: var tax: string。”在任何项目上，这种编译期间的类型检查可以节省大量的时间。 默认参数声明一个函数时，可以指定默认的参数值 。唯一的限制是带默认值的参数， 不能在必需（required）参数的前面 。在上面代码中，要将NY作为state参数的默认值，就不能像下列声明一样： 123function calcTax(state: string = &apos;NY&apos;， income: number, dependents: number): number &#123; // the code goes here&#125; 需要更改参数的顺序 ，以保证在默认参数之后没有必需的参数： 123function calcTax(income: number, dependents: number, state: string = &apos;NY&apos;): number &#123; //the code goes here&#125; 甚至需要更改calcTax()函数体中的一行代码，现在可以使用两个或三个参数自由地调用它： 123var tax: number = calcTax(50000, 2);//or var tax： number = calcTax(5000, 2, &apos;NY&apos;); 两次调用的结果将是一样的。 可选参数在TypeScript中，通过 向参数名称附加一个问号 ，可以轻松地 将函数参数标记为可选的 ，唯一的限制是 可选的参数必须在函数声明的最后 。当编写带可选参数的函数代码时， 需要提供应用程序逻辑来处理没有提供可选参数的情况 。下面是修改税款计算函数：如果没有指定dependents,就不对计算的税款进行减免。 12345678910111213141516171819202122function calcTax(income: number, state: string = &apos;NY&apos;, dependents?: number): number &#123; var deduction: number; //处理dependents中的可选值 if (dependents) &#123; deduction = dependents * 500; &#125; else &#123; deduction = 0; &#125; if (state = &apos;NY&apos;) &#123; return income * 0.06 - deduction; &#125; else if (state = &apos;NJ&apos;) &#123; return income * 0.05 - deduction; &#125;&#125;var tax: number = calcTax(50000, &apos;NJ&apos;, 3);console.log(&quot;Your tax is&quot; + tax);var tax: number = calcTax(50000);console.log(&quot;Your tax is&quot; + tax); 请注意dependents?: number中的问号。现在该函数会检查是否为dependents提供值。如果没有，就将0赋给变量deduction；否则，为每个家属（dependent）减免扣税$500。1000运行上面代码将产生以下输出： 12Your tax is 1000Your tax is 3000 箭头函数表达式TypeScript 支持在表达式中使用匿名函数的简化语法 。不需要使用关键字function,宽箭头符号（=&gt;）用于将参数和函数体分开。TypeScript支持箭头函数的ES6语法。在其他一些编程语言中，箭头函数被称为 lambdda表达式 。 我们来看一个最简单的箭头函数的例子，函数体只有一行代码： 12var getName = () =&gt; &apos;John Smith&apos;;console.log(getName()); 空括号表示上述箭头函数没有参数。单行的箭头表达式不需要花括号或显式的return语句，而上述代码片段将在控制台打印“John Smith”。如果在TypeScript的playground中实验此代码，它们将被转换成以下ES5代码： 12var getName = function () &#123; return &apos;John Smith&apos;; &#125;;console.log(getName()); 如果箭头函数的函数体由多行构成，那么必须将它们括在大括号内并使用return语句。以下代码片段将硬编码的字符串值转换成大写形式，并在控制台打印“PETER LUGER”： 12345var getNameSuper = () =&gt; &#123; var name = &apos;Peter Luger&apos;.toUpperCase(); return name;&#125;console.log(getNameUpper()); 除了提供较短的语法之外，箭头函数表达式也消除了this关键字臭名昭著的混乱。在JavaScript中，如果在一个函数中使用this关键字，它可能并不指向正在调用此函数的对象。者可能会导致运行时bug，并需要额外的调试时间。下面看一个例子。下面代码有两个函数：StockQuoteGeneratorArrow()和StockQuoteGeneratorAnonymous()。每隔一秒，这两个函数就会调用Math.random(),为被作为参数提供的股票号（symbol）生成一个随机的价格。在内部，StockQuoteGeneratorArrow()使用箭头函数语法，提供setInterval()的参数，而StockQuoteGeneratorAnonymous()使用匿名函数。 123456789101112131415161718192021function StockQuoteGeneratorArrow(symbol: string) &#123; //将股票代号赋值给this.symbol this.symbol = symbol; setInterval(() =&gt; &#123; console.log(&quot;StockQuoteGeneratorArrow. The price quote for &quot; + this.symbol + &quot; is &quot; + Math.random()); &#125;, 1000);&#125;var stockQuoteGeneratorArrow = new StockQuoteGeneratorArrow(&quot;IBM&quot;);function StockQuoteGeneratorAnonymous(symbol: string) &#123; //将股票代码赋值给this.symbol this.symbol = symbol; setInterval(function() &#123; console.log(&quot;StockQuoteGeneratorAnonymous. The price quote for &quot; + this.symbol + &quot; is &quot; + Math.random()); &#125;, 1000);&#125;var stockQuoteGeneratorAnonymous = new StockQuoteGeneratorAnonymous(&quot;IBM&quot;); 这两种情况汇中，都将股票代号（“IBM”）赋给了对象this上的变量symbol。但是使用箭头函数，对构造函数StockQuoteGeneratorArrow()的实例引用，会被自动保存到单独的变量中；当从箭头函数中引用this.symbol时，会正确地找到它，并在控制台输出中使用“IBM”。但是当浏览器中调用匿名函数时，this指向全局的Window对象，该对象没有symbol属性。在Web浏览器中运行此代码，每隔一秒会打印下面这样的内容： 12StockQuoteGeneratorArrow. The price quote for IBM is 0.6888406401347633StockQuoteGeneratorAnonymous. The price quote for undefined is 0.7601010292924124 如你所见，当使用箭头函数时，它将IBM识别为股票编代号，但在匿名函数中是undefined。 注意TypeScript 使用一个外部作用域的this引用，通过传入此引用，它会替换箭头函数表达式中的this 。这就是为什么StockQuoteGeneratorArrow()中箭头内的代码能够正确地看到来自外部作用域的this.symbol的原因所在。 函数重载JavaScript 不支持函数重载 ，所以让几个函数同名但参数列表不同是不可能的。TypeScript的创建者引入了函数重载，但由于代码必须转码到单个JavaScript函数中，因此重载的语法不是很优雅。可以为仅有一个函数体的函数声明多个签名，（在此函数体中）需要检查参数的数量和类型，进而执行相应部分的代码： 1234567891011function attr(name: string): string;function attr(name: string, value: string): string;function attr(map: any): void;function attr(nameOrMap: any, value?: string): any &#123; if (nameOrMap &amp;&amp; typeof nameOrMap == &apos;string&apos;) &#123; //handle string case &#125; else &#123; //handle map case &#125; //handle value here&#125; 类如果有Java或C#开发经验，将会熟悉它们的经典形式中的类和继承的概念。在这些语言中，类的定义被作为单独的实体（像是蓝图）加载到内存中，并由该类的全部示例共享。如果一个类继承自另一个类，就使用两个类组合后的蓝图来实例化对象。 TypeScrript是JavaScript的超集，JavaScript仅支持原型继承，可以通过 将一个对象附加到另一个对象的prototype属性 来创建继承层级结构。在这种情况下，对象的继承（或者更确切地说链接）是动态创建的。 在TypeScript中，关键字class是简化编码的语法糖。最终，类会被转码为带有原型继承的JavaScript对象。在JavaScript中，可以声明一个构造函数并使用关键字new实例化它。在TypeScript中，也可以声明一个类并使用操作符new实例化它。 类可以包括 构造函数 、 字段（也称属性）和 方法 。声明的属性和方法通常被称为 类成员 。 我们创建一个简单的Person类，它包括四个属性用于存储姓、名、年龄和社会安全号码（Social Security number, 分配给每个美国合法居民的唯一标识符）。在下面的代码中可以看到声明并实例化Person类的TypeScript代码； 12345678910111213class Person &#123; firstName: string; lastName: string; age: number; ssn: string;&#125;var p = new Person();p.firstName = &quot;John&quot;;p.lastName = &quot;Smith&quot;;p.age = 29;p.ssn = &quot;123-90-4567&quot;; 然后是一个由tsc编译器生成的JavaScript闭包。 12345678910 var Person = /** @class */ (function () &#123; function Person() &#123; &#125; return Person;&#125;()); var p = new Person(); p.firstName = &quot;John&quot;; p.lastName = &quot;Smith&quot;; p.age = 29; p.ssn = &quot;123-90-4567&quot;; 通过为函数Person创建一个闭包，TypeScript编译器启用了暴露 或隐藏Person对象元素的机制。 TypeScript也支持类的构造函数，它允许在实例化对象时初始化对象变量。类构造函数仅会在对象创建期间被调用一次。下面代码显示了Person类的下一版，它使用关键字constructor,并用传给构造函数的值实例化类的字段。 123456789101112131415class Person &#123; firstName: string; lastName: string; age: number; ssn: string; constructor(firstName: string, lastName: string, age: number, ssn: string) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.ssn = ssn; &#125;&#125;var p = new Person(&quot;John&quot;, &quot;Smith&quot;, 29, &quot;123-90-4567&quot;); 生成的ES5版本在下面代码中显示。 12345678910var Person = /** @class */ (function () &#123; function Person(firstName, lastName, age, ssn) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.ssn = ssn; &#125; return Person;&#125;());var p = new Person(&quot;John&quot;, &quot;Smith&quot;, 29, &quot;123-90-4567&quot;); 一些JavaScript开发者看不到使用类的价值，因为他们 可以使用构造函数和闭包轻易地编写出相同的功能 。但JavaScript初学者会发现，相比于构造函数和闭包， 类的语法更易于阅读和编写 。 访问修饰符JavaScript无法将变量或方法声明为私有的（private, 对外部代码不可见）。要隐藏对象里的属性（或方法），需要创建闭包，这样既不会将属性附加到变量this，也不会在闭包return语句中返回。 TypeScript提供了关键字 public 、protected 和 private ，以帮助在开发阶段控制对象成员的访问。默认情况下，所有的类成员都具有public访问权限 ，并且它们 从类的外部都是可见的 。如果一个成员被声明带有protected修饰符，那么 它在该类机器子类中是可见的 。被声明为private的类成员 仅在该类内部可见 。 我们使用关键字private来隐藏ssn属性的值，所以它无法从Person对象的外部被直接访问。我们将展示两个版本，它们都声明了具有使用访问修饰符的属性类。此类的较长版本看起来是这样的： 12345678910111213141516class Person &#123; public firstName: string; public lastName: string; public age: number; private _ssn: string; constructor(firstName: string, lastName: string, age: number, ssn: string) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this._ssn = ssn; &#125;&#125;var p = new Person(&quot;John&quot;, &quot;Smith&quot;, 29, &quot;123-90-4567&quot;);console.log(&quot;Last name: &quot; + p.lastName + &quot; SSN: &quot; + p._ssn); 请注意， 私有变量的名称以下画线开始：_ssn。这只是私有属性的命名惯例。 上面的代码的最后一行尝试从外部访问私有的属性_ssn，所以TypeScript分线器将给出如下编译错误：“Property ‘_ssn’ is private and is only accessible in calss ‘Person’”。但 除非使用了编译器选项–noEmitOn-Error ,否则错误的代码将被转码为JavaScript。 1234567891011var Person = /** @class */ (function () &#123; function Person(firstName, lastName, age, ssn) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this._ssn = ssn; &#125; return Person;&#125;());var p = new Person(&quot;John&quot;, &quot;Smith&quot;, 29, &quot;123-90-4567&quot;);console.log(&quot;Last name: &quot; + p.lastName + &quot; SSN: &quot; + p._ssn); 关键字private仅使其在TypeScript代码中是私有的 。当尝试从外部访问一个对象的属性时，IDE将不会在上下文相关帮助中显示私有成员，但是， 生产（环境）中的JavaScript会将类的所有属性和方法视为公开的 。 TypeScript 允许使用构造函数的参数提供访问修饰符 ，例如以下Person类的简短版本所示： 123456class Person &#123; constructor(public firstName: string, public lastName: string, public age: number, private _ssn: string) &#123; &#125;&#125;var p = new Person(&quot;John&quot;, &quot;Smith&quot;, 29, &quot;123-90-4567&quot;); 当使用带有访问修饰符的构造函数时，TypeScript编译器会将其作为一条指令 ，创建并保留与构造的参数相匹配的类属性 。 不需要显式声明并初始化它们 。Person类的长短两个版本都会生成相同的JavaScript。 提示访问修饰符有助于在开发期间控制对类成员的访问，但并不像Java和C#这样的语言那么严格。 方法当一个函数被声明在一个类中时，它被称为 方法 。在JavaScript中，需要在对象的原型上声明方法；但是使用类，可以通过指定一个后跟括号和大括号的名称来声明方法，就像在其他面向对象语言中一样。 接下来的代码片段展示了如何声明并使用具有方法doSomething()的类MyClass，此方法有一个参数，没有返回值。 12345678class MyClass &#123; doSomething(howManyTimes: number)： void &#123; // do something here &#125;&#125;var mc = new MyClass();mc.doSomething(5); 静态成员和实例成员上面的代码中，首先创建了类的一个实例，然后使用一个指向此实例的引用变量来 访问它的成员： 1mc.doSomething(5) 如果使用 关键字static 声明一个类属性或方法，它的值将被类的所有实例共享 ，而 无需创建一个实例来访问静态成员 。不是使用引用变量（例如mc）,而是 使用类的名称 。 1234567class MyClass &#123; static doSomething(howManyTimes: number): void &#123; // do something here &#125;&#125;MyClass.doSomething(5); 如果实例化一个类 ，并且 需要从声明在此类中的另一个方法中调用一个类方法 ，则 必须 使用 关键字this（例如。this.doSomething(5)）。在其他的编程语言中，在类的代码中使用this是可选的，但如果没有显式地使用this,TypeScript编译器将会抱怨服务找到该方法。 我们将公共的设置器（setter）和访问器（getter）方法添加到Person类，以设置并获取_ssn的值。 1234567891011121314151617181920class Person &#123; //在这一版中，构造函数的最后一个参数是可选的（_ssn?） constructor(public firstName: string, public lastName: string, public gae: number, private _ssn?: string) &#123; &#125; //访问器方法 get ssn(): string &#123; return this._ssn; &#125; //设置器方法 set ssn(value: string) &#123; this._ssn = value; &#125;&#125;var p = new Person(&quot;John&quot;, &quot;Smith&quot;, 29);// 创建Person对象的实例后，使用ssn设置器将该值赋给_ssnp.ssn = &quot;456-70-1234&quot;;console.log(&quot;Last name: &quot; + p.lastName + &quot;SSN: &quot; + p.ssn); 在上面代码中，访问器和设置器不包含任何应用程序逻辑；但是在实现的应用程序中，这些方法会执行验证。例如，访问器和设置器中的代码可以检查调用者是否被授权获取或设置_ssn值。 注意从ES5规范开始，JavaScript也支持访问器和设置器。 请注意，在这些方法中 使用了关键字this来访问对象的属性 。 这在TypeScript中是强制性的 。 继承JavaScript 支持基于原型对象的继承，其中一个对象可以使用另一个对象作为原型。像ES6及其他面向对象语言一样，TypeScrript具有用于类继承的关键字extends。但是，在转码为JavaScript的过程中，生成的代码会使用原型继承的语法 。下面代码显示了如何创建一个Employee类，它扩展了Person类。 1234567class Person &#123; constructor(public firstName: string, public lastName: string,, public age： number, private _ssn: string) &#123; &#125;&#125;class Employee extends Person &#123;&#125; 下面代码可以看到转码后的JavaScript版本，它使用原型继承。 1234567891011121314151617181920212223242526var __extends = (this &amp;&amp; this.__extends) || (function () &#123; var extendStatics = Object.setPrototypeOf || (&#123; __proto__: [] &#125; instanceof Array &amp;&amp; function (d, b) &#123; d.__proto__ = b; &#125;) || function (d, b) &#123; for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; &#125;; return function (d, b) &#123; extendStatics(d, b); function __() &#123; this.constructor = d; &#125; d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()); &#125;;&#125;)();var Person = /** @class */ (function () &#123; function Person(firstName, lastName, age, number, _ssn) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this._ssn = _ssn; &#125; return Person;&#125;());var Employee = /** @class */ (function (_super) &#123; __extends(Employee, _super); function Employee() &#123; return _super !== null &amp;&amp; _super.apply(this, arguments) || this; &#125; return Employee;&#125;(Person)); 此代码的TypeSccript版本更简洁且易于阅读。 我们来为Employee类添加一个构造函数和department属性。 12345678910111213class Employee extends Person &#123; //声明属性department department: string; //创建一个具有额外的department参数的构造函数 constructor(firstName: string, lastName: string, age: number, _ssn: string, department: string) &#123; //声明构造函数的子类必须调用父类的构造函数 super(firstName, lastName, age, _ssn); this.department = department; &#125;&#125; 如果要在子类类型的对象上，调用一个声明在父类中的方法，可以使用此方法的名 ，就像它被声明在子类中一样 。但是，有时 要专门调用父类的方法 ，这正是 使用关键字super 的时候。 关键字super可以有两种使用方式。在 派生类的构造函数中 ，将其作为一个方法进行调用 。还可以 使用关键字super来专门调用父类的方法 。这 通常被用于方法重写（method overriding）。例如，如果父类及子类都要doSomething()方法，则子类 可复用编码在父类中功能 ，并且 还可以添加其他的功能 ： 1234doSomething() &#123; super.doSomething(); // Add more functionality here&#125; 泛型 TypeScript 支持参数化类型 ，也称为 泛型（generics） ，它可以用于各种场景。例如，可以创建一个函数，它 能够使用任何类型的值 ，但 在特定的上下文调用时 ，能够明确地指定具体的类型 。 举另一个例子：一个数组可以保存任何类型的对象，但是可以指定该数组中允许特定对象类型（例如,Person的实例）。如果试图添加不同类型的对象，TypeScript编译器将生成错误。 以下代码片段声明了一个Person类，创建了它的两个实例，并将它们存储在使用泛型类型声明的数组workers中。通过将它们放在 尖括号中 （例如，&lt;Person&gt; ）来表示泛型。 12345678910111213141516class Person &#123; name: string;&#125;class Employee extends Person &#123; department: number;&#125;class Animal &#123; breed: string;&#125;var workers: Array&lt;Person&gt; = [];workers[0] = new Person();workers[1] = new Employee();workers[2] = new Animal(); //compile-time error 在此代码片段中，声明了Person、Employee和Animal类，以及一个带有泛型类型的数组workers。通过这么做，表示计划 仅存储Person类或其子类 。尝试将一个Animal实例存进相同的数组，将导致编译时错误。 如果在一个拥有动物员工（如警犬）的组织里工作，可以如下更改数组workers的声明： 1var workers: Array&lt;any&gt; = []; 可以为任意对象或函数使用泛型类型吗？不行。对象或函数的创建者必须允许这一特性。如果在GitHub上（参见 http://mng.bz/I3V7 ），打开TypeScript的类型定义文件（lib.d.ts）,并搜索“interface Array”,将会看到Array的声明，如下所示。 12345678910111213141516171819202122 //////////////////////////////// ECMAScript Array API (specially handled by compiler)/////////////////////////////interface Array&lt;T&gt; &#123; /** * Gets or sets the length of the array. This is a number one higher than the highest element defined in an array. */ length: number; /** * Returns a string representation of an array. */ toString(): string; toLocaleString(): string; /** * Appends new elements to an array, and returns the new length of the array. * @param items New elements of the Array. */ push(...items: T[]): number; /** * Removes the last element from an array and returns it. */ pop(): T; 第四行中的 &lt;T&gt; ，意味着 TypeScript允许使用Array声明类型参数 ，并且编译器 将检查程序中提供的特定类型 。上面代码将泛型参数 &lt;T&gt; 指定为&lt;Person&gt; 。但是，由于 ES6不支持泛型 ，因此在转码器 生成的代码中将看不到它们 。对于开发者，它只是额外的编译时的安全网 。 在上面代码中，在第18行可以看到另一个T。当 使用函数参数指定泛型类型 时，不需要尖括号 。但在TypeScript中，实际上没有类型T。这里的T,意指方法push()可以将特定类型的对象推入一个数组中，如下所示： 1workers.push(new Person()); 在本节中，我们说明了使用泛型类型的一个用例，其中包含已经支持泛型的数组。也可以 创建自己的支持泛型的类或函数 。在代码中的某个地方，如果要尝试调用方法saySomething(),但提供了错误的类型，TypeScript编译器将给出错误。 123456789function saySomething&lt;T&gt;(data: T) &#123;&#125;//用一个字符串替换TsaySomething&lt;string&gt;(&quot;Hello&quot;);//产生一个编译错误，因为123不是以字符串saySomething&lt;string&gt;(123); 生成的JavaScript将不会包含任何泛型信息 ，上面的代码将被转码成如下代码： 1234function saySomething(data) &#123;&#125;saySomething(&quot;Hello&quot;);saySomething(123); 如果想深入学习泛型，请参阅TypeScript手册（详见 http://mng.bz/447K ）的Generics部分。 接口JavaScript 不支持接口的概念 ，在其他的面向对象语言中，接口被 用来引入API必须准守的代码契约（code contract）。契约的一个例子可以是，类X声明它实现了接口Y。 如果类X不包括接口Y中声明的一个方法是实现，被认为是违反了契约 ，并且不会被编译。 TypeScript包含关键字 interface 和用于支持接口的 implements,但 接口不会转码为JavaScript代码 。它们 只是帮助你避免在开发过程中使用错误的类型 。 在TypeScript中，使用接口的模式有两种： 声明一个接口，它定义了一个包含一些属性的自定义类型。 然后，声明一个具有这种类型的参数的方法。当此方法被调用时，编译器将检查作为参数给出的对象是否包含所有在该接口中声明的属性。 声明一个包含（未实现的）抽象方法的接口。 当一个类声明它implements此接口时，该类必须提供所有抽象方法的实现。 声明自定义类型使用接口声明自定义类型 当使用JavaScript框架时，可能会遇到需要某中配置对象作为函数参数的API。要弄明白此配置对象中的哪个属性必须提供，需要打开此API的文档或者阅读该框架的源码。在TypeScript中，可以 声明一个接口 ，它包含了配置对象中必须存在的所有属性及其类型 。 我们看看如何在Person类中完成 这些，它包含一个构造函数，有四个参数：firstName、lastName、age和ssn。这一次，将声明一个包含四个成员的接口IPerson，并且将修改Person类的构造函数，以将此自定义类型的对象用作参数。 1234567891011121314151617181920212223242526interface IPerson &#123; firstName: string; lastName: string; age: number; //声明接口IPerson,将ssn作为可选成员（注意问号） ssn?: string;&#125;class Person &#123; //类Person有一个构造函数，它带有一个类型为IPerson的参数 constructor(public config: IPerson) &#123; &#125;&#125;//创建一个成员与IPerson兼容的对象字面量aPersonvar aPerson: IPerson = &#123; firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, age: 29&#125;//实例化Person对象，提供一个IPerson类型的对象作为参数var p = new Person(aPerson);console.log(&quot;Last name: &quot; + p.config.lastName); TypeScript 具有结构化的类型系统 ，这意味着如果两个不同的类型包含相同的成员，这些类型将被认为是兼容的。拥有相同的成员，意思是这些成员具有相同的名称和类型。在上面代码中，即使不指定变量aPerson的类型，它也仍会被认为是与Person兼容的，而且当实例化Person对象时，可以被用作构造函数参数。 如果改变了IPerson中一个成员的名称或类型，TypeScript将会报错。另一方面，如果尝试实例化一个Person，其中包括一个对象，它拥有IPerson所有必需的成员和一些其他的成员，则不会引发红色标识（错误）。可以将以下对象作为Person的构造函数的一个参数： 123456var anEmployee: IPerson = &#123; firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, age: 29, department: &quot;HR&quot;&#125; 在接口IPerson中，没有定义成员department。但是，只要该对象拥有接口中列出的其他全部成员，就满足契约条款。 接口IPerson没有定义任何方法，但是，TypeScript接口可以包括没有实现的方法签名。 关键字implements 使用关键字implements 关键字implements与类声明一起使用 ，以声明该类将实现的特定的接口。假如接口IPayable的声明如下： 12345interface IPayable &#123; increase_cap: number; increasePay(percent: number): boolean&#125; 现在，类Employee可以声明它实现了IPayable: 123class Employee implementsd IPayable &#123; // The implementation goes here&#125; 在进入实现细节之前，我们来回答下面这个问题：“为什么不把所有必需的代码都写在类中，而将一部分代码隔离到接口中？”我们假设，要编写一个应用程序，它可以让你为你的组织的雇员增加薪水。可以创建一个Employee类（扩展自Person类），并包含increaseSalary()方法，然后，业务分析人员可能要求新增为外包人员增加工资的功能，他们为你们公司工作。但是，外包人员用他们自己公司名称和ID表示，他们没有工资的概念，并且按小时付费。 可以创建另一个类Contractor（不是继承自Person类），其中包括一些属性和increaseHourlyRate()方法 。现在，你有了两个不同的API：一个用于增加员工的工资，另一个用于增加外包人员的工资。更好的解决方案是：创建一个通用得我接口IPayable,并让Employee和Contractor类为各自提供不同的IPayable实现 ，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface IPayable &#123; //接口IPayable包括方法increasePay()的签名，它将被Employee和Contractor实现 increasePay(percent: number): boolean&#125;class Person &#123; //Person类作为Employee的基类 // properties are omitted tor brevity constructor() &#123; &#125;&#125;//Employee类继承自Person类，并实现了接口IPayable。一个类可以实现多个接口class Employee extends Person implements IPayable &#123; //Employee 类实现了increasePay()方法。员工的工资可以增加任意金额。所以此方法只是在控制台打印消息，并返回true。（允许增加） increasePay(percent: number): boolean &#123; console.log(&quot;Increasing salary by &quot; + percent); return true; &#125;&#125;class Contractor implements IPayable &#123; //Contractor类包含一个属性，它将加薪的上限设置为20% increaseCap: number = 20; increasePay(percent: number): boolean &#123; //Contractor类中increasePay()的实现有所不同。使用大于20的参数调用increasePay()，返回消息“Sorry”和返回值false if (percent &lt; this.increaseCap) &#123; console.log(&quot;Increasing hourly rate by &quot; + percent); return true; &#125; else &#123; console.log(&quot;Sorry, the increase cap for contractors is &quot;, this.increaseCap); return false; &#125; &#125;&#125;//声明一个带有泛型&lt;IPayable&gt;的数组，允许放置IPayable类型的任何对象（但请参阅下方注解）var workers : Array&lt;IPayable&gt; = [];workers[0] = new Employee();workers[1] = new Contractor();//现在，可以在数组workers中任何对象上调用increasePay()。请注意，不要对带有单个参数的worker的箭头函数表达式使用括号workers.forEach(worker =&gt; worker.increasePay(30)); 运行上面代码，会在浏览器的控制台产生如下输出： 12Increasing salary by 30Sorry, the increase cap for contractors is 20 为什么要使用关键字inplements声明类？ 上面代码说明了 TypeScript的结构化的子类型 。如果从Employee或Contractor的声明中删除implements IPayable，代码仍然可以工作，而且编译器不会对将这些添加到workers数组的几行代码报错。编译器足够聪明地看到，虽然该类没有显示地声明implements IPayable，但它正确地实现了increasePay()。 但是，如果删除了implements IPayable，并尝试修改任何一个类中increasePay()方法的签名，就不能将这个对象放到workers数组中，因为对象不再是IPayable类型。此外，没有关键字implements,IDE支持（例如重构）将会被破坏。 使用可调用接口TypeScript具有一个有趣的特性，叫做 可调用接口（callable interface）,它包含一个 裸函数签名 （bare function signature, 不带函数名称的签名）。以下示例显示了一个裸函数签名，它接收一个number类型的参数并返回一个boolean值： 1(percent: number): boolean; 该裸函数签名表示 此接口的实例是可调用的 。咋下面代码中，将展示声明IPayable的不同版本，其中包含一个裸函数签名。为了简洁起见，为此例中删除了继承。将会声明独立的函数，用于实现员工及外包人员的工资增加规则。这些函数将作为参数传递，并会被Person类的构造函数调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//包含一个裸函数签名的可调用接口interface IPayable &#123; (percent: number): boolean;&#125;class Person &#123; //Person类的构造函数，将可调用接口IPable的一个实现作为一个参数 constructor(private validator: IPayable) &#123; &#125; //increasePay()方法调用传入的IPayable实现上的裸函数，提供用于验证的工资增加值 increasePay(percent: number): boolean &#123; return this.validator(percent); &#125;&#125;//通过使用箭头函数表达式，实现了员工工资增加规则var forEmployees: IPayable = (percent) =&gt; &#123; console.log(&quot;Increasing salary by &quot;, percent); return true;&#125;//通过使用箭头函数表达式，实现了外包人员工资的增加规则var forContractors: IPayable = (percent) =&gt; &#123; var increaseCap: number = 20; if (percent &lt; increaseCap) &#123; console.log(&quot;Increasing hourly rate by &quot; + percent); return true; &#125; else &#123; console.log(&quot;Sorry, the increase cap for contractors is &quot;, increaseCap); return false; &#125;&#125;var workers : Array&lt;Person&gt; = [];//实例化两个Person对象，传入不同的加薪规则workers[0] = new Person(forEmployees);workers[1] = new Person(forContractors);//调用每个实例上的increasePay()，验证加薪30%workers.forEach(worker =&gt; worker.increasePay(30)); 运行上面代码，将会在浏览器的控制台生成以下输出： 12Increasing salary by 30Sorry, the increase cap for contractors is 20 将类作为接口 在TypeScript中，可以将任何类看作接口。如果声明了类A{}和B{},写作class A implements B {}是完全合法的。 当转码成JavaScript时，TypeScript接口不会生成任何输出 。而且如果在一个单独的文件（例如iplayable.ts）中放入一个接口声明，并使用tsc编译它，将生成要给空的ipayable.js文件。如果使用SystemJS从文件（例如ipayable.js）导入此接口，将会报错，因为不能导入空文件。需要让SystemJS知道，必须将IPayable作为模块，并在全局的System注册表中注册它。这可以通过在配置SystemJS时使用meta注解来完成，如下所示： 12345678910Symtem.config(&#123; transpiler: &apos;typescript&apos;, typescriptOPtions: &#123;emitDecoratorMetadata: true&#125;, packages: &#123;app: &#123;defaultExtension: &apos;ts&apos;&#125;&#125; meta: &#123; &apos;app/ipayable.ts&apos;: &#123; format: &apos;es6&apos; &#125; &#125;&#125;); 接口机制提供了创建自定义类型的一种方式，并最小化了类型相关错误数量。此外，它极大地简化了依赖注入设计模式的实现。 可以在TypeScript手册（详见 http://mng.bz/spm7 ）的“Interfaces”小节找到更多详情。 注意 实用工具TypeDoc是一个便捷的工具，用于根据TypeScript代码中的注释生成程序文档，可以从 www.npmjs.com/package/typedoc 获得。 使用注解添加类元数据术语 元数据 （metadata）有着不同的定义。流行的定义是，元数据是 有关数据的数据 。我们认为 ** 元数据是描述代码的数据 。TypeScript装饰器提供了一种为代码添加元数据的方式。特别地，要 将TypeScript类转换为Angular组件，可以 使用元数据注解它 。注解以@符号开头。 要将TypeScript类转换为Angualr UI组件，需要使用注解@Component装饰它。Angular将内部解析注解并生成代码 ， 这会将所需的行为添加到此TypeScript类： 123456789101112@Component(&#123; //这里包含选择器名称，以在HTML文档中识别组件 //提供具有HTML片段的template属性来渲染组件。组件的样式也在这里 // //&#125;)class HelloWordComponent &#123; //实现组件的应用程序逻辑的代码在这里 //&#125; 当使用注解时，应该有一个 注解处理器 ，它可以 解析注解的内容 ，并将其 转换成运行时（浏览器的JavaScript引擎）可以理解的代码 。Angular编译器ngc 执行注解处理器的职责。 要使用Angular支持注解 ，需要将它们的实现导入到应用程序中 。例如，需要从Angular模块带入@Component注解。 1import &#123; Component &#125; from &apos;Angular 2/core&apos; 虽然这些注解的实现是在Angular中完成的，但可能需要一个标注化的机制来创建自己的注解。这就要用到 TypeScript装饰器 。Angular提供了它的注解，用于装饰代码，但 TypeScript允许在装饰器的支持下创建自己的注解 。 类型定义文件 几年来，TypeScript定义文件的一个大型代码库—— DefinitelyTped ，一直是 新的ECNAScript API 以及 数百个用JavaScript编写的流行框架和库 的唯一来源。这些（定义）文件的目的，是 让TypeScript编译器知道这些库的API所期望的类型 。虽然代码仓库definitelytyped.org仍然存在，但是npmjs.org成为类型定义文件的新的代码仓库。而且我们在所有代码示例中都使用了它。 任何定义文件名称的后缀都是d.ts，而且在运行npm install之后，可以在node_modules/@Angular的子目录中找到定义文件。 所有必需的*.d.ts文件，都与Angular的npm包打包在一起，并且不需要单独安装它们。项目中定义文件的存在，将允许TypeScript编译器确保代码在调用Angular API时，使用正确的类型 。 例如，通过调用bootstrapModule()方法启动Angular应用程序，会将应用程序的根模块作为参数传给它。文件application_ref.d.ts包含此方法的如下定义： 12bootstrapModule&lt;M&gt;(moduleType: ConcreteType&lt;M&gt;),compilerOptions?: CompilerOPtions | CompilerOptions[]): Promise&lt;NgModuleRef&lt;M&gt;&gt;; 通过阅读此定义，你和编译器tsc了解到，可以使用一个ConcreteType类型的必选参数和一个可选的编译器选项数组来调用该方法。如果application_ref.d.ts文件不是项目的一部分，TypeScript可能会允许使用错误的参数类型调用bootstrapModule()方法，或者根本不带任何参数，这将会导致运行时错误。但是由于application_def.d.ts存在，因此TypeScript会生成编译时错误提示“Supplied parameters do not match any signature of call target”。当编写调用Angular函数或为对象属性赋值的代码时，类型定义文件还允许IDE显示上下文相关的帮助。 安装类型定义文件要为使用JavaSript编写的库或框架安装类型定义文件，开发者需要使用类型定义管理器：tsd和Typings。前者被弃用了，因为它仅允许从definitelytyped.org获取*.d.ts文件。在TypeScrit2.0发布之前，使用Typings(详见 https://github.com/typeings/typeings ),它允许从任意的代码仓库引入类型定义（文件）。 随着TypeScript2.0的发布，不再需要为基于npm的项目使用类型定义管理器了 。现在，npmjs.org的npm仓库包含了一个@types组织，里面存储着所有流行的JavaScript库的类型定义（文件）。来自definitelytyped.org的所有库都发布在那里。 假设需要为jQuery安装类型定义文件。运行以下命令，将在目录node_modules/@types中安装类型定义（文件），并将此依赖保存到项目的package.json文件中： 1npm install @types/jquery --save-dev 在许多项目中都将使用类是命令安装类型定义（文件）。例如，ES6为数组引入find()方法，但如果TypeScript项目将ES5配置成编译目标，IDE将会用红色高亮显示find()方法，因为ES5不支持它。安装es6-shim类型定义文件将消除IDE中的红色（提示）： 1npm i @types/es6-shim --save-dev 如果tsc找不到类型定义文件怎么办？在TypeScript2.0时，tsc有可能找不到位于目录node_modules/@types中的类型定义文件。如果遇到这个问题，请在tsconfig.json文件的types部分添加所需的文件。以下是一个例子： 1234&quot;compilerOptions&quot;: &#123; ... &quot;types&quot;: [&quot;es6-shim&quot;, &quot;jasmine&quot;],&#125; 模块解析及引用标签除非使用CommonJS模块，否则需要显式地为代码添加要给引用，以指向所需的类型定义（文件），如下所示： 1/// &lt;reference types=&quot;typings/jquery.d.ts&quot; /&gt; 使用CommonJS模块作为一个tsc选项，而且每个项目的tsconfig.json文件包含如下选项： 1&quot;module&quot;: &quot;commonjs&quot; 当tsc看到一条指向某个模块的import语句时，它会自动尝试在node_modules目录中寻找 &lt;module-name&gt;d.ts文件。如果没有找到，它会向上一级重复此过程。可以在TypeScript手册（参见 http://mng.bz/ih4z）的“Typings for npm Modules”小节，阅读更多这方面的信息。在即将发布的tsc版本中，将会实现相同的策略，用于MD模块解析。 Angular包含所有需要的类型定义文件，并且不需要使用类型定义管理器，除非应用程序使用了其他第三方的JavaScript库。在这种情况下，就需要手动安装它们的（类型）定义文件， 以获得IDE的上下文帮助 Angular在其d.ts文件中使用了ES6语法，而且对于大多数模块，可以使用以下导入语法：import {Component} from ‘Angular 2/core’。你将会找到Component类的定义，并且将导入其他的Angular模块和组件。 TSlint控制代码风格使用TSlint控制代码风格 TSLint是一个工具，可以 用来保证程序的编写符合指定的规则和代码风格。可以配置TSLint来 检查项目中的TypeScript代码 ，检查是否正确对齐和缩进 ，所有的接口名称是否都是以大写的I开头 ，以及 类名是否都使用CameCase表示法 ，等等。 可以使用如下命令全局安装TSLint： 1npm install tslint -g 要在项目目录中安装TSLint，请使用以下命令： 1npm install tslint 要应用于代码的规则可以在配置文件tslint.json中指定。TSLint附带一个示例的规则文件，该文件的名称是sample.tslint.json,它位于docs目录中。可以根据需要打开或关闭具体的规则。 有关使用TSLint的详细信息，请访问 www.npmjs.com/package/tslint 。IDE可能支持开箱即用。 IDE有几个IDE支持TypeScript，最流行的是 WebStorm 、Visual Studio Code 、 Sublime Text 和 Atom 。所有这些IDE和编辑器都剋在Windows、Mac OS和Linux（环境）工作。如果是在Windows电脑上开发TypeScript/Angular应用程序，可以使用 Visual Studio 2015 。 开发流程概述TypeScript/Angular开发流程概述 TypeScript/Angular应用程序的开发和部署流程由多个步骤组成，它们应该能够自动化。有多种方法可以做到这一点，以下步骤列表可以用来创建Angular应用程序。 为项目创建一个目录 创建一个package.json文件，其中列出了应用程序所有的依赖项，例如Angular包、测试框架Jasmine，等等。 使用npm install 命令，安装所有在package.json中列出的包和库。 编写应用程序代码。 通过SystemJS加载器的帮助，将应用程序加载到浏览器中，此加载器不仅可以加载应用程序，还可以在浏览器中将TypeScript转换成JavaScript。 在Webpack及其他插件的帮助下，压缩并打包代码和资源。 使用npm脚本将所有的文件复制到分发目录中。 注意Angular CLI是一个命令行实用工具，可以作为项目的骨架，生成组件和服务，并准备构建。 注意由于TypeScript是JavaScript的超集，因此错误处理（的方式）与JavaScript相同。在Mozilla Developer Network （参见 http://mng.bz/FwfO ）上，可以在Error构造函数相关的JavaScriptTeference文章中，阅读有关不同的错误类型的信息。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备面试]]></title>
    <url>%2F2018%2F07%2F29%2Fprepare-for-an-interview%2F</url>
    <content type="text"><![CDATA[准备方式关于自己 自我介绍（一般1分钟左右，着重突出你的 1.积极上进 2.做过的有关案例 3.对这家公司的兴趣和看法） 我有哪些优秀特质（着重突出针对这个岗位，需要凸显的特质，有的放矢） 我有什么需要提高、最希望提升的特质？ （比如：经验还不够丰富） 说一说你做过的印象深刻的项目（着重说一个，你是怎么思考的，怎么解决了问题的，事后如何复盘的） 关于这家公司 用http://news.baidu.com 搜索公司名称、创始人名字，认真读完前5页新闻 能够不假思索地，用三句话描述清楚这家公司的业务流程 能够不假思索地，说出3-5个这家公司的品牌产品、品牌活动、举办的重大事件的主题 了解这家公司是处于哪个阶段（初创期、高速成长期、逐渐成熟期），以便推测对方需要的团队是什么状态 能说出3-5家，这家公司的竞争对手/业务比较接近的公司 关于行业态势 在百度中，搜索3-5家竞品、或者业务比较接近的公司，了解竞争态势 了解面试公司所处的行业， 并且对这个行业的新闻，进行检索恶补 关于产品 亲自下载、注册、试用要去面试的公司的产品，必须超过15分钟，最好覆盖各个功能模块 总结出产品做得最棒的三个特质、三个让你觉得困惑和有待提升的特质 关于岗位职能 认真阅读你要去的这个公司的招聘要求，弄清楚这个岗位是干嘛的，如果没有，请在电话里和通知你面试的人，确认一下岗位职责。话术：您好，抱歉由于我的简历是请朋友内推的，我能否跟您再确认一下，我即将面试的岗位的具体职责，以便我提前做些准备，更高效的跟您面谈？ 针对岗位要求，思考：如果我去担当这家产品的XXX，我会如何做？这是必考题，请一定给出至少3条答案。 你还有什么想问的？（一般可以问一下对方公司：目前市场运营是什么思路？面试官对自己有什么期望？） 转换行业，哪些是需要重新学习和适应的？（这一类都属于障碍题） 举个例子 原文阅读]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[技术要求以及复习]]></title>
    <url>%2F2018%2F07%2F29%2Ftechnical-requirement-and-review%2F</url>
    <content type="text"><![CDATA[技术要求 腾讯 计算机相关专业本科及以上学历，或者非计算机相关专业、但是业余自修过计算机专业的所有必修课； 丰富的编码实战经验，热爱计算机编程； 有激情，有创造力，也有强悍的逻辑性，喜欢研究新技术、新标准； 至少熟悉JSP/CGI/python/php/nodejs或一种其他类似后台技术，对前后端联合开发的技术原理有全面认识； 熟悉JS/AS/AJAX/HTML5/CSS等前端开发技术； 对DNS/HTTP和相关的其他底层网络协议有比较全面的了解。 阿里 我们希望你，可以熟练使用各种Web前端技术，包括HTML(5)/CSS(3)/Javascript等，并有相关的项目开发经验或成果； 我们希望你，用过git，grunt或gulp等工具，最好有自己的github仓库； 我们希望你，有基于Ajax应用的开发经验，有NodeJS/Java开发经验，或者有移动端开发经验； 我们希望你，深刻理解Web标准，对可用性、可访问性等相关知识有实际的了解； 我们希望你，对算法、数据结构、建模有一定了解； 我们希望你，关注新事物、新技术，有较强的学习能力，喜欢挑战，并且个性乐观开朗，逻辑性强，善于和各种背景的人合作。 百度 精通HTML、CSS及JavaScript等Web前端技术 具备跨浏览器、跨终端的前端开发经验 了解至少一种Server端语言（Node.JS/PHP/Python/Java等） 具备扎实的计算机基础，对数据结构和算法设计有充分理解 热爱互联网，对互联网产品和技术有浓厚的兴趣，热衷于追求技术极致与创新 具有良好的沟通能力和团队合作精神、优秀的分析问题和解决问题的能力 网易1、不管学的是什么专业，都有一颗对互联网无比热爱，愿意为之付出的心。2、你技术扎实，活好肯干，熟悉W3C标准，能熟练运用XHTML、CSS进行合理的网页制作，熟悉各种主流浏览器的CSS兼容性问题的解决方法；3、你Java也可以用得很6，能进行常规Web应用的开发，有相关的开发经验的话，帅气值加五分。4、你有洞察人心的隐藏技能，对交互体验、可用性、用户体验有一定程度的理解；5、你抗压能力强，遇到难题冲上去就是干，关键还能和团队打得一手好配合。 京东1-2019年毕业，计算机相关专业本科及以上学历2-丰富的编码实战经验，热爱计算机编程3-有激情，有创造力，也有强悍的逻辑性，喜欢研究新技术、新标准4-至少熟悉JSP/CGI/python/php/nodejs或一种其他类似后台技术，对前后端联合开发的技术原理有全面认识5-熟悉JS/AS/AJAX/HTML5/CSS等前端开发技术6-对DNS/HTTP和相关的其他底层网络协议有比较全面的了解 顺丰1、国家统招本科及以上学历，计算机类相关专业；2、熟悉JavaScript语言，具有一定的Javascript编程基础;熟悉HTML5+CSS3，具有一定的编程基础；3、了解Http协议，了解浏览器原理，能处理浏览器兼容问题的优先；4、熟悉页面编程调试和开发工具，具有实际项目经验的优先；5、熟悉软件开发的流程,熟悉Maven，git/SVN等工具优先；6、有UI/UE设计经验者优先。 小米 1、本科学历以上，有前端开发经验者优先； 2、熟悉HTML、CSS及JavaScript等Web前端技术； 3、熟悉Linux系统，对算法、数据结构以及后台开发(C/C++/PHP/Java等)有一定了解； 4、有良好的技术视野和规划能力； 5、良好的沟通与表达能力、思路清晰，较强的动手能力与逻辑分析能力； 拼多多 2019年应届毕业生，本科及以上学历，计算机相关专业，热爱计算机科学和互联网技术； 具备扎实的数据结构和计算机系统基础，编码功底扎实； 可以熟练使用各种 Web 前端技术，包括HTML(5)/CSS(3)/Javascript等，并有相关的项目开发经验或成果； 有基于 Ajax 应用的开发经验，有 NodeJS 开发经验，或者有移动端开发经验为佳； 有较强的学习能力，有强烈的责任心和自我驱动力； 能及时关注和学习业界最新技术，具备较好的逻辑分析能力，个性开朗乐观，具备良好的沟通能力和团队合作精神。 唯品会 熟悉HTML. CSS等网页制作技术，能够进行基本页面架构和布局，知晓常见响应式布局方案 熟练运用JavaScript. Ajax等Web开发技术，以及jQuery. zepto等基础库 了解sass或less等CSS扩展语言 熟悉W3C标准，对表现与数据分离. Web语义化等有一定的理解 对组件化. 模块化等前端开发模式有一定的理解，熟悉前后端分离 对angular/vue/react等mv*框架有一定了解及实践 熟悉gulp. webpack等至少一种前端构建工具 知晓团队开发流程，熟练使用SVN或Git等工具进行代码管理 对前端兴趣浓厚，有志于从事前端技术事业 思路清晰，积极主动，具备良好的代码风格和习惯，善于学习. 总结，乐于分享 具备以下能力者优先： 具有移动端HTML5/CSS3等开发经验 熟悉Java或其他任意一门后端语言 熟悉后端Freemarker模版语言 有作品可以展示的优先 复习 重点复习 HTML5、CSS3、JavaScript、AJAX、数据结构、Http协议、浏览器兼容问题 优先复习 Node.js、Java、ES6、Linux系统、DNS、算法]]></content>
      <categories>
        <category>找工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用命令]]></title>
    <url>%2F2018%2F07%2F29%2Fmarkdown-command%2F</url>
    <content type="text"><![CDATA[Markdown常用命令 用于展示常用的Markdown命令，采用 示例 和 代码 的形式展示，部分语法会给出 说明 。 介绍Markdown标题 Atx方式一级标题二级标题三级标题四级标题五级标题六级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 Setext方式大标题小标题1234大标题===小标题--- 列表 符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长 无序列表 无序列表1 无序列表2 无序列表3 123- 无序列表1- 无序列表2- 无序列表3 有序列表 有序列表1 有序列表2 有序列表3 1231. 有序列表12. 有序列表23. 有序列表3 嵌套列表 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 1234- 嵌套列表1 + 嵌套列表2 * 嵌套列表3- 嵌套列表4 引用 这里是引用 这里是引用中的引用 12&gt; 这里是引用 &gt;&gt;这里是引用中的引用 图片与链接 插入连接阿有的博客 1[阿有的博客](https://www.songxingguo.com/) 自动连接&#x31;&#x33;&#x32;&#56;&#57;&#56;&#x39;&#57;&#x34;&#x32;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109; 1&lt;1328989942@qq.com&gt; 插入图片 1![这里是图片](http://pajsphiyq.bkt.clouddn.com/images/mine/mine-bg.jpg) 设置图片宽度和高度 1&lt;img src=&quot;http://pajsphiyq.bkt.clouddn.com/images/mine/mine-bg.jpg&quot; width=256 height=auto alt=&quot;这里是设置宽度和高度的图片&quot; /&gt; 粗体与斜体 粗体这里是粗体 1**这里是粗体** 斜体这里是斜体 1*这里是斜体* 代码框 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;A Tiny HTML Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Let&apos;s rock the browser, HTML5 style.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 分割线 1*** 注释1&lt;!-- 注释 --&gt; 段落 半方大的空白&ensp;或&#8194;看，飞碟 全方大的空白&emsp;或&#8195;看，飞碟 不断行的空白格&nbsp;或&#160;看，飞碟 &emsp;&emsp;段落从此开始。 1234半方大的空白&amp;ensp;或&amp;#8194;看，飞碟全方大的空白&amp;emsp;或&amp;#8195;看，飞碟不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟&amp;emsp;&amp;emsp;段落从此开始。 标签 HTML、CSS、JavaScript 1`HTML`、`CSS`、`JavaScript` 字体、字号、颜色 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; 表格 项目 价格 Computer $1600 Phone $12 Pipe $1 12345项目 | 价格-------- | ---Computer | $1600Phone | $12Pipe | $1 生成目录 该命令在本文档中是不能正确显示的。 1[TOC] 链接引用 可以用于将链接统一放在一起，方便管理。 这里是链接 123[这里是链接][link][link]: https://www.songxingguo.com/ 参考文献 该命令在本文档中是不能正确显示的。 12参考文献[^demo][^demo]: http://marxi.co/client_en 相关文章阅读 认识与入门 Markdown Markdown 语法 示例 字体 字号 颜色 Welcome to Marxico MarkDown 图片大小问题 Markdown 语法说明 (简体中文版) Markdown 语法说明 (英文版)]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Markdown </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Angular 2开发实战》学习笔记-ECMAScript 6概述]]></title>
    <url>%2F2018%2F07%2F25%2FAngular-2-ECMAScript-6%2F</url>
    <content type="text"><![CDATA[ECMAScript 6概述 ECMASript的故事 可以访问ECMAScript兼容性网站 http://mng.bz/ao59 查看截至目前ES6的支持情况 。 使用转码器，比如 Traceur (详见 http://github.com/google/traceur-compiler ）或 Babel（详见 https://babeljs.io ）,将ES6转换成ES5的版本，所有浏览器都支持ES5标准。 学习JavaScript的github地址为 http://mng.bz/EIH 。 2016年发布了ES7标准（又称ES 2016）,这是一次小型发布会。ESMAScript 2017语言标准发布在 http://tc39.github.io/ecma262/ 上。 ES6并 不会废弃任何旧的语法 ，因此可以在最新的Web浏览器或独立的JavaScript引擎中安全地运行遗留的ES5或ES3。 模板字面量ES6引入了一种新的语法，用来处理包含了嵌入式语法的字符串字面量 ，此功能被称为 字符串插值 （string interpolation）。 在ES5中，可以使用 字符串拼接 创建一个包含字符串字面量与变量的混合字符串。 12var customerName = &quot;John Smith&quot;;console.log(&quot;Hello&quot; + customerName); 在ES6中，模板字面量被反引号包围。可以将 表达式嵌入文字 中，将其 放在以美元符号为前缀的大括号之间。在下面代码片段中，变量custimerName的值被嵌入到字符串字面量中： 1234567var customerName = &quot;John Smith&quot;;console.lgo(`Hello $&#123;customerNamr&#125;`);function getCustomer() &#123; return &quot;Allan Lou&quot;;&#125;console.log(`Hello $&#123;getCustomer()&#125;`); 上述代码的输出为： 12Hello John SmithHello Allan Lou 在大括号之间可以使用任何有效的JavaScript表达式。 多行字符串在代码中字符串可以被写成多行。使用反引号可以编写多行字符串 ，而无须把它们拼接在一起或者使用反斜杠： 12345var message = `Please enter a password that has at least 8 characters and includes a capital letter`;console.log(message); 生成的字符串会把所有空格也视为字符串内容的一部分，因此输出如下所示： 123Please enter a password that has at least 8 characters and includes a capital letter 带标签的模板字符串如果一个 模板字符串紧跟在一个函数名称引用后面 ，那么这个字符串首先 会被计算 ，之后 被传入到函数中做进一步处理 。模板字符串部分会被组成一个数组 ，在模板中 经过计算的表达式会被当成独立的参数 传入到函数中。这种语法看起来有些不同，因为在常规的函数调用中不会使用括号： 1mytag`Hello $&#123;name&#125;`; 下面介绍 如何根据region变量打印出带有货币符号的金额 。如果region变量的值为1，那么金额不变，在金额前面加一个美元符号。如果region变量的值为2，则需要转换金额，以汇率计算，并在前面加一个欧元符号。模板字符串看起来如下所示： 1`You&apos;ve earned $&#123;region&#125; $&#123;amount&#125;!` 调用currencyAdjustment()函数，带标签的模板字符串看起来如下所示： 1currencyAdjustment`You&apos;ve earned $&#123;region&#125; $&#123;amount&#125;!` currencyAdjustment()函数接收三个参数： 第一个参数是 模板字符串中所有的字符串 ，第二个参数获得 region的值 ，第三个参数获得 amount的值 。第一参数之后的参数的数量可以是任意 。完整的示例如下面的代码清单所示： 1234567891011121314151617181920function currencyAdjustment(stringParts, region, amount) &#123; console.log(stringParts); console.lgo(region); console.log(amount); var sign; if(sign==1) &#123; sign = &quot;$&quot; &#125; else &#123; sign = &apos;\u20AC&apos;; amount = 0.9*amount; &#125; return `$&#123;stringParts[0]&#125; $&#123;sign&#125;$&#123;amount&#125;$&#123;stringParts[2]&#125;`;&#125;var amount = 100;var region = 2;var message = currencyAdjustment`You&apos;ve earned $&#123;region&#125; $&#123;amount&#125;!`console.log(message); currencyAdjustment()函数接收一个内嵌了region和amount的字符串，并解析这模板，将字符串的部分与这些值分开（空格也被认为是字符串的一部分） 。为了方便说明在程序开始会打印模板解析的结果，之后函数将会检查region，开始货币转换，返回一个新的字符串模板。运行代码会产生如下输出： 1234[&quot;You&apos;ve earned &quot;,&quot; &quot;,&quot;!&quot;]2100You&apos;ve earned €90! 有关带标签的模板字符串的更多详细信息，请参阅由AxelRauschmayer编写的Exploring ES6一书中的Template Literals章节，可从 http://exploringjs.com 获取。 可选参数和默认值 在ES6中，可以 为函数参数指定默认值 ，这对于当函数被调用却没有传参数的情况是非常有用的。假设有一个计算税费的函数，它有两个参数：一个是全年的收入（income）;另一个是居住的州（state）。如果没有传state的值，你希望能够使用Florida。 在ES5中，需要在函数体开始的时候检查是否提供了state值，如果没有，则使用Florida： 123456789function calcTaxES5(income, state) &#123; state = state || &quot;Florida&quot;; console.log(&quot;ES5. Calculating tax for the resident of &quot; + state + &quot;with the income &quot; + income);&#125;calcTaxES5（50000); 下面是代码的输出结果： 1&quot;ES5. Calculating tax for the resident if Florida with the income 50000&quot; 在ES6中，需要 在函数签名中指定默认值 ： 123456function calcTaxES6(income, state = &quot;Florida&quot;) &#123; console.log(&quot;ES6. Calculating tax for the resident of &quot; + state + &quot;with the income &quot; + income);&#125;calcTaxES6(50000); 输出与上面看起来是一样的： 1&quot;ES6. Calculating tax for the resident if Florida with the income 50000&quot; 除了能够为可选参数提供硬编码的默认值之外，甚至可以 把函数的返回值作为默认值 ： 12345678function calcTaxES6(income, state = getDefaultState()) &#123; console.log(&quot;ES6. Calculating tax for the resident of &quot; + state + &quot;with the income &quot; + income);&#125;function getDefaultState() &#123; return &quot;Florida&quot;;&#125; 请记住，每次调用calcTaxES6()同样 也会调用getDefaultState()函数 ，这 可能会带来性能问题 。这个可选参数的新语法能够让你 编写更少的代码 ，并 使代码更好理解 。 变量的作用域ES5中作用域机制相当混乱。无论在哪里使用var声明的变量，声明都会被移动到作用域的顶部 ，这被称为 变量提升（hoisting）。 this 关键字的使用也不像Java或C#语言那么简单。 ES6通过引入 关键字let 来 消除变量提升带来的混乱 ，通过 箭头函数 来 解决this带来的混乱 。 变量提升在JavaScript中，所有的变量声明都会被移到顶部 ，并且 没有块级作用域 。看看下面的简单示例，其中 在for循环中声明了变量i ,但是 在循环外面仍然可以使用。 123456789function foo() &#123; for (var i = 0; i &lt; 10; i++) &#123; &#125; console.log(&quot;i=&quot; + i);&#125;foo(); 运行代码后会打印i=10。变量i在循环外仍然可以被访问，尽管它看起来似乎只能在循环内部调用。JavaScript自动把变量的声明提升到顶部 。 在这个例子中，因为只有一个变量被命名为i，提升不会引起任何问题。如果在函数内部和外部同时声明名字一样的两个变量，就 可能会造成代码逻辑上的混乱 。思考一下下面代码，在 全局作用域内声明了变量customer 。之后在 本地作用域内同样引入一个customer变量 ，但是 会把引入的这个变量注释掉 。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hoisting.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; &quot;use strict&quot;; var customer = &quot;Joe&quot;; (function() &#123; console.log(&quot;The name of the customer inside the function is &quot; + customer); /* if(2 &gt; 1) &#123; var customer = &quot;Mary&quot;; &#125;*/ &#125;)(); console.log(&quot;The name of the customer outside the function is &quot; + customer);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用Chrome浏览器打开这个文件，查看Chrome Developer Tools中控制台输出。正如我们所期望的，全局变量customer在函数的内部和外部都可见的,如下图所示。 取消对if语句的注释，在大括号中初始化customer变量。现在，有两个名字一样的变量，其中 一个是全局变量 ，而 另一个变量则在函数的作用域内 。刷新浏览器页面，控制台的输出与之前不同了，函数中的customer变量为undefined,如下图所示。 这是因为在ES5中，变量声明 总是 被提升到作用域顶部 ，但是 变量并不会被初始化 。因此 第二个没有初始化的变量被提升到了函数顶部 ，console.log()打印的值为 函数内容部定义的变量的值 ，，而不是全局变量customer的值。 函数的声明同样会被提升 ，因此 可以在声明一个函数之前调用它 ： 12345doSomething();function doSomething() &#123; console.log(&quot;I&apos;m doing something&quot;);&#125; 另一方面，函数表达式被认为是变量初始化 ，因此 不会被提升。在下面的代码片段中，变量doSomething()的值为undefined : 12345doSomething();var doSomething = function() &#123; console.log(&quot;I&apos;m doing something&quot;);&#125; let和const使用ES6关键字let代替var声明变量，能够 让变量拥有块级作用域 。下面是一个示例： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;let.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; &quot;use strict&quot;; let customer = &quot;Joe&quot;; (function() &#123; console.log(&quot;The name of the customer inside the function is &quot; + customer); if(2 &gt; 1) &#123; let customer = &quot;Mary&quot;; console.log(&quot;The name of the customer inside the block is &quot; + customer); &#125; &#125;)(); for (let i =0; i &lt; 5; i++) &#123; console.log(&quot;i=&quot; + i); &#125; console.log(&quot;i=&quot; + i); //prints Uncaught Reference Error: i is not defined&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现在两个customer变量有不同的作用域和值，如下图所示。 如果循环中声明一个变量，它只是循环中可用： 12345for (let i =0; i &lt; 5; i++) &#123; console.log(&quot;i=&quot; + i);&#125; console.log(&quot;i=&quot; + i); //Reference Error: i is not defined 在Traceur REPL中测试let关键字，访问Traceur的Transcoding Demo页面（ http://mng.bz/b191 ）,把输入的ES6语法已交互的方式转码为ES5。 简而言之，如果正在开发新的应用程序，请不要使用var,而是使用let。let关键字允许为变量无限制地分配值 。 如果要声明一个变量，使其 在分配了值之后不会被重新分配 ，可以使用const关键词。常量同样支持块级作用域 。 let和const的唯一区别是：const不允许改变已经被分配的值 。程序中 优先推荐使用const ;如果 变量需要被改变 ，那么 使用let替换const。 函数的块级作用域如果在一个块（一对大括号）中声明了一个函数，那么在快外，该函数是不可见的。下面的代码将抛出错误： “doSomething is note defined”。 1234567&#123; function doSomething() &#123; console.log(&quot;In doSomething&quot;); &#125;&#125;doSomething(); 在ES5中，doSomething()声明将会被提升，并打印“In doSomething”。在ES5中并不推荐在块中声明一个函数（参加 http://mng.bz/Bvym 中的 “ES5 Implementtation Best Practice”）,这是因为 不同浏览器会以不同的方式解析此语法 ，产生不一致的结果。 箭头函数、this和that ES6引入了箭头函数表达式，为匿名函数提供了更短的写法 ，为this变量添加了词法作用域 。在其他编程语言（如C#和Java）中，类似的语法被称为lambda表达式。 箭头函数表达式的语法包括 参数 、箭头符号（=&gt;）、以及 函数体 。如果 函数体只有一个表达式， 可以不写大括号 。如果 一个单一表达式函数返回值 ，那么 可以省略return语句，结果被隐式地返回： 1let sun = (arg1, arg2) =&gt; arg1 + arg2; 如果 函数体是多行的箭头函数表达式 ，那么 需要使用大括号闭合函数体 ，并 使用显式的return语句 ： 1234(arg1, arg2) =&gt; &#123; //do something return someResult;&#125; 如果箭头函数 没有任何参数 ，使用空括号 ： 1234() =&gt; &#123; // do something return someResult;&#125; 如果箭头函数 只有一个参数 ，括号不是必需的 ： 123arg1 =&gt; &#123; //do something&#125; 在下面的代码片段中，箭头函数作为参数传入reduce()方法用来计算合计，另一个箭头函数被传入filter()方法用来打印偶数： 12345var myArray = [1, 2, 3, 4, 5];console.log(&quot;The sum if myArray elements is &quot; + myArray.reduce((a,b) = &gt; a + b); //pints 15console.lgo(&quot;The even numbers in myArray are &quot; + myArray.filter(value =&gt; value % 2 == 0); prints 2 4 在ES5中，搞清楚关键字this是那个对象的引用并不是简单的任务。在线搜索“JavaScript this and that”,会发现很多类似的文章，人们都在抱怨this指向了“错误”的对象。基于函数如何被调用以及是否严格模式（参见 http://mng.bz/VNVL 上有关Mozila Developer NetNork的“Strict Mode”）, this 引用可以有不同的值 。 考虑thisAndThat.html文件中的代码，它会每秒调用一次getQuote()函数。getQuote()函数会在StockQuoteGenerator()构造函数中为股票代码打印随机生成的价格。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;thisAndThat.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; function StockQuoteGenerator(symbol) &#123; // this.symbol = symbol; //is undefined inside getQuote() var that = this; that.symbol = symbol; setInterval(function getQuote() &#123; console.log(&quot;The price quote for &quot; + that.symbol + &quot; is &quot; + Math.random()); &#125;,1000); &#125; var stockQuoteGenerator = new StockQuoteGenerator(&quot;IBM&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码中被注释部分，演示了this的错误用法。当函数需要一个值时，虽然看起来是同一个this引用，但实际上并不是，。如果 没有把this变量的值保存到that中 ，使用setInterval()或回调函数调用getQuote()函数 得到的this.symbol的值将是undefined 。在getQuote()中， this指向全局对象 ，与StockQuoteGenerator构造函数中定义的this不一致。 另一种可能的解决方式是 使用JavaScriptcall()、apply()或bind()函数 ，以 确保函数运行在指定的this对象中 。 提示 如果不了解JavaScript中this问题，详见Richard Bovell的文章“Understand JavaScript s ‘this’ with Clarity and Master It”（网址为 http://mng.bz/ZQfz ） fatArrow.html文件演示了箭头函数的解决方案，无须像thisAndThat.html中所做的那样，在that中存储this。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;fatArrow.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; &quot;use strict&quot;; function StockQuoteGenerator(symbol) &#123; this.symbol = symbol; setInterval(() =&gt; &#123; console.log(&quot;The price quote for &quot; + that.symbol + &quot; is &quot; + Math.random()); &#125;,1000); &#125; var stockQuoteGenerator = new StockQuoteGenerator(&quot;IBM&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 箭头函数被当成参数传入setInterval()中，它 使用了封闭上下文中的this值 ，因此可以识别this.symbol的值为IBM。 rest和扩展运算符 在ES5中， 编写可变长度参数 的函数需要 使用特殊的arguments对象 。这个 对象类似于数组 ，其中包含了对应传递给函数的参数。隐式的arguments变量 在任何函数中都可以被视为局部变量 。 ES6有 rest 和 扩展运算符 ，都 用三个点（…）来表示 。rest操作符被 用于为函数传递可变长度参数 ，该操作符必须是 参数列表中最后一个参数 。如果函数参数的名字 以三个点开始 ，函数将会 以数组的形式得到参数的剩余部分 。例如，在rest操作符的作用下只需使用一个变量名便可以向函数传递多个customers: 123function processCustomers(...customers) &#123; //implementation of the function goes here&#125; 在这个函数中，可以 像处理任何数组一样处理customers数据 。 想象一下，需要编写一个用来计算税费的函数，第一个参数是income，后面根据客户数量，可以又任意数量的参数来表示顾客的名字。下面代码显示了分别使用老语法和新语法处理可变参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;rest.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; &quot;use strict&quot;; //ES5 and arguments object function calcTaxES5() &#123; //income是第一个参数 console.log(&quot;ES5. Calculating tax for customers with the income &quot;, arguments[0]); //从第二个元素起提取出一个数组 var customers = [].slice.call(arguments, 1); customers.forEach(function(customer) &#123; console.log(&quot;Processing &quot;, customer); &#125;); &#125; calcTaxES5(50000, &quot;Smith&quot;, &quot;Johnson&quot;, &quot;McDonald&quot;); calcTaxES5(750000, &quot;Smith&quot;, &quot;Olson&quot;, &quot;Clinton&quot;); //ES6 and rest operator function calcTaxdES6(income, ...customers) &#123; console.log(&quot;ES6. Calculating tax for customers with the income &quot;, income); customers.forEach(function(customer) &#123; console.log(&quot;Processing&quot;, customer); &#125;); &#125; calcTaxdES6(50000, &quot;Smith&quot;, &quot;Johnson&quot;, &quot;McDonald&quot;); calcTaxdES6(750000, &quot;Olson&quot;, &quot;Clinton&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; calcTaxEs5()和calcTaxEs6()函数产生相同的结果： 123456789101112131415ES5. Calculating tax for customers with the income 50000Processing SmithProcessing JohnsonProcessing McDonaldES5. Calculating tax for customers with the income 750000Processing SmithProcessing OlsonProcessing ClintonES6. Calculating tax for customers with the income 50000Processing SmithProcessing JohnsonProcessing McDonaldES6. Calculating tax for customers with the income 750000Processing OlsonProcessing Clinton 不过，它们在处理customers时还是有差异的，因为arguments对象并不是一个真正的数组，在ES5中不得不使用slice()和call()方法 创建一个数组 ，并从arguments中的第二个元素开始提取顾客姓名，放入到新创建的数组中。 ES6则不需要使用这些技巧，rest操作符能够返回一个正常的customers数组。rest参数能 让代码更简单 ，可读性更强 。 如果 rest操作符 能够把 变长参数转换为数组 ，那么 扩展运算符 则执行相反的操作； 把一个数组分解到参数列表中 。假设需要编写一个函数，计算给定收入的三名顾客的税费。这一次，参数的长度是固定的 ，但是顾客被存放到要给数组中。可以使用扩展运算符——三个点（…）, 把数组分解到独立参数的列表中 。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;spread.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; &quot;use strict&quot;; function calcTaxSpread(customer1, customer2, customer3, income) &#123; console.log(&quot;ES6. Caclulating tax for customers with the income &quot;, income); console.log(&quot;Processing&quot;, customer1, customer2, customer3); &#125; var customers = [&quot;Smith&quot;, &quot;Johnson&quot;, &quot;McDonald&quot;]; //扩展运算符 calcTaxSpread(...customers, 50000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个示例中，并不会从customers数组中提取值，然后把这些值作为函数的参数，而是使用扩展运算符处理数组，就好像在对函数说：“你需要三个参数，而我只会给你一个数组，你自己把它们提取出来吧”。注意，作为rest运算符的反向操作， 扩展运算符不一定必须是参数列表中的最后一个参数 。 generator函数 当浏览器执行一个 常规的JavaScript函数 时，它 将会从头一直运行到结尾 ，不会被打断。但是 generator函数 执行过程 可以被多次暂停和恢复 。generator函数可以控制运行在同一线程中的脚本调用。一旦generator函数中的代码 执行到关键字yield ，函数将会被挂起 ，通过 调用generator的next() 能够 恢复函数的执行 。 为 把一个常规函数转换成generator函数 ，需要 在关键词function和函数名之间添加一个星号 。下面是一个示例： 12345function* doSomething() &#123; console.log(&quot;Started processing&quot;); yield; console.log(&quot;Resumed processing&quot;);&#125; 当调用这个函数时，它并 不会立即执行函数代码 ，而是会 返回一个特殊的generator对象 ，它 可以被认为是一个 迭代器 。下面的代码 不会打印任何东西 ： 1var iterator = dosomething(); 为了开始执行函数体，需要 调用generator的next()方法 ： 1iterator.next(); 在这行代码执行后，doSomething()函数将会 打印“Started processing” ,并且由于 执行到yield操作符 ， 函数将暂停执行 。再次 调用next()方法 将会 打印“Resumed peocessing” 。 当需要 编写一个产生数据流的函数 时，generator函数是非常有用的。想象一下，需要一个函数能够检索和生成指定代码（IBM、MSFT等）的股票价格。如果股票价格第一指定的价格（限价），那么购买这只股票。 下面的generator函数getStockPrice()模拟了这种场景。为了简单起见，它并不会从股票交易所检索价格，而是采用由Math。random()生成的随机数代替。 12345678function* getStockPrice(symbol) &#123; while(true) &#123; yield Math.random() * 100; console.log(`resuming for $&#123;symbol&#125;`); &#125;&#125; 如果在yield之后的值，那么它应该被返回给调用函数，但是这个函数并没有执行完。尽管getStockPrice()中有一个无限循环，但只有当调用getStockPrice()的脚本在这个genernator上调用next()时，才会产生（返回）价格，如下所示： 1234567891011121314151617//创建Generator对象，但是不执行getStockPrice()函数体，getStockPrice将会提供IBM价格的数据流。let priceGenerator = getStockPrice(&quot;IBM&quot;);//设置限价为$15初始化价格为$100const limitPrice = 15;let price = 100;//请求股票价格，直到价格低于$15while(price &gt; limitPrice) &#123; //请求价格并打印到控制台 price = priceGenerator.next().value; console.log(`The generator returned $&#123;price&#125;`);&#125;//如果价格低于$15,循环结束，打印一条关于购买的股票以及购买价格的消息console.log(`buying at $&#123;price&#125; !!!`); 运行代码，在浏览器的控制台将会打印类似于下面的输出： 12345678The generator returned 83.18050163853641resuming for IBMThe generator returned 88.87640154512837resuming for IBMThe generator returned 46.90606158470856resuming for IBMThe generator returned 1.1542147358593269buying at 1.1542147358593269 !!! 注意消息的顺序。当调用priceGenerator的next()方法时，被暂停的getStockPrice方法会被恢复，yield下面的代码会打印出“resuming for IBM”，即使控制流退出函数，之后再次进入函数，getStockPrice()也仍然记录symbol的值为“IBM”。当yield操作符把控制权还给外部脚本后，它将 会创建堆栈的快照 ，以便能够记录所有本地变量值 ，即便generator函数恢复，这些值也不会丢。 利用generator函数，可以 分离某些操作执行 （如获取报价）以及这些操作产生数据的消耗 。数据使用者可以 惰性求值 并且 决定是否需要请求更多的数据 。 解构创建对象 意味着 在内存中构造它们 。解构（Destructuring）意味着 将对象分解 。在ES5中可以 编写一个方法来解构任何对象和数组 。ES6引入了 解构赋值语法 ，允许通过 指定匹配模式（matching pattern），利用简单的表达式从一个对象的属性或一个数组中提取数据 。 解构表达式由 匹配模式 、等号 以及需要分解的 对象 或 数组 组成。用示例说明会更容易理解。下面会有一个具体示例： 解构对象假设getStock()函数返回一个Stock对象，其中包括symbol和price属性。在ES5中，如过想要把这些属性的值分配给不同的变量，首先需要 创建一个变量来存储Stock对象，之后编写两条语句， 把对象属性分配到对应的变量中 ： 123var stock = getStock();var symbol = stock.symbol;var price = stock.price; 在ES6中，只需要在等号左侧 写一个匹配模式，并 把Stock对象分配给它 ： 1let &#123;symbol, price&#125;= getStock(); 在等号左侧，你会看到大括号与平时的用法有些不太一样，这是 匹配表达式语法 的一部分。当在左侧看到的大括号时，应该把它们认为是 代码块 而 不是对象字面量 。下面的代码演示了如何从getStock()函数中得到Stock对象，并把其解构到两个变量中。 12345678910function getStock() &#123; return &#123; symbol: &quot;IBM&quot;, price: 100.00 &#125;&#125;let &#123;symbol, price&#125; = getStock();concole.log(`The price of $&#123;symbol&#125; is $&#123;price&#125;`); 运行上面的代码将会打印如下输出： 1The price of IBM is 100 换句话说，通过一个 赋值表达式 ，将 一组数据（在本例中是对象属性）绑定到另一组变量 （symbol和price）中。即使Stock对象除了这两个属性外 还有其他属性 ，结构表达式也 仍然可以工作 ，因为symbol和price 满足匹配模式 。匹配表达式 仅列出 希望提取 的对象属性对应的变量。 上面代码，只有在变量名称与Stock对象属性名称一致时才会工作。让我们把symbol改变称sym: 1let &#123;sym, price&#125; = getStock(); 这样输出结果将会发生变化，因为JavaScript并不知道要把对象的symbol属性赋给sym变量： 1The price of undefined is 100 这是一个错误的模式匹配示例。如果确实需要用变量sym映射到symbol属性，那么需要 为symbol分配一个别名 ： 1let &#123;symnol: sym, price&#125; = getStock(); 如果等号左侧变量的 数量超过对象属性的数量 ， 额外的变量将会被分配值undefined。如果在等号左侧 添加了一个StockExchange变量 ，它 将会被初始化为undefined ,这是因为getStock()返回的对象中没有同名的属性： 12let &#123;sym, price, stockExchange&#125; = getStock();console..log(`The price of $&#123;symbol&#125; is $&#123;price&#125; $&#123;stockExchange&#125;`); 如果将上面的结构表达式应用到同一个Stock对象上，控制台输出将如下所示： 1The price of IBM is 100 undefined 如果希望stockExchange变量有一个 默认值 ，比如“NASDAQ”,可以重写解构表达式，如下所示： 1let &#123;sym, price, stockExchange=&quot;NASDAQ&quot;&#125; = getStock(); 嵌套对象也可以解构。 在下面代码中创建了一个嵌套对象用来表示MSFT股票，并把其传递给printStockInfo()函数，该函数从对象中提取股票代码这证券交易所的名称。 1234567891011121314let msft = &#123;symbol: &quot;MSFT&quot;， lastPrice: 50。00， exchange: &#123; name: &quot;NASDAQ&quot;, tradingHours: &quot;9:30am-4pm&quot;, &#125; &#125; function printStockInfo(stock) &#123; let &#123;symbol, exchange: &#123;name&#125;&#125; = stock; console.log(`The $&#123;symbol&#125; stock is traded at $&#123;name&#125;`); &#125; printStockInfo(msft); 运行这个脚本将会打印如下输出： 1The MSFT stock if traded at NASDAQ 解构数组数组解构 与对象解构 类似 ，但是会用 方括号 代替大括号。当 解构对象*8 时，需要 声明匹配属性的变量 ；而当 解构数组 时，则需要 声明匹配索引的变量** 。下面的代码会从数组中提取两个数组元素并复制给两个变量： 12let [name1, name2] = [&quot;Smith&quot;, &quot;Clinton&quot;];console.log(`name1 = $&#123;name1&#125;, name2 = $&#123;name2&#125;`); 输出如下所示： 1name1 = Smith, name2 = Clinton 如果仅需要 提取数组的第二个元素 ，匹配模式应该这么写： 1let [, name2] = [&quot;Smith&quot;, &quot;Clinton&quot;]; 如果 函数返回一个数组 ，结构语法会将其 转换为一个返回多个数据的函数 ，如下面的getCustomers()函数所示： 123456function getCustomers() &#123; return [&quot;Smith&quot;, , , &quot;Gonzales&quot;];&#125;let [firstCustomer, , , lastCustomer] = getCustomers();console.log(`The first customer is $&#123;firstCustomer&#125; and the last one is $&#123;lastCustomer&#125;`); 现在我们可以 将rest参数和数据结构组合在一起使用 。假设有一个数组，其中包含了若干名顾客，但是只需处理最开始的两个元素。下面的代码片段展示了如何实现： 123456let customers = [&quot;Smith&quot;, &quot;Clinton&quot;, &quot;Lou&quot;, &quot;Gonzles&quot;];let [firstCust, secondCust, ...otherCust] = customers;console.log(`The first customer is $&#123;firstCust&#125; and the second one is $&#123;secondCust&#125;`);console.log(`Other customers are $&#123;otherCust&#125;`); 代码在控制台产生的输出如下所示： 12The first customer is Smith and the second one is ClintonOther customers are Lou,Gonzles 另外一种用法，可以匹配模式以及rest参数一起传递给函数： 12345678var customers = [&quot;Smith&quot;, &quot;Clinton&quot;, &quot;Lou&quot;, &quot;Gonzles&quot;];function processFirstTwoCustomers([firstCust, secondCust, ...otherCust]) &#123; console.log(`The first customer is $&#123;firstCust&#125; and the second one is $&#123;secondCust&#125;`); console.log(`Other customers are $&#123;otherCust&#125;`);&#125;processFirstTwoCustomers(customers); 输出与上次执行是一致的： 12The first customer is Smith and the second one is ClintonOther customers are Lou,Gonzles 总而言之，解构的好处是当 需要从对象属性或数组中初始一些变量 时，可以 写更少的代码 。 迭代用forEach()、for-in和for-of进行迭代 可以使用不同的JavaScript关键字和API对对象集合进行遍历。在本节中，将会展示如何使用新的for-of循环，将会对for-of、for-in以及forEach()方法进行比较。 使用forEach()方法考虑下面的代码，对一个包含了4个数字的数组进行迭代。该数组还有一个额外的desciption属性，这个 属性会被forEach()忽略 ： 1234var numbersArray = [1, 2, 3, 4];numbersArray.description = &quot;four numbers&quot;;numbersArray.forEach(forEach(n) =&gt; console.log(n)); 脚本输出如下所示： 12341234 forEach()方法将一个函数作为参数，并从数组中正确的打印四个数字，忽略了description属性。forEach()的另一个限制是 无法提前打断循环 。可以使用every()方法代替forEach()或借助其他一些hack手段来实现这个功能。 使用for-in循环for-in能够 循环遍历对象的属性以及集合数据 。在JavaScript中，任何一个对象都是 键值对集合 。键对应的是属性名称，值是属性的值。数组有五个属性：numbers Array其中有四个为数字，一个是description属性。让我们遍历这数组的属性： 123456var numbersArray = [1, 2, 3, 4];numbersArray.description = &quot;four numbers&quot;;for(let n in numbersArray) &#123; console.log(n);&#125; 上面代码的输出如下所示： 123450123description 通过调试器运行此代码，显示每个属性都是字符串。为了 查看属性实际的值 ，可以使用numbersArray[n]打印数组元素： 123456var numbersArray = [1, 2, 3, 4];numbersArray.description = &quot;four numbers&quot;;for(let n in numbersArray) &#123; console.log(numbersArray[n]);&#125; 输出如下所示： 123451234four numbers 正如你看到的，for-in循环 遍历的是所有属性 ，而 不仅仅是数据 ，这个可能并非预期效果。 使用for-of循环ES6引入了for-of循环，能够做到 只遍历数据 而 不读取数据集合中的其他属性 。可以使用break关键字打断循环： 12345678910111213var numbersArray = [1, 2, 3, 4];numbersArray.description = &quot;four numbers&quot;;console.log(&quot;Running for of for the entire array&quot;);for (let n of numbersArray) &#123; console.log(n);&#125;console.log(&quot;Running for of with a break&quot;);for (let n of numbersArray) &#123; if (n &gt; 2) break; console.log(n);&#125; 输出如下所示： 12345678Running for of for the entire array1234Running for of with a break12 for-of 可以遍历 任何一个可被迭代的对象 ，包括Array、Map、Set以及其他一些对象。字符串同样是可迭代的。下面的代码将会打印字符串“John”,一次一个字母。 123for (let char of &quot;John&quot;) &#123; console.log(char);&#125; 类与继承ES3和ES5都支持 面向对象编程 以及 继承 ,但是使用ES6的 类 够更容易地 开发代码 和 理解代码 。 在ES5中，既可以 创建一个全新的对象 ，也可以 从其他对象继承得到一个对象 。默认所有JavaScript对象 继承自Object类 。对象的继承是由一个名为 prototype的特殊属性 实现的，该属性 指向对象的父级 ，这被称为 原型继承 （prototypal inheritance）。例如，为了创建继承自对象Tax的NJTax对象，需要这么写： 1234567891011function Tax() &#123; //The code of the tax object goes here&#125;function NJTax() &#123; //The code of New Jersey tax object goes here &#125;//NJTax继承自TaxNJTax.prototype = new Tax();var njTax = new NJTax(); ES6新引入关键字 class 和 extends ,使其在语法与其他面向对象编程语言（如Java和C#）保持一致。上面的代码按照ES6的写法如下所示： 123456789class Tax &#123; //The code of the tax class goes here&#125;class NJTax extends Tax &#123; // The code of New Jersey tax object goes here&#125;var njTax = new NJTax(); Tax是父级或者称为超类，NJTax是子级或者称为子类。可以认为NJTax类与Tax类是“is a”的关系。换句话说，NJTax是一个Tax。可以在NJTax中 实现额外的功能 ，但NJTax始终是一个（“is a”）Tax,或者说是一种（“is a kind of”） Tax。同样，如果创建一个继承自Person的类Employee,那么Employee是Person。可以创建一个或多个对象，如下所示： 1234//Tax对象的第一个实例var tax1 = new Tax();//Tax对象的第二个实例var tax2 = new Tax(); 提示类声明是不会被提升的。在使用类之前需要首先声明它。 这些对象 都具有Tax类的属性和方法 ，但是它们 保持不同的状态 。例如，第一个实例可以创建一名年收入$50 000的客户，而第二个实例可以创建为一名年收入$75 000的客户。每一个实例 共享同一份Tax中声明的方法的拷贝 ，因此 不会有重复的代码存在 。 在ES5中，为了 避免代码重复 ，可以通过不在对象中声明方法而是在 属性中声明方法 来解决： 12345678910function Tax() &#123; //The code of the tax object goes here&#125;Tax.prototype = &#123; calcTax: function() &#123; // code to calculate tax goes here &#125;&#125; JavaScript依旧是 原型继承的语言 ，但是ES6能够令开发者 编写更优雅的代码 ： 123456class Tax &#123; calcTax() &#123; // code to calculate tax goes here &#125;&#125; 不支持成员变量ES6语法不支持声明Java、C#或TypeScript中类似的类成员变量。下面的语法是不受支持的： 123class Tax &#123; var income;&#125; 构造函数在实例化的过程中，类会执行一些特使方法中的代码，这些方法被称为 构造函数 。在Java和C#这类开发语言中，构造函数的名称必须与类的名称保持一致；但在ES6中，使用constructor关键字 声明类的构造函数： 1234567class Tax &#123; constructor (income) &#123; this.income = income; &#125;&#125;var myTax = new Tax(50000); 构造函数是 一类特殊的方法 ，当对象 创建时只会被执行一次 。如果对Java或C#语言熟悉的话，就会发现上面的代码看起来有些不同；并没有 单独 声明一个类级别的income变量 ，而是 动态的创建在this对象上 ，使用构造函数的参数来初始化this.income。this变量 指向 当前对象的实例 。 下面的示例将会展示如何创建子类NJTax的实例，并把50 000传入到它的构造函数中： 12345678910111213class Tax &#123; constructor(income) &#123; this.income = income; &#125;&#125;class NJTax extends Tax &#123; // The code of New Jersey tax object goes here&#125;var njTax = new NJTax(50000);console.log(`The income in njTax instance is $&#123;njTax.income&#125;`); 上面代码片段的输出如下所示： 1The income in njTax instance is 50000 由于子类NJTax并没有定义自己的构造函数，因此当初始化NJTax时， 父类Tax的构造函数会自动被调用 。 注意通过njTax引用变量可以类的外部访问到income变量。 静态变量如果一个类的属性希望能够 被它的多个实例共享 ，那么需要在类声明的 外部创建这个属性 。在下面的示例中，counter变量被对象A的两个实例所共享： 123456789101112class A &#123;&#125;A.counter = 0;var a1 = new A();A.counter++;console.log(A.counter);var a2 = new A();A.counter++;console.log(A.counter); 执行代码后，输出如下： 1212 访问器、设置器访问器、设置器以及方法定义 对象的访问器（getter）和设置器（setter）方法并不是ES6的新语法，在介绍新的方法定义语法之前，先回顾一下。设置器和生成器把函数 绑定到对象的属性中 。考虑对象字面量Tax声明和使用： 12345678var Tax = &#123; taxableIncome: 0, get income() &#123;return this.taxableIncome;&#125;, set income(value) &#123;this.taxableIncome = value&#125;&#125;;Tax.income = 50000;console.log(&quot;Income: &quot; + Tax.income); // prints Income: 50000 注意分配和检索income的值时使用的是 点符号 ，就好像它是Tax对象的 一个声明属性一样 。 在ES5中，需要使用function关键字声明函数，如calculateTax = function(){…}。ES6允许在定义任何方法的时候 忽略function关键字 。 123456789var Tax = &#123; taxableIncome: 0, get income() &#123;return this.taxableIncome&#125; set income(value) &#123;this.taxtableIncome=value&#125;, calculateTax() &#123;return this.taxableIncome*0.13&#125;&#125;Tax.income = 50000;console.log(`For the income $&#123;Tax.income&#125; your tax is $&#123;Tax.calculateTax()&#125;`); 输出如下： 1For the incoem 50000 your tax is 6500 访问器和设置器为处理属性提供了一种方便的语法 。例如，如果决定为income访问器添加校验代码，那么使用Tax.income的脚本不需要改动。缺点是ES6并 不支持 在类中 声明私有变量 ，因此访问器和设置器中的变量（如taxtableIncome）总是可以被直接访问。 super和super()super关键字和super()函数, super()函数 允许 子类（后代）调用父类（祖先）的构造函数 。super关键字 用于调用父类声明的方法 。下面代码展示了super()函数和super关键字。Tax类中定义一个calculateFrderalTax()方法，在它的子类NJTax中添加calculateStateTax()方法。父类和子类分别有自己的calcMinTax()方法。 123456789101112131415161718192021222324252627282930313233343536373839&quot;use strict&quot;;class Tax &#123; constructor(income) &#123; this.income = income; &#125; calculateFederalTax() &#123; console.log(`Calculating federal tax for income $&#123;this.income&#125;`); &#125; calcMinTax() &#123; console.log(&quot;In Tax. Calculating min tax&quot;); return 123; &#125;&#125;class NJTax extends Tax &#123; constructor(income, stateTaxPersent) &#123; super(income); this.stateTaxPersent=stateTaxPersent; &#125; calculateStateTax() &#123; console.log(`Calculating state tax for income $&#123;this.income&#125;`); &#125; calcMinTax() &#123; super.calcMinTax(); console.log(&quot;In NJTax. Adjusting min tax&quot;); &#125;&#125;var theTax = new NJTax(50000, 6);theTax.calculateFederalTax();theTax.calculateStateTax();theTax.calcMinTax(); 运行代码，得到以下输出： 1234Calculating federal tax for income 50000Calculating state tax for income 50000In Tax. Calculating min taxIn NJTax. Adjusting min tax NJTax类有自己显式定义的构造函数，拥有两个参数，分别是income和stateTaxPersent，当实例化NJTax时需要提供两个参数。为了确保Tax的构造函数被调用（其中会设置对象的inome属性），在子类的构造函数中 显式调用了父类的构造方法 ：super(“50000”)。如果不加入上面的代码，下面的代码将会保错；即使不报错，Tax中的代码也不会得到income的值。 如果需要 调用父类的构造函数 ，只能通过在 子类的构造函数中调用super()函数 来实现。另一种 调用父类代码的方法 是 使用super关键字 。Tax和NJTax都有calcMinTax()方法。父类Tax中的calMinTax根据美国联邦税法计算最基本的最少纳税金额，子类中的calcMinTax获得基本值并对其进行调整。两个方法拥有同样的签名，因此这也是 方法重写（method overriding）的一个例子。 通过 调用super.calcMinTax() ，确保了计算州税时会考虑联邦税金。如果没有调用super.calcMinTax(),方法重写将会启动，子类的calcMinTax()方法将会被执行。方法重写被 用于替换父类方法的功能 ，而 不改变父类的代码 。 关于类和继承的警告ES6中的类 只是提高代码的可读性的语法糖 。在底层实现中， JavaScript仍然使用原型链继承 ，这使得子运行时能够动态替换父级，而类只有一个父级。尽量 避免 创建 深层继承结构 ，因为这会 降低代码的灵活性 ，也会 让重构代码变得复杂 。尽管使用super关键字和super()函数能够调用父级的代码，但是应该 尽量避免使用它们 ，这是因为它们 会在父类之间产生高度耦合性 。子类知道关于父类的内容越少越好。如果对象的父类发生了变化，新的父类可能并没有super()试图调用的方法。 promise处理异步流程 使用promise处理异步流程,在之前的ECMAScript实现中，如果希望 处理异步流程 ，将不得不使用 回调 ，把一个函数作为另一个函数的参数传入其中以便调用。回调可以被 同步 或 异步 的调用。 在上面的章节中，把一个 回调函数 传给了 forEach()函数 用于 同步调用 。向服务器发送一个 AJAX请求 时，设置一个 回调函数 ，当从服务器 返回结果时该回调函数将会被调用 。 回调地狱 假设一种情况：需要从服务器获得若干订单数据，整个流程开始于一个异步调用，用于从服务器获得顾客信息，之后需要为每位顾客调用另一个函数获得订单。根据每一个订单获得产品。调用最后一个方法得到产品详情。 在 异步流过程中 ，无获知每一步操作是否完成 ，因此需要编写回调函数，以便操作完成时调用它。示例中使用setTimeout()函数模拟延迟，每一个操作需要一秒钟的时间来完成。 1234567891011121314151617function getProductDetails() &#123; setTimeout(function()&#123; console.log(&apos;Getting customers&apos;); setTimeout(function()&#123; console.log(&apos;Getting orders&apos;); setTimeout(function() &#123; console.log(&apos;Getting products&apos;); setTimeout(function() &#123; console.log(&apos;Getting products details&apos;); &#125;, 1000); &#125;, 1000); &#125;, 1000); &#125;, 1000);&#125;getProductDetails(); 运行代码后将会以每一秒延迟的间隔打印如下信息： 1234Getting customersGetting ordersGetting productsGetting products details 上面的 代码嵌套程度已经令人很难阅读了 ，现在想象一下，如果需要向其中添加业务逻辑或错误处理，这样编写代码的方式通常被称为 回调地狱 或 回调金字塔（代码的空格令其看起来像个三角形）。 ES6 promise ES6引入了promise，在 保持与回调相同功能 的同时，消除回调嵌套 并 令代码更易阅读 。Promise对象 等待并监听异步操作的结果 ，通知代码执行是否执行成功或失败 ,以便能够相应地处理下一步操作。Promise对象 表示一个未来结果的操作 ，可能是以下状态之一： Fulfilled: 操作成功完成。 Rejected: 操作失败并返回一个错误。 Pending: 操作正在处理中，既没有fulfilled,也没有rejected。 可以通过为构造函数提供两个函数来实例化一个Promise对象：一个函数在 操作处于fullfilled状态时会被调用 ；另一个函数在 操作处于rejected时被调用 。考虑一下带getCustomers()函数的脚本。 123456789101112131415161718192021function getCustomers() &#123; return new Promise(function(resolve, reject) &#123; console.log(&quot;Getting customers&quot;); // Emulate an async server call here setTimeout(function() &#123; var success = true; if (success) &#123; //得到顾客 resolve(&quot;John Somith&quot;); &#125; else &#123; reject(&quot;Can&apos;t get customers&quot;); &#125; &#125;, 1000); &#125;);&#125;let promise = getCustomers() .then((cust) =&gt; console.log(cust)) .catch((err) =&gt; console.error(err)); console.log(&quot;Invoked getCustomers. Waiting for results&quot;); getCustomers()函数返回一个promise对象，这个对象被初始化时，构造函数接收一个函数作为参数，该函数持有resolve和reject。在上面的代码中，如果接收到顾客信息，就调用resolve()。为了简单起见，setTimeout()模拟一个持续一秒钟的异步请求，并且通过硬编码的方式设置success标志为true.在真实场景中，可以利用XMLHttpRequest对象制造一个请求。如果请求结果成功返回，则调用resolve()；如果又异常发生，则调用reject()。 在上面代码的底部，向Promise()实例附加then()和catch()方法。在这两个方法中只有一个会被调用。当从函数内部调用resolve(“John Smith”)时，这会导致then()被调用，并接收“John Smith”作为参数。如果把success改为false，catch()方法将会被调用，并接收“Can’t get coustomers”作为参数。 运行代码，会在控制塔打印下面的信息： 123Getting customersInvoked getCustomers. Waiting for resultsJohn Somith 注意信息“Invoked getCustomers. Waiting for results”比“John Somith”更早被打印，这证明getCustomers()函数是异步工作的。 每个promise表示一个异步操作，通过链式调用 来 保证特定的操作顺序 。现在添加一个getOrders()函数，该函数能够找到指定的顾客的订单，与getCustomeers()一起链式调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243function getCustomers() &#123; let promise = new Promise(function(resolve, reject) &#123; console.log(&quot;Getting customers&quot;); // Emulate an async server call here setTimeout(function() &#123; var success = true; if (success) &#123; //得到顾客 resolve(&quot;John Somith&quot;); &#125; else &#123; reject(&quot;Can&apos;t get customers&quot;); &#125; &#125;, 1000); &#125;); return promise;&#125;function getOders(customer) &#123; let promise = new Promise(function(resolve, reject) &#123; // Emulate an async server call here setTimeout(function() &#123; var success = true; if (success) &#123; //得到订单 resolve(`Found the order 123 for $&#123;customer&#125;`); &#125; else &#123; reject(&quot;Can&apos;t get orders&quot;); &#125; &#125;, 1000); &#125;); return promise;&#125;getCustomers() .then((cust) =&gt; &#123;console.log(cust); return cust&#125;) .then((cust) =&gt; getOders(cust)) .then((order) =&gt; console.log(order)) .catch((err) =&gt; console.error(err)); console.log(&quot;Invoked getCustomers and getOrders. Waiting for results&quot;); 上面的代码不仅仅 声明和链式调用了两个函数 ，还演示了如何在控制台中 打印中间信息 。上面代码输出如下（注意getCustomers()返回的顾客数据被正确传给了getOders()）： 1234Getting customersInvoked getCustomers and getOrders. Waiting for resultsJohn SomithFound the order 123 for John Somith 可以使用then()链式调用多个函数，而整个链式调用过程中只使用一个错误处理脚本。如果有错误发生，将会 遍历整个then()方法链 ，直到找到一个错误处理函数。发生错误后不会再有then()方法被调用 。 在上面代码中，把变量success的值改为false将会打印信息“Can’t get customers”,并且getOders()方法将不会被调用。如果删除这些控制台打印，检索顾客和订单的 代码看起来整洁并易于理解 ： 123getCustomers() .then((cust) =&gt; getOders(cust)) .catch((err) =&gt; console.error(err)); 即使添加更多的then()方法，也不会让代码的可读性降低。 多个promise一次resolve多个promise,需要考虑的另一种情况是不相互依赖的异步函数。假设需要调用两个函数，这两个函数并没有特定的调用顺序，但是只有在两者完成之后才能执行某些操作。Promise有一个all()方法，可以 处理一个可迭代的promise集合并执行（resolve）它们 。因为all()方法返回一个promise对象，所以可以为执行结果添加then()或catch()，或者两者都添加。 让我们看看如何使用all()处理getCustomers()和getOders()函数： 12Promise.all([getCustomers(), getOders()]).then((order) =&gt; console.log(order)) 上面代码产生如下的输出如下： 123Getting customersGetting orders for undefined [&quot;John Somith&quot;, &quot;Found the order 123 for undefined&quot;] 注意信息“Getting orders for undefined”。这是因为没有以有序的方式resolve promise,因此getOders()没有接收到顾客作为参数。当然，这种场景下使用Promise.all()并不是什么好主意，但在有些情况下Promise.all()是很好的解决方案。想象一下，有一个Web门户网站，它需要调用过个异步请求以获得天气、股票市场新闻以及交通信息。如果希望在所有异步请求都完成之后才显示门户页面，Promise.all()正是所需要的： 12Promise.all([getWrather(), getStockMarketNews(), getTraffic()]) .then(renderGUI); 与回调相比，promise能够 让代码更线性 ，更加容易阅读 ，并且 能够表示应用程序的多种状态 。promise的劣势是，promise无法被取消 。想象一下，一位不耐烦的客户单击一个按钮很多次，想从服务器获取数据。每次单击都会创建一个promise并初始化一个HTTP请求，并没有办法能做到只保持最新的请求而取消没有完成的请求。Promise对象下一步的优化是obervable对象，Observable对象在未来的ECMAScript规范中可能会被引入。 注意用来从网络中获取资源的新推出的 Fetch API 可能很快将会取代XMLRequest对象。Fetch API基于promise,有关详细信息，请参阅Mozilla开发人员网络文档（详见 http://mng.bz/mbMe ）。 模块 在任何一种编程语言中，把代码拆分到模块中都有助于 将应用程序组织成具有逻辑的可复用单元 。模块化应用程序能够 让软件开发者更有效地拆分开发任务 。开发者可以决定模块应该暴露 那些API以提供外部使用 ，哪些API应该仅在内部使用 。 ES5并没有用于创建模块的语言结构，因此不得不采用以下方法： 利用 立即执行函数 来手动实现一种模块设计模式（请参阅Todd Motto的文章“Mastering the Module Pattern”, 网址为 http://toddmotto.com/mastering-the-module-pattern/ ） 使用AMD(详见 http://mng.bz/7L1d ) 或CommonJS（详见 http://mng.bz/JKVc ）标准的第三方实现。 CommonJS被创建用于 模块化 那些 运行在非Web浏览器环境中的JavaScript应用程序 （比如那些用Node.js开发并部署在Google V8引擎下的应用程序）。AMD主要用于 运行在Web浏览器中的应用程序 。 在任何“体面”（decent-sized）的应用程序中，都应该尽量 减少客户端需要加载的JavaScript代码量 。想象一个典型的电商网站。是否需要在打开应用程序首页的时候就加载处理支付的代码？如果用户从来就没有点击过订单提交按钮呢？把应用程序模块化将会是非常好的事情，这样 代码就能够被按需加载 。RequireJs 可能是 最流行的实现AMD标准的第三方库 。它可以 定义模块间的依赖关系 ，并把它们 按需加载到浏览器中 。 从ES6开始， 模块已经成为语言的一部分 ，这就意味着开发者 将会停止使用第三方库来实现各种标准 。即使Web浏览器原生不支持ES6模块，也还是有一些 polyfill 能够让你从现在开始使用JavaScript模块。我们将使用 SystemJs 作为polyfill。 导入和导出通常来说，模块只是一个 JavaScript代码文件 ，它 实现了特定的功能 并 对外提供公共API 以便其他JavaScript程序能够使用，并没有特殊的关键字用来声明特定文件中的代码是模块。但是在脚本中，关键字 import 和 export 会 将脚本转换成ES6模块 。 import关键字 允许一个脚本 声明它需要使用在另一个脚本文件中定义的变量和函数 。同样， export关键字 能够 声明模块需要导出给其他脚本使用的变量、函数或类 。换句话说，通过使用export关键字，可以 将选择的API提供给其他模块使用 。模块中 没有被显式导出函数、变量和类仍然被封装在模块中 。 注意模块和常规JavaScript文件之间的主要区别是：当使用 &lt;script&gt; 标签添加一个常规JavaScript文件到页面时，它 会变成全局上下文的一部分 ，而 模块中的声明则是局部的 ，不会变成全局命名空间的一部分。即使是被导出的成员，也仅对那些导入它们的模块可用。 ES6提供了两种export用法：命名导出 和 默认导出 。使用命名导出，可以 在模块的多个成员（如类、函数和变量）的前面添加export关键字 。下面文件（tax.js）中的代码会导出变量taxCode和函数calcTaxes(),但是doSomethingEles()函数仍然对外部脚本隐藏： 123export var taxCode;export function calcTaxes()&#123; // the code goes here&#125;export doSomethingElse() &#123; //the code goes here&#125; 当其他脚本需要 导入这些命名导出的成员时 ，它们的 名字必须放在大括号中 。main.js文件说明如下： 123import &#123;taxCode, calcTaxes&#125; from &apos;tax&apos;;if (taxCode === 1) &#123; // do something &#125;calcTaxes(); 此处tax引用的是文件名，去掉后缀名。模块中所有被导出的成员中 可以有一个标记为default,这 意味着它是匿名导出 ，其他模块可以在导入它的语句中为它指定任何名字。在my_modules.js文件中导出一个函数，如下所示： 12export default function() &#123; // do something &#125; //没有分号export var taxCode; main.js文件既导入默认导出的函数，又导入命名导出的变量，并将coolFunction分配给默认导出的函数： 12import coolFunction, &#123; taxCode &#125; from &apos;my_module&apos;;coolFunction(); 注意对于coolFunction，并 不需要用大括号括起来，但是taxCode需要用大括号括起来。脚本导入由default关键词导出的类、变量或函数，可以在 不需要使用任何特殊关键字的情况下为它们指定新的名字 ： 12import aVeryCoolFunction, &#123;taxCode&#125; form &apos;my_module’；aVeryCoolFunction(); 但是，如果需要给一个已经命名导出成员一个别名 ，需要这么写： 1import coolFunction, &#123;taxCode as taxCode2016&#125; from &apos;my_module&apos;; import语句并不会复制导出的代码。导入的是引用。 脚本不会修改导入的模块或成员，如果导入模块中的值发生变化，那么新值会立刻反映到所有导入该模块的地方。 动态加载模块 使用ES6模块加载器动态加载模块,ES6规范的早期草稿定义了一个动态模块加载器，名为 System,但它并没有被写入到规范的最终版本中。在未来，System对象将会被浏览器作为原生的基于promise的加载器实现 ，使用方法如下所示： 1234567System.import(&apos;someModule&apos;) .then(function(modulr) &#123; module.dosomething(); &#125;) .catch(function(error) &#123; // handle error here &#125;); 现在还没有浏览器实现System对象，因此需要使用polyfill。System有很多polyfill，ES6模块加载器是其中一个，另一个是SystemJS。 注意 尽管es6-module-loader.js是System对象的一个polyfill，但它仅能加载ES6模块；而通过SystemJS加载器不仅支持ES6模块，同样支持AMD和CommonJS模块。 ES6模块加载器的polyfill可以在GitHub上找到，网址为http://mng.bz/MD8w 。下载并解压这个加载器，复制es6-module-loader.js文件到工程目录下，并把其引入到HTML文件中，早于应用程序脚本加载： 12&lt;script src=&quot;es6-module-loader.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;my_app.js&quot;&gt;&lt;/script&gt; 为了确保ES6脚本能够在所有浏览器中工作，需要把其转码成ES5。这个任务 可以作为构建工程 的一部分，也 可以在浏览器中实时完成 。我们将使用Traceur编译器来演示如何在浏览器中实时转码。 首先需要把转码器、模块加载器以及代码脚本全部引入到HTML文件中。既可以将Traceur脚本下载到本地目录中，也可以直接使用远程链接，如下所示： 123&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;es6-module-loader.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;my-es6-app.js&quot;&gt;&lt;/script&gt; 下面考虑一个在线电商的简单示例，其中包括能够按需加载的运输模块和账单模块。应用程序由一个HTML文件以及两个模块组成。HTML文件中有一个名为加载运输模块（Load the Shipping Module）的按钮。若用户单击这个按钮，应用程序将会加载并运行运输模块，运输模块依赖于账单谋爱。运输模块如下所示： 12345678910import &#123;processPayment&#125; from &apos;billing&apos;export function ship() &#123; processPayment(); console.log(&quot;shipping products...&quot;);&#125;function calculateShippingCost() &#123; console.log(&quot;Calculating shipping cost&quot;);&#125; ship()函数可以被外部脚本调用，calculateShippingCost()是私有的。运输模块以import语句开始，因此能够调用账单模块processPayment()函数。下面为账单模块的代码： 1234567function validateBillingInfo() &#123; console.log(&quot;validating billing info...&quot;);&#125;export function processPayment() &#123; console.log(&quot;processing payment...&quot;);&#125; 账单模块中也有一个公共的processPayment()函数，以及一个私有的validateBillingInfo(0函数。 HTML文件中包括一个按钮，该按钮的单击事件会触发使用es6-module-loader的System.import()加载运输模块。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;modules.html&lt;/title&gt; &lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;es6-module-loader.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;shippingBtn&quot;&gt;Load the Shipping Module&lt;/button&gt; &lt;script type=&quot;module&quot;&gt; let btn = document.querySelector(&apos;#shippingBtn&apos;); btn.addEventListener(&apos;click&apos;, () =&gt; &#123; System.import(&apos;shipping&apos;) .then(function(module) &#123; console.log(&quot;Shpping module Loaded.&quot;, module); module.ship(); //抛出一个异常 module.calculateShippingCost(); &#125;) .catch(function(err) &#123; console.log(&quot;In error handler&quot;, err); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; System。import()返回一个ES6promise对象；当模块被加载时，执行then()中指定的函数。如果发生错误，错误由catch()函数捕获。 在then()中，把信息打印到控制台，并调用运输模块的ship()函数，在ship()函数中调用账单模块的processPayment()。之后，当试图调用calculateShippingCost()函数时，会发现发生异常，这是因为calculateShippingCost()函数并没有被导出，而是私有的。 提示 如果使用Traceur并且在HTML文件中又有一个内联脚本，，使用type=”module”确保Traceur能够把它转换为ES5。如果不声明type=”module”,这个脚本在那些不支持let关键词和箭头函数的浏览器中是无法工作的。 为了能够运行这个示例，需要npm和node.js。之后在任何目录中下载并安装es6-module加载器，运行如下命令： 1npm install es6-module-loader 在此之后，创建一个application文件夹，并把es6-module-loader.js文件（从npm下载器的压缩版本）复制到该文件夹中。示例应用程序有三个额外的文件，如上面代码所示。为简单起见，将所有这些文件放到一个文件夹中。 注意 为了查看此代码，需要启动一台Web服务器来运行代码。可以安装一个基本的HTTP服务器作为Web服务器，如live-server。 在Google Chrome中运行moduleLoader.html，打开Chrome Developer Tools。 如果应用程序中包括10个500KB大小的模块，延迟加载模块就很有必要了。 如果想深入了解ES6语法，可以阅读Axel Rauschmayer撰写的Exploring ES6（参见 http://exploringjs.com/es6 ）。Eric Douglas在GitHub（参见 http://mng.bz/cZFX ）上维护包括各种ES6学习资料的汇总信息。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Angular 2开发实战》学习笔记-Angular入门]]></title>
    <url>%2F2018%2F07%2F25%2FAngular-2-primary%2F</url>
    <content type="text"><![CDATA[Angular入门 代码示例，网址为 http://github.com/Farata/angular2typescript 。 第一个Angular应用程序 将展示使用TypeScript、ES5、ES6编写的Hello World应用程序的三个版本。 TypeScript版本的Hello World此 应用程序包含两个文件： 12index.htmlmain.ts 在HTML文件中加载Angular Angular框架的代码由模块（每个模块一个文件）组成，它们被组合到库中，将库从逻辑上分组成包，例如@angular/core、@angular/common等。必须 在应用程序代码之前加载所需的包 。 下面创建一个index.html文件，它首先加载必需的 **Angular脚本** 、**TypeScript编译器** 以及 **SystemJS模块加载器** 。以下代码从内容分发网络（Content Delivery Network，CDN）unpkg.com 载入这些脚本。 `代码清单2.1 TypeScript index.html` 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src=&quot;//unpkg.com/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt; //Zone.js 是一个提供变更检测的库 &lt;script src=&quot;//unpkg.com/zone.js@0.8.4&quot;&gt;&lt;/script&gt; //TypeScript编译器在浏览器中将源代码编译成JavaScript &lt;script src=&quot;//unpkg.com/typescript@2.0.0&quot;&gt;&lt;/script&gt; //SystemJS将应用程序代码动态加载到浏览器中。 &lt;script src=&quot;//unpkg.com/systemjs@0.19.37/dist/system.src.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //配置SystemJS加载器，用于加载并编译TypeScript代码 System.config(&#123; transpiler: &apos;typescript&apos;, typescriptOptions: &#123;emitDecoratorMetadata: true&#125;, //将Angular模块的名称映射到它们的CDN位置 map: &#123; &apos;rxjs&apos;: &apos;https://unpkg.com/rxjs@5.0.0-beta.12&apos;, &apos;@angular/core&apos; : &apos;https://unpkg.com/@angular/core@2.0.0&apos;, &apos;@angular/common&apos; : &apos;https://unpkg.com/@angular/common@2.0.0&apos;, &apos;@angular/compiler&apos; : &apos;https://unpkg.com/@angular/compiler@2.0.0&apos;, &apos;@angular/platform-browser&apos; : &apos;https://unpkg.com/@angular/platform-browser@2.0.0&apos;, &apos;@angular/platform-browser-dynamic&apos;: &apos;https://unpkg.com/@angular/platform-browser-dynamic@2.0.0&apos; &#125;, //为每个Angualr模块指定main脚本 packages: &#123; &apos;@angular/core&apos; : &#123;main: &apos;index.js&apos;&#125;, &apos;@angular/common&apos; : &#123;main: &apos;index.js&apos;&#125;, &apos;@angular/compiler&apos; : &#123;main: &apos;index.js&apos;&#125;, &apos;@angular/platform-browser&apos; : &#123;main: &apos;index.js&apos;&#125;, &apos;@angular/platform-browser-dynamic&apos;: &#123;main: &apos;index.js&apos;&#125; &#125; &#125;); //指示Angular从main.ts文件加载主模块 System.import(&apos;main.ts&apos;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; //自定义的HTML元素&lt;hello-world&gt;&lt;/hello-world&gt; 表示main.ts中实现的组件。 &lt;hello-world&gt;&lt;/hello-world&gt;&lt;/body&gt;&lt;/html&gt; 当此应用程序启动时， &lt;hello-world&gt;标签将由代码清单2.2中所示的@Component注解的模板内容替代。 &gt;提示 如果使用的是IE（Internet Explorer）浏览器，那么可能需要添加额外的脚本 system-polyfills.js 。 &gt;内容分发网络（CDN） unpkg（ http://unpkg.com ）是发布到npm（ http://www.npmjs.com/ ）包管理器的注册表（软件）包的一个CDN。检查npmjs.com以查找特定包的最新版本。如果想要查看哪个其他版本的包可用，请运行 npm info packagename 命令。 TypeScript文件 现在创建main.ts文件，它具有TypeScript/Angular代码和以下三个部分： 1. 声明Hello World组件 2. 将其包组装成一个模块 3. 加载该模块 `代码清单2.2 TypeScript main.ts` 123456789101112131415161718192021222324252627282930313233343536//从相应的Angular包导入引导方法和@Component注解，使其可用于应用程序代码import &#123;Component&#125; from &apos;@angular/core&apos;;import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;import &#123; platformBrowserDynamic &#125; from &apos;@angular/platform-browser-dynamic&apos;;// Component@Component(&#123; //在HelloWorldComponent类之上的@Component注解将其转换为Angular组件 selector: &apos;hello-world&apos;, //template属性定义了用于渲染此组件的HTML标记 template: &apos;&lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;&apos;&#125;)注解过的HelloWorldCompoent类表示组件class HelloWorldComponent &#123; //name属性被用于组件模板的数据绑定表达式中 name: string; constructor() &#123; //在构造函数中，使用值Angular 2初始化绑定到模板的name属性 this.name = &apos;Angular&apos;; &#125;&#125;// Module @NgModule(&#123; //声明模块内容 imports: [ BrowserModule ], declarations: [ HelloWorldComponent ], bootstrap: [ HelloWorldComponent ]&#125;)export class AppModule &#123; &#125; //声明表示模块的类// App bootstrapplatformBrowserDynamic().bootstrapModule(AppModule); //加载此模块 &gt; 元数据 **元数据是关于数据的附加信息。** 对于类，元数据 **是关于该类的附加信息** 。例如，@Component装饰器（有名注解）告诉Angular（元数据处理器）这 **不是一个常规类，而是一个组件** 。**Angular根据@Compnents装饰器的属性中提供的信息生成额外的JavaScript代码** 。@Component装饰器不会更改装饰的类，但**会添加一些描述该类的数据** ，因此Angular编译器可以在浏览器的内存（动态编译）或磁盘上的文件（静态编译）中正确生成组件的最终代码。 通过使用与@Component注解的 **selector属性中的组件名称相匹配的标签** ，任何应用程序组件都可以包含在HTML文件（或其他组件的模板）中。 **组件选择器类似于CSS选择器** ，因此给定‘hello-world’选择器，就将使用名为&lt;hello-world&gt;的元素将这个组件渲染到HTML页面中。 **Angular会将此行转换成document.querySelctorAll(selector)** 。 请注意，在代码清单2.2中整个模板都包含在 **反引号** 中，以 **将模板转换成一个字符串** 。这样，就可以在模板中 **使用单引号和双引号** ，并 **将器分成多行以进行更好的格式化** 。该模板包含 **数据绑定表达式{{name}}** ,而且在运行时，Angular将在组件上找到name属性，并 **用具体值替换大括号中的数据绑定表达式** 。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Angular 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《HTML5秘籍》学习笔记-编写更有意义的标记]]></title>
    <url>%2F2018%2F07%2F25%2FHTML5-sign%2F</url>
    <content type="text"><![CDATA[编写更有意义的标记 使用微数据（microdata）,解决文件级语义问题的前言标准，可以让网页和搜索结果的内容更加丰富。 回顾语义元素从页面结构开始讨论语义是因为页面结构容易把握。绝大多数网站在规划布局时，都会使用为数不多的几种常见设计元素（页眉、页脚、侧边栏、菜单），结果网站的布局——除了外观装饰有所不同外——都很相似。 由于结构化的内容是又很多更小的内容片段构成的，而组织这些内容片段的方式没有一定之规。 HTML5的策略是双管齐下。一方面，它 只增强了很少几个文本级语义元素 ；另一方面，任何人都 可以定义自己的信息 。HTML5支持一个 独立的微数据标准 。这个标准为人们提供了扩展的可能性，任何人都可以定义自己的信息，在自己的页面中为信息添加标注。 首先，来认识三个新的文本级的语义元素： &lt;time&gt; 、 &lt;output&gt; 和 &lt;mark&gt; 。 标注日期和时间网页中经常会出现日期和时间信息。有了 &lt;time&gt; 元素可以解决 没有标准的方式来标注日期的问题，通过它可以标注日期、时间或日期与时间的组合。先看个例子： 1The Party starts &lt;time&gt;2014-03-21&lt;/time&gt; 用 `&lt;time&gt;` 元素来标注日期似乎有点违反直觉，这是HTML5的古怪行为之一。更适合的元素显然应该是 `&lt;datatime&gt;`。 &lt;time&gt; 元素在这儿扮演两个角色。首先，它 表示日期和时间位于标记的哪个地方 。其次，它 以任何软件程序都能理解的方式提供日期和时间。 前面的例子符合第二个角色的要求，使用了通用日期格式。 可以采用任何格式来表示日期，只要你在datetime属性中提供计算机能看懂的通用格式日期就行，比如： 1The party starts &lt;time datetime=&quot;2014-03-21&quot;&gt;March 21&lt;sup&gt;st&lt;/sup&gt;&lt;/time&gt; 在浏览器中的效果如下所示： 1The party starts March 21^st. 对于时间部分， &lt;time&gt; 也有类似的规则，标准的时间格式如下： 1HH:MM 首先是2位数的小时（24小时制），然后是2位数的分钟。比如： 1Parties starts &lt;time datatime=&quot;2014-03-21 16:30&quot;&gt;4:30 p.m.&lt;/time&gt; 最后，组合以上两个规则可以指定具体日期和时间，日期在前，空一个格，时间在后： 1The party starts &lt;time datatime=&quot;2014-03-21 16:30&quot;&gt;March 21&lt;sup&gt;st&lt;/sup&gt; at 4:30 p.m.&lt;/time&gt; 最初 `&lt;time&gt;` 元素要求用一种稍有不同的格式组合日期和时间。2014-03-21T16:30的格式还可以用，因此在别人的网页也可能出现。 在组合日期和时间的情况下，有时候还需要 后缀时区信息 。比如：纽约在东五区，即UTC-5:00。（关于时区的划分，请参见 http://en.wikipedia.org/wiki/Time_zone。）要表示纽约时间下午4:30，应该使用如下标记： 1The party starts &lt;time datetime=&quot;2014-03-21 16:30-05:00&quot;&gt;March 21&lt;sup&gt;st&lt;/sup&gt; at 4:30 p.m.&lt;/time&gt; 这样，看你网页的人，能看到他们想看到的格式，而搜索机器人和其他软件则能看到它们可以处理的值，而且毫无歧义。 另外， &lt;time&gt; 还有 一个pubdate属性 。如果当前内容（例如 &lt;time&gt; 元素所在的 &lt;article&gt; ）对应一个发表日期，可以使用这个属性。下面就是一个例子： 1Published on &lt;time datetime=&quot;2014-03-21&quot; pubdate&gt;March 31,2014&lt;/time&gt;. 因为 `&lt;time&gt;`元素是纯粹是信息性的，没有任何附加样式，所以可以在任何浏览器中使用。不必担心兼容性问题。 使用 &lt;output&gt; 标注JavaScript返回值HTML5还包含一个语义元素 &lt;output&gt;,它能使 某种JavaScript驱动页面更加清晰 。实际上，这个元素是 一个占位符 ，用于展示一小段计算后的信息 。 通常的做法是给占位符指定一个ID属性，这样JavaScript代码就可以在计算时找到它。Web开发人员一般将 &lt;span&gt; 元素用作占位符，而唯一的问题是该元素不提供任何语义： 1&lt;p&gt;Your BMI: &lt;span id=&quot;result&quot;&gt;&lt;/span&gt;&lt;/p&gt; 以下则是使用HTML5的更有意义的版本： 1&lt;p&gt;Your BMI：&lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/ 实际的JavaScript代码无需改变，因为它只是根据ID属性查找元素，不用考虑元素类型： 1var resultElement = document.getElementById(&quot;result&quot;); 通常，这种页面都会采用一个 &lt;form&gt; 元素。在这个例子中，需要包含3个文本框，以便用户使用在其中输入信息： 123456789&lt;form action=&quot;#&quot; id=&quot;bmiCalculator&quot;&gt; &lt;label for=&quot;feet&quot; inches&gt;Height:&lt;/label&gt; &lt;input name=&quot;feet&quot;&gt;feet&lt;/br&gt; &lt;input name=&quot;inches&quot;&gt;inches&lt;br&gt; &lt;labelfor=&quot;punds&quot;&gt;Weight:&lt;/label&gt; &lt;input name=&quot;pounds&quot;&gt;pounds&lt;br&gt;&lt;br&gt; ...&lt;/form&gt; 可以为 &lt;output&gt; 元素添加form和for属性，前者的值是 包含相关控件表单ID ,后者的值是 以空格分隔的相关控件的ID 。比如下面的例子： 123&lt;p&gt; Your BMI: &lt;output id=&quot;result&quot; from=&quot;bniCalculator&quot; for=&quot;feet inches punds&quot; &gt;&lt;/p&gt; 这些属性的唯一用处就是 表明 &lt;output&gt; 从那些控件获取结果这一信息 。如果其他人需要编辑你的页面， 那些属性可以帮他们理清思路 。 提示可以在 http://prosetech.com/html5 找到所有示例页面。 使用 &lt;mark&gt; 标注突显文本&lt;mark&gt; 用于标注一段文本 ， 这段文本会突出显示 。在需要引用其他人的内容，而你想引起别人的注意，就可以使用 &lt;mark&gt; 元素： 12345678910111213 &lt;p&gt;In 2009, Facebook made a bold grab to own everyone&apos;s content,&lt;em&gt;forever&lt;/em&gt;. This is the text they put in their terms of service:&lt;/p&gt; &lt;blockquote&gt;You hereby grant Facebook an &lt;mark&gt;irrevocable, perpetual, non-exclusive, transferable, fully paid, worldwide license&lt;/mark&gt; (with the right to sublicense) to &lt;mark&gt;use, copy, publish&lt;/mark&gt;, stream, store, retain, publicly perform or display, transmit, scan, reformat, modify, edit, frame, translate, excerpt, adapt, create derivative works and distribute (through multiple tiers), &lt;mark&gt;any user content you post&lt;/mark&gt; on or in connection with the Facebook Service or the promotion thereof subject only to your privacy settings or enable a user to post. &lt;/blockquote&gt; &lt;p&gt;Fortunately, they&apos;ve since backtracked and weakened the language considerably.Here&apos;s the relevant section today:&lt;/p&gt; &lt;blockquote&gt;&lt;mark&gt;You own all of the content and information you post on Facebook&lt;/mark&gt;, and you can control how it is shared through your privacy and application settings. In addition: 1. For content that is covered by intellectual property rights, like photos and videos (&quot;IP content&quot;), you&lt;/mark&gt; specifically give us the following permission, subject to your privacy and application settings: &lt;mark&gt;you grant us a non-exclusive, transferable, sub-licensable, royalty-free, worldwide license to use any content that you post&lt;/mark&gt; on or in connection with Facebook. &lt;mark&gt;This license ends when you delete your content or your account&lt;/mark&gt; unless your content has been shared with others, and they have not deleted it. &lt;/blockquote&gt; 如下图3-2所示，浏览器会给 &lt;mark&gt; 中的文本添加黄色背景。 图3-2 也可以使用 &lt;mark&gt; 标注重要的内容或关键字 ——就像搜索引擎在搜索结果中显示匹配的文本那样，还 可以与 &lt;del&gt;（删除的文本）和 &lt;ins&gt;（插入的文本）组合使用 ,以标注文档的变化。 &lt;mark&gt; 元素并不十分必要，HTML5规范认为它是一个语义元素，但实际上它更多地则是被用于表现目的。默认情况下，被标注的文本会带有浅黄色的背景（见图3-2），不过可以通过样式规则为它应用不同的样式。 提示 应该坚持只用 &lt;mark&gt;（结合你想使用的任意CSS格式）来传达适当的语义。那就是 使用 &lt;mark&gt;来吸引人注意那些变得很重要的文本 。 即使沿用默认的黄色背景，也应该为不支持HTML5的浏览器添加后备样式表。以下就是相应的样式规则： 1234mark &#123; bakground-color: yellow; color: black;&#125; 其他语义元素 ARIA ARIA（Accessible Rich Internet Application, 无障碍富因特网应用）是一个还在制定中的标准， 它规定了在任意HTML元素上使用属性 ， 而通过这些属性可以为屏幕阅读器提供额外的信息 。例如，ARIA中规定了一个role属性，表示所在元素的用途。下面就以一个表示页眉的 &lt;div&gt; 元素为例： 1&lt;div class=&quot;header&quot; 通过为其指定值为banner的role属性，可以告诉屏幕阅读器它的用途是保存横幅广告： 1&lt;div class=&quot;header&quot; role=&quot;banner&quot;&gt; HTML5为标注页眉提供了一个语义元素。因此，最适合的方式莫过于： 1&lt;header role=&quot;banner&quot;&gt; 这个示例说明了两方面的问题: 首先，ARIA规定了一些推荐的角色名。（要了解所有角色名，请参考规范中相应部分： http://tinyurl.com/roles-aria 。）其次，部分ARIA与新HTML5语义元素重复——只是合情合理的，因为ARIA早于HTML5。不过重复也不是完全重复。 ARIA还 针对表单定义了属性 。文本框的 aria-required属性 表示 用户必须输入值 。而文本框的 aria-invalid属性 表示 当前值不正确 。这些属性可以让屏幕阅读器用户，特别是视力不好的用户，不会因为看不到提示信息（比如必填字段旁的星号，或闪烁的红色错误图标）而受影响。 如果想创造一个 可以无障碍访问的网站 ，必须 既要考虑ARIA,又要考虑HTML5 。因为屏幕阅读器支持ARIA，不支持HTML5。 注意 要了解有关ARIA（全名是WAI-ARIA, 因为它是由Web Accessibility Initiative 工作组负责制定的）的 更多信息，请参考其规范： http://www.w3.org/TR/wai-aria/ 。 RDFaRDFa（Rrsource Description Framework, 资源描述框架） 也是一种使用属性向网页中嵌入详细信息的标准 。RDFa有一个明显的优点; 它是一个稳定不变的标准 。RDFa也有两个明显的缺点。首先，RDFa最初是为XHTML而非HTML5设计的，因此关于严格的RDFa与松散的HTML5如何混写的争论一直不绝于耳。其次，RDFa很复杂，嵌入RDFa元数据后的网页比最初要长得多，而且显得很笨重。 可以在Wikipedia上看到完整的介绍： http://en.wikipedia.org/wiki/RDFa 。 微格式微格式 （Microformats）是 一种在网页中嵌入元数据的简单而又比较合理的方式 。它是一组统一的宽松的约定，这些约定 有助于网页之间共享结构化信息 ，但 又不会导致像采用RDFa那样复杂 。 微格式的应用的方式比较新颖，它们附加在通常用于添加样式的class属性上。你可以根据数据的类型，使用某些标准样式名来标注数据 。然后，其他程序可以读取你的标记，提取数据并 通过检查class属性来确定数据的含义 。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《HTML5秘籍》学习笔记-用语义元素构造网页]]></title>
    <url>%2F2018%2F07%2F22%2FHTML5-semantics%2F</url>
    <content type="text"><![CDATA[用语义元素构造网页 为了能够把侧边栏与页眉分开，以及把广告条与菜单分开。HTML5为此引入了一组构造页面的新元素，这组元素能发挥 &lt;div&gt; 一样的作用，但是却能传达出更多的语义。 语义元素 &lt;time&gt;元素 1Registration begins on &lt;time&gt;2014-11-25&lt;/time&gt;. 代码在网页中呈现的结果如下所示： 1Registration begins on 2014-11-25. &lt;time&gt; 元素没有任何内置的样式，元素中的文本和普通文本没有区别。 设计 &lt;time&gt; 元素的用意是让它包含一小段信息。但大多数HTML5语义元素的用途是 标识页面中的一个内容区块 。比如， &lt;nav&gt; 元素用于标识一组导航链接。而 &lt;footer&gt; 元素用于标识通常放在页面底部的文脚（或页脚）。大概有十几个类似的新元素。 所有语义元素都有一个显著的特点： 不真正做任何事。相对来说， &lt;video&gt; 元素则囊括了在页面中充当视频播放器的全部能力。 使用这些新元素的理由： 容易修改和维护通过HTML5的语义元素，通过标记就可以传达出额外的结构化信息。 无障碍性现代Web设计的一个重要主题，就是让任何人都能无障碍的访问网页。换句话说，要让使用屏幕阅读器和其他辅助工具的人都能够在页面中自由导航。兼容HTML5的无障碍工具可以为残疾人士提供更好的上网体验。（仅举一个例子，有了 &lt;nav&gt; 元素，屏幕阅读器就能迅速返回导航区，进而找到网页链接。） 搜索引擎优化如果搜索引擎能更好的理解你的站点，那搜索者的查询就会越容易与你的内容匹配，因而你的网站列在搜索结果中的可能性也就越大。 未来功能新浏览器和Web编辑器工具一定会利用语义元素。比如，浏览器可以提供一个页面内容的纲要，以方便跳转到页面适当的区块。类似地，网页设计工具也能包含一些方便你构建或编辑菜单的功能，而方法就是组织你放在 &lt;nav&gt; 区块中的内容。 最关键的问题在于，如果正确地使用了语义元素，就能够 创建更加清晰的页面结构 ，就能 适应未来的浏览器和Web设计工具的发展趋势 。 改造传统的HTML页面 要了解和熟悉新的语义元素（包括学习如何使用它们来构造页面），最好的方式莫过于拿一个经典的HTML文档作为例子，然后把HTML5的一些新鲜营养充实进去。例子访问 http://prosetech.com/html5 。 构造页面的老办法这个示例页面使用的是HTML最佳实践，没有任何通过标记来格式化的痕迹。没有粗体或斜体元素，没有嵌入的样式。总之，这是一个格式非常规范的页面， 所有样式均来自外部样式表 。 1234567891011121314151617181920212223&lt;div class=&quot;header&quot;&gt; &lt;h1&gt;How the World Could End&lt;/h1&gt; &lt;p class=&quot;Teaser&quot;&gt;Scenarios that spell the end of life as we know it&lt;/p&gt; &lt;p class=&quot;Byline&quot;&gt;by Ray N.Carnation&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;content&quot;&gt; &lt;p&gt;&lt;span class=&quot;LeadIn&quot;&gt;Right now&lt;/span&gt;, you&apos;re probably ...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;h2&gt;Mayna Doomsday&lt;/h2&gt; &lt;p&gt;Skeptics suggest...&lt;/p&gt; ...&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt; &lt;p class=&quot;Disclaimer&quot;&gt;These apocalyptic predictions ...&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;AboutUs.html&quot;&gt;About Us&lt;/a&gt; ... &lt;/p&gt; &lt;p&gt;Copyright @ 2014&lt;/p&gt;&lt;/div&gt; 编写规范的传统HTML页面中，通过使用 &lt;div&gt; 和 &lt;span&gt; 元素，已经把大部分工作移交给了样式表。通过 &lt;span&gt; 可以为 处在其他元素中的少量文本添加样式 ，而通过 &lt;div&gt; 不仅可以为 整个内容区块添加样式 ，还可以 构建起整个页面结构 。 因为使用了 &lt;div&gt; 元素，所以添加样式很容易。使用下列规则为页眉及其中内容添加样式。 12345678910111213141516171819202122232425262728/* 为&lt;div&gt;添加样式，使其具有页眉的外观（蓝色带边框）*/.Header &#123; background-color: #7695FE; boder:thin #336699 solid; padding: 10px; margin: 10px; text-align: center;&#125;/* 为页眉中的 &lt;h1&gt; 添加样式(这是文章的标题）*/.Header h1 &#123; margin: 0px; color: white; font-size: xx-large;&#125;/* 为页眉中的子标题添加样式 */.Header .Teaser &#123; margin: 0px; font-weight: bold;&#125;/* 为页面中的署名行添加样式 */.Header .Byline &#123; font-style: italic; font-size: small; margin: 0px;&#125; 使用H5构造页面&lt;div&gt; 目前依旧是Web设计中的必备元素，它是 一个直观、多用途的容器 ，可以通过它 为页面中的任何区块应用样式 。但 &lt;div&gt; 的问题在于，它本身 不反映与页面相关的任何信息 。 要通过HTML5改进这种情况，可以把 &lt;div&gt; 替换成更具有描述性的语义元素。这些语义元素的行为与 &lt;div&gt; 元素类似：它们 仅包含一组标记，除此之外没有其他作用 ，可以将它 作为“格式挂钩”来为页面应用样式 。不过，除此之外，它们还会 为页面添加一点语义 。 下面代码是对传统页面的简单修改之后的结果，删除了两个 &lt;div&gt; 元素，但添加了两个HTML5的语义元素：&lt;header&gt; 和 &lt;footer&gt; 。 1234567891011121314151617181920212223&lt;header class=&quot;header&quot;&gt; &lt;h1&gt;How the World Could End&lt;/h1&gt; &lt;p class=&quot;Teaser&quot;&gt;Scenarios that spell the end of life as we know it&lt;/p&gt; &lt;p class=&quot;Byline&quot;&gt;by Ray N.Carnation&lt;/p&gt;&lt;/header&gt;&lt;div class=&quot;content&quot;&gt; &lt;p&gt;&lt;span class=&quot;LeadIn&quot;&gt;Right now&lt;/span&gt;, you&apos;re probably ...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;h2&gt;Mayna Doomsday&lt;/h2&gt; &lt;p&gt;Skeptics suggest...&lt;/p&gt; ...&lt;/div&gt;&lt;footer class=&quot;footer&quot;&gt; &lt;p class=&quot;Disclaimer&quot;&gt;These apocalyptic predictions ...&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;AboutUs.html&quot;&gt;About Us&lt;/a&gt; ... &lt;/p&gt; &lt;p&gt;Copyright @ 2014&lt;/p&gt;&lt;/footer&gt; 如果修改一个大型网站，可以考虑用HTML5中相应的 语义元素来包装已有的 &lt;div&gt; 元素 。 不管怎么说，这里的类名还是有点多余。可以变成这样： 12345&lt;header&gt; &lt;h1&gt;How the World Could End&lt;/h1&gt; &lt;p class=&quot;Teaser&quot;&gt;Scenarios that spell the end of life as we know it&lt;/p&gt; &lt;p class=&quot;Byline&quot;&gt;by Ray N.Carnation&lt;/p&gt; &lt;/header&gt; 但这样修改后，就得修改样式表规则，直接 通过元素名来应用样式 。 下面是修改之后的为 &lt;header&gt;及其包含的所有元素应用样式规则： 12345678910111213141516171819/* 为&lt;header&gt;添加样式，使其具有页眉的外观（蓝色带边框）*/header &#123; ...&#125;/* 为&lt;header&gt;中的 &lt;h1&gt; 添加样式(这是文章的标题）*/header h1 &#123; ...&#125;/* 为&lt;header&gt;中的子标题添加样式 */header .Teaser &#123; ...&#125;/* 为&lt;header&gt;中的署名行添加样式 */header .Byline &#123; ...&#125; HTML5页面经常会混合各种语义元素和更通用的 &lt;div&gt; 容器。 注意： 上面的网页在IE9之前的Internet Explorer 中无法显示。 最后，还有一个元素有必要用在示例页面中。那就是HTML5的 &lt;article&gt; 元素，这个元素 表示一个完整的、自成一体的内容块 ，比如博客文章或新闻报道。 &lt;article&gt; 元素应该包含所有相关的内容，包括标题、作者署名以及正文。添加了 &lt;article&gt; 元素之后的页面结构就变成如下所示： 1234567891011121314151617181920&lt;article&gt; &lt;header&gt; &lt;h1&gt;How the World Could End&lt;/h1&gt; ... &lt;/header&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;&lt;span class=&quot;LeadIn&quot;&gt;Right now&lt;/span&gt;, you&apos;re probably ...&lt;/p&gt; &lt;p&gt;...&lt;/p&gt; &lt;h2&gt;Mayna Doomsday&lt;/h2&gt; &lt;p&gt;Skeptics suggest...&lt;/p&gt; ... &lt;/div&gt;&lt;/article&gt;&lt;footer&gt; &lt;p class=&quot;Disclaimer&quot;&gt;These apocalyptic predictions ...&lt;/p&gt; ...&lt;/footer&gt; 最终的页面结构示意图： 添加插图HTML5规范建议我们将插图想象成一本书中的附图；换句话说，插图虽独立于文本，但文本中会提到它 。 一般来说，插图应该是浮动的；换句话说，应该把它 放在相关文本旁边的一个比较近便的位置上 ，而不要把它们锁定在特定的词或元素旁边。而且，插图通常 还会有与之相伴的浮动图题 。 下面是个这篇文章添加插图的HTML标记。 1234567&lt;p&gt;&lt;span class=&quot;LeadIn&quot;&gt;Right now&lt;/span&gt;, you&apos;re probably ...&lt;/p&gt;&lt;div class=&quot;FloatFigure&quot;&gt; &lt;img src=&quot;human_skull.jpg&quot; alt=&quot;Human skull&quot;&gt; &lt;p&gt;Will you be the last person standing if one of these apocalyptic scenarios play out?&lt;/p&gt;&lt;/div&gt;&lt;p&gt;But don&apos;t get too smug ...&lt;/p&gt; 下面是给出的样式规则： 12345678910111213141516/* 为插图应用样式 */.FloatFigure &#123; float: left; margin-left: 0px; margin-top: opx; margin-right: 20px; margin-bottom: 0px;&#125;/* 为题图应用样式 */.FloatFigure p &#123; max-width: 200px; font-size: small; font-style: italic; margin-bottom: 5px;&#125; HTML5专门量身打造了一个了一个新的语义元素为内容添加插图，下面是用 &lt;figure&gt; 改造后的HTML5文档： 1234&lt;figure class=&quot;FloatFigure&quot;&gt; &lt;img src=&quot;human_skull.jpg&quot; alt=&quot;Human skull&quot;&gt; &lt;figcaption&gt;Will you be the last person standing if one of these apocalyptic scenarios play out?&lt;/figcaption&gt;&lt;/figure&gt; 而题图是放在 &lt;figure&gt; 中的 &lt;figcaption&gt; 元素里的。 当然，给插图和图题应用什么样式，把它们放在什么位置上，还是由你说了算。使用新元素之后，插图还是那样，但不同的是标注插图的标记现在的含义已经非常明确了。（随便在提个醒，&lt;figcaption&gt; 元素不是只能包含文本——任何HTML元素都可以，比如链接、小图标等。） 因为图题中经常包含了对图片的完整说明，所以alt文本就显得有点多余了。这种情况下，可以把 &lt;img&gt; 元素中的alt属性删除： 1234&lt;figure class=&quot;FloatFigure&quot;&gt; &lt;img src=&quot;human_skull.jpg&quot;&gt; &lt;figcaption&gt;A human skull lies on the sand&lt;/figcaption&gt;&lt;/figure&gt; 这里要小心的是，不能把alt文本设成空字符串。因为这意味着你的图片纯粹是装饰用的，屏幕阅读器会忽略不读。 添加附注新的 &lt;aside&gt; 元素 表示与它周围的文本没有密切关系的内容 。这就是说，你可以像在印刷品中使用附录栏一样使用 &lt;aside&gt; 元素，可以通过它 介绍另一个相关的话题 ，或者 对主文档中提出的某个观点进行解释 。另外，也可以用 &lt;aside&gt; 来盛放广告、相关内容链接，甚至醒目引文（pull quote）。 当然，使用熟悉的 &lt;div&gt; 元素也可以创造出这种效果，但用 &lt;aside&gt; 元素包装同样的内容，可以让标记更富有意义： 123456789&lt;p&gt;... (in a suitably robotic voice) &quot;who&apos; s your daddy now?&quot;&lt;/p&gt;&lt;aside class=&quot;PullQuote&quot;&gt; &lt;img src=-&quot;quotes_start.png&quot; alt=&quot;Quote&quot;&gt; We don&apos;t know how the universe started, so we can&apos;t be sure it won&apos;t just end, maybe today. &lt;img src=&quot;quotes_end.png&quot; alt=&quot;End quote&quot;&gt;&lt;/aside&gt;&lt;h2&gt;Unexplained Singularity&lt;/h2&gt; 下面给出了相应的样式： 1234567891011121314151617.PullQuote &#123; float: right; max-width: 300px; border-top: thin black solid; border-bottom: thick black solid; font-size: 30px; line-height: 130%; font-style: italic; padding-top: 5px; padding-bottom: 5px; margin-left: 15px; margin-bottom: 10px;&#125;.PullQuote img &#123; vertical-align: bottom;&#125; 语义元素的来历：可以看看这里： https://developers.google.com/webmasters/state-of-the-web/ 。 对语义元素的支持情况所幸的是，HTML5的这些语义元素已经基本得到了所有现代浏览器的支持。最大绊脚石还是IE9之前的Internet Expolorer，包括仍然占很大比例的IE8. 幸运的是，语义元素还是一个比较容易弥补的功能。只要让浏览器把它们当做普通的 &lt;div&gt; 元素就行了。 为语义元素添加样式浏览器在遇到不认识的元素时，会把它们 当成内联（inline）元素 。大多数HTML5语义元素（包括已经介绍的这些，但除 &lt;time&gt; 之外）都是 块级元素 ，也就是 需要在单独一行上来呈现它们 ，同时在 它们与前后元素之间各添加一些空间 。 为解决浏览器不认识HTML5语义元素，只要在样式表中添加一条“超级规则”即可。下面就是一条为9个HTML5元素应用块级显示格式的规则： 123article, aside, figure, figcaption, footer, header, main, nav, section, summary &#123; display: block;&#125; 这条规则 对于能够识别HTML5元素的浏览器没有作用 ，因为它们的display属性已经被默认设成了block.而且这条规则 也不影响我们已经为这些元素应用的样式 ，那些样式照样可以添加到它们身上。 使用H5“垫片”对于大多数浏览器而言，上面的技术可以解决兼容问题。但这里的“大多数”不包括IE8及更早的版本。换句话说，对于较早版本的IE,还要面临一个挑战：它们会拒绝给无法识别的元素应用样式。好在，有一个变通方案：通过JavaScript创建新元素，就可以骗过IE,让它识别外来元素。比如，下面的脚本可以让IE识别并为 &lt;header&gt; 元素应用样式： 123&lt;script&gt; document.createElement(&apos;header&apos;)&lt;/script&gt; 实际上，不用自己亲自写这些代码，因为已经有人写好了，只要拿过来用就可以了。 要使用这个脚本，只要在页面的 &lt;header&gt; 区块中引用它即可 ，就像这样： 1234&lt;head&gt; &lt;title&gt;...&lt;.title&gt; &lt;script src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;script&gt;&lt;/head&gt; 这行代码会从html5.goolecode.com这个Web服务器上取得脚本，然后在浏览器处理页面其余部分之前运行。 这个脚本 使用前面描述的JavaScript代码创建所有的新HTML5元素 ，然后还会 为它们动态应用上面提到的样式 ，确保新元素能正确的显示为块元素。 前面的html5.js脚本应该是有条件执行的—— 只有你使用旧版本Internet Explorer的情况下才会执行 。为了避免不必要地加载JavaScript文件，可以像下面这样 把引用脚本的代码放在IE的条件注释中： 123&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;script&gt;&lt;![endif]--&gt; 这样，其他浏览器（IE9及更高版本）就会忽略这行脚本，为页面节省数毫秒的加载时间。 也可以 下载垫片脚本放在本地目录里 ，地址为 http://tinyurl.com/the-shiv 。 注意： 可以在页面开头添加“Web标志”解决IE的安全提示条问题。 一站式解决方案 Modernizr内置了HTML5垫片脚本 ，因此 会自动解决上述问题 ，不用再使用html5.js或者添加什么样式规则了。 使用语义元素设计站点 理解 &lt;header&gt; 对于 &lt;header&gt; 元素来说，又两种使用方式，但差别并不大。一种是 用它标注内容的标题 ，另一种是 用它标注网页的页眉 。 如果处理的是内容，那么除非必要，一般不必使用 &lt;header&gt; 。只有在内容标题还附带了其他信息的情况下，才有必要考虑 &lt;header&gt; 。也就是说，其中包含标题、摘要、发表日期、作者署名、图片、或子主题链接等很多内容，例如： 12345&lt;header&gt; &lt;h1&gt;How the world Could End&lt;/h1&gt; &lt;p class=&quot;Tagline&quot;&gt;Scenarios that spell the end of life as we know it &lt;/p&gt; &lt;p class=&quot;Byline&quot;&gt; by Ray N.Carnation&lt;/p&gt;&lt;/header&gt; 不过，在为网站创建页眉的时候，人们多数会直接考虑 &lt;header&gt; 元素，即便这个页眉就是一个CSS控制的长盒子，里面啥都没有。 结论如下： 网页中 可以包含多个 &lt;header&gt; 元素（通常也应该如此） ，即使相应的区块在页面中的角色不一样。 在真实的网站中，可能几十个甚至更多个页面都会有相同的布局（以及相同的侧边栏）。访客点击页面的链接之后，唯一变化的地方就是主页面中的内容。 使用开发网站的技术和技巧把网页变成网站： 服务器端框架 其实背后的思想都很简单，在浏览器请求某个页面时，Web服务器 临时将页面的各个部分组装起来，包括公共的元素（如导航条）和内容。这是目前最常用的一种技术，也是构建大型、专业网站的必由之路。以不同方式实现这种手段的技术不计其数，包括很早就出现的服务器端包含的功能，一些 富Web应用平台（如ASP.NET和PHP），还有 内容管理系统（如Drupal和WordPress）。 页面模板 Dreamwraver、Expression Web等功能强大的页面编辑器中就有页面模板功能。模板就是 一个定义了页面结构并且包含页面中会重复出现的内容（像页眉和侧边栏）的页面 。有了模板，就 可以利用它来创建网站的所有页面 。最关键的是，更新模板之后网页编辑器会自动更新使用该模板的所有页面。 站点标题结构： 随着HTML5获得胜利并统治Web,好像过多个 &lt;h1&gt; 的设计会越来越时髦。不过现在，很多开发人员为了让屏幕阅读器开心，仍然坚持只使用一个 &lt;h1&gt; 。 标注导航链接在传统的HTML网站中，可能会把整个侧边栏都放到一个 &lt;div&gt; 中。而在HTML5时代，则应该主要使用两个针对性更强的元素： &lt;aside&gt; 和 &lt;nav&gt; 。 要说 &lt;aside&gt; 元素 ，倒是跟 &lt;header&gt; 元素有点像， &lt;aside&gt; 的含义也有些发散。可以用它来 标注一段与正文相关的内容 ，也可以用它 表示页面中一个完全独立的区块 ——作为页面主要内容的陪衬。 而 &lt;nav&gt; 元素则 用于包装一组链接 。这些链接可以指向当前页面中的主题，也可以指向网站中的其他页面。多数页面中都会 包含多个 &lt;nav&gt; 区块 。但不是所有链接都需要 &lt;nav&gt; 区块——相反， &lt;nav&gt; 通常 用于页面中最大最主要的导航区 。 事实上，如下图所示，至少有两个比较合理的方式来构造侧边栏。 第一种，侧边栏这里的导航又长又复杂(比如都用上了可折叠的菜单形式），只是后面跟着一段小内容。 第二种，侧边栏有多种用途，而没有哪一种用途是主要用途。 以下就是构成侧边栏的标记，包含三个区块： 123456789101112131415161718&lt;aside&gt; &lt;nav&gt; &lt;h2&gt;Articles&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;...&quot;&gt;How The World Could End&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;...&quot;&gt;Would Aliens Enslave or Eradicate Us?&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;section&gt; &lt;h2&gt;About Us&lt;/h2&gt; &lt;p&gt;Apocalypse Today is a world leader in conspiracy theories ...&quot;&lt;/p&gt; &lt;/section&gt; &lt;div&gt; &lt;img src=&quot;ad.jpg&quot; alt=&quot;Luckies cigarette ad: it&apos;s toasted&quot;&gt; &lt;/div&gt;&lt;/aside&gt; 看完这些代码，应该注意到如下关键点。 标题（Articles和About Us）使用的是二级标题。这样，它们就自然位于网站的一级标题之下，从而方便屏幕阅读器无障碍的阅读标题。 链接以 &lt;ul&gt; 和 &lt;li&gt; 元素组成的无序列表来标记。处理一组链接的最佳方式，也是最无障碍的方式，就是使用列表。不过，得通过样式表删除列表项默认的缩进和项目符号。 “About Us”包含在一个 &lt;section&gt; 元素中。&lt;section&gt; 适合任何以标题开头的内容区块。 图片广告放在一个 &lt;div&gt;里。有了 &lt;di&gt; 区块在之间的关系就更加明确了。 复杂的侧边栏可能会以 &lt;header&gt; 和 &lt;footer&gt; 元素作为开头和结尾，也可能包含多个 &lt;nav&gt; 区块——存档文章链接一个、新闻报道连接诶一个、友情链接一个或相关站点链接一个，等等。 下面是侧边栏的样式表： 12345678910aside .NavSidebar &#123; position: absolute; top: 179px; left: 0px; paddding: 5px 15px 0px 15px; width: 203px; min-height: 1500px; background-color: #eee; font-size: small;&#125; 其他样式可以从 http://prosetech.com/html5 下载示例代码。 注意： &lt;nav&gt; 通常会单独出现，有时候也会出现在 &lt;aside&gt; 中。其实，还有经常出现在顶部的 &lt;header&gt; 元素中。 下面是整个页面布局关系： 使用 `&lt;details&gt;` 和 `&lt;summary&gt;` 的折叠框,HTML5新添加了两个语义元素，用于辅助将折叠区块（通过单击区块标题能够显示或隐藏其中的内容）这种行为自动化。具体做法是可以把折叠的区块放在一个 `&lt;details&gt;` 元素中，而把标题放在一个 `&lt;summary&gt;` 元素中。最终结构类似如下这样： 1234&lt;details&gt; &lt;summary&gt;Section #1&lt;/summary&gt; &lt;p&gt;If you can see this content, the section is expanded&lt;/p&gt;&lt;/details&gt; **注意：** 对这两个元素支持的浏览器还很少。 理解区块 区块元素 &lt;section&gt; 是应该最后考虑的语义元素。如果有一个带标题的内容块而其他语义元素都不合适，那么选择 &lt;section&gt; 通常比选择 &lt;div&gt; 更好些。 可以放在 &lt;section&gt; 中的内容有以下几种。 与页面主体内容并列显示的小内容块。 独立性内容，但却不能用文章（ &lt;article&gt;）来描述，比如客户的购物记录或产品清单。 分组内容——例如，新闻站点中的一组文章。 比较长的文档中的一部分。 最后， &lt;section&gt; 元素也会影响网页的纲要。 理解 &lt;footer&gt; &lt;footer&gt;与内容丰富的“胖” &lt;header&gt; 可谓天生一对。在 &lt;header&gt; 中 不仅可以放副标题和作者署名，还可以添加图片、导航区域（使用 &lt;nav&gt; 元素）、以及任何有必要放在页面顶部的内容 。 但HTML5规定，只能在 &lt;footer&gt; 元素中放一些 网站版权信息、作品来源、法律限制以及链接之类的信息 。不能 在 &lt;footer&gt; 里面放太多链接、重要的内容或无关的内容，如广告、社交媒体按钮以及网站部件等。 “胖” 页脚中经常会用到如下所示的一些花哨的技术。 固定位置，这样就可以让页脚始终固定在浏览器窗口底部。 关闭按钮，这样用户看完页脚内容后，单击它们就可以腾出页面空间。 部分透明的背景，这样就可以透过页脚看到内容。 动画，页脚在视图中弹出，或者滑入视图(例如，可以看看在 http://www.nytimes.com 上阅读到一篇文章最后时弹出的相关文章提示框）。 如果站点中包含这种页脚，就要作出选择。比较简单的方法就是无视规定。可是，假如不想违反标准规定，那就调整一下标记。 调整标记的关键在于从多余的内容中提取出标准的页脚来。这些内容看起来还是一个页脚，但在标记中，其他内容都不包含在 &lt;footer&gt; 元素中。以下就是“胖”页脚的实际结构： 123456789&lt;div id=&quot;FatFooter&quot;&gt; &lt;!-- “胖” 页脚的内容 --&gt; &lt;img onclick=&quot;CloseBox()&quot; src=&quot;close_icon.png&quot; class=&quot;CloseButton&quot;&gt; ... &lt;footer&gt; &lt;!-- 标准页脚内容 --&gt; &lt;p&gt;The views expressed on this site do not ... &lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 最外围的 &lt;div&gt; 没有特殊含义，它只负责把多余的内容和标准的页脚内容包装起来。同样，下面给出了应用的一些样式表规则： 123456789#FatFooter &#123; position: fixed; bootom: 0px; height: 145px; width: 100%; background:#ECD672; border-top: thin solid black; font-size: small;&#125; 当然，也可以把页脚中其余内容放在一个 &lt;aside&gt; 元素中，从而清晰地表明其中内容属于一个独立区块，与页面中的其他内容无关。相应的标记结构类似如下所示： 1234567891011&lt;div id=&quot;FatFooter&quot;&gt; &lt;aside&gt; &lt;!-- “胖” 页脚的内容 --&gt; &lt;img onclick=&quot;CloseBox()&quot; src=&quot;close_icon.png&quot; class=&quot;CloseButton&quot;&gt; ... &lt;/aside&gt; &lt;footer&gt; &lt;!-- 标准页脚内容 --&gt; &lt;p&gt;The views expressed on this site do not ... &lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 这里最重要的一点是没有把 &lt;footer&gt; 放到 &lt;aside&gt; 元素中。因为 &lt;footer&gt; 并不属于 &lt;aside&gt;, 而是整个网站的一部分。类似地，如果有一个 &lt;footer&gt; 属于某些内容，那么就应该将这个 &lt;footer&gt; 放在包含相应内容的元素中。 注意： 如果一个元素看起来不适合你标注的内容，那就不要用。当然，，也可以上网去讨论，最好的一个去处就是 http://html5doctor.com 。 标识主要内容&lt;main&gt; 元素用于标识网页中的主要内容。 在启示录网站中，就用 &lt;main&gt; 包装了 &lt;article&gt;： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; &lt;header&gt; ... &lt;/header&gt; &lt;aside&gt; ... &lt;/aside&gt; &lt;main&gt; &lt;article&gt; ... &lt;/article&gt; &lt;/main&gt; &lt;footer&gt; ... &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 不能 把 &lt;main&gt; 元素嵌套到 &lt;article&gt;（或其他任何语义元素）里边。这是因为 &lt;main&gt; 元素的使命就是 包裹页面中的主要内容 ，而非标识文档中某个重要的部分 。换句话说，一个页面中 只能有一个 &lt;main&gt; 元素。 &lt;main&gt; 元素对屏幕阅读器很重要 ，有了它，屏幕阅读器就可以跳过那些次要的内容，比如页眉、导航菜单、广告、和侧边栏，直达内容。这个例子中 &lt;main&gt; 紧挨着 &lt;article&gt; ，这 不 是必须的。在复杂些的页面中，比如包含多个 &lt;article&gt; 元素时， &lt;main&gt; 应该包含所有 &lt;article&gt;,像这样： 123456789101112131415&lt;main&gt; &lt;article&gt; ... &lt;/article&gt; &lt;article&gt; ... &lt;/article&gt; &lt;article&gt; ... &lt;/article&gt; ...&lt;/main&gt; 很明显，每个 &lt;article&gt; 都包含自己的内容，而 &lt;main&gt; 包含所有文章。 总之一句话，就是 &lt;main&gt; 只应该包含主要内容，而不是上下左右的外部细节。 HTML5纲要HTML5定义了一组规则，用于说明如何为网页创建文档纲要（document outline） 。网页纲要能够提高很多便利： 浏览器可以让你从纲要中的一处跳到另一处。 设计工具可以让你通过在纲要视图中拖放来重排区块。 搜索引擎可以使用纲要构建更好的页面预览。 屏幕阅读器通过使用纲要可以引导视力障碍的用户在深度嵌套的区块和子区块中导航。 如何查看纲要目前，还没有浏览器实现HTML5纲要（或者提供一种查看方式）。不过，有几个工具填补了这个空白。 在线HTML纲要生成器 访问 http://gsnedders.html5.org/outliner/ ，告诉纲要生成器你想为那个网页生成纲要。可以通过三种方式提交网页：从本地电脑中上传、提供URL或直接在文本框中粘贴标记。 Chrome扩展 在Chrome浏览器中查看网页纲要是，可以使用h5o插件分析纲要。访问 http://code.google.com/p/h5o 安装插件，然后在网上打开一个HTML5页面看一看。然后浏览器地址栏中会出现一个纲要图标，点击该图标就会显示页面的结构。 Opera扩展 Chrome的h5o扩展也有一个针对Opera开发的版本，安装地址在 http://tinyurl.com/3k3ecdy 。 基本纲要要知道自己网页的纲要是什么样子，可以想象把页面中的所有内容都剥离，只 剩下编号的标题元素（ &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;等）中的文本。然后，根据它们在 标记中位置缩进标题 ，那么嵌套最深的标题在纲要中的缩进也最多。 以最初的还没有应用HTML5元素之前的启示录文章页面的标记为例： 1234567891011121314151617181920&lt;dody&gt; &lt;div class=&quot;Header&quot;&gt; &lt;h1&gt;How World Could End&lt;/h1&gt; ... &lt;/div&gt; ... &lt;h2&gt;Mayan Doomsday&lt;/h2&gt; ... &lt;h2&gt;Robot Takeover&lt;/h2&gt; ... &lt;h2&gt;Unexplained Singularity&lt;/h2&gt; ... &lt;h2&gt;Runaway Climate Change&lt;/h2&gt; ... &lt;h2&gt;Global Epidenmic&lt;/h2&gt; &lt;div class=&quot;Footer&quot;&gt; ... &lt;/div&gt;&lt;/body&gt; 这个简单的结构会生成如下所示的纲要： 1234561.How World Could End 1.Mayan Doomsday 2.Robot Takeover 3.Unexplained Singularity 4.Runaway Climate Change 5.Global Epidenmic 两个级别的标题（ &lt;h1&gt;和&lt;h2&gt;）就创建两级的纲要。这种对应关系与文字处理软件中的纲要功能类似 。比如，可以在微软Word的文档结构图窗格中看到类似的纲要。换个例子，对于下面的标记： 12345&lt;h1&gt;Level-1 Heading&lt;/h1&gt;&lt;h2&gt;Level-2 Heading&lt;/h2&gt;&lt;h2&gt;Level-2 Heading&lt;/h2&gt;&lt;h3&gt;Level-3 Heading&lt;/h3&gt;&lt;h2&gt;Level-2 Heading&lt;/h2&gt; 会生成如下所示的纲要： 123451.一级标题 2.二级标题 2.二级标题 1.三级标题 3.二级标题 最后，纲要算法也很聪明，能够自动忽略跳过的级别 。例如，如果写的标记有点不太规范，从 &lt;h1&gt; 直接就跳到了 &lt;h3&gt;： 12345&lt;h1&gt;Level-1 Heading&lt;/h1&gt;&lt;h2&gt;Level-2 Heading&lt;/h2&gt;&lt;h1&gt;Level-1 Heading&lt;/h1&gt;&lt;h3&gt;Level-3 Heading&lt;/h3&gt;&lt;h2&gt;Level-2 Heading&lt;/h2&gt; 那会得到如下纲要： 123451.一级标题 1.二级标题2.一级标题 1.三级标题 2.二级标题 本来的三级标题与二级标题放在同一层次上了，正是由于这种纲要算法可以消除网页标题级别不完美匹配的问题。 分块元素分块元素（sectioning element）是指那些 在页面中创建新的、嵌套纲要的元素 。这些元素有 &lt;article&gt; 、 &lt;aside&gt; 、 &lt;nav&gt; 和 &lt;section&gt; 。要理解分块元素的作用，可以想象一个包含两个 &lt;article&gt; 元素的页面。因为 &lt;article&gt; 是一个分块元素，所以 这个页面中（至少）有三个纲要：整个页面有一个纲要、每篇文章有一个嵌套的纲要 。 为了进一步弄清楚到底是什么情况，我们来看一看用HTML5改造之后的启示录文章页面： 1234567891011121314151617181920212223242526&lt;dody&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;How World Could End&lt;/h1&gt; ... &lt;/header&gt; &lt;div class=&quot;Content&quot;&gt; ... &lt;h2&gt;Mayan Doomsday&lt;/h2&gt; ... &lt;h2&gt;Robot Takeover&lt;/h2&gt; ... &lt;h2&gt;Unexplained Singularity&lt;/h2&gt; ... &lt;h2&gt;Runaway Climate Change&lt;/h2&gt; ... &lt;h2&gt;Global Epidenmic&lt;/h2&gt; ... &lt;/div&gt; &lt;/article&gt; &lt;footer&gt; ... &lt;/footer&gt;&lt;/body&gt; 将这些标记复制到 http://gsnedders.html5.org/outliner/ 中，可以看到下面的结果： 12345671.Untitled Section 1.How World Could End 1.Mayan Doomsday 2.Robot Takeover 3.Unexplained Singularity 4.Runaway Climate Change 5.Global Epidenmic 这个纲要开始于 一个无标题的区块（Untitled Section），也就是 最上层的 &lt;body&gt; 元素 。然后，&lt;article&gt; 元素开始一个新的嵌套的纲要，其中包含一个 &lt;h1&gt; 元素和几个 &lt;h2&gt; 元素。 有时候，Untitled Section意味着一个错误。尽管 &lt;aside&gt; 和 &lt;nav&gt; 元素可以不带标题，但 &lt;article&gt; 和 &lt;section&gt; 则万万不可。 现在，再看一个复杂一点的例子。比如带有导航侧边栏的启示录站： http://prosetech.com/html5/Chapter%2002/FatFooter.html 。把相应的链接放到纲要生成器中，可以得到如下结果： 123456789101112131.Apocalypse Today 1.Untitled Section 1.Articles 2.About Us 2.How the World Could End 1.Scenarios that spell the end of life as we know 2.Mayan Doomsday 3.Robot Takeover 4.Untitled Section 5.Unexplained Singularity 6.Runaway Climate Change 7.Global Epidemic 3.Untitled Section 这一次，标记包含三个分块元素，因此就有 三个嵌套的纲要：一个属于侧边栏，一个属于文章，另外一个属于页脚。此外，也有 三个无标题区块 ，但都是合乎规范的-第一个是属于侧边栏的 &lt;aside&gt; 元素，第二个是文章中醒目引文的 &lt;aside&gt; 元素，第三个是页脚“胖”页脚部分的 &lt;aside&gt; 元素。 除了分块元素之外，还有一些元素被称作 区块根 （section root）。这些元素不是从已有纲要向下分支，而是 产生自己的纲要，但不会出现在包含页面的主纲要视图中 。比如包含网页内容的 &lt;body&gt; 元素就是一个区块根，这当然合理。但HTML5还把下列元素视为区块根：&lt;blockquote&gt; 、&lt;td&gt;、 &lt;fieldset&gt; 、 &lt;figure&gt; 和 &lt;details&gt; 。 分块元素对复杂页面的意义： 分块对联合（syndication）和聚合（aggregation）都有很大的意义，这两种方式都是从一个页面取得内容，然后注入到另一个页面的技术。 在HTML5中，只要把这篇文章嵌套在一个 &lt;article&gt; 元素中，那么抓过来的内容就会变成它自己嵌套纲要的一部分。而这个纲要可以从任意级别的标题开始，几级标题都无所谓。 最后的结论是： HTML5有一个讲究逻辑的纲要机制，让组合文档变得更容易。在这种纲要机制下，标题的位置变得更加重要，而实际的级别则没有那么重要了。 解决一个纲要问题 有时候也会出现一个问题。比如：你创建了一下页面结构： 1234567891011121314151617181920&lt;body&gt; &lt;article&gt; &lt;h1&gt;Natural Wonders to Visit Before You Die&lt;/h1&gt; ... &lt;h2&gt;In North America&lt;/h2&gt; ... &lt;h3&gt;The Grand Canyon&lt;/h3&gt; ... &lt;h3&gt;Yellowstone National Park&lt;/h3&gt; ... &lt;h2&gt;In the Rest of the World&lt;/h2&gt; ... &lt;aside&gt;...&lt;/aside&gt; ... &lt;h3&gt;Galapagos Islands&lt;/h3&gt; ... &lt;h3&gt;The Swisss Alps&lt;/h3&gt; ... &lt;/article&gt;&lt;/body&gt; 然后，你觉得这个页面的纲要应该是这样的： 1234567891.Untitled Section for the &lt;body&gt; 1.Natural Wonders to Visit Before You Die 1.In North America 1.The Grand Canyon 2.Yellowstone National Park 2.In the Rest of the World 3.Untitled Section for the &lt;aside&gt; 1.Galapagos Islands 2.The Swisss Alps 但实际上纲要确实这样的： 1234567891. Untitled Section for the &lt;body&gt; 1.Natural Wonders to Visit Before You Die 1.In North America 1.The Grand Canyon 2.Yellowstone National Park 2.In the Rest of the World 3.Untitled Section for the &lt;aside&gt; 4.Galapagos Islands 5.The Swisss Alps 不知怎么地， &lt;h2&gt; 后面多出来的那个 &lt;aside&gt; 把后面的两个 &lt;h3&gt; 元素都带了出来，让它们在逻辑上跟 &lt;h2&gt; 元素排在了同一层次上。这显然不是想要的结果。 为解决这个问题，首先需要理解HTML5的纲要机制，即每次遇到编号标题元素（ &lt;h1&gt;、 &lt;h2&gt;、&lt;h3&gt; ，等等），只要该元素 不在某个区块顶部 ，就会为它 自动创建一个新的区块 。 对这个例子来说，纲要机制对一开头的 &lt;h1&gt; 元素什么都不做，因为它位于 &lt;article&gt; 区块的顶部。但纲要算法却会为接下来的 &lt;h2&gt; 和 &lt;h3&gt; 创建新的区块，就好像你写了如下标记一样： 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;article&gt; &lt;h1&gt;Natural Wonders to Visit Before You Die&lt;/h1&gt; ... &lt;section&gt; &lt;h2&gt;In North America&lt;/h2&gt; ... &lt;section&gt; &lt;h3&gt;The Grand Canyon&lt;/h3&gt; ... &lt;/section&gt; &lt;section&gt; &lt;h3&gt;Yellowstone National Park&lt;/h3&gt; ... &lt;/section&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;In the Rest of the World&lt;/h2&gt; ... &lt;/section&gt; &lt;aside&gt;...&lt;/aside&gt; ... &lt;section&gt; &lt;h3&gt;Galapagos Islands&lt;/h3&gt; ... &lt;/section&gt; &lt;section&gt; &lt;h3&gt;The Swisss Alps&lt;/h3&gt; ... &lt;/section&gt; &lt;/article&gt;&lt;/body&gt; 多数情况下，这些自动创建的区块不是问题。事实上，这些区块通常还很有用，因为这样可以确保为正确编号的标题仍然能排在正确的纲要级别上。但这样做的代价就是偶尔会出现小差错，就像我们这个例子。 而这个问题的原因就是因为 碰到了 &lt;aside&gt; 元素，而关闭了为 &lt;h2&gt; 创建的子区块 。 为了纠正这个问题，需要通过自己定义区块和子区块，来代替纲要机制的自动创建行为。在标记中 明确为该 &lt;h2&gt; 定义一个区块即可解决问题： 12345678910111213141516171819202122&lt;body&gt; &lt;article&gt; &lt;h1&gt;Natural Wonders to Visit Before You Die&lt;/h1&gt; ... &lt;h2&gt;In North America&lt;/h2&gt; ... &lt;h3&gt;The Grand Canyon&lt;/h3&gt; ... &lt;h3&gt;Yellowstone National Park&lt;/h3&gt; ... &lt;section&gt; &lt;h2&gt;In the Rest of the World&lt;/h2&gt; ... &lt;aside&gt;...&lt;/aside&gt; ... &lt;h3&gt;Galapagos Islands&lt;/h3&gt; ... &lt;h3&gt;The Swisss Alps&lt;/h3&gt; ... &lt;/section&gt; &lt;/article&gt;&lt;/body&gt; 这样，纲要算法就不必再为第二个 &lt;h2&gt; 自动创建区块了，因而也就避免了在它发现 &lt;aside&gt; 时去关闭该区块的风险。 修改后的纲要： 1234567891.Untitled Section for the &lt;body&gt; 1.Natural Wonders to Visit Before You Die 1.In North America 1.The Grand Canyon 2.Yellowstone National Park 2.In the Rest of the World 1.Untitled Section for the &lt;aside&gt; 2.Galapagos Islands 3.The Swisss Alps 另一个办法是用 &lt;div&gt; 元素替换 &lt;aside&gt; 。因为 &lt;div&gt; 不是分块元素，因此不会导致前面的区块意外关闭。 假如不小心在 两个不同级别的标题之间插入了一个分块元素 ，那就要检查一下纲要，看这样干是不是说得过去。 最好是把HTML5的纲要机制当成一种 质量保障工具 ，它有时候可以帮上你的忙。通过在纲要生成器中查看自己的标记，有可能 发现其他问题导致的错误，而且能够 确保你正确地使用语义元素 。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Angular 2开发实战》学习笔记-Angular 2介绍]]></title>
    <url>%2F2018%2F07%2F20%2FAngular-2-introduce%2F</url>
    <content type="text"><![CDATA[Angular 2介绍 Angular 2（以下简称Angular）是一个由Google维护的开源JavaScript框架，它完全重写了备受欢迎的AngularJs（Angular 1.x版本）。 JavaScript框架和库框架能够让你完全控制自己应用程序中的架构、设计模式和代码风格。 Angular是用于开发Web应用程序的众多框架之一。 框架为代码提供了一个结构，并强制按照特定方式编写代码。库通常会提供大量的组件和API接口，它们可以在任何代码中被调用。换句话说，与库相比，框架对应用程序的设计更有用。 重量级框架重量级框架包含了开发一个Web应用程序需要的所有东西。这将为你的代码强加一个结构，并配套UI组件和工具以便开发和部署应用程序。Ext JS是一个由Sencha创建和维护的全能型框架。它配备了一套优秀的UI框架，其中包括一个高级的数据表格和图表控件，这对于开发后台企业级应用程序是至关重要的。如果一个应用程序采用Ext JS框架，那么它的大小不会小于1MB。Ext JS是入侵式框架，一旦采用，并不能很容易切换到其他框架。 Sencha同时推出了Sencha Touch框架，主要用于开发面向移动设备的Web应用程序。 轻量级框架请量级框架为Web应用程序添加结构，提供一种在不同视图之间切换的导航方式，通常会把应用程序拆分成不同的层，实现模型-视图-控制器（Model-View-Controller,MVC）设计模式。还有一类轻量级框架，专门用于测试用JavaScript开发的应用程序。 Angular是用于开发Web应用程序的开源框架。使用Angular更容易创建那些能够被插入到HTML文档中并实现了应用逻辑的自定义组件。Angular大量地使用数据绑定，包含该一个依赖注入模块，支持模块化，并提供路由机制。Angular并不像Angular那样基于MVC的，整个框架并不包括UI组件。 Ember.js是用于开发Web应用程序的开源框架。它包括路由机制，支持双向数据绑定。Ember.js使用大量的代码约定，从而提高了软件开发人员的生成效率。 Jasmine是一个JavaScript开源测试框架。Jasmine不需要任何一个Dom对象，它包括一系列方法用来测试应用程序中某些行为是否符合预期。Jasmine经常与Karma一起使用，Karma是一个测试运行器，能运行在不同的浏览器中。 库jQuery是流行的JavaScript。它的用法简单，不需要大幅改变自己的Web编程方式。jQuery用于查找和操作Dom元素，处理浏览器事件以及浏览器兼容性问题。jQuery是一个可扩展库，全世界的开发者为其开发了数以千计的插件。如果找不到符合自己要求的插件，还可以自行开发一个。 Bootstrap是一个由Twitter开发的开源UI组件库。使用响应式Web设计原则构建组件。 Google基于一系列设计原则开发了一套UI组件库，叫做Material Design,它可能会成为Bootstrap替代品。Material Design对跨屏幕展示做了优化，并搭配了一套漂亮的UI组件。 React是一个由Facebook开发的开源用户界面库。React作为MVC模式中的V(View)层，是非侵入式的，可以与其他任何库和框架结合使用。React创建自有的虚拟DOM对象，最大限度地减少对浏览器DOM的访问，从而达到更好的性能。对于内容的渲染，React引入了JSX格式，这是一个对JavaScript的扩展，看起来像是XML。React建议使用JSX，但这并不是必需的。 Polymer是一个由Google开放的基于Web Components标准构建自定义组件库。它搭配了一套非常漂亮的可定制的UI组件，可以作为标签在HTML页面中被引用。Pilymer还为应用程序提供离线工作模块以及使用GoogleAPI的组件（如日历，地图等）。 RxJS是一组使用了可观察集合并组合异步请求和基于事件编程的库。它允许应用程序处理异步数据流。使用RxJS，数据流会被表示为一个可观察队列。RxJS可以单独使用，也可以与其他JavaScript框架结合使用。 查看顶级网站使用了什么JavaScript框架和库，可以访问“JavaScript开发网站的使用的使用统计情况”页面，网址为 http://trends.builtwith.com/javascript 。 什么是Node.jsNode.js（或者称为Node）不仅仅是一个框架或库，它还是一个运行时环境。 Node.js框架可以用于开发浏览器之外运行的JavaScript程序。可以使用JavaScript或TypeScript开发Web应用程序的服务器端程序；Google为Chrome浏览器开发了一款高性能V8 JavaScript引擎，可用于运行使用Node.jsAPI编写的代码。Node.js包括一个API，具有操作文件系统、访问数据库、监听HTTP请求的功能。 JavaScript社区成员们已经构建了大量的工具用于开发Web应用程序，借助于Node的JavaScript引擎，可以在命令行中运行这些工具。 AngularJS高级概述 Angular的故事 AngularJS流行原因 AngularJS具有利用指令概念创建自定义HTML标签和属性的机制，允许根据自己应哟程序的需要扩展HTML标签。 AngularJS是入侵式的，但不会产生过多的干扰。可以把ng-app属性添加到任何一个 &lt;div&gt; 标签上，只有这个 &lt;div&gt; 标签里面的内容会被影响，页面中的其他部分仍然是纯粹的HTML和JavaScript。 AngularJS令你能够轻松地把数据绑定到视图上，更改数据将会触发相应视图元素自动更新，反之亦然。 AngularJS配套有一个可配置的路由，使你能够对应用程序的组件与URL模式进行映射，当URL变化时会导致页面对应的视图发生变化。 在控制器中定义应用程序的数据流，数据流是JavaScript对象类型，其中包括属性和方法。 AngularJS应用程序使用有层级关系的作用域来存储由控制器和视图分享的数据。 AngularJS包含了一个依赖注入模块，使你能够以解耦方式开发应用程序。 与jQuery简化DOM操作相反，AngularJS允许开发者以MVC模式设计应用程序，从而把逻辑从UI层分离出来。下图描述了一个用于处理产品的AngularJS应用程序的工作流示例。 AngularJS应用程序架构示例 一旦模式中保持的数据发生变化，AngularJS就会自动更新视图。如果用户修改了视图中输入框里的数据，那么UI变化也会传递给模型。这个双向更新机制被称为双向数据绑定。如下图所示。 双向绑定意味着其中一个会自动更新另一个，因此在AngularJS中，模型和视图是紧密绑定在一起的。 双向绑定 模式数据保存在一个特定$scope对象的上下文中，AngularJS作用域是一个有层级结构的对象。$rootScope是为整个应用程序创建的。控制器和指令（自定义组件）有自己的$scope对象。 可以通过创建和加载模块对象来实现模块化。当一个特定模块依赖于其他对象（如控制器、模块或服务）时，Angular的注入机制将会创建这些对象的实例。下面代码片段展示了AngularJS将对象注入其他对象的一种方法： AngularJS经常被用来创建单页面应用程序，用户操作或服务器返回数据只会更新页面中的指定部分（子视图）。 通过配置ng-route路由组件来设置AngularJS中视图之间的导航。可以根据URL模式指定多个.when选项将应用程序导航到相应的视图。下面代码示例将会演示路由的使用。 AngularJS支持深度链接，当把页面加入到书签中时，不仅可以收藏整个网页，还可以收藏页面中的某个特定状态。 Angular高级概述与AngularJS相比，Angular在很多方面的表现都会更好。Angular更容易学习，应用程序的框架的结构也被简化了，并且代码更容易书写。 简化代码Angular应用程序支持ECMAScript 6(ES6)中的标准模块、异步模块定义（Asynchronous Module Definition ,AMD）以及CommonJS格式。通常一个模块一个文件。使用通用的模块加载器SystemJS，并添加import语句。 应用程序的着陆页面HTML文件中包含了Angular模块以及它们的依赖。应用程序的代码通过加载自己的根模块进行引导。所有必需的组件和服务将会根据模块中声明和导入语句进行加载。 每个组件的HTML片段都可以在组件内部（template属性）或者通过templateURL属性从组件引用的文件中内联得到。 组件是Angular新架构的核心内容。如下图展示了一个由4个组件和2个服务组成的示例Angular应用程序的示意图。所有这些都会被封装到一个模块中。 声明一个组件的简单方式就是用TypeScript写一个类(当然，也可以使用ES5、ES6或Dart)。 如果为TypeScript的类前缀添加了一个@NgModule元数据注解，那么表示它是一个模块。 如果为类前缀添加了一个@Component元数据注解，那么表示它是一个组件。@Component注解（又被称为装饰器）包含了template属性，声明了一个用于浏览器渲染HTML片段。元数据注解允许在设计阶段修改组件的属性。HTML模板可能包含被双大括号包围的数据绑定表达式。事件绑定也在@Component注解的template属性中定义，并且在类中作为方法被实现。 另一个元数据注解是@Injectable,它表示创建的组件会被DI模块处理。 @Component注解还包含了selector属性，用来声明能够在HTML文档中使用的自定义标签。当Angular发现一个匹配selector属性值的HTML元素时，就会知道是哪个组件实现了这个元素。 12345&lt;body&gt; &lt;auction-application&gt; &lt;search-product [productID] = &quot;123&quot;&gt;&lt;/search-product&gt; &lt;/auction-aplication&gt;&lt;/body&gt; 父组件通过为子组件绑定输入属性来向其传递数据（注意上面代码中的方括号），而子元素通过经过它们的输出属性触发事件来实现与父组件的通信。 下面的代码显示了一个搜索组件SearchComponent。它的selector属性被声明为search-product，因此可以在HTML文档中通过 &lt;search-product&gt; 标签来引用它：、 12345678910111213141516171819202122@Component(&#123; selector: &apos;search-product&apos;, template: `&lt;from&gt; &lt;div&gt; &lt;input id=&quot;prodToFind&quot; #prod&gt; &lt;button (click)=&quot;findProduct(prod, value)&quot;&gt;Find Product&lt;/button&gt; Product name: &#123;&#123;product.name&#125;&#125; &lt;/div&gt; &lt;/from&gt; `&#125;)class SearchComponent &#123; @Input( ) productID: number; product: Product; findProduct(productName: string) &#123; // Implementation of the click hander goes here &#125; // Other code can go here&#125; 下图为组件内部工作原理。 组件从服务中获取数据并用于渲染，这些数据用类的方式来定义。在TypeScript中Product类可以是下面的结构： 123456789class Product &#123; id：number; name: string; description: string; bid: number; price:number; // construct and other methods go here&#125; 注意，TypeScript允许在声明类变量的同时指定类型。为让UI组件SearchComponent掌握自己的数据，可以声明一个类变量，如product: 123456789@Component (&#123; /* code omitted for brevity */ &#125;)class SearchComponent &#123; product: Product; findProduct(productID) &#123; // The implementation of the click handler // for the Find components button goes here &#125;&#125; 如果SearchComponent想要返回多个产品，可以声明一个数组来存储产品： 1products: Array&lt;Product&gt;; 在上面代码中 &lt;Product&gt; 使用了泛型符号，表示TypeScript编译器中只有Product类型的对象被允许存储在这个数组中。 Angular不是一个MVC框架，因此你的应用程序不会有独立的控制器（MVC模式中的C(Controller层））。组件和被注入的服务（如果需要的话）囊括了所有必需的代码。在我们的例子中，SearchProduct类除了包含HTML视图中UI组件的代码，还包含了与控制器有关的代码。 为了彻底地分离TypeScript代码和HTML片段，在@Component注解中不建议使用template属性，而推荐使用单独的文件存储HTML片段，并使用templaateUrl属性代替template属性引用该文件。 不需要像AngularJS一样处理多层级的scrope对象，因为Angular是基于组件的，属性创建在组件的this.对象上，this对象也在组件的作用域内。 创建对象实例的一种方法是使用new操作符。依赖注入（Dependency Injection, DI）是一种设计模式，能够倒置创建依赖对象的过程。不需要显式地创建对象实例（比如使用new关键字），框架将会创建这些实例对象并把它们注入到代码中。Angualr自带了一个DI模块。 在AngularJS中，有几种注册依赖的方式，它们经常会令开发者感到困惑。在Angular中，只能通过组件的构造函数向其注入依赖。下面的TypeScript代码片段显示了如何将ProductService组件注入到SearchComponent中。只需要指定一个provider,并把构造函数的参数声明为该provider的类型。 123456789101112@Component(&#123; selector: &apos;search-product&apos;, providers: [ProductService], template: `&lt;div&gt;...&lt;/div&gt;&#125;) class SearchComponent &#123; products: Array&lt;Product&gt; = []; constructor(productService: ProductService) &#123; this.products = productServive.getProducts(); &#125;&#125; 上面的代码中并没有使用new操作符。Angular将会实例化一个ProductService对象，并在SearchComponent中提供这个对象的引用。 总而言之，Angular比AngularJS更简单，原因如下： 应用程序的每个构建块(building block)都是一个组件，包括功能封装性良好的视图、控制器和自动生成的属性变更检测器。 组件可以编程为注解类。 不需要处理多层级作用域。 依赖的组件通过组件的构造函数进行注入。 双向绑定功能是默认关闭的。 变更检测机制被重写了，性能更好。 大多数的企业级软件开发人员都是Java、C#和C++程序员，对他们来说，Angular的概念很容易理解。 性能提升Repaint Rate Challenge网站（ http://mathieuancelin.github.io/js-repaint-perfs ）对比了各种框架的渲染性能。 渲染性能的提升主要得益Angular框架内部的重新设计。渲染组件与应用程序的API被解耦到两个层面，使你能够在独立的Web工作线程中允许非UI相关代码。除了同时可以运行不同层面的代码之外，Web浏览器也可能会为这些线程分配不同的CPU内核。有关新渲染框架更多信息可以在Google Docs文档“Angular 2 Rendering Architecture”中找到，网址为 http://mng.bz/K403 。 把渲染层解耦出来还有一个重要的好处：可以根据不同的设备选择不同的渲染引擎。每个组件都包括@Component注解，其中包含了一个定义组件外观的HTML模板。 如果创建一个 &lt;stock=price&gt; 组件以便在页面中显示股票价格，那么UI部分的代码如下所示： 1234567@Component(&#123; selectoe: &apos;stock-price&apos;, template; &apos;&lt;div&gt;The price of an IBM chare is $165.50&lt;/div&gt;&apos;&#125;)class StockPriceComponent &#123; ...&#125; Angular渲染引擎是一个独立的模块，它允许第三方供应商使用非浏览器依赖的平台作为渲染引擎，来替换默认的DOM渲染引擎。比如，可以在不同设备之间重用TypeScript代码，利用第三方UI渲染引擎在移动设备上渲染原生的组件。组件中TypeScript代码将会被保留，但是@Component装饰器的template属性中的内容可能会变更为XML或其他用于渲染原生组件的开发语言。 在NativeScript框架中已经实现了上述Angular 2渲染引擎。NativeScript框架在JavaScript和原生iOS UI组件或Android UI组件之间提供了一座桥梁，可以重用组件的代码，而仅仅是在模板中把HTML替换为XML。 另一种自定义UI渲染引擎允许Angular与React Native搭配使用，这是为iOS和Android创建原生（非混合）UI的一条途径。 Angular引入了全新的性能更强的变更检测机制，这也为Angular带来了性能上的提升。Angular不使用自动的双向绑定，需要手动开启。单向数据绑定简化了大量相互依赖的组件间变更检测的流程。现在可以把一个组件排除在变更检测工作流之外，当检测到其他组件发生变更时，这个组件不会被检查。 注意： 如果要使用AngularJS,可以通过使用ng-forward(参见 http://github.com/ngUpgraders/ng-forward ）来编写Angular风格的代码。另一个方法是使用ngUpgrade(参见 http://angular.io/docs/ts/latest/guide/upgrade.html ）,它能够令Angular和AngularJS在一个应用程序中共存，然后逐步切换到最新的版本框架，但这种方法会造成应用程序的体积变大。 Angular开发者工具 JavaScript是公认的Web应用程序前端开发语言。ES6是脚本语言的最新标准化规范，而JavaScript是其最流行的实现。 TypeScript是JavaScript的超集，令开发人员更加高效。TypeScript支持ES6的大多数功能，还额外提供了类型、接口、元数据注解等特性。 TypeScript代码分析器使用type-definition文件来处理那些没有使用TypeScript开发的代码。DefinitelyType是一个流行的type-definition文件集合，描述了数百个JavaScript库和框架的API。使用type-definition文件可以让IDE具备上下文相关帮助和高亮显示错误提示的功能。可以从npmjs.org@types组织安装type-definition文件。 因为目前大多数浏览器仅支持ECMSScript 5(ES5）语法，因此如果需要使用TypeScript或ES6编写代码，那么需要在部署时对代码执行转换。Angular开发者可能会用到Babel、Traceur和TypeScript编译器来进行代码转换。 SystemJs是一个通用模块加载器，能够加载ES6、AMD和CommonJs标准的模块。 Angular CLI是一个代码生成器，允许生成一个全新的Angular项目，包括组件、服务和路由，此外还有部署应用程序的构建工具。 Node.js是一个建立在Chrome的JavaScript引擎上的平台。Node包括一个框架和一个运行时环境，用于在浏览器之外允许JavaScript代码。 npm是一个包管理器，可以让你下载工具、JavaScript库和框架。npm中存储了数以千计的包，可以用它安装所有的包，从开发者工具（比如TypeScript编译器）到安装应用程序依赖。npm还可以运行脚本，可以用npm启动HTTP服务器以及自动化构建。 Bower曾经是一个非常流行的包管理器，用来解决应用程序依赖之间的关系（比如Angular 2和jQuery）。由于可以从npm下载到一切，因此现在Bower已不再使用。 jspm同样是另一个包管理器。现代Web应用程序是由可加载模块组成的，jspm整合了SystemJS，这使得加载模块变得轻而易举。 Grunt是一个任务运行器。开发代码和部署代码之间需要执行很多步骤，这些步骤必须自动化完成。可能需要转换TypeScript或ES6代码为兼容性更好的ES5语法，压缩代码、图片和CSS。可能还需要检查代码质量，以及对应用程序做单元测试。使用Grunt,可以将所有任务及其依赖关系配置到一个JSON文件中，这样整个处理过程将是100%自动完成的。 Gulp是另外一个任务运行器。与Grunt一样，Gulp也可以自动化执行任务。但不同的是，Gulp并不在JSON中配置整个处理过程，而是用JavaScript编码来实现。这就允许在必要时可以调试整个处理过程。 JSLint和ESLint是代码分析工具，用来查找JavaScript代码或JSON格式的文档中是否存在问题。它们是代码质量检查工具。通过JSLint和ESLint运行JavaScript程序会产生若干警告信息，提示如何改善程序的代码质量。 TSLint是TypeScript的代码质量检查工具。它具有可扩展的检查规则集合，以及强制推荐代码风格和模式。 压缩工具是文件的体积更小，比如UglifyJS。在JavaScript中，它们会删除代码注解和换行符，缩短变量名称。压缩还可以用于HTML、CSS和图片文件。 打包程序将多个文件和它们的依赖封装到一个独立的文件中，比如Webpack。 因为JavaScript的语法非常宽松，应用程序需要测试，所以需要选择一个测试框架。比如，使用Jasmine测试框架和Karma测试运行器。 现代的IDE和文本编辑器，比如WebStrom、Visual Studio、 Visual Studio Code、Sublime Text、Atom等都支持JavaScript和TypeScript。 所有主流的Web浏览器都带有开发者工具，可以在浏览器内部调试自己的程序。即使程序是用TypeScript所写并被部署到JavaScript中，也仍然可以用source maps；调试原始代码。 Web应用程序应该可以在移动设备上使用，应该选择支持响应式设计的UI组件，确保UI布局会根据用户设备的屏幕尺寸自动适应。 开发Angular应用程序比开发AngularJS应用程序容易，但是最初的开发环境一定要设置正确，这样才能真正享受开发过程。 如何使用Angular 在线拍卖示例介绍 开发Angular应用程序总结起来就是创建组件和组合组件。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Angular 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Angular 2 开发实战》学习笔记-前言]]></title>
    <url>%2F2018%2F07%2F20%2FAngular2%2F</url>
    <content type="text"><![CDATA[译者序 与Angular 1.x 相比，Angular 2继承了前者的整合性，延续了“All in One” 的设计理念，并在变更检测性能、指令简化、以及移动前端开发等方面做了很大改进，开发语言层面全面拥抱了TypeScript。 需要注意的是，Angualr 2 并不兼容Angular 1.x。 序言 Angular 2和TypeSript是用于Web应用开发的正确工具，主要原因有下面这些： 组UI和应用程序逻辑分隔干净 渲染UI的代码和实现业务逻辑的代码之间得以干净地分隔。UI不是必须要用HTML渲染，并且已经又支持渲染iOS和Android原生UI的产品了。 模块化 又用于应用程序模块化的简单机制，支持模块的延迟加载。 导航支持 路由支持单页面应用程序中复杂的导航场景。 低耦合 依赖注入提供了一种在组件和服务之间实现低耦合的干净方式。绑定和事件允许创建可复用且低耦合的组件。 组件生命周期 每个组件都经过一个明确定义的生命周期，并且有用于拦截重要的组件事件的钩子，供应用程序开发者使用。 变更检测 自动（快速）的更改检测机制手动强制UI更新，同时也提供了一种微调此过程的方法。 没有回调地狱 Anugular 2 附带了RxJs库，它允许安排基于订阅的异步数据处理，从而消除回调地狱。 表单及验证 设计良好的表单及自定义验证支持。可以通过验证支持。可以通过编程或为目标中的from元素添加指令的方式创建表单。 测试 对单元测试和端到端测试支持良好，并且可以将测试集成到自动化的构建过程中。 Webpack打包及优化 使用Webpack（及其各种插件）打包并优化代码，可将部署的应用程序小型化。 工具 工具支持和Java及.NET平台一样好。TypeScript代码分析器会在输入时警告出现的错误，脚手架和部署工具（Angualr CLI）会帮你编写样板代码和配置脚本。 代码简洁 使用TypeScript类和皆接口，使代码更简洁并易于阅读和编写。 编译器 TypeScript会生成人类可以阅读的JavaScript。TypeScript代码可以编译成ES3、ES5和ES6版本的JavaScript。特定于Angualr代码的（不要与TypeScript编译器混淆）提前（Aot, Ahead-of-time）编译，消除了将编译器与应用程序打包在一起的必要性，这进一步降低了框架的开销。 服务器渲染 在线下的一个构建步骤中，Angular Universal会将应用程序转换成HTML,这可以用于服务器的渲染，从而大大提高搜索引擎索引和SEO。 现代UI组件 一个现代风格的UI库（Angular Material 2）正处在开发过程中。 前言 Angular 2应用程序能够支持使用两种JavaScript语法（ES5和ES6）进行开发，同样也支持使用Dart和TypeScript进行开发。框架本身使用TypeScript开发。 TypeScript是JavaScript的一个超集。 本书示例源代码可以从网站 https://www.manning.com/books/angular-2-development-with-typescript 下载。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Angular 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 安装使用MySQL]]></title>
    <url>%2F2018%2F07%2F20%2FUbuntu16-04-MySQL%2F</url>
    <content type="text"><![CDATA[安装Mysql数据库 安装前先更新软件包列表 1sudo apt update 删除Mysql 12sudo apt-get remove mysql-*dpkg -l |grep ^rc|awk &apos;&#123;print $2&#125;&apos; |sudo xargs dpkg -P 安装 1sudo apt-get install mysql-client mysql-server libmysqlclient-dev 因为Ubuntu是16.04的，所以会默认安装5.7版本。 安装完成后查看Mysql状态 1sudo service mysql status 启动服务 1sudo service mysql start 解决启动报错问题 12345ls -ld /var/run/mysqld/mkdir -p /var/run/mysqldls -ld /var/run/mysqld/sudo chown mysql.mysql /var/run/mysqld/sudo /etc/init.d/mysql start 登录Mysql数据库 1mysql -u root -p 重启Mysql 1/etc/init.d/mysql restart 数据库操作 登录Mysql数据库1mysql -u root -p -u 表示选择登陆的用户名， -p 表示登陆的用户密码，上面命令输入之后会提示输入密码，此时输入密码就可以登录到mysql。 查看数据库1show databases; 管理的数据库1use dbname; 查看数据库表1show tables; 查看表结构1desc tablename; 删除表1drop table [if exists] tablename; 退出1exit; / quit; 参考教程ubuntu16.04彻底卸载mysql并且重新安装mysqluUbuntu 16.04 安装使用MySQLUbuntu16.04下安装MySQL及简单操作Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’Linux mysql停止失败的解决办法 Stopping MySQL database server mysqld]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>Ubuntu </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《HTML5秘籍》学习笔记-HTML5简介]]></title>
    <url>%2F2018%2F07%2F16%2FHTML5-brief%2F</url>
    <content type="text"><![CDATA[HTML5简介 HTML5的故事 HTML5三个主要原理 不破坏Web标准不该引入导致已有网页无法工作的改变。 HTML5规范包括两部分。第一部分，面向Web开人员，要求摒弃过去的那些坏习惯和被摒弃的元素。第二部分,针对的是浏览器开发商，它们需要支持HTML中存在的一切，以做到向后兼容。 修补牛蹄子路牛蹄子路指的是高低不平但使用频率很高的路，通过它可以从一个地方到另一个地方。 HTML5标准化了这些非官方（但广泛应用）的技术。 实用至上改变应该以实用为目的。改变越多，代价也就越大。 HTML标准加入官方的支持，让功能在所有浏览器中都能一致的工作。 让网站不依赖插件也能够提供视频、丰富的交互功能以及各种漂亮的效果。 HTML5标记初体验 最简单的H5文档123&lt;!DOCTYPE html&gt;&lt;title&gt;A Tiny HTML Document&lt;/title&gt;&lt;p&gt;Let&apos;s rock the browser, HTML5 style.&lt;/p&gt; 开始是HTML5的文档声明，然后是页面标题和一些内容。在这里，内容是包含在一个段落中的文本。 当然，HTML5允许没有关闭的标签（浏览器知道在文档后面关闭所有没有关闭的标签），HTML5标准也允许你省略 &lt;title&gt; 元素。 瘦骨嶙峋的H5文档1234567&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;A Tiny HTML Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Let&apos;s rock the browser, HTML5 style.&lt;/p&gt;&lt;/body&gt; 使用和来将关于页面的信息（头部）与页面的实际内容（主体）分开。在为页面添加脚本、样式表和元数据的时候，这种结构特别实用。 真正实用的H5文档 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;A Tiny HTML Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Let&apos;s rock the browser, HTML5 style.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 最后，选择用元素来封装整个文档（不包含文档类型声明那一行）。 注意： 使不使用 &lt;html&gt; 、 &lt;head&gt; 、 &lt;body&gt; 元素只代表一种风格。事实上，浏览器会自动假设页面中已经包含了这些元素。 HTML5文档类型每个HTML5文档的第一行都必须是一个特定的文档类型声明。这个文档类型声明用于宣告后面的文档标记遵循那个标准。 文档标记遵循HTML5标准： 1&lt;!DOCTYPE html&gt; XHTML1.0严格型的文档类型声明： 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; HTML5的文档声明不包括官方规范的版本号。事实上，这个声明只表示当前页面是HTML页面。这与HTML5是一门活着的语言的远见是分不开的。换句话说，只要有新功能添加到HTML语言中，你在页面中都可以使用它们，而不必为此修改文档类型声明。 要求保留文档类型声明，主要是由于历史原因。如果没有文档类型声明，那大多数浏览器将转换到一种混杂模式（quirk mode）。 HTML5文档类型声明是最短的有效文档类型声明，因此它总能触发标准模式。 虽然文档类型声明主要目的是告诉浏览器去做什么，但其他代理也可以检测该声明。比如： HTML5验证器、搜索引擎、设计工具，还有人-在想知道你当初在页面中想写什么样的标记时。 字符编码 字符编码是一种标准，计算机根据它把文本转换成保存在文档中的字节序列（或者在打开文件时将字节序列转换成文本形式）。由于历史原因，现在的编码标准有很多种。 但实际上英文网站今天都使用一种叫UTF-8的编码，这种编码简洁、转换速度快，而且支持任何你想要的非英文字符。 一般来说，经过配置的Web服务器会告诉浏览器它提供的网页采用了什么编码。 在HTML5文档中添加字符编码信息，只要在 &lt;head&gt; 区块的最开始处（如果没有添加 &lt;head&gt; 元素，则是紧跟在文档类型声明之后）添加相应的 &lt;meta&gt; 元素。 1234&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;A Tiny HTML Document/title&gt;&lt;/head&gt; 页面语言 指明网页中使用的自然语言是一种好习惯。有时候对搜索引擎可以通过它来筛选结果。 给内容指定语言，可以在任何元素上使用lang属性，并为该属性指定相应语言的语言代码（比如， en表示英语）。各国语言代码可以在这里查到：http://people.w3.org/tishida/utils/subtags/ 。 为整个页面添加语言说明的最简单方式，就是为 &lt;html&gt; 元素指定lang属性： 1&lt;html lang=&quot;en&quot;&gt; 如果页面中包含多种语言的文本，可以为文本中不同的区块指定lang属性，指定 该区块中文本的语言。 添加样式表 指定想要使用的CSS样式表时，需要在HTML5文档的 &lt;head&gt; 区块中添加 &lt;link&gt; 元素， 例如： 12345&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;A Tiny HTML Document/title&gt; &lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt; CSS是网页中唯一可用的样式表语言，所以网页中过去要求的type=”text/css”属性就没有必要了。 添加JavaScript 下面就是一个引入外部JavaScript代码的文件示例： 12345&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;A Tiny HTML Document/title&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 没有必要加上language=”JavaScript”属性，浏览器会假定你想要使用JavaScript，除非你想使用其他脚本语言。 即使是引用外部JavaScript文件，也不能忘了后面的 &lt;/script&gt; 标签。假如你不写这个标签或者使用空元素语法想缩短标记，页面将不会执行加载脚本。 如果你在Inernet Explorer中花大量的时间测试包含JavaScript页面，还应该在 &lt;head&gt; 区块中包含一行特殊的注释，叫做Web标志（mark of the web）；这行注释要放在指定字符编码的元数据便签后面，如下所示： 123456&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- saved from url=(0014)about:internet --&gt; &lt;title&gt;A Tiny HTML Document/title&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 这条注释告诉Internet Explorer将页面视为从远程网站上下载下来的。否则，IE会切换到一种特殊的锁定模式，弹出一条安全警告，在你点了“允许阻止内容”按钮后才会执行JavaScript代码。 其他浏览器都会忽略这个“Web标志”注释，对远程站点和本地文件使用相同的安全设置。 最终的HTML5文档 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;A Tiny HTML Document&lt;/title&gt; &lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Let&apos;s rock the browser, HTML5 style.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 虽然这不再是一个最短的HTML5文档，但以它为基础可以构建出任何网页。 HTML5语法 放松的规则HTML5不区分大小写，因此类似下面这样的标记是没有问题的： 1&lt;P&gt;Capital and lowercase letters &lt;EM&gt; don&apos;t metter&lt;/eM&gt; in tag names.&lt;/p&gt; HTML5还允许省略关闭空元素（void element）的斜杆；所谓空元素，就是不会嵌套内容的元素，如&lt;img&gt;(图像）、 &lt;br&gt;(换行）或 &lt;hr&gt;(水平线）。以下是三中添加换行的等价方式： 1234I cannot &lt;br /&gt;move backward&lt;br&gt;or forward.&lt;br/&gt;I am caught HTML5也修改了属性语法规则。属性值中只要不包含受限的字符（比如&gt;、=或空格），就可以不加引号。下面这个 &lt;img&gt; 元素就利用了这点： 1&lt;img alt=&quot;Horsehead Nebula&quot; src=Horsehead01.jpg&gt; 只有属性名没有属性值也可以。虽然XHTML要求必须采用如下冗余的语法将复选框设置为选中状态： 1&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; 但现在可以只包含属性名，回到HTML4.01时代的传统短语法形式： 1&lt;input type=&quot;checkbox&quot; checked&gt; 如果能做到如下几点（也是尽管不是必须遵循的）， 基本上就可以算作良好的HTML5风格了。 包含可选的 &lt;html&gt;、 &lt;body&gt; 和 &lt;head&gt;元素。要给页面定义自然语言&lt;html&gt;是最理想的地方；而 &lt;body&gt; 和 &lt;head&gt; 有助于将页面内容与其他页面信息分离。 标签全部小写（如用 &lt;p&gt; 而非 &lt;P&gt;）。虽然不是必须这么做，但是这种形式很常见，输入起来要轻松容易很多，而且并不会让人触目惊心。 为属性值加引号。加引号是为了防止不经意间犯错。要知道，没有引号的话，一个无效字符就能破坏整个页面。 不加斜杆、使用短语法属性。 HTML5验证以下是HTML5验证器会关注的一些可能的问题： 缺少必要元素（例如 &lt;title&gt; 元素）； 有开始标签但没有结束标签； 标签嵌套又错误； 不包含必要属性的标签（例如没有src属性的 &lt;img&gt; 元素）； 元素或内容放错了地方（例如把文本直接放在了&lt;head&gt; 区块中）。 可以使用在线验证工具，下面是W3C标准组织提供的流行的验证器，在浏览器中，打开http://validator.w3.org XHTML的回归XHTML 强制要求的规则要么仍具有指导意义（例如，元素要正确嵌套），要么仍然是一种得到支持的可选约定（例如，空元素可以包含结束的斜杆）。 将一个HTML5文档转换成XHTMl5文档（器本质是给HTML5加上了XML的限制），必须在 &lt;html&gt; 元素中明确添加XHTML命名空间、关闭每个元素、所有标签都要小写等。下面就是一个XHTML5文档示例： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;htttp://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;A Tiny HTML Document&lt;/title&gt; &lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Let&apos;s rock the browser, HTML5 style.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 可以使用 http://validator.w3.org/nu 进行验证。 HTML5元素家族 新增的元素 删除的元素剔除的少量元素，浏览器仍然可以得到浏览器的支持，但任何遵循规范的HTML5验证器都会敏感地查出它们的藏身之所，并给出错误提示。 HTML5沿袭了表示不欢迎表现性元素的思想（最初萌发于XHTML）。所谓表现性元素，指的是那些仅仅是为网页添加样式的元素。 HTML5埋葬了已经摒弃的HTML框架，&lt;iframe&gt; 元素侥幸得以保留，主要是Web应用中经常利用 &lt;iframe&gt; 实现一些集成任务，比如在网页中包含YouTube窗口、广告和谷歌搜索框等。 还有另外一些元素，由于冗余或容易导致误会等原因也被剔除了，比如 &lt;acronym&gt; （代之为 &lt;abbr&gt;）和 &lt;applet&gt; （因为 &lt;object&gt; 更好）。 完整的元素列表，可参考 http://dev.w3.org/html5/markup/ 。 改变的元素 &lt;small&gt; 元素 HTML5将一些旧元素用于新的目的。例如， &lt;small&gt; 元素的用途不再是减小文本字体大小，而是表示“附属细则”（small print）,比如页面底部没人想让你看到的那些法律条款。 放在 &lt;small&gt; 元素中的文本仍然照常显示，只不过字体稍小一点。 注意： 一种看法是认为它最大限度的向后兼容，另一种看法认为它会导致旧网页中相应元素的语义变化。 &lt;hr&gt; 元素 另一个改变的元素是 &lt;hr&gt; (horizontal rule, 水平线)，用于在两个区域间画一条线。在HTML5中 &lt;hr&gt; 表示主题的转换，即从一个主题变为另一个主题。默认格式还在，只不过又赋予了新的含义。 &lt;s&gt; 元素 不仅仅是给文本加一条删除线，而它现在表示不再准确或不相关的内容。 粗体和斜体 HTML中最常用的两个表示粗体和斜体的元素 &lt;b&gt; 和 &lt;i&gt; 部分被 &lt;strong&gt; 和 &lt;em&gt; 元素取代。 其背后的思想是停止从格式（粗体和斜体）的角度来看问题，而是要换成使用具有真实逻辑含义（重要或重音）的元素。 但 &lt;b&gt; 和 &lt;i&gt; 这两个标签仍然作为XHTML新引入的两个标签的简写形式存在着。 下面分别说明： 使用 &lt;strong&gt; 表示重要的文本内容，也就是那些需要在周围文本中突出出来的文本。 使用 &lt;b&gt; 表示应该用粗体表示的文本，但该文本并不比其他文本重要。比如,关键字、产品名称等所有需要用粗体表示的文本都可以用这个标签。 使用 &lt;em&gt; 表示重读的文本，也就是在朗读的时候要大声读出来。 使用 &lt;i&gt; 表示应该用斜体表示的文本，但该文本并不比其他文本更重要。比如，外文单词、技术术语等所需要使用斜体表示的文本都可以用这个标签。 调整的元素 &lt;address&gt; 元素 提供HTML文档作者的联系信息，比如邮件地址或网站链接： 123&lt;address&gt; &lt;a href=&quot;mailto:songxingguo.com&quot;&gt;Xingguo Song&lt;/a&gt;&lt;/address&gt; &lt;cite&gt; 元素 引用某些作品，去标注人名已经不对了。 1&lt;cite&gt; HTML5 秘籍 &lt;/cite&gt; &lt;a&gt; 元素 HTML以前的版本允许用 &lt;a&gt; 元素来标注可以单击的文本或图像。而在HTML5中，可以在 &lt;a&gt; 元素中放置任何东西（所有文本都会变成蓝色并带有下划线，而图像则会产生蓝色的边框）。Web浏览器支持这种做法已经有很多年了，HTML5只不过是把这种行为写进了规范。 &lt;ol&gt; 元素 有序列表有了reversed属性，只是目前不是所有浏览器都支持。 标准化的元素 &lt;embed&gt; 元素 向页面中加入插件的通用方法。 &lt;wbr&gt; 元素 表示可以在某处换行，如果词太长了，一行放不下，那浏览器就会在标注的地方断行（只有一行容不下来了才会断行）。 &lt;nobr&gt; 元素 HTML5认为 &lt;nobr&gt; 已经不合时宜，可以在CSS中使用white-space属性，将它的值设定为nowarp。 今天开始用HTML5 对付旧版本浏览器平稳退化： 为老的浏览器提供替代内容（比如使用Flash插件的视频播放器）。 借助JavaScript: HTML5中的某些功能完全可以使用优秀的JavaScript库实现（最差的情况，完全通过手工编写JavaScript代码也可以写出来）。 了解浏览器支持情况在浏览器中打开http://caniuse.com 。 红色代表不支持，浅绿色表示支持，橄榄绿色表示部分支持，灰色表示不确定（一般是因为浏览器的当前版本还在开发过程中，相应功能还没有加入）。 上图为HTML5浏览器支持情况 浏览器装机情况统计可以查看流行的流量跟踪站点GlobalStats。 在浏览器中打开http://gs.statcounter.com （国内只有翻墙才能访问）。 打开网站可以看到一个折线图，显示着最近几年常用的浏览器，可以选择不同的条件显示统计不同的数据（比如，可以统计国内的浏览器使用情况）。 上图为国内浏览器使用情况 通过Modernizr检测功能加载页面，通过JavaScript脚本检测某个具体的功能是否可用，然后，可以对用户进行提示（最衰的方法）、平稳退化到没有那么花哨的版本（稍好一些），或者采用其他方法实现浏览器本该支持的HTML5功能（最佳）。 Modernizr是一个小巧、持续更新的工具，专门用于测试浏览器对很多HTML5及相关功能的支持情况。 在刘浏览器中打开 http://modernizr.com/download ，下载完整版Moderniznr，并将js引入到 &lt;head&gt; 区块中。 使用“腻子脚本”填补功能缺陷Moderniznr可以帮你找出浏览器支持上的缺陷。它会在某个功能不可用时提醒你，但除此之外不会帮你弥补这些缺陷。而这就是腻子脚本（polyfill）的用途所在。腻子脚本就是一大堆五花八门的技术，目的是填平旧浏览器对HTML5支持上的缺陷。 不过，腻子脚本并不完美。有些脚本依赖的技术同样得不到普遍的支持。 腻子脚本的完整集合，页面地址为：http://tinyurl.com/polyfill 。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题]]></title>
    <url>%2F2018%2F07%2F15%2Fcross-domain%2F</url>
    <content type="text"><![CDATA[写在前面前后端分离的到来，给我们工作上带来了一下便利，但是也随之产生了一些问题，前后端分离意味这个在实际的工作中会存在客户端域名和和服务器端域名，而客服端向服务器端发出请求也就存在跨域的问题。 如果大家有兴趣可以看一下后面这篇文章，了解前后端分离的的历史原由。前后端分离 什么是跨域 域名地址的组成 图片来自慕课网 跨域错误代码 图片来自慕课网 跨域的定义 跨域是JavaScript出于安全方面的考虑，不允许跨域调用其他页面对象。是JavaScript同源策略的限制。 常见跨域场景 图片来自慕课网 处理跨域的方法方法一：代理 服务器后台做代理，a.com 调用 b.com的服务时不直接调用，而是通过a.com的服务器后台去调用b.com的服务。 图片来自慕课网 方法二：JSONP 用JSONP定义参数名称，只支持GET请求。 图片来自慕课网 方法三： XHR2 跨域资源共享（CORS） 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置。带cookie请求：前后端都需要设置字段，另外需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 图片来自慕课网 方法四： nginx代理 nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; nginx反向代理接口跨域 跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： 123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 方法五：nodejs中间件node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。 方法六：WebSocketWebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 参考教程处理跨域方式 慕课网 前端常见跨域解决方案（全）]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 常见问题处理]]></title>
    <url>%2F2018%2F07%2F13%2FWindows%2F</url>
    <content type="text"><![CDATA[解决文件正在被使用问题该问题解决分为两步，第一步，找到进程号；第二步，杀死它。 复制被占用的文件路径 复制路径。 查找进程号 1、打开 任务管理器, 点击 性能，再点击 打开资源监视器。 2、点击 关联句柄，在搜索处 粘贴文件路径，回车搜索，出现被占用的进程号。 杀死进程号 打开刚才的 任务管理器， 点击 服务，在服务中找到上面 搜索的进程号，选中该进程，鼠标 右键，然后点击 停止 杀死该进程。 Windows开机启动服务 教程链接附上]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文书写]]></title>
    <url>%2F2018%2F07%2F11%2Fpaper-writing%2F</url>
    <content type="text"><![CDATA[写在前面综合课程设计刚刚结束，在这次综合课程设计，是我第一次真正意义上的写了一次正规的论文，虽说只是得了一个良，但是心里依然很满足了，因为在整个过程中我学会了很多书写论文在格式上的要求以及对WPS工具（Word文档）的使用，为了不让记忆随着时间的流逝而消失，我打算将所有记忆在忘记之前封存于我的博客之中。 本文将从论文格式、WPS工具（Word文档）的使用、总结三个方面诉说我对于论文书写的一些看法。 最终论文下载 特别说明：该论文格式要求为 重庆理工大学软件工程专业毕业论文格式 要求。 论文格式 封面格式封面格式要求： 封面标题 小初、黑体、居中 封面题目 二号、黑体 封面内容 三号、仿宋 目录格式目录格式要求： 目录标题 三号、黑体、居中 目录一级标题 小四号、黑体、左对齐 目录二级标题 小四号、宋体、二级标题缩进 摘要格式中文摘要格式要求： 摘要标题 三号、黑体、居中 摘要文本 小四号、宋体、首行缩进两字 关键词标题 小四号、黑体 关键词文本 小四号、宋体 英文摘要格式要求： 摘要标题 三号、黑体、居中 摘要文本 小四号、Times New Roman字体 关键词标题 小四号、Times New Roman字体、加粗 关键词文本 小四号、Times New Roman字体 正文格式正文格式要求： 正文一级标题 三号、黑体、居中 正文二级标题 小四号、黑体 正文三级标题 小四号、黑体 正文中文文本 小四号、宋体、首行缩进两字 正文英文文本 小四号、Times New Roman字体 引用文献 方括号数字上标 参考文献参考文献格式要求： 参考文献标题 三号、黑体、居中 参考文献中文文本 小四号、宋体 参考文献英文文本 小四号、Times New Roman字体 格式要求文件下载 封面格式要求下载 目录与摘要格式要求下载 正文与参考文献格式要求下载 WPS工具的使用 定义公共样式在写文档之前可以将先将格式要求定义为公共样式，方便重复使用，也便于修改。 需修改的公共样式： 目录1、目录2、标题1、标题2、标题3、正文、正文缩进、表格标题、表格样式、图片标题、序号样式等。 修改步骤： 1、点击 开始，选中样式 右键，选择 修改样式。 2、根据实际情况修改公共样式。 目录生成方法一： 点击 引用，然后点击 目录，进行 手动生成 或者 自动生成。 方法二 点击 插入，然后点击 文档部件，再点击 域。 然后再点击 创建目录，保持默认值，点击 确认。 插入与删除分页插入分页 点击 插入，选择 分页，点击 分页符 就可以在鼠标位置插入一个分页符。 删除分页符 点击 开始，点击如下的 切换符号，显示分页符（分页符默认是隐藏的，所以我们需要将分页符首先显示出来）。 然后找到 相应的分页符，鼠标 放到分页符前，点击键盘上的 Delete 按钮删除分页符。 去掉封面的页眉设置页眉的时候，我们总是会将所有页眉都设置为一样的，但是在实际上论文的封面是不需要的页眉的，我们需要去掉。 解决方法：页眉是根据分节来确定样式的不同的，所以我们可以在目录之前插入分节符就可以让封面有不同的样式了。 1、首先在目录之前插入分节符。鼠标放到 目录 前，然后点击 插入，点击 分页 再点击 下一页分节符。 2、接着 双击选择目录页眉，然后 去掉同前节。 3、最后就是 删除封面上的页眉 了。 摘要部分插入不同的页码摘要部分插入不同的页码和上面所说的去除封面页眉类似，也是分节的问题。 解决方法：在摘要部分前后插入分节符。 1、摘要前后 插入分节符，方法和上面一样就不重复了，插入后的效果如下。 摘要前： 摘要后： 2、双击摘要页码，点击 设置页码，选择 样式 和 本节，点击 确认。 设置页边距点击 页面布局， 然后点击 页边距,再选择 适中。 总结 论文书写过程中存在的问题 没有页眉 截图没有只截有效部分 不够紧凑 性能需求没有精确、以及可衡量 目录不符合格式要求 论文每章不够丰满 表格内容没有充满窗体，内容过于分散 文章最后没有姓名和时间 表格没有单倍行距，太分散 前后的序号类型不一致 左右页边距太大，应该为2.5左右（可以直接选择Word文档中的适中页边距） 关键词小于3个，应该3-5个关键词 参考文献少于5个 ，综合课程设计应该5-8个，毕业设计应该15以上，其中至少3个英文文献 页面下部留白，应该调整图片大小或者调整文字和图片的相对位置或者填充文字不要让页面留白 日期错误 书写心得 每个老师要求不同，应该因人而异。 论文前后一致 缩写提前说明（比如：以下简称We重理工） 总结写论文时，文章、表格、图片应该尽量紧凑，不要留白。 最后奉上一篇指导老师写的 论文写法概要下载 。 写在最后 论文的书写就是用心不断的去多看、多修改、多调整。]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[knex.js中文文档-其他]]></title>
    <url>%2F2018%2F07%2F01%2Fknex-js-other%2F</url>
    <content type="text"><![CDATA[Raw有时您可能需要在查询中使用原始表达式。原始查询对象可以在任何地方注入，并且使用正确的绑定可以确保正确地转义您的值，从而防止SQL注入攻击。 Raw Parameter Binding 人们可以参数化SQL给予knex.raw(sql, bindings)。参数可以是位置命名的。也可以选择参数是否应该被视为值或作为sql标识符，例如在’TableName.ColumnName’引用的情况下。 例： 12345knex(&apos;users&apos;).select(knex.raw(&apos;count(*) as user_count, status&apos;)).where(knex.raw(1)).orWhere(knex.raw(&apos;status &lt;&gt; ?&apos;, [1])).groupBy(&apos;status&apos;) 输出： 1select count(*) as user_count, status from `users` where 1 or status &lt;&gt; 1 group by `status` 位置绑定?被解释为值并被??解释为标识符。 例： 1knex(&apos;users&apos;).where(knex.raw(&apos;?? = ?&apos;, [&apos;user.name&apos;, 1])) 输出： 1select * from `users` where `user`.`name` = 1 命名的绑定例如:name被解释为值并被:name:解释为标识符。只要值不是任何值，就会处理命名绑定undefined。 例： 1234567knex(&apos;users&apos;).where(knex.raw(&apos;:name: = :thisGuy or :name: = :otherGuy or :name: = :undefinedBinding&apos;, &#123; name: &apos;users.name&apos;, thisGuy: &apos;Bob&apos;, otherGuy: &apos;Jay&apos;, undefinedBinding: undefined&#125;)) 错误： 1Undefined binding(s) detected when compiling RAW query: `users`.`name` = ? or `users`.`name` = ? or `users`.`name` = :undefinedBinding 对于只有单个绑定的简单查询，.raw可以接受所述绑定作为其第二个参数。 例： 12345678910knex(&apos;users&apos;).where( knex.raw(&apos;LOWER(&quot;login&quot;) = ?&apos;, &apos;knex&apos;)).orWhere( knex.raw(&apos;accesslevel = ?&apos;, 1)).orWhere( knex.raw(&apos;updtime = ?&apos;, new Date.UTC(&apos;01-01-2016&apos;))) 错误： 1Date.UTC is not a constructor 请注意，由于含糊不清，数组必须作为参数传递到包含数组中。 例： 1234knex.raw(&apos;select * from users where id in (?)&apos;, [1, 2, 3]);// Error: Expected 3 bindings, saw 1knex.raw(&apos;select * from users where id in (?)&apos;, [[1, 2, 3]]) 输出： 1select * from users where id in (1, 2, 3) 为了防止更换?一个可以使用转义序列\?。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).where(&apos;id&apos;, &apos;=&apos;, 1).whereRaw(&apos;?? \\? ?&apos;, [&apos;jsonColumn&apos;, &apos;jsonKey&apos;]) 输出： 1select * from `users` where `id` = 1 and `jsonColumn` ? &apos;jsonKey&apos; 为了防止替换命名绑定，可以使用转义序列\:。 例： 1234knex.select(&apos;*&apos;).from(&apos;users&apos;).whereRaw(&quot;:property: = &apos;\\:value&apos; OR \\:property: = :value&quot;, &#123; property: &apos;name&apos;, value: &apos;Bob&apos;&#125;) 输出： 1select * from `users` where `name` = &apos;:value&apos; OR :property: = &apos;Bob&apos; Raw Expressions 原始表达式通过使用knex.raw(sql, [bindings])并传递它作为查询链中任何值的值来创建。 例： 12345knex(&apos;users&apos;).select(knex.raw(&apos;count(*) as user_count, status&apos;)).where(knex.raw(1)).orWhere(knex.raw(&apos;status &lt;&gt; ?&apos;, [1])).groupBy(&apos;status&apos;) 输出： 1select count(*) as user_count, status from `users` where 1 or status &lt;&gt; 1 group by `status` Raw Queries 该knex.raw也可用于构建一个完整的查询并执行它，作为一个标准的查询生成器的查询将被执行。这样做的好处是它使用连接池并为不同的客户端库提供标准接口。 1knex.raw(&apos;select * from users where id = ?&apos;, [1]).then(function(resp) &#123; ... &#125;); 请注意，响应将是任何底层sql库通常会在普通查询中返回的内容，因此您可能需要查看执行查询的基本库的文档，以确定如何处理响应。 Wrapped Queries原始查询构建器还附带了一个wrap方法，该方法允许将查询包装在一个值中： 例： 123456var subcolumn = knex.raw(&apos;select avg(salary) from employee where dept_no = e.dept_no&apos;).wrap(&apos;(&apos;, &apos;) avg_sal_dept&apos;);knex.select(&apos;e.lastname&apos;, &apos;e.salary&apos;, subcolumn).from(&apos;employee as e&apos;).whereRaw(&apos;dept_no = e.dept_no&apos;) 输出： 1select `e`.`lastname`, `e`.`salary`, (select avg(salary) from employee where dept_no = e.dept_no) avg_sal_dept from `employee` as `e` where dept_no = e.dept_no 请注意，使用as方法可以更轻松地实现上述示例。 例： 12345678var subcolumn = knex.avg(&apos;salary&apos;).from(&apos;employee&apos;).whereRaw(&apos;dept_no = e.dept_no&apos;).as(&apos;avg_sal_dept&apos;);knex.select(&apos;e.lastname&apos;, &apos;e.salary&apos;, subcolumn).from(&apos;employee as e&apos;).whereRaw(&apos;dept_no = e.dept_no&apos;) 输出： 1select `e`.`lastname`, `e`.`salary`, (select avg(`salary`) from `employee` where dept_no = e.dept_no) as `avg_sal_dept` from `employee` as `e` where dept_no = e.dept_no]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>knexjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[knex.js 学习笔记]]></title>
    <url>%2F2018%2F07%2F01%2Fknex.js-note%2F</url>
    <content type="text"><![CDATA[多表查询 内连接— .join(table, first, [operator], second) 连接构建器可用于指定表之间的连接，第一个参数是连接表，后三个参数分别是第一个连接列，连接操作符和第二个连接列。(等同于自然连接） 例： 12345knex(&apos;book as b&apos;) .join(&apos;book_borrow as bb&apos;, &apos;b.book_id&apos;, &apos;bb.book_id&apos;) .select(&apos;book_name as bookName&apos;, &apos;borrow_end_date as endDate&apos;, knex.raw(&apos;DATEDIFF( borrow_end_date,NOW()) as count&apos;)) .where(&#123;user_id: userId&#125;) .orderBy(&apos;borrow_end_date&apos;).first() 输出： 123456789101112SELECT `book_name` AS `bookName`, `borrow_end_date` AS `endDate`, DATEDIFF(borrow_end_date, NOW()) AS `count`FROM `book` AS `b`INNER JOIN `book_borrow` AS `bb` ON `b`.`book_id` = `bb`.`book_id`WHERE `user_id` = &apos;1&apos;ORDER BY `borrow_end_date` ASCLIMIT 1 等同于下面的 自然连接 12345678910111213SELECT book_name bookName, borrow_end_date endDate, DATEDIFF(borrow_end_date, NOW())FROM book b, book_borrow bbWHERE b.book_id = bb.book_idAND user_id = 1ORDER BY borrow_end_dateLIMIT 1 外连接 子查询 使用自定义函数 -.row() 查询中使用原始表达式 例： 12345knex(&apos;book as b&apos;) .join(&apos;book_borrow as bb&apos;, &apos;b.book_id&apos;, &apos;bb.book_id&apos;) .select(&apos;book_name as bookName&apos;, &apos;borrow_end_date as endDate&apos;, knex.raw(&apos;DATEDIFF( borrow_end_date,NOW()) as count&apos;)) .where(&#123;user_id: userId&#125;) .orderBy(&apos;borrow_end_date&apos;).first() 输出： 123456789101112SELECT `book_name` AS `bookName`, `borrow_end_date` AS `endDate`, DATEDIFF(borrow_end_date, NOW()) AS `count`FROM `book` AS `b`INNER JOIN `book_borrow` AS `bb` ON `b`.`book_id` = `bb`.`book_id`WHERE `user_id` = &apos;1&apos;ORDER BY `borrow_end_date` ASCLIMIT 1]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>knexjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习笔记]]></title>
    <url>%2F2018%2F06%2F30%2Fkoa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装 Koa 依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持. 你可以使用自己喜欢的版本管理器快速安装支持的 node 版本： 123nvm install 7npm i koanode app.js 使用 Babel 实现 Async 方法 要在 node &lt; 7.6 版本的 Koa 中使用 async 方法, 我们推荐使用 babel’s require hook. 123require(&apos;babel-register&apos;);// 应用的其余 require 需要被放到 hook 后面const app = require(&apos;./app&apos;); 要解析和编译 async 方法, 你至少应该有 transform-async-to-generator 或 transform-async-to-module-method 插件. 新建 .babelrc 文件： 123&#123; &quot;plugins&quot;: [&quot;transform-async-to-generator&quot;]&#125; 你也可以用 env preset 的 target 参数 “node”: “current” 替代. 应用程序 Koa 应用程序是 一个包含一组中间件函数的对象 ，它是 按照类似堆栈的方式组织和执行的 。 Koa 类似于你可能遇到过的许多其他中间件系统，例如 Ruby 的 Rack ，Connect 等，然而，一个关键的设计点是 在其低级中间件层中提供高级“语法糖” 。 这提高了 互操作性 ，稳健性 ，并使 书写中间件更加愉快 。这包括诸如 内容协商 ，缓存清理 ，代理支持 和 重定向 等常见任务的方法。 尽管 提供了相当多的有用的方法 Koa 仍保持了一个很小的体积 ，因为没有捆绑中间件。 第一个Koa应用 hello world : 12345678const Koa = require(&apos;koa&apos;);const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = &apos;Hello World&apos;;&#125;);app.listen(3000); 级联 Koa 中间件以更传统的方式级联，您可能习惯使用类似的工具 - 之前难以让用户友好地使用 node 的回调。然而，使用 async 功能，我们可以实现 “真实” 的中间件。对比 Connect 的实现，通过一系列功能直接传递控制，直到一个返回，Koa 调用“下游”，然后控制流回“上游”。 下面以 “Hello World” 的响应作为示例，当请求开始时首先 请求流 通过 x-response-time 和 logging 中间件，然后继续移交控制给 response 中间件 。 当一个中间件调用 next() 则该函数 暂停并将控制传递给定义的下一个中间件 。 当在下游没有更多的中间件执行后，堆栈将展开并且每个中间件恢复执行其上游行为 。 123456789101112131415161718192021222324252627const Koa = require(&apos;koa&apos;);const app = new Koa();// loggerapp.use(async (ctx, next) =&gt; &#123; await next(); const rt = ctx.response.get(&apos;X-Response-Time&apos;); console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`);&#125;);// x-response-timeapp.use(async (ctx, next) =&gt; &#123; const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set(&apos;X-Response-Time&apos;, `$&#123;ms&#125;ms`);&#125;);// responseapp.use(async ctx =&gt; &#123; ctx.body = &apos;Hello World&apos;;&#125;);app.listen(3000); 设置应用程序设置是 app 实例上的属性，目前支持如下： app.env 默认是 NODE_ENV 或 “development”app.proxy 当真正的代理头字段将被信任时app.subdomainOffset 对于要忽略的 .subdomains 偏移[2] app.listen(…)Koa 应用程序不是 HTTP 服务器的1对1展现。 可以将一个或多个 Koa 应用程序安装在一起以形成具有单个HTTP服务器的更大应用程序。 创建并返回 HTTP 服务器，将给定的参数传递给 Server#listen()。这些内容都记录在 nodejs.org. 以下是一个无作用的 Koa 应用程序被绑定到 3000 端口： 123const Koa = require(&apos;koa&apos;);const app = new Koa();app.listen(3000); 这里的 app.listen(…) 方法只是以下方法的语法糖: 1234const http = require(&apos;http&apos;);const Koa = require(&apos;koa&apos;);const app = new Koa();http.createServer(app.callback()).listen(3000); 这意味着您可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址： 123456const http = require(&apos;http&apos;);const https = require(&apos;https&apos;);const Koa = require(&apos;koa&apos;);const app = new Koa();http.createServer(app.callback()).listen(3000);https.createServer(app.callback()).listen(3001); app.callback()返回适用于 http.createServer() 方法的回调函数来处理请求。你也可以使用此回调函数将 koa 应用程序挂载到 Connect/Express 应用程序中。 app.use(function)将给定的中间件方法添加到此应用程序。参阅 Middleware 获取更多信息. app.keys=设置签名的 Cookie 密钥。 这些被传递给 KeyGrip，但是你也可以传递你自己的 KeyGrip 实例。 例如，以下是可以接受的： 12app.keys = [&apos;im a newer secret&apos;, &apos;i like turtle&apos;];app.keys = new KeyGrip([&apos;im a newer secret&apos;, &apos;i like turtle&apos;], &apos;sha256&apos;); 这些密钥可以倒换，并在使用 { signed: true } 参数签名 Cookie 时使用。 1ctx.cookies.set(&apos;name&apos;, &apos;tobi&apos;, &#123; signed: true &#125;); app.contextapp.context 是从其创建 ctx 的原型。您可以通过编辑 app.context 为 ctx 添加其他属性。这对于将 ctx 添加到整个应用程序中使用的属性或方法非常有用，这可能会更加有效（不需要中间件）和/或 更简单（更少的 require()），而更多地依赖于ctx，这可以被认为是一种反模式。 例如，要从 ctx 添加对数据库的引用： 12345app.context.db = db();app.use(async ctx =&gt; &#123; console.log(ctx.db);&#125;); 注意:ctx 上的许多属性都是使用 getter ，setter 和 Object.defineProperty() 定义的。你只能通过在 app.context 上使用 Object.defineProperty() 来编辑这些属性（不推荐）。查阅 https://github.com/koajs/koa/issues/652.安装的应用程序目前使用其父级的 ctx 和设置。 因此，安装的应用程序只是一组中间件。 错误处理默认情况下，将所有错误输出到 stderr，除非 app.silent 为 true。 当 err.status 是 404 或 err.expose 是 true 时默认错误处理程序也不会输出错误。 要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个 “error” 事件侦听器： 123app.on(&apos;error&apos;, err =&gt; &#123; log.error(&apos;server error&apos;, err)&#125;); 如果 req/res 期间出现错误，并且 _无法_ 响应客户端，Context实例仍然被传递： 123app.on(&apos;error&apos;, (err, ctx) =&gt; &#123; log.error(&apos;server error&apos;, err, ctx)&#125;); 当发生错误 _并且_ 仍然可以响应客户端时，也没有数据被写入 socket 中，Koa 将用一个 500 “内部服务器错误” 进行适当的响应。在任一情况下，为了记录目的，都会发出应用级 “错误”。]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[knex.js中文文档-查询]]></title>
    <url>%2F2018%2F06%2F30%2Fknex.js-query%2F</url>
    <content type="text"><![CDATA[knexjs 简介 &emsp;&emsp;Knex.js是为Postgres，MSSQL，MySQL，MariaDB，SQLite3，Oracle和Amazon Redshift设计的“包含电池”SQL查询构建器，其设计灵活，便于携带并且使用起来非常有趣。它具有传统的节点样式回调以及用于清洁异步流控制的承诺接口，流接口，全功能查询和模式构建器，事务支持（带保存点），连接池 以及不同查询客户和方言之间的标准化响应。传送门 支持&emsp;&emsp;Knex的主要目标环境是Node.js，您需要安装该knex库，然后安装适当的数据库库：pg适用于PostgreSQL和Amazon Redshift，mysql适用于MySQL或MariaDB，sqlite3适用于SQLite3或mssql适用于MSSQL。 安装1234567891011$ npm install knex --save# Then add one of the following (adding a --save) flag:$ npm install pg$ npm install sqlite3$ npm install mysql$ npm install mysql2$ npm install mariasql$ npm install strong-oracle$ npm install oracle$ npm install mssql 初始数据库&emsp;&emsp;该knex模块本身是一个为Knex提供配置对象的函数，它接受一些参数。该client参数是必需的，并确定哪个客户端适配器将与该库一起使用。 mysql数据库初始化 123456789var knex = require(&apos;knex&apos;)(&#123; client: &apos;mysql&apos;, connection: &#123; host : &apos;127.0.0.1&apos;, user : &apos;your_database_user&apos;, password : &apos;your_database_password&apos;, database : &apos;myapp_test&apos; &#125;&#125;); knex 查询构造器knex 查询构造器是用于构建和执行标准的SQL查询,例如：select, insert, update, delete. 在API的许多地方，表名或列名等标识符都可以传递给方法。 最常见的只需要简单tableName.columnName，tableName或者columnName，但在许多情况下，还需要传递一个别名，以便稍后在查询中引用该标识符。 Identifier Syntax有两种方法可以为标识符声明别名。可以直接 as aliasName 为标识符提供前缀，也可以传递对象 { aliasName: &#39;identifierName&#39; } 。 如果对象具有多个别名 { alias1: &#39;identifier1&#39;, alias2: &#39;identifier2&#39; } ，则所有别名标识符将扩展为逗号分隔列表。 例： 123456 knex(&#123; a: &apos;table&apos;, b: &apos;table&apos; &#125;).select(&#123; aTitle: &apos;a.title&apos;, bTitle: &apos;b.title&apos;&#125;).whereRaw(&apos;?? = ??&apos;, [&apos;a.column_1&apos;, &apos;b.column_2&apos;]) 输出： 1select `a`.`title` as `aTitle`, `b`.`title` as `bTitle` from `table` as `a`, `table` as `b` where `a`.`column_1` = `b`.`column_2` knex -knex(tableName, options={only: boolean}) / knex.[methodName] 查询构建器通过指定要查询的表名或通过直接在knex对象上调用任何方法来启动。这将启动类似jQuery的链，您可以根据需要调用其他查询构建器方法来构造查询，最终调用任何接口方法，将其转换为toString或返回一个promise对象，回调或链式执行查询。 timeout-.timeout(ms, options={cancel: boolean}) 设置查询的超时时间，并且如果超时超时，将会引发TimeoutError。该错误包含有关查询，绑定和设置的超时的信息。对于想要确保执行的复杂查询不会花太长时间。传递选项的可选第二个参数：cancel：if ，如果达到超时则取消查询。*注意：目前只支持MySQL和MariaDB。 例： 1knex.select().from(&apos;books&apos;).timeout(1000) 输出： 1select * from `books` 例： 1knex.select().from(&apos;books&apos;).timeout(1000, &#123;cancel: true&#125;) // MySQL and MariaDB only 输出： 1select * from `books` select-.select([*columns]) 创建一个select查询，为查询提供可选的列数组，如果在构建查询时没有指定，则最终默认为*。select调用的响应将使用从数据库中选择的对象数组来解析。 例： 1knex.select(&apos;title&apos;, &apos;author&apos;, &apos;year&apos;).from(&apos;books&apos;) 输出： 1select `title`, `author`, `year` from `books` 例： 1knex.select().table(&apos;books&apos;) 输出： 1select * from `books` as-.as(name) 允许对子查询进行别名，并取出希望命名当前查询的字符串。如果查询不是子查询，它将被忽略。 例: 123knex.avg(&apos;sum_column1&apos;).from(function() &#123; this.sum(&apos;column1 as sum_column1&apos;).from(&apos;t1&apos;).groupBy(&apos;column1&apos;).as(&apos;t1&apos;)&#125;).as(&apos;ignored_alias&apos;) 输出： 1select avg(`sum_column1`) from (select sum(`column1`) as `sum_column1` from `t1` group by `column1`) as `t1` column— .column(columns) 专门设置要在选择查询中选择的列，并获取数组，列表或列名称。传递对象将使用给定的键自动对列进行别名。 例： 1knex.column(&apos;title&apos;, &apos;author&apos;, &apos;year&apos;).select().from(&apos;books&apos;) 输出： 1select `title`, `author`, `year` from `books` 例： 1knex.column([&apos;title&apos;, &apos;author&apos;, &apos;year&apos;]).select().from(&apos;books&apos;) 输出： 1select `title`, `author`, `year` from `books` 例： 1knex.column(&apos;title&apos;, &#123;by: &apos;author&apos;&#125;, &apos;year&apos;).select().from(&apos;books&apos;) 输出： 1select `title`, `author` as `by`, `year` from `books` from— .from([tableName], options={only: boolean}) 指定当前查询中使用的表格，如果已经指定了当前表格名称，则替换当前表格名称。这通常用于高级where或union方法中执行的子查询。传递选项的可选第二个参数：only：if ，在放弃继承表数据之前使用ONLY关键字。*注意：目前只支持PostgreSQL。 truetableName 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;) 输出： 1select * from `users` with— .with(alias, function|raw) 为查询添加“with”子句。“With”子句由PostgreSQL，Oracle，SQLite3和MSSQL支持。 例: 1knex.with(&apos;with_alias&apos;, knex.raw(&apos;select * from &quot;books&quot; where &quot;author&quot; = ?&apos;, &apos;Test&apos;)).select(&apos;*&apos;).from(&apos;with_alias&apos;) 输出： 1with `with_alias` as (select * from &quot;books&quot; where &quot;author&quot; = &apos;Test&apos;) select * from `with_alias` 例: 123knex.with(&apos;with_alias&apos;, (qb) =&gt; &#123; qb.select(&apos;*&apos;).from(&apos;books&apos;).where(&apos;author&apos;, &apos;Test&apos;)&#125;).select(&apos;*&apos;).from(&apos;with_alias&apos;) 输出： 1with `with_alias` as (select * from `books` where `author` = &apos;Test&apos;) select * from `with_alias` withSchema — .withSchema([schemaName]) 指定要用作表名前缀的模式。 例： 1knex.withSchema(&apos;public&apos;).select(&apos;*&apos;).from(&apos;users&apos;) 输出： 1select * from `public`.`users` Where 语句 有几种方法可以帮助动态地从句。在很多地方，函数可以用来代替值，构造子查询。在大多数地方，现有的knex查询可能用于组成子查询等。请查看每种使用说明方法的几个示例： 重要提示：undefined为任何where函数提供值的knex将导致knex在SQL编译期间抛出错误。这是为了你和我们的缘故。Knex不知道如何处理where子句中的未定义值，并且通常在提供一个开头时会出现编程错误。该错误将引发包含查询类型和已编译的查询字符串的消息。 例： 1234knex(&apos;accounts&apos;).where(&apos;login&apos;, undefined).select().toSQL() 错误： 1Undefined binding(s) detected when compiling SELECT query: select * from `accounts` where `login` = ? where— .where(~mixed~) 对象语法 例： 1234knex(&apos;users&apos;).where(&#123; first_name: &apos;Test&apos;, last_name: &apos;User&apos;&#125;).select(&apos;id&apos;) 输出： 1select `id` from `users` where `first_name` = &apos;Test&apos; and `last_name` = &apos;User&apos; 键值对 例： 1knex(&apos;users&apos;).where(&apos;id&apos;, 1) 输出： 1select * from `users` where `id` = 1 函数 例： 1234567knex(&apos;users&apos;).where((builder) =&gt; builder.whereIn(&apos;id&apos;, [1, 11, 15]).whereNotIn(&apos;id&apos;, [17, 19])).andWhere(function() &#123; this.where(&apos;id&apos;, &apos;&gt;&apos;, 10)&#125;) 输出： 1select * from `users` where (`id` in (1, 11, 15) and `id` not in (17, 19)) and (`id` &gt; 10) 链式调用 例: 123knex(&apos;users&apos;).where(function() &#123; this.where(&apos;id&apos;, 1).orWhere(&apos;id&apos;, &apos;&gt;&apos;, 10)&#125;).orWhere(&#123;name: &apos;Tester&apos;&#125;) 输出： 1select * from `users` where (`id` = 1 or `id` &gt; 10) or (`name` = &apos;Tester&apos;) 分隔符 例： 1knex(&apos;users&apos;).where(&apos;columnName&apos;, &apos;like&apos;, &apos;%rowlikeme%&apos;) 输出： 1select * from `users` where `columnName` like &apos;%rowlikeme%&apos; 以上查询演示了返回指定列中出现特定模式的所有用户的常见用例。 例： 1knex(&apos;users&apos;).where(&apos;votes&apos;, &apos;&gt;&apos;, 100) 输出： 1select * from `users` where `votes` &gt; 100 例： 123var subquery = knex(&apos;users&apos;).where(&apos;votes&apos;, &apos;&gt;&apos;, 100).andWhere(&apos;status&apos;, &apos;active&apos;).orWhere(&apos;name&apos;, &apos;John&apos;).select(&apos;id&apos;);knex(&apos;accounts&apos;).where(&apos;id&apos;, &apos;in&apos;, subquery) 输出： 1select * from `accounts` where `id` in (select `id` from `users` where `votes` &gt; 100 and `status` = &apos;active&apos; or `name` = &apos;John&apos;) 或者与对象一起自动包装声明并创建一个or (and - and - and)子句 例： 1knex(&apos;users&apos;).where(&apos;id&apos;, 1).orWhere(&#123;votes: 100, user: &apos;knex&apos;&#125;) 输出： 1select * from `users` where `id` = 1 or (`votes` = 100 and `user` = &apos;knex&apos;) whereNot— .whereNot(~mixed~) 对象 例： 1234knex(&apos;users&apos;).whereNot(&#123; first_name: &apos;Test&apos;, last_name: &apos;User&apos;&#125;).select(&apos;id&apos;) 输出： 1select `id` from `users` where not `first_name` = &apos;Test&apos; and not `last_name` = &apos;User&apos; 键值对 例： 1knex(&apos;users&apos;).whereNot(&apos;id&apos;, 1) 输出： 1select * from `users` where not `id` = 1 链式调用 例： 123knex(&apos;users&apos;).whereNot(function() &#123; this.where(&apos;id&apos;, 1).orWhereNot(&apos;id&apos;, &apos;&gt;&apos;, 10)&#125;).orWhereNot(&#123;name: &apos;Tester&apos;&#125;) 输出： 1select * from `users` where not (`id` = 1 or not `id` &gt; 10) or not `name` = &apos;Tester&apos; 分隔符 例： 1knex(&apos;users&apos;).whereNot(&apos;votes&apos;, &apos;&gt;&apos;, 100) 输出： 1select * from `users` where not `votes` &gt; 100 CAVEAT：WhereNot不适用于“in”和“between”类型的子查询。您应该使用“not in”和“not betwee”之间。 例： 1234567var subquery = knex(&apos;users&apos;) .whereNot(&apos;votes&apos;, &apos;&gt;&apos;, 100) .andWhere(&apos;status&apos;, &apos;active&apos;) .orWhere(&apos;name&apos;, &apos;John&apos;) .select(&apos;id&apos;);knex(&apos;accounts&apos;).where(&apos;id&apos;, &apos;not in&apos;, subquery) 输出： 1select * from `accounts` where `id` not in (select `id` from `users` where not `votes` &gt; 100 and `status` = &apos;active&apos; or `name` = &apos;John&apos;) whereIn— .whereIn(column|columns, array|callback|builder) / .orWhereIn .where（’id’，’in’，obj）的简写，.whereIn和.orWhereIn方法在查询中添加“where in”子句。 例： 123knex.select(&apos;name&apos;).from(&apos;users&apos;).whereIn(&apos;id&apos;, [1, 2, 3]).orWhereIn(&apos;id&apos;, [4, 5, 6]) 输出： 1select `name` from `users` where `id` in (1, 2, 3) or `id` in (4, 5, 6) 例： 1234knex.select(&apos;name&apos;).from(&apos;users&apos;).whereIn(&apos;account_id&apos;, function() &#123; this.select(&apos;id&apos;).from(&apos;accounts&apos;);&#125;) 输出： 1select `name` from `users` where `account_id` in (select `id` from `accounts`) 例： 1234var subquery = knex.select(&apos;id&apos;).from(&apos;accounts&apos;);knex.select(&apos;name&apos;).from(&apos;users&apos;) .whereIn(&apos;account_id&apos;, subquery) 输出： 1select `name` from `users` where `account_id` in (select `id` from `accounts`) 例： 12knex.select(&apos;name&apos;).from(&apos;users&apos;).whereIn([&apos;account_id&apos;, &apos;email&apos;], [[3, &apos;test3@example.com&apos;], [4, &apos;test4@example.com&apos;]]) 输出： 1select `name` from `users` where (`account_id`, `email`) in ((3, &apos;test3@example.com&apos;), (4, &apos;test4@example.com&apos;)) 例： 12knex.select(&apos;name&apos;).from(&apos;users&apos;).whereIn([&apos;account_id&apos;, &apos;email&apos;], knex.select(&apos;id&apos;, &apos;email&apos;).from(&apos;accounts&apos;)) 输出： 1select `name` from `users` where (`account_id`, `email`) in (select `id`, `email` from `accounts`) whereNotIn — .whereNotIn(column, array|callback|builder) / .orWhereNotIn 例： 1knex(&apos;users&apos;).whereNotIn(&apos;id&apos;, [1, 2, 3]) 输出： 1select * from `users` where `id` not in (1, 2, 3) 例： 1knex(&apos;users&apos;).where(&apos;name&apos;, &apos;like&apos;, &apos;%Test%&apos;).orWhereNotIn(&apos;id&apos;, [1, 2, 3]) 输出： 1select * from `users` where `name` like &apos;%Test%&apos; or `id` not in (1, 2, 3) whereNull-.whereNull(column) / .orWhereNull 例： 1knex(&apos;users&apos;).whereNull(&apos;updated_at&apos;) 输出： 1select * from `users` where `updated_at` is null whereNotNull -.whereNotNull(column) / .orWhereNotNull 例： 1knex(&apos;users&apos;).whereNotNull(&apos;created_at&apos;) 输出： 1select * from `users` where `created_at` is not null WhereExists -.whereExists(builder | callback) / .orWhereExists 例： 123knex(&apos;users&apos;).whereExists(function() &#123; this.select(&apos;*&apos;).from(&apos;accounts&apos;).whereRaw(&apos;users.account_id = accounts.id&apos;);&#125;) 输出： 1select * from `users` where exists (select * from `accounts` where users.account_id = accounts.id) 例： 1knex(&apos;users&apos;).whereExists(knex.select(&apos;*&apos;).from(&apos;accounts&apos;).whereRaw(&apos;users.account_id = accounts.id&apos;)) 输出： 1select * from `users` where exists (select * from `accounts` where users.account_id = accounts.id) whereNotExists — .whereNotExists(builder | callback) / .orWhereNotExists 例： 123knex(&apos;users&apos;).whereNotExists(function() &#123; this.select(&apos;*&apos;).from(&apos;accounts&apos;).whereRaw(&apos;users.account_id = accounts.id&apos;);&#125;) 输出： 1select * from `users` where not exists (select * from `accounts` where users.account_id = accounts.id) 例： 1knex(&apos;users&apos;).whereNotExists(knex.select(&apos;*&apos;).from(&apos;accounts&apos;).whereRaw(&apos;users.account_id = accounts.id&apos;)) 输出： 1select * from `users` where not exists (select * from `accounts` where users.account_id = accounts.id) whereBetween— .whereBetween(column, range) / .orWhereBetween 例： 1knex(&apos;users&apos;).whereBetween(&apos;votes&apos;, [1, 100]) 输出： 1select * from `users` where `votes` between 1 and 100 whereNotBetween— .whereNotBetween(column, range) / .orWhereNotBetween 例： 1knex(&apos;users&apos;).whereNotBetween(&apos;votes&apos;, [1, 100]) 输出： 1select * from `users` where `votes` not between 1 and 100 whereRaw — .whereRaw(query, [bindings]) .where(knex.raw(query))的简写. 例： 1knex(&apos;users&apos;).whereRaw(&apos;id = ?&apos;, [1]) 输出： 12select * from `users` where id = 1Join Me Join 语句提供了几种帮助构建连接的方法。 join— .join(table, first, [operator], second) 连接构建器可用于指定表之间的连接，第一个参数是连接表，后三个参数分别是第一个连接列，连接操作符和第二个连接列。 例： 123knex(&apos;users&apos;).join(&apos;contacts&apos;, &apos;users.id&apos;, &apos;=&apos;, &apos;contacts.user_id&apos;).select(&apos;users.id&apos;, &apos;contacts.phone&apos;) 输出： 1select `users`.`id`, `contacts`.`phone` from `users` inner join `contacts` on `users`.`id` = `contacts`.`user_id` 例： 123knex(&apos;users&apos;).join(&apos;contacts&apos;, &apos;users.id&apos;, &apos;contacts.user_id&apos;).select(&apos;users.id&apos;, &apos;contacts.phone&apos;) 输出： 1select `users`.`id`, `contacts`.`phone` from `users` inner join `contacts` on `users`.`id` = `contacts`.`user_id` 对于分组连接，指定一个函数作为连接查询的第二个参数，并使用on具有orOn或andOn创建联接所用括号分组。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;accounts&apos;, function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;).orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;)&#125;) 输出： 1select * from `users` inner join `accounts` on `accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id` 对于加入语句嵌套，指定一个函数作为第一个参数on，orOn或andOn 例： 123456knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;accounts&apos;, function() &#123; this.on(function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;) this.orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;) &#125;)&#125;) 输出： 1select * from `users` inner join `accounts` on (`accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id`) 也可以使用对象来表示连接语法。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;accounts&apos;, &#123;&apos;accounts.id&apos;: &apos;users.account_id&apos;&#125;) 输出： 1select * from `users` inner join `accounts` on `accounts`.`id` = `users`.`account_id` 如果需要在连接而不是列中使用文字值（字符串，数字或布尔值），请使用knex.raw。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;accounts&apos;, &apos;accounts.type&apos;, knex.raw(&apos;?&apos;, [&apos;admin&apos;])) 输出： 1select * from `users` inner join `accounts` on `accounts`.`type` = &apos;admin&apos; innerJoin-.innerJoin(table, ~mixed~) 例： 1knex.from(&apos;users&apos;).innerJoin(&apos;accounts&apos;, &apos;users.id&apos;, &apos;accounts.user_id&apos;) 输出： 1select * from `users` inner join `accounts` on `users`.`id` = `accounts`.`user_id` 例： 1knex.table(&apos;users&apos;).innerJoin(&apos;accounts&apos;, &apos;users.id&apos;, &apos;=&apos;, &apos;accounts.user_id&apos;) 输出： 1select * from `users` inner join `accounts` on `users`.`id` = `accounts`.`user_id` 例： 123knex(&apos;users&apos;).innerJoin(&apos;accounts&apos;, function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;).orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;)&#125;) 输出： 1select * from `users` inner join `accounts` on `accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id` leftJoin-.leftJoin(table, ~mixed~) 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).leftJoin(&apos;accounts&apos;, &apos;users.id&apos;, &apos;accounts.user_id&apos;) 输出： 1select * from `users` left join `accounts` on `users`.`id` = `accounts`.`user_id` 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).leftJoin(&apos;accounts&apos;, function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;).orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;)&#125;) 输出： 1select * from `users` left join `accounts` on `accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id` leftOuterJoin-.leftOuterJoin(table, ~mixed~) 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).leftOuterJoin(&apos;accounts&apos;, &apos;users.id&apos;, &apos;accounts.user_id&apos;) 输出： 1select * from `users` left outer join `accounts` on `users`.`id` = `accounts`.`user_id` 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).leftOuterJoin(&apos;accounts&apos;, function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;).orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;)&#125;) 输出： 1select * from `users` left outer join `accounts` on `accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id` rightJoin— .rightJoin(table, ~mixed~) 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).rightJoin(&apos;accounts&apos;, &apos;users.id&apos;, &apos;accounts.user_id&apos;) 输出： 1select * from `users` right join `accounts` on `users`.`id` = `accounts`.`user_id` 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).rightJoin(&apos;accounts&apos;, function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;).orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;)&#125;) 输出： 1select * from `users` right join `accounts` on `accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id` rightOuterJoin— .rightOuterJoin(table, ~mixed~) 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).rightOuterJoin(&apos;accounts&apos;, &apos;users.id&apos;, &apos;accounts.user_id&apos;) 输出： 1select * from `users` right outer join `accounts` on `users`.`id` = `accounts`.`user_id` 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).rightOuterJoin(&apos;accounts&apos;, function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;).orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;)&#125;) 输出： 1select * from `users` right outer join `accounts` on `accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id` fullOuterJoin-.fullOuterJoin(table, ~mixed~) 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).fullOuterJoin(&apos;accounts&apos;, &apos;users.id&apos;, &apos;accounts.user_id&apos;) 输出： 1select * from `users` full outer join `accounts` on `users`.`id` = `accounts`.`user_id` 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).fullOuterJoin(&apos;accounts&apos;, function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;).orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;)&#125;) 输出： 1select * from `users` full outer join `accounts` on `accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id` crossJoin-.crossJoin(table, ~mixed~) 交叉连接条件仅在MySQL和SQLite3中受支持。对于连接条件而不是使用innerJoin。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).crossJoin(&apos;accounts&apos;) 输出： 1select * from `users` cross join `accounts` 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).crossJoin(&apos;accounts&apos;, &apos;users.id&apos;, &apos;accounts.user_id&apos;) 输出： 1select * from `users` cross join `accounts` on `users`.`id` = `accounts`.`user_id` 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).crossJoin(&apos;accounts&apos;, function() &#123; this.on(&apos;accounts.id&apos;, &apos;=&apos;, &apos;users.account_id&apos;).orOn(&apos;accounts.owner_id&apos;, &apos;=&apos;, &apos;users.id&apos;)&#125;) 输出： 1select * from `users` cross join `accounts` on `accounts`.`id` = `users`.`account_id` or `accounts`.`owner_id` = `users`.`id` joinRaw-.joinRaw(sql, [bindings]) 例： 1knex.select(&apos;*&apos;).from(&apos;accounts&apos;).joinRaw(&apos;natural full join table1&apos;).where(&apos;id&apos;, 1) 输出： 1select * from `accounts` natural full join table1 where `id` = 1 例： 1knex.select(&apos;*&apos;).from(&apos;accounts&apos;).join(knex.raw(&apos;natural full join table1&apos;)).where(&apos;id&apos;, 1) 输出： 1select * from `accounts` inner join natural full join table1 where `id` = 1 Having 语句 having -.having(column, operator, value) 向查询添加having子句。 例： 1234knex(&apos;users&apos;).groupBy(&apos;count&apos;).orderBy(&apos;name&apos;, &apos;desc&apos;).having(&apos;count&apos;, &apos;&gt;&apos;, 100) 输出： 1select * from `users` group by `count` having `count` &gt; 100 order by `name` desc havingIn -.havingIn(column, values) 向查询添加havingIn子句。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).havingIn(&apos;id&apos;, [5, 3, 10, 17]) 输出： 1select * from `users` having `id` in (5, 3, 10, 17) havingNotIn -.havingNotIn(column, values) 向查询添加havingNotIn子句。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).havingNotIn(&apos;id&apos;, [5, 3, 10, 17]) 输出： 1select * from `users` having `id` not in (5, 3, 10, 17) havingNull -.havingNull(column) 向查询添加havingNull子句。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).havingNull(&apos;email&apos;) 输出： 1select * from `users` having `email` is null havingNotNull -.havingNotNull(column) 向查询添加havingNotNull子句。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).havingNotNull(&apos;email&apos;) 输出： 1select * from `users` having `email` is not null havingExists -.havingExists(builder | callback) 向查询添加一个havingExists子句。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).havingExists(function() &#123; this.select(&apos;*&apos;).from(&apos;accounts&apos;).whereRaw(&apos;users.account_id = accounts.id&apos;);&#125;) 输出： 1select * from `users` having exists (select * from `accounts` where users.account_id = accounts.id) havingNotExists -.havingNotExists(builder | callback) 向查询添加havingNotExists子句。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).havingNotExists(function() &#123; this.select(&apos;*&apos;).from(&apos;accounts&apos;).whereRaw(&apos;users.account_id = accounts.id&apos;);&#125;) 输出： 1select * from `users` having not exists (select * from `accounts` where users.account_id = accounts.id) havingBetween -.havingBetween(column, range) 向查询添加一个havingBetween子句。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).havingBetween(&apos;id&apos;, [5, 10]) 输出： 1select * from `users` having `id` between 5 and 10 havingNotBetween -.havingNotBetween(column, range) 向查询添加havingNotBetween子句。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).havingNotBetween(&apos;id&apos;, [5, 10]) 输出： 1select * from `users` having `id` not between 5 and 10 havingRaw -.havingRaw(column, operator, value) 向查询添加havingRaw子句。 例： 1234knex(&apos;users&apos;).groupBy(&apos;count&apos;).orderBy(&apos;name&apos;, &apos;desc&apos;).havingRaw(&apos;count &gt; ?&apos;, [100]) 输出： 1select * from `users` group by `count` having count &gt; 100 order by `name` desc On 语句 onIn -.onIn(column, values) 向查询添加onIn子句。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;contacts&apos;, function() &#123; this.on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.id&apos;).onIn(&apos;contacts.id&apos;, [7, 15, 23, 41])&#125;) 输出： 1select * from `users` inner join `contacts` on `users`.`id` = `contacts`.`id` and `contacts`.`id` in (7, 15, 23, 41) onNotIn -.onNotIn(column, values) 向查询添加一个onNotIn子句。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;contacts&apos;, function() &#123; this.on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.id&apos;).onNotIn(&apos;contacts.id&apos;, [7, 15, 23, 41])&#125;) 输出： 1select * from `users` inner join `contacts` on `users`.`id` = `contacts`.`id` and `contacts`.`id` not in (7, 15, 23, 41) onNull -.onNull(column) 向查询添加一个onNull子句。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;contacts&apos;, function() &#123; this.on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.id&apos;).onNull(&apos;contacts.email&apos;)&#125;) 输出： 1select * from `users` inner join `contacts` on `users`.`id` = `contacts`.`id` and `contacts`.`email` is null onNotNull -.onNotNull(column) 向查询添加一个onNotNull子句。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;contacts&apos;, function() &#123; this.on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.id&apos;).onNotNull(&apos;contacts.email&apos;)&#125;) 输出： 1select * from `users` inner join `contacts` on `users`.`id` = `contacts`.`id` and `contacts`.`email` is not null onExists -.onExists(builder | callback) 向查询添加一个onExists子句。 例： 12345knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;contacts&apos;, function() &#123; this.on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.id&apos;).onExists(function() &#123; this.select(&apos;*&apos;).from(&apos;accounts&apos;).whereRaw(&apos;users.account_id = accounts.id&apos;); &#125;)&#125;) 输出： 1select * from `users` inner join `contacts` on `users`.`id` = `contacts`.`id` and exists (select * from `accounts` where users.account_id = accounts.id) onNotExists-.onNotExists(builder | callback)向查询添加一个onNotExists子句。 例： 12345knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;contacts&apos;, function() &#123; this.on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.id&apos;).onNotExists(function() &#123; this.select(&apos;*&apos;).from(&apos;accounts&apos;).whereRaw(&apos;users.account_id = accounts.id&apos;); &#125;)&#125;) 输出： 1select * from `users` inner join `contacts` on `users`.`id` = `contacts`.`id` and not exists (select * from `accounts` where users.account_id = accounts.id) onBetween-.onBetween(column, range)向查询添加一个onBetween子句。 例： 123 knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;contacts&apos;, function() &#123; this.on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.id&apos;).onBetween(&apos;contacts.id&apos;, [5, 30])&#125;) 输出： 1select * from `users` inner join `contacts` on `users`.`id` = `contacts`.`id` and `contacts`.`id` between 5 and 30 onNotBetween-.onNotBetween(column, range)向查询添加一个onNotBetween子句。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).join(&apos;contacts&apos;, function() &#123; this.on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.id&apos;).onNotBetween(&apos;contacts.id&apos;, [5, 30])&#125;) 输出： 1select * from `users` inner join `contacts` on `users`.`id` = `contacts`.`id` and `contacts`.`id` not between 5 and 30 Clear 语句 clearSelect-.clearSelect()清除查询中的所有select子句，不包括子查询。 例： 1knex.select(&apos;email&apos;, &apos;name&apos;).from(&apos;users&apos;).clearSelect() 输出： 1select * from `users` clearWhere -.clearWhere() 清除查询中的所有where子句，不包括子查询。 例： 1knex.select(&apos;email&apos;, &apos;name&apos;).from(&apos;users&apos;).where(&apos;id&apos;, 1).clearWhere() 输出： 1select `email`, `name` from `users` clearOrder -.clearOrder() 清除查询中的所有订单子句，不包括子查询。 例： 1knex.select().from(&apos;users&apos;).orderBy(&apos;name&apos;, &apos;desc&apos;).clearOrder() 输出： 1select * from `users` distinct -.distinct() 去除重复的记录。 例： 1234// select distinct &apos;first_name&apos; from customersknex(&apos;customers&apos;) .distinct(&apos;first_name&apos;, &apos;last_name&apos;) .select() 输出： 1select distinct `first_name`, `last_name` from `customers` groupBy -.groupBy(*names) 向查询添加一个group by子句。 例： 1knex(&apos;users&apos;).groupBy(&apos;count&apos;) 输出： 1select * from `users` group by `count` groupByRaw -.groupByRaw(sql) 向查询添加一个原始的group by子句。 例： 1knex.select(&apos;year&apos;, knex.raw(&apos;SUM(profit)&apos;)).from(&apos;sales&apos;).groupByRaw(&apos;year WITH ROLLUP&apos;) 输出： 1select `year`, SUM(profit) from `sales` group by year WITH ROLLUP orderBy -.orderBy(column, [direction]) 向查询添加一个order by子句。 例： 1knex(&apos;users&apos;).orderBy(&apos;name&apos;, &apos;desc&apos;) 输出： 1select * from `users` order by `name` desc orderByRaw-.orderByRaw(sql)通过raw子句向查询添加一个订单。 例： 1knex.select(&apos;*&apos;).from(&apos;table&apos;).orderByRaw(&apos;col DESC NULLS LAST&apos;) 输出： 1select * from `table` order by col DESC NULLS LAST offset -.offset(value) 为查询添加一个偏移子句。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).offset(10) 输出： 1select * from `users` limit 18446744073709551615 offset 10 limit -.limit(value)向查询添加限制子句。 例： 1knex.select(&apos;*&apos;).from(&apos;users&apos;).limit(10).offset(30) 输出： 1select * from `users` limit 10 offset 30 union -.union([*queries], [wrap]) 创建联合查询，采用数组或回调列表构建union语句，并使用可选的布尔换行。查询将使用真正的wrap参数单独包装在括号中。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).whereNull(&apos;last_name&apos;).union(function() &#123; this.select(&apos;*&apos;).from(&apos;users&apos;).whereNull(&apos;first_name&apos;);&#125;) 输出： 1select * from `users` where `last_name` is null union select * from `users` where `first_name` is null unionAll -.unionAll(query) 使用与union方法相同的方法签名创建union的所有查询。 例： 123knex.select(&apos;*&apos;).from(&apos;users&apos;).whereNull(&apos;last_name&apos;).unionAll(function() &#123; this.select(&apos;*&apos;).from(&apos;users&apos;).whereNull(&apos;first_name&apos;);&#125;) 输出： 1select * from `users` where `last_name` is null union all select * from `users` where `first_name` is null insert -.insert(data, [returning]) 创建插入查询，将要插入行的属性的哈希或插入的数组作为单个插入命令执行。使用包含插入模型的第一个插入标识的数组或者包含所有插入的postgresql标识的数组或Amazon Redshift的行数解析承诺/实现回调。 例： 12// Returns [1] in &quot;mysql&quot;, &quot;sqlite&quot;, &quot;oracle&quot;; [] in &quot;postgresql&quot; unless the &apos;returning&apos; parameter is set.knex(&apos;books&apos;).insert(&#123;title: &apos;Slaughterhouse Five&apos;&#125;) 输出： 1insert into `books` (`title`) values (&apos;Slaughterhouse Five&apos;) 例： 12// Normalizes for empty keys on multi-row insert:knex(&apos;coords&apos;).insert([&#123;x: 20&#125;, &#123;y: 30&#125;, &#123;x: 10, y: 20&#125;]) 输出： 12insert into `coords` (`x`, `y`) values (20, DEFAULT), (DEFAULT, 30), (10, 20)// Returns [2] in &quot;mysql&quot;, &quot;sqlite&quot;; [2, 3] in &quot;postgresql&quot; 例： 1knex.insert([&#123;title: &apos;Great Gatsby&apos;&#125;, &#123;title: &apos;Fahrenheit 451&apos;&#125;], &apos;id&apos;).into(&apos;books&apos;) 输出： 1insert into `books` (`title`) values (&apos;Great Gatsby&apos;), (&apos;Fahrenheit 451&apos;) 如果一个人更喜欢用一个未定义的键替换NULL而不是DEFAULT一个，可以useNullAsDefault在knex config中给出配置参数。 12345678910111213var knex = require(&apos;knex&apos;)(&#123; client: &apos;mysql&apos;, connection: &#123; host : &apos;127.0.0.1&apos;, user : &apos;your_database_user&apos;, password : &apos;your_database_password&apos;, database : &apos;myapp_test&apos; &#125;, useNullAsDefault: true&#125;);knex(&apos;coords&apos;).insert([&#123;x: 20&#125;, &#123;y: 30&#125;, &#123;x: 10, y: 20&#125;])// insert into `coords` (`x`, `y`) values (20, NULL), (NULL, 30), (10, 20)&quot; returning-.returning(column) / .returning([column1, column2, …]) 由PostgreSQL，MSSQL和Oracle数据库使用，返回方法指定insert和update方法应返回哪一列。Passed column参数可以是字符串或字符串数​​组。传入字符串时，会将SQL结果报告为指定列中的值数组。传入字符串数组时，会将SQL结果报告为对象数组，每个对象包含每个指定列的单个属性。Amazon Redshift不支持返回方法。 例： 1234// Returns [1]knex(&apos;books&apos;) .returning(&apos;id&apos;) .insert(&#123;title: &apos;Slaughterhouse Five&apos;&#125;) 输出： 1insert into `books` (`title`) values (&apos;Slaughterhouse Five&apos;) 例： 1234// Returns [2] in &quot;mysql&quot;, &quot;sqlite&quot;; [2, 3] in &quot;postgresql&quot;knex(&apos;books&apos;) .returning(&apos;id&apos;) .insert([&#123;title: &apos;Great Gatsby&apos;&#125;, &#123;title: &apos;Fahrenheit 451&apos;&#125;]) 输出： 1insert into `books` (`title`) values (&apos;Great Gatsby&apos;), (&apos;Fahrenheit 451&apos;) 例： 1234// Returns [ &#123; id: 1, title: &apos;Slaughterhouse Five&apos; &#125; ]knex(&apos;books&apos;) .returning([&apos;id&apos;,&apos;title&apos;]) .insert(&#123;title: &apos;Slaughterhouse Five&apos;&#125;) 输出： 1insert into `books` (`title`) values (&apos;Slaughterhouse Five&apos;) update-.update(data, [returning]) / .update(key, value, [returning]) 创建更新查询，根据其他查询约束更新属性哈希值或键/值对。使用受影响的查询行数解析promise /履行回调。如果要更新的键的值未定义，则忽略该键。 例： 123456knex(&apos;books&apos;).where(&apos;published_date&apos;, &apos;&lt;&apos;, 2000).update(&#123; status: &apos;archived&apos;, thisKeyIsSkipped: undefined&#125;) 输出： 1update `books` set `status` = &apos;archived&apos; where `published_date` &lt; 2000 例： 12// Returns [1] in &quot;mysql&quot;, &quot;sqlite&quot;, &quot;oracle&quot;; [] in &quot;postgresql&quot; unless the &apos;returning&apos; parameter is set.knex(&apos;books&apos;).update(&apos;title&apos;, &apos;Slaughterhouse Five&apos;) 输出： 1update `books` set `title` = &apos;Slaughterhouse Five&apos; del / delete -.del() 别名为del，因为delete是JavaScript中的保留字，此方法将根据查询中指定的其他条件删除一行或多行。使用受影响的查询行数解析promise /履行回调。 例： 123knex(&apos;accounts&apos;).where(&apos;activated&apos;, false).del() 输出： 1delete from `accounts` where `activated` = false transacting -.transacting(transactionObj) 由knex.transaction使用，交易方法可链接到任何查询，并将希望加入查询的对象作为交易的一部分传递给。 12345678910111213141516var Promise = require(&apos;bluebird&apos;);knex.transaction(function(trx) &#123; knex(&apos;books&apos;).transacting(trx).insert(&#123;name: &apos;Old Books&apos;&#125;) .then(function(resp) &#123; var id = resp[0]; return someExternalMethod(id, trx); &#125;) .then(trx.commit) .catch(trx.rollback);&#125;).then(function(resp) &#123; console.log(&apos;Transaction complete.&apos;);&#125;).catch(function(err) &#123; console.error(err);&#125;); forUpdate -.transacting(t).forUpdate() 在指定事务之后动态添加，forUpdate在select语句期间在PostgreSQL和MySQL中添加FOR UPDATE。由于缺少表锁，在Amazon Redshift上不支持。 例： 1234knex(&apos;tableName&apos;).transacting(trx).forUpdate().select(&apos;*&apos;) 输出： 1select * from `tableName` for update forShare -.transacting(t).forShare() 在指定事务后动态添加的forShare在select语句中添加了PostShareSQL中的FOR SHARE和MySQL中的LOCK IN SHARE MODE。由于缺少表锁，在Amazon Redshift上不支持。 例： 1234knex(&apos;tableName&apos;).transacting(trx).forShare().select(&apos;*&apos;) 输出： 1select * from `tableName` lock in share mode count -.count(column|columns|raw) 对指定的列或列数组执行计数（请注意，某些驱动程序不支持多列）。还接受原始表达式。请注意，在Postgres中，count会返回一个bigint类型，它将是一个String而不是一个Number（更多信息）。 例： 1knex(&apos;users&apos;).count(&apos;active&apos;) 输出： 1select count(`active`) from `users` 例： 1knex(&apos;users&apos;).count(&apos;active as a&apos;) 输出： 1select count(`active`) as `a` from `users` 例： 1knex(&apos;users&apos;).count(&#123; a: &apos;active&apos; &#125;) 输出： 1select count(`active`) as `a` from `users` 例： 1knex(&apos;users&apos;).count(&apos;id&apos;, &apos;active&apos;) 输出： 1select count(`id`) from `users` 例： 1knex(&apos;users&apos;).count(&#123; count: [&apos;id&apos;, &apos;active&apos;] &#125;) 输出： 1select count(`id`, `active`) as `count` from `users` 例： 1knex(&apos;users&apos;).count(knex.raw(&apos;??&apos;, [&apos;active&apos;])) 输出： 1select count(`active`) from `users` 使用countDistinct在聚合函数内添加一个不同的表达式。 例： 1knex(&apos;users&apos;).countDistinct(&apos;active&apos;) 输出： 1select count(distinct `active`) from `users` min -.min(column|columns|raw) 获取指定列或列数组的最小值（请注意，某些驱动程序不支持多列）。还接受原始表达式。 例： 1knex(&apos;users&apos;).min(&apos;age&apos;) 输出： 1select min(`age`) from `users` 例： 1knex(&apos;users&apos;).min(&apos;age as a&apos;) 输出： 1select min(`age`) as `a` from `users` 例： 1knex(&apos;users&apos;).min(&#123; a: &apos;age&apos; &#125;) 输出： 1select min(`age`) as `a` from `users` 例： 1knex(&apos;users&apos;).min(&apos;age&apos;, &apos;logins&apos;) 输出： 1select min(`age`) from `users` 例： 1knex(&apos;users&apos;).min(&#123; min: [&apos;age&apos;, &apos;logins&apos;] &#125;) 输出： 1select min(`age`, `logins`) as `min` from `users` 例： 1knex(&apos;users&apos;).min(knex.raw(&apos;??&apos;, [&apos;age&apos;])) 输出： 1select min(`age`) from `users` max -.max(column|columns|raw) 获取指定列或列数组的最大值（请注意，有些驱动程序不支持多列）。还接受原始表达式。 例： 1knex(&apos;users&apos;).max(&apos;age&apos;) 输出： 1select max(`age`) from `users` 例： 1knex(&apos;users&apos;).max(&apos;age as a&apos;) 输出： 1select max(`age`) as `a` from `users` 例： 1knex(&apos;users&apos;).max(&#123; a: &apos;age&apos; &#125;) 输出： 1select max(`age`) as `a` from `users` 例： 1knex(&apos;users&apos;).max(&apos;age&apos;, &apos;logins&apos;) 输出： 1select max(`age`) from `users` 例： 1knex(&apos;users&apos;).max(&#123; max: [&apos;age&apos;, &apos;logins&apos;] &#125;) 输出： 1select max(`age`, `logins`) as `max` from `users` 例： 1knex(&apos;users&apos;).max(knex.raw(&apos;??&apos;, [&apos;age&apos;])) 输出： 1select max(`age`) from `users` sum -.sum(column|columns|raw) 检索给定列或列数组的值的总和（请注意，某些驱动程序不支持多列）。还接受原始表达式。 例： 1knex(&apos;users&apos;).sum(&apos;products&apos;) 输出： 1select sum(`products`) from `users` 例： 1knex(&apos;users&apos;).sum(&apos;products as p&apos;) 输出： 1select sum(`products`) as `p` from `users` 例： 1knex(&apos;users&apos;).sum(&#123; p: &apos;products&apos; &#125;) 输出： 1select sum(`products`) as `p` from `users` 例： 1knex(&apos;users&apos;).sum(&apos;products&apos;, &apos;orders&apos;) 输出： 1select sum(`products`) from `users` 例： 1knex(&apos;users&apos;).sum(&#123; sum: [&apos;products&apos;, &apos;orders&apos;] &#125;) 输出： 1select sum(`products`, `orders`) as `sum` from `users` 例： 1knex(&apos;users&apos;).sum(knex.raw(&apos;??&apos;, [&apos;products&apos;])) 输出： 1select sum(`products`) from `users` 使用sumDistinct在聚合函数内添加一个不同的表达式。 例： 1knex(&apos;users&apos;).sumDistinct(&apos;products&apos;) 输出： 1select sum(distinct `products`) from `users` avg -.avg(column|columns|raw) 检索给定列或列数组的值的平均值（请注意，有些驱动程序不支持多列）。还接受原始表达式。 例： 1knex(&apos;users&apos;).avg(&apos;age&apos;) 输出： 1select avg(`age`) from `users` 例： 1knex(&apos;users&apos;).avg(&apos;age as a&apos;) 输出： 1select avg(`age`) as `a` from `users` 例： 1knex(&apos;users&apos;).avg(&#123; a: &apos;age&apos; &#125;) 输出： 1select avg(`age`) as `a` from `users` 例： 1knex(&apos;users&apos;).avg(&apos;age&apos;, &apos;logins&apos;) 输出： 1select avg(`age`) from `users` 例： 1knex(&apos;users&apos;).avg(&#123; avg: [&apos;age&apos;, &apos;logins&apos;] &#125;) 输出： 1select avg(`age`, `logins`) as `avg` from `users` 例： 1knex(&apos;users&apos;).avg(knex.raw(&apos;??&apos;, [&apos;age&apos;])) 输出： 1select avg(`age`) from `users` 使用avgDistinct在聚合函数内添加一个不同的表达式。 例： 1knex(&apos;users&apos;).avgDistinct(&apos;age&apos;) 输出： 1select avg(distinct `age`) from `users` increment -.increment(column, amount) 按指定的量增加列值。 例： 123knex(&apos;accounts&apos;).where(&apos;userid&apos;, &apos;=&apos;, 1).increment(&apos;balance&apos;, 10) 输出： 1update `accounts` set `balance` = `balance` + 10 where `userid` = 1 decrement -.decrement(column, amount) 将列值减少指定的量。 例： 1knex(&apos;accounts&apos;).where(&apos;userid&apos;, &apos;=&apos;, 1).decrement(&apos;balance&apos;, 5) 输出： 1update `accounts` set `balance` = `balance` - 5 where `userid` = 1 truncate-.truncate()截断当前表。 例： 1knex(&apos;accounts&apos;).truncate() 输出： 1truncate `accounts` pluck -.pluck(id) 这将从结果中的每一行中抽取指定列，产生一个承诺，解析为所选值的数组。 1knex.table(&apos;users&apos;).pluck(&apos;id&apos;).then(function(ids) &#123; console.log(ids); &#125;); 第一 -.first([columns]) 与select类似，但仅使用查询中的第一条记录检索和解析。 1knex.table(&apos;users&apos;).first(&apos;id&apos;, &apos;name&apos;).then(function(row) &#123; console.log(row); &#125;); clone -.clone() 克隆当前查询链，可用于在不改变原始查询的情况下在其他查询中重复使用部分查询片段。 modify -.modify(fn, *arguments) 允许封装并重新使用查询片段和常见行为作为函数。回调函数应接收查询构建器作为其第一个参数，然后接受传递给其修改的其余（可选）参数。 123456var withUserName = function(queryBuilder, foreignKey) &#123; queryBuilder.leftJoin(&apos;users&apos;, foreignKey, &apos;users.id&apos;).select(&apos;users.user_name&apos;);&#125;;knex.table(&apos;articles&apos;).select(&apos;title&apos;, &apos;body&apos;).modify(withUserName, &apos;articles_user.id&apos;).then(function(article) &#123; console.log(article.user_name);&#125;); columnInfo -.columnInfo([columnName])返回一个对象，其中包含有关当前表的列信息，如果传递了一个列，则返回一个单独的列，返回一个具有以下键的对象：defaultValue：列类型的默认值：列类型maxLength：为此设置的最大长度列可为空：列是否可以为空 1knex(&apos;users&apos;).columnInfo().then(function(info) &#123; // ... &#125;); debug -.debug([enabled]) 覆盖当前查询链的全局调试设置。如果启用省略，查询调试将被打开。 connection（不完整） - 此功能被错误地记录为功能。如果实现，该方法将设置数据库连接用于查询而不使用连接池。 options-.options()允许在数据库客户端特定库中定义的其他选项中进行混合： 12345678910knex(&apos;accounts as a1&apos;).leftJoin(&apos;accounts as a2&apos;, function() &#123; this.on(&apos;a1.email&apos;, &apos;&lt;&gt;&apos;, &apos;a2.email&apos;);&#125;).select([&apos;a1.email&apos;, &apos;a2.email&apos;]).where(knex.raw(&apos;a1.id = 1&apos;)).options(&#123; nestTables: true, rowMode: &apos;array&apos; &#125;).limit(2).then(... queryContext -.queryContext(context) 允许配置要传递给wrapIdentifier和postProcessResponse挂钩的上下文： 123knex(&apos;accounts as a1&apos;).queryContext(&#123; foo: &apos;bar&apos; &#125;).select([&apos;a1.email&apos;, &apos;a2.email&apos;]) 上下文可以是任何类型的值，并将被传递给钩子而不需要修改。但是请注意，在查询构建器实例被克隆时，对象将被浅层克隆，这意味着它们将包含原始对象的所有属性，但不会是同一个对象引用。这允许修改克隆的查询生成器实例的上下文。 queryContext不带参数调用将返回为查询构建器实例配置的任何上下文。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>knexjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米MIX 2线刷步骤]]></title>
    <url>%2F2018%2F06%2F29%2Frefresh-boot%2F</url>
    <content type="text"><![CDATA[刷机背景 MIUI 10首批机型在6月19日进行公测，作为小米发烧友的我也迫不及待想用上MIUI 10, 在MIUI 10首批机型公测下载 中刷机包有两种，分别是卡刷包 和 线刷包。卡刷包刷机 就将刷机包下载到手机，使用手机的版本升级进行刷机，操作比较简单，但是要求只能是相同版本升级，跨版本就不行，比如：稳定版刷机到开发版就是不行的。当然了如果想进行跨版本的升级就只能使用线刷包，比较麻烦，下面我就说一下线刷过程，我只是将刷机步骤资源整合一下，具体步骤会通过链接查看。 刷机机型为 小米MIX 2 刷机系统为 稳定版9.6.xx(具体那个版本记不清了） 线刷大体思路 线刷会清除数据，刷机前做好数据备份 打开开发者选项，绑定绑定账号和设备（可能是出于安全考虑，绑定之后需要72小时之后才能进行解锁BL） 小米手机解锁BL和上锁BL教程 下载刷机包 下载刷机工具进行刷机 友情提示：线刷的时候需要解锁BL，会降低系统安全性，但是使用刷机工具刷机之后会重新给系统上锁BL,所以刷机的小伙伴们，可以放心大胆的刷机。 备份数据 点击设置，进入设置 点击同步，进入同步 点击小米云服务，进入小米云服务 备份系统数据 点击立即同步 备份系统桌面 点击桌面备份，进入桌面备份 点击立即备份 绑定绑定账号和设备（操作后等待72小时） 可以参考下面教程 还在为小米手机如何解锁及解锁后如何加锁而烦恼吗？ 友情提示：小米的开发者选项是隐藏的，可以按 开发者选项在哪里怎么打开 进行打开。 小米手机解锁BL和上锁BL教程 可以参考下面教程（当然了还是它） 还在为小米手机如何解锁及解锁后如何加锁而烦恼吗？ 下载刷机包 下载地址 MIUI 10首批机型公测下载 选择小米MIX 2线刷包下载 下载刷机工具进行刷机 线刷教程 通用线刷教程 感谢 非常感谢刷机教程的提供者们，感谢你们！！！]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2018%2F06%2F20%2Fflex-layout%2F</url>
    <content type="text"><![CDATA[基本概念 Flex布局分为：父容器和子容器，主轴和交叉轴。 关于Flex的属性一共有 13 个，分别是： justify-content align-items align-content flex-direction flex-wrap flex-flow flex-basis flex-grow flex-shrink flex order algn-self display 按作用的对象（子容器和父容器 ）可以分为下面的内容： 按属性的功能，我们大致可以把属性分为 4 大类，分别是： 元素排列（justify-content、align-items、algn-self, align-content） 换行方式 （flex-direction、 flex-wrap、flex-flow） 伸缩方式 （flex-basis、flex-grow、flex-shrink、flex） 主轴排序 （order） 下面从 4 个大类分别介绍每个属性。 元素排列元素排列共有三个属性，分别是： justify-content设置子容器沿主轴排列, 用于定义如何 沿着主轴方向排列子容器。 位置排列 flex-start：起始端对齐 flex-end：末尾段对齐 center：居中对齐 分布排列 space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距 离是子容器间距的一半（子容器和父容器之间的距离是子容器之间距离的一半）。 space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。 align-items 设置子容器如何沿交叉轴排列,用于定义如何 单行 沿着交叉轴向分配子容器的间距。 位置排列 flex-start：起始端对齐 flex-end：末尾段对齐 center：居中对齐 基线对齐 baseline： baseline 默认是指 首行文字，即 first baseline，所有 子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器 将会 与交叉轴起始端相切以确定基线。 拉伸排列 stretch：子容器 沿交叉轴方向的尺寸 拉伸至 与父容器一致。 algn-self 单独设置子容器如何沿交叉轴排列。每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 align-items 属性完全一致，如果两者同时设置则以子容器的 align-self 属性为准。 align-content 多行沿交叉轴对齐, 用于子容器 多行 排列时，设置行与行之间的对齐方式。属性和上面所说的类似，只是 align-content 是 行与行之间 的排列，而 justify-content 、align-items 、 algn-self 是 子容器之间 的排列。 位置排列 flex-start：起始端对齐 flex-end：末尾段对齐 center：居中对齐 分布排列 space-around：等边距均匀分布 space-between：等间距均匀分布 stretch：拉伸对齐 换行方式 flex-direction主轴的方向,用于决定主轴的方向，交叉轴的方向由主轴确定。（其他属性都要参照主轴确定） 主轴 主轴的起始端由 flex-start 表示，末尾段由 flex-end 表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。 向右：flex-direction: row 向下：flex-direction: column 向左：flex-direction: row-reverse 向上：flex-direction: column-reverse 交叉轴 主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由 你flex-start 和 flex-end 表示。 flex-wrap用于决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行。 nowrap：不换行 wrap：换行 wrap-reverse：逆序换行 逆序换行是指沿着交叉轴的反方向换行。 flex-flow flow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行。相当于 flex-direction 与 flex-wrap 的组合。 伸缩方式 flex-basis设置基准大小，表示在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。 flex-grow 设置扩展比例,子容器弹性伸展的比例。剩余空间按比例分配给子容器。 flex-shrink 设置收缩比例, 子容器弹性收缩的比例。超出的部分按比例从给子容器中减去。 flex 主轴上如何伸缩，是上面三个属性的缩写，允许 1 - 3 个值连用，子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定。 无单位数字（如：1, 2, 3） 有单位数字（如：15px，30px，60px） none 关键字。 子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩。 主轴排序 order设置排列顺序,改变子容器的排列顺序，覆盖 HTML 代码中的顺序，默认值为 0，可以为负值，数值越小排列越靠前。 回顾以上就是 flex 布局的全部属性，一共 12 个，父容器、子容器各 6 个，可以随时通过下图进行回顾。 学习误区 Flex布局没有水平轴和垂直轴的概念，只有主轴和交叉轴，主轴可以是水平的也可以是水平的也可以是垂直的，这要根据具体的 flex-direction 属性设置来决定。 在每两个嵌套元素之间都可以使用flex布局，并且flex布局的元素也可以嵌套使用。 感谢参考文章: 一劳永逸的搞定 flex 布局 - osimly Flex 布局教程：语法篇 - 阮一峰 Flex 布局教程：实例篇 - 阮一峰]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将博客源码推送到github上]]></title>
    <url>%2F2018%2F06%2F18%2Fpush-source-code%2F</url>
    <content type="text"><![CDATA[前提 已经搭建了一个Hexo博客 背景 &emsp;&emsp;使用命令 Hexo d 推送到github上的是Hexo生成的静态文件，而如果我们 换一台电脑就无法编辑博客了，所以我们需要把Hexo博客的源码推送到github上，方便我们在其他电脑上也能进行博客的编辑。也保证博客文章不会丢失。(但需要注意的是github上的仓库是开源的，也就是说所有人的都可以看到你的源代码） 新建source-code分支 github上的博客仓库新建 source-code 分支 将 source-code 设置为默认分支 将源代码推送到 source-code 分支上 初始化git仓库 1git init 关联远程仓库 1git remote add origin https://github.com/songxingguo/hexoblog.github.io.git 从远程分支拉取代码,并查看远程分支 1git pull 查看远程分支 1git branch --remote 查看本地分支 1git branch 检出远程分支中的 source-code 分支 1git checkout origin/source-code 进入博客根路径，然后执行下面代码 1234git status git add -Agit commit -m &quot;source code&quot;git push 源码推送到了github的 source-code 分支上了]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序基础学习]]></title>
    <url>%2F2018%2F06%2F15%2FWeChat-Basics%2F</url>
    <content type="text"><![CDATA[模板 模板的作用 避免重复开发，提升效率。 模板类似与React的组件思想提高重用性，但是模板只是只是包括视图和样式，并且两者需要分别引入对应的目标文件中。 模板的定义 创建模板文件 一个模板wxml文件中可以创建多个template，通过name进行区分。 ES6的扩展语法：… , 可以用于将数据解构之后传给模板使用。 .xml文件中定义模板 123&lt;template name=&quot;list-item&quot;&gt; &lt;view class=&quot;kind-list-item&quot;&gt;&lt;/view&gt;&lt;/template&gt; 模板的使用 在.wxml文件中引入模板的.wxml文件 1&lt;import src=&quot;../../components/list-item/list-item.wxml&quot; /&gt; 使用模板 1&lt;template is=&quot;list-item&quot; data=&quot;&#123;&#123;item&#125;&#125;&quot;/&gt; 在.wxss文件中引入模板的.wxss文件 @import &quot;../../components/list-item/list-item.wxss&quot;;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS博客搭建]]></title>
    <url>%2F2018%2F06%2F13%2Fnodejs-blog-build%2F</url>
    <content type="text"><![CDATA[pm2启动服务 pm2官网 安装pm2 1npm install -g pm2 使用 PM2 管理nodejs进程 启动服务 配置pm2.json文件 123456789 &#123;&quot;name&quot;: &quot;dynablog.songxingguo.com&quot;,&quot;script&quot;: &quot;bin/www&quot;,&quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm Z&quot;,&quot;exec_mode&quot;: &quot;cluster&quot;,&quot;instances&quot;: 2,&quot;error_file&quot;: &quot;logs/stderr.log&quot;,&quot;out_file&quot;: &quot;logs/stdout.log&quot; &#125; 加载pm2.json文件 1pm2 reload pm2.json 或 1pm2 start pm2.json 常用命令 常用命令]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题修改]]></title>
    <url>%2F2018%2F06%2F06%2Fhexo-theme%2F</url>
    <content type="text"><![CDATA[前提&emsp;&emsp;已经使用Hexo搭建一个博客 选取自己喜欢的主题&emsp;&emsp;在Hexo 主题列表 中选取一个自己喜欢的主题， &emsp;&emsp;我这儿选取的是 hiker 主题 将主题clone到themes目录下 进入博客根目录，将代码clone到 themes/hiker 目录下 1git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker 效果： 然后进入主题文件目录下，执行 npm install 安装主题依赖的资源 12cd themes/Hikernpm install 效果： 修改博客_config.yml文件 打开博客的—config.yml文件，找到 theme 字段并修改为 hiker 重新启动服务 进入博客根目录，重新启动服务 1234cd ../../hexo clean hexo ghexo s 点击 http://localhost:4000 查看]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客部署到Github Pages]]></title>
    <url>%2F2018%2F06%2F06%2Fdeploy-github-pages%2F</url>
    <content type="text"><![CDATA[前提拥有github账号已经搭建了一个Hexo博客 前景知识Github Pages是一个静态页面服务器，可以用来展示托管在gitbub仓库的静态页面。 Github Pages 提供了三种方式展示静态页面。 仓库以 xx.github.io 命名 仓库创建gh-pages分支 下面以第一种方式推送到Gitbub Pages 创建仓库登录github账号,点击New repository 创建仓库, 输入名称 hexoblog.github.io 点击 Create repository ,创建成功 修改博客配置信息 config.yml打开配置文件 将代码拉到最后找到deploy修改成下面内容: 1234deploy: type: git repository: https://github.com/songxingguo/hexoblog.github.io.git branch: master repository : 上面创建的仓库地址。branch : 提交到仓库的那个分支 修改后,保存 部署博客打开命令行，进入博客项目目录 安装hexo-deployer-git 1npm install hexo-deployer-git --save 然后依次执行下面代码： 清除缓存文件 (db.json) 和已生成的静态文件 (public) 1$ hexo clean 生成静态文件 1$ hexo g 部署网站 1$ hexo d 出现下面界面就部署成功了 修改Github Pages设置进入github查看部署的代码 点击 setting 然后往下拉，找到 Github Pages 选择 master branch 之后保存 点击 Github Pages上的链接，查看博客效果]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Mysql数据库]]></title>
    <url>%2F2018%2F06%2F06%2Flinux-install-mysql%2F</url>
    <content type="text"><![CDATA[安装Mysql数据库 wget 命令下载mysql压缩包（大约300M） 1wget http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.11-linux-glibc2.5-x86_64.tar.gz 2.解压压缩包1tar -zxvf mysql-5.7.11-linux-glibc2.5-x86_64.tar.gz 1rm -f mysql-5.7.11-linux-glibc2.5-x86_64.tar.gz 1mv mysql-5.7.11-linux-glibc2.5-x86_64/ mysql 1groups mysql 1groupadd mysql 1useradd -r -g mysql mysql` 1cd database/mysql-5.7 1chown -R mysql:mysql ./ 常用命令 查看Mysql服务 1lsof -i:3306 或者 1service mysqld status 按名称查找 1find / -name mysql 删除所有查询的mysql 1find / -name mysql|xargs rm -rf]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux配置Node环境]]></title>
    <url>%2F2018%2F06%2F06%2Flinux-node%2F</url>
    <content type="text"><![CDATA[配置node环境 wget命令下载Node.js安装包（下载到当前目录）。 1wget https://nodejs.org/dist/v6.9.5/node-v6.9.5-linux-x64.tar.xz 解压文件（解压到当前目录）。 1tar xvf node-v6.9.5-linux-x64.tar.xz 创建软链接，使node和npm命令全局有效。 12ln -s /root/node-v6.9.5-linux-x64/bin/node /usr/local/bin/nodeln -s /root/node-v6.9.5-linux-x64/bin/npm /usr/local/bin/npm 查看node、npm版本。 12node -vnpm -v nvm管理Node版本 列出Node.js的所有版本。 1nvm list-remote 运行 nvm ls 查看已安装Node.js版本，当前使用的版本为v6.9.5。返回结果如下所示。 1nvm ls NVM的更多操作请参考帮助文档： 1nvm help]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F06%2F04%2Flinux-command%2F</url>
    <content type="text"><![CDATA[文件操作 创建文件 1touch example.js 编辑文件 1vim example.js 输入 i，进入编辑模式。 输入为v进入视图模式，可进行多行选择。 使用Esc按钮，退出编辑模式，输入:wq，回车，保存文件内容并退出。 查看文件 1cat /var/log/mysqld.log 删除文件 1rm example.js 文件夹操作 新建文件夹 1mkdir test 强制并递归删除目录（删除有内容的文件夹） 1rm -rf /root/node-v6.9.5-linux-x64.tar.xz 拷贝文件夹 如将/test1目录下的file1复制到/test3目录，并将文件名改为file2,可输入以下命令： 1cp /test1/file1 /test3/file2 移动文件夹 如将/test1目录下的file1复制到/test3 目录，并将文件名改为file2,可输入以下命令： 1mv /test1/file1 /test3/file2 如果是移动文件夹下的所有文件的话就可以文件夹后面跟上 /* 1mv /data/new/* /data/old/ 目录操作 查看目录中的文件 1ls -l -a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件 -a 横向展示 1ls -a -all 竖向展示 1ls -all 查看目录文件 1ll 相对路径 1root/data 绝对路径(最前面多一个斜杠） 1/root/data 回到根目录 1../.. ~代表你的/home/用户名目录 假设你的用户名是x，那么~/就是/home/x/ . 是代表此目录本身，但是一般可以不写 所以cd ~/. 和cd ~ 和cd ~/效果是一样的 文件下载目录 wget等命令行工具：默认下载到运行该程序的当前目录 浏览器：默认的下载目录一般在桌面，具体情况可以查看设置 其他下载工具：一般都会在/home/用户名/里面的该工具的隐藏目录下或是新建的download目录下，具体情况请查看配置文件 链接操作 添加链接 1ln -s /usr/jboss4.0.5.GA/jboss 删除链接 1rm /usr/jboss4.0.5.GA/jboss 综合应用 将文件移动位置并改变链接123456mkdir -p /opt/node/mv /root/node-v6.9.5-linux-x64/* /opt/node/rm -f /usr/local/bin/noderm -f /usr/local/bin/npmln -s /opt/node/bin/node /usr/local/bin/nodeln -s /opt/node/bin/npm /usr/local/bin/npm 进程 查看进程 1ps -ef|grep mysqld 或者 1ps aux|grep mysql 杀死进程(上边的进程号) 1kill -9 112704 杀死所有输出的进程 1ps aux|grep mysql|awk &apos;&#123;print $2&#125;&apos;|xargs kill -9]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2018%2F06%2F02%2Fblog-build%2F</url>
    <content type="text"><![CDATA[前言大三的我，做过项目，平时也看了不少的书，但是能记住却少之有少。于是我希望通过博客将学过的知识整理下来，形成自己的知识体系。在今年上半年开始就打算搭建博客，在网上百度了各种资料，找到博客三种搭建方式: Wordpress、Jekyll、Hexo。其中Wordpress是需要服务器的，作为学生党的我当然没钱买服务器了，于是果断放弃了Wordpress,那就再看看Jekeyll吧，就来到了Jekyll的官网 ，看了一下是不需要服务器的 ，那就撸起袖子开干吧，按着官方的教程往下弄，但Jekyll是设计是基于Ruby的，而我又没有Ruby的环境，那就顺理成章的来到了Ruby的官网找到了Windows系统的下载连接。但说起最气的就是安装Ruby了，下载一个只有8兆左右的却怎么也下载不下来，下载了一半结果进度就不动了，接着试了几次，都没下载下来。那个真是把我气的那是不要不要的。这东西光是下载下来就花了我接近一个小时。最后在千辛万苦下终于还是弄出来了一个Jekeyll的博客。当然了，前面的说所的一切都是我们今天的主角Hexo做铺垫的。下面我们正式进入正题吧。 大纲 Hello Wrold 博客部署到Github Pages 更换主题 可视化编写文档 将源代码推送到github相同仓库的不同分支 使用Travis CI 进行自动发布代码 将博客推送给百度 使用Coding作为国内访问站点 实现windows开机启动Hexo 服务 图床七牛云 优秀教程 统计访问量Hexo搭建博客系列：（五）Hexo添加不蒜子和LeanCloud统计无标题文章 gh-pages 展示项目如何用Github的gh-pages分支展示自己的项目 Travis CI 自动部署使用 Travis CI 自动更新 GitHub Pages]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo问题解决]]></title>
    <url>%2F2018%2F06%2F02%2FHexo-problem%2F</url>
    <content type="text"><![CDATA[服务busy结束服务，使用命令清除1hexo clean 重新启动服务1hexo s]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TravisCI]]></title>
    <url>%2F2018%2F05%2F19%2FavisCI%2F</url>
    <content type="text"><![CDATA[#TravisCI学习入门]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>TravisCI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[快速开始 前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git Windows系统 安装hexo脚手架打开命令行工具，全局安装hexo脚手架 1npm install -g hexo-cli 安装成功： 新建博客进入项目存放的目录，执行代码： 12345678910111213141516171819 hexo init hexo-blog cd hexo-blog npm install ``` hexo-blog 为博客写项目的名称 文件目录：![文件目录](http://p9myzkds7.bkt.clouddn.com/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png)新建完成后，指定文件夹的目录如下： ```bash . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml 博客配置信息。 package.json 应用程序的信息。 scaffolds 模版文件夹。 source 资源文件夹是存放用户资源的地方。 themes 主题文件夹。Hexo 会根据主题来生成静态页面。 启动服务代码 1hexo server 或 1hexo s 运行命令 访问端口 http://localhost:4000/]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React进阶]]></title>
    <url>%2F2018%2F03%2F26%2Freact-advanced%2F</url>
    <content type="text"><![CDATA[React进阶前端应用状态管理 —— 状态提升我们将这种组件之间共享的状态交给组件最近的公共父节点保管，然后通过 props 把状态传递给子组件，这样就可以在组件之间共享数据了。 总结一下：当某个状态被多个组件依赖或者影响的时候，就把该状态提升到这些组件的最近公共父组件中去管理，用 props 传递数据或者函数来管理这种依赖或着影响的行为。 你可以看到 React.js 并没有提供好的解决方案来管理这种组件之间的共享状态。在实际项目当中状态提升并不是一个好的解决方案，所以我们后续会引入 Redux 这样的状态管理工具来帮助我们来管理这种共享状态，但是在讲解到 Redux 之前，我们暂时采取状态提升的方式来进行管理。 对于不会被多个组件依赖和影响的状态（例如某种下拉菜单的展开和收起状态），一般来说只需要保存在组件内部即可，不需要做提升或者特殊的管理。 挂载阶段的组件生命周期（一）React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载。这一节我们学习了 React.js 控制组件在页面上挂载和删除过程里面几个方法： componentWillMount：组件挂载开始之前，也就是在组件调用 render 方法之前调用。componentDidMount：组件挂载完成以后，也就是 DOM 元素已经插入页面后调用。componentWillUnmount：组件对应的 DOM 元素从页面中删除之前调用。但这一节并没有讲这几个方法到底在实际项目当中有什么作用，下一节我们通过例子来讲解一下这几个方法的用途。 挂载阶段的组件生命周期（二）一般来说，所有关于组件自身的状态的初始化工作都会放在 constructor 里面去做。你会发现本书所有组件的 state 的初始化工作都是放在 constructor 里面的。 一些组件启动的动作，包括像 Ajax 数据的拉取操作、一些定时器的启动等，就可以放在 componentWillMount 里面进行，例如 Ajax：1234567... componentWillMount () &#123; ajax.get('http://json-api.com/user', (userData) =&gt; &#123; this.setState(&#123; userData &#125;) &#125;) &#125;... 多次的隐藏和显示会让 React.js 重新构造和销毁 Clock 组件，每次构造都会重新构建一个定时器。而销毁组件的时候没有清除定时器，所以你看到报错会越来越多。而且因为 JavaScript 的闭包特性，这样会导致严重的内存泄漏。 这时候componentWillUnmount 就可以派上用场了，它的作用就是在组件销毁的时候，做这种清场的工作。例如清除该组件的定时器和其他的数据清理工作。我们给 Clock 添加 componentWillUnmount，在组件销毁的时候清除该组件的定时器： 12345... componentWillUnmount () &#123; clearInterval(this.timer) &#125;... 我们一般会把组件的 state 的初始化工作放在 constructor 里面去做；在 componentWillMount 进行组件的启动工作，例如 Ajax 数据拉取、定时器的启动；组件从页面上销毁的时候，有时候需要一些数据的清理，例如定时器的清理，就会放在 componentWillUnmount 里面去做。 说一下本节没有提到的 componentDidMount 。一般来说，有些组件的启动工作是依赖 DOM 的，例如动画的启动，而 componentWillMount 的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在 componentDidMount 当中。componentDidMount 的具体使用我们会在接下来的章节当中结合 DOM 来讲。 更新阶段的组件生命周期从之前的章节我们了解到，组件的挂载指的是将组件渲染并且构造 DOM 元素然后插入页面的过程。这是一个从无到有的过程，React.js 提供一些生命周期函数可以给我们在这个过程中做一些操作。 除了挂载阶段，还有一种“更新阶段”。说白了就是 setState 导致 React.js 重新渲染组件并且把组件的变化应用到 DOM 元素上的过程，这是一个组件的变化过程。而 React.js 也提供了一系列的生命周期函数可以让我们在这个组件更新的过程执行一些操作。 关于更新阶段的组件生命周期： shouldComponentUpdate(nextProps, nextState)：你可以通过这个方法控制组件是否重新渲染。如果返回 false 组件就不会重新渲染。这个生命周期在 React.js 性能优化上非常有用。componentWillReceiveProps(nextProps)：组件从父组件接收到新的 props 之前调用。componentWillUpdate()：组件开始重新渲染之前调用。componentDidUpdate()：组件重新渲染并且把更改变更到真实的 DOM 以后调用。 但这里建议大家可以先简单了解 React.js 组件是有更新阶段的，并且有这么几个更新阶段的生命周期即可。然后在深入项目实战的时候逐渐地掌握理解他们，现在并不需要对他们放过多的精力。 irtual-DOM 策略:https://github.com/livoras/blog/issues/13 ref 和 React.js 中的 DOM 操作在 React.js 当中你基本不需要和 DOM 直接打交道。React.js 提供了一系列的 on* 方法帮助我们进行事件监听，所以 React.js 当中不需要直接调用 addEventListener 的 DOM API；以前我们通过手动 DOM 操作进行页面更新（例如借助 jQuery），而在 React.js 当中可以直接通过 setState 的方式重新渲染组件，渲染的时候可以把新的 props 传递给子组件，从而达到页面更新的效果。 React.js 这种重新渲染的机制帮助我们免除了绝大部分的 DOM 更新操作，也让类似于 jQuery 这种以封装 DOM 操作为主的第三方的库从我们的开发工具链中删除。 但是 React.js 并不能完全满足所有 DOM 操作需求，有些时候我们还是需要和 DOM 打交道。比如说你想进入页面以后自动 focus 到某个输入框，你需要调用 input.focus() 的 DOM API，比如说你想动态获取某个 DOM 元素的尺寸来做后续的动画，等等。 React.js 当中提供了 ref 属性来帮助我们获取已经挂载的元素的 DOM 节点，你可以给某个 JSX 元素加上 ref属性：12345678910111213141516class AutoFocusInput extends Component &#123; componentDidMount () &#123; this.input.focus() &#125; render () &#123; return ( &lt;input ref=&#123;(input) =&gt; this.input = input&#125; /&gt; ) &#125;&#125;ReactDOM.render( &lt;AutoFocusInput /&gt;, document.getElementById('root')) 可以看到我们给 input 元素加了一个 ref 属性，这个属性值是一个函数。当 input 元素在页面上挂载完成以后，React.js 就会调用这个函数，并且把这个挂载以后的 DOM 节点传给这个函数。在函数中我们把这个 DOM 元素设置为组件实例的一个属性，这样以后我们就可以通过 this.input 获取到这个 DOM 元素。 然后我们就可以在 componentDidMount 中使用这个 DOM 元素，并且调用 this.input.focus() 的 DOM API。整体就达到了页面加载完成就自动 focus 到输入框的功能（大家可以注意到我们用上了 componentDidMount 这个组件生命周期）。 我们可以给任意代表 HTML 元素标签加上 ref 从而获取到它 DOM 元素然后调用 DOM API。但是记住一个原则：能不用 ref 就不用。特别是要避免用 ref 来做 React.js 本来就可以帮助你做到的页面自动更新的操作和事件监听。多余的 DOM 操作其实是代码里面的“噪音”，不利于我们理解和维护。 顺带一提的是，其实可以给组件标签也加上 ref ，例如：1&lt;Clock ref=&#123;(clock) =&gt; this.clock = clock&#125; /&gt; 这样你获取到的是这个 Clock 组件在 React.js 内部初始化的实例。但这并不是什么常用的做法，而且也并不建议这么做，所以这里就简单提及，有兴趣的朋友可以自己学习探索。 props.children 和容器类组件dangerouslySetHTML 和 style 属性dangerouslySetHTML于安全考虑的原因（XSS 攻击），在 React.js 当中所有的表达式插入的内容都会被自动转义，就相当于 jQuery 里面的 text(…) 函数一样，任何的 HTML 格式都会被转义掉： 12345678910111213141516class Editor extends Component &#123; constructor() &#123; super() this.state = &#123; content: '&lt;h1&gt;React.js 小书&lt;/h1&gt;' &#125; &#125; render () &#123; return ( &lt;div className='editor-wrapper'&gt; &#123;this.state.content&#125; &lt;/div&gt; ) &#125;&#125; 表达式插入并不会把一个渲染到页面，而是把它的文本形式渲染了。那要怎么才能做到设置动态 HTML 结构的效果呢？React.js 提供了一个属性 dangerouslySetInnerHTML，可以让我们设置动态设置元素的 innerHTML： 123456789... render () &#123; return ( &lt;div className='editor-wrapper' dangerouslySetInnerHTML=&#123;&#123;__html: this.state.content&#125;&#125; /&gt; ) &#125;... 需要给 dangerouslySetInnerHTML 传入一个对象，这个对象的 __html 属性值就相当于元素的 innerHTML，这样我们就可以动态渲染元素的 innerHTML 结构了。 有写朋友会觉得很奇怪，为什么要把一件这么简单的事情搞得这么复杂，名字又长，还要传入一个奇怪的对象。那是因为设置 innerHTML 可能会导致跨站脚本攻击（XSS），所以 React.js 团队认为把事情搞复杂可以防止（警示）大家滥用这个属性。这个属性不必要的情况就不要使用。 style在 React.js 中你需要把 CSS 属性变成一个对象再传给元素：1&lt;h1 style=&#123;&#123;fontSize: '12px', color: 'red'&#125;&#125;&gt;React.js 小书&lt;/h1&gt; style 接受一个对象，这个对象里面是这个元素的 CSS 属性键值对，原来 CSS 属性中带 - 的元素都必须要去掉 - 换成驼峰命名，如 font-size 换成 fontSize，text-align 换成 textAlign。 用对象作为 style 方便我们动态设置元素的样式。我们可以用 props 或者 state 中的数据生成样式对象再传给元素，然后用 setState 就可以修改样式，非常灵活： 1&lt;h1 style=&#123;&#123;fontSize: '12px', color: this.state.color&#125;&#125;&gt;React.js 小书&lt;/h1&gt; 只要简单地 setState({color: ‘blue’}) 就可以修改元素的颜色成蓝色。 PropTypes 和组件参数验证都说 JavaScript 是一门灵活的语言 —— 这就是像是说“你是个好人”一样，凡事都有背后没有说出来的话。JavaScript 的灵活性体现在弱类型、高阶函数等语言特性上。而语言的弱类型一般来说确实让我们写代码很爽，但是也很容易出 bug。 变量没有固定类型可以随意赋值，在我们构建大型应用程序的时候并不是什么好的事情。你写下了 let a = {} ，如果这是个共享的状态并且在某个地方把 a = 3，那么 a.xxx 就会让程序崩溃了。而这种非常隐晦但是低级的错误在强类型的语言例如 C/C++、Java 中是不可能发生的，这些代码连编译都不可能通过，也别妄图运行。 大型应用程序的构建其实更适合用强类型的语言来构建，它有更多的规则，可以帮助我们在编写代码阶段、编译阶段规避掉很多问题，让我们的应用程序更加的安全。JavaScript 早就脱离了玩具语言的领域并且投入到大型的应用程序的生产活动中，因为它的弱类型，常常意味着不是很安全。所以近年来出现了类似 TypeScript 和 Flow 等技术，来弥补 JavaScript 这方面的缺陷。 于是 React.js 就提供了一种机制，让你可以给组件的配置参数加上类型验证，就用上述的评论组件例子，你可以配置 Comment 只能接受对象类型的 comment 参数，你传个数字进来组件就强制报错。我们这里先安装一个 React 提供的第三方库 prop-types： 它可以帮助我们验证 props 的参数类型，例如：1234567891011121314151617181920import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'class Comment extends Component &#123; static propTypes = &#123; comment: PropTypes.object &#125; render () &#123; const &#123; comment &#125; = this.props return ( &lt;div className='comment'&gt; &lt;div className='comment-user'&gt; &lt;span&gt;&#123;comment.username&#125; &lt;/span&gt;： &lt;/div&gt; &lt;p&gt;&#123;comment.content&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 注意我们在文件头部引入了 PropTypes，并且给 Comment 组件类添加了类属性 propTypes，里面的内容的意思就是你传入的 comment 类型必须为 object（对象）。 虽然 propTypes 帮我们指定了参数类型，但是并没有说这个参数一定要传入，事实上，这些参数默认都是可选的。可选参数我们可以通过配置 defaultProps，让它在不传入的时候有默认值。但是我们这里并没有配置 defaultProps，所以如果直接用 而不传入任何参数的话，comment 就会是 undefined，comment.username 会导致程序报错： 这个出错信息并不够友好。我们可以通过 isRequired 关键字来强制组件某个参数必须传入：12345...static propTypes = &#123; comment: PropTypes.object.isRequired&#125;... React.js 提供的 PropTypes 提供了一系列的数据类型可以用来配置组件的参数：123456789PropTypes.arrayPropTypes.boolPropTypes.funcPropTypes.numberPropTypes.objectPropTypes.stringPropTypes.nodePropTypes.element... 更多类型及其用法可以参看官方文档： Typechecking With PropTypes - React。https://facebook.github.io/react/docs/typechecking-with-proptypes.html 组件参数验证在构建大型的组件库的时候相当有用，可以帮助我们迅速定位这种类型错误，让我们组件开发更加规范。另外也起到了一个说明文档的作用，如果大家都约定都写 propTypes ，那你在使用别人写的组件的时候，只要看到组件的 propTypes 就清晰地知道这个组件到底能够接受什么参数，什么参数是可选的，什么参数是必选的。 总结通过 PropTypes 给组件的参数做类型限制，可以在帮助我们迅速定位错误，这在构建大型应用程序的时候特别有用；另外，给组件加上 propTypes，也让组件的开发、使用更加规范清晰。 这里建议大家写组件的时候尽量都写 propTypes，有时候有点麻烦，但是是值得的。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React入门]]></title>
    <url>%2F2018%2F03%2F25%2Freact-primer%2F</url>
    <content type="text"><![CDATA[React学习React渲染页面的过程JSX 到页面的渲染如下图： 有些同学可能会问，为什么不直接从 JSX 直接渲染构造 DOM 结构，而是要经过中间这么一层呢？ 第一个原因是，当我们拿到一个表示 UI 的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能把这个结构渲染到 canvas 上，或者是手机 App 上。所以这也是为什么会要把 react-dom 单独抽离出来的原因，可以想象有一个叫 react-canvas 可以帮我们把 UI 渲染到 canvas 上，或者是有一个叫 react-app 可以帮我们把它转换成原生的 App（实际上这玩意叫 ReactNative）。 第二个原因是，有了这样一个对象。当数据变化，需要更新组件的时候，就可以用比较快的算法操作这个 JavaScript 对象，而不用直接操作页面上的 DOM，这样可以尽量少的减少浏览器重排，极大地优化性能。这个在以后的章节中我们会提到。 JSX中{}的使用简而言之，{} 内可以放任何 JavaScript 的代码，包括变量、表达式计算、函数执行等等 12345678910111213141516...render () &#123; const isGoodWord = true return ( &lt;div&gt; &lt;h1&gt; React 小书 &#123;isGoodWord ? &lt;strong&gt; is good&lt;/strong&gt; : null &#125; &lt;/h1&gt; &lt;/div&gt; )&#125;... 这样就相当于在 isGoodWord 为 true 的时候显示 is good，否则就隐藏。 条件返回 JSX 的方式在 React.js 中很常见，组件的呈现方式随着数据的变化而不一样，你可以利用 JSX 这种灵活的方式随时组合构建不同的页面结构。 JSX 元素变量同样的，如果你能理解 JSX 元素就是 JavaScript 对象。那么你就可以联想到，JSX 元素其实可以像 JavaScript 对象那样自由地赋值给变量，或者作为函数参数传递、或者作为函数的返回值。 123456789101112131415...render () &#123; const isGoodWord = true const goodWord = &lt;strong&gt; is good&lt;/strong&gt; const badWord = &lt;span&gt; is not good&lt;/span&gt; return ( &lt;div&gt; &lt;h1&gt; React 小书 &#123;isGoodWord ? goodWord : badWord&#125; &lt;/h1&gt; &lt;/div&gt; )&#125;... 1234567891011121314151617181920...renderGoodWord (goodWord, badWord) &#123; const isGoodWord = true return isGoodWord ? goodWord : badWord&#125;render () &#123; return ( &lt;div&gt; &lt;h1&gt; React 小书 &#123;this.renderGoodWord( &lt;strong&gt; is good&lt;/strong&gt;, &lt;span&gt; is not good&lt;/span&gt; )&#125; &lt;/h1&gt; &lt;/div&gt; )&#125;... 这里我们定义了一个 renderGoodWord 函数，这个函数接受两个 JSX 元素作为参数，并且随机返回其中一个。在 render 方法中，我们把上面例子的两个 JSX 元素传入 renderGoodWord 当中，通过表达式插入把该函数返回的 JSX 元素插入到页面上 JSX与html中不不同之处直接使用 class 在 React.js 的元素上添加类名如 这种方式是不合法的。因为 class 是 JavaScript 的关键字，所以 React.js 中定义了一种新的方式：className 来帮助我们给元素添加类名。 还有一个特例就是 for 属性，例如 Male，因为 for 也是 JavaScript 的关键字，所以在 JSX 用 htmlFor 替代，即 Male。而其他的 HTML 属性例如 style 、data-* 等就可以像普通的 HTML 属性那样直接添加上去。 自定义组件和组件树自定义的组件都必须要用大写字母开头，普通的 HTML 标签都用小写字母开头。 组件可以和组件组合在一起，组件内部可以使用别的组件。就像普通的 HTML 标签一样使用就可以。这样的组合嵌套，最后构成一个所谓的组件树，就正如上面的例子那样，Index 用了 Header、Main、Footer，Header 又使用了 Title 。这样用这样的树状结构表示它们之间的关系： 这里的结构还是比较简单，因为我们的页面结构并不复杂。当页面结构复杂起来，有许多不同的组件嵌套组合的话，组件树会相当的复杂和庞大。理解组件树的概念对后面理解数据是如何在组件树内自上往下流动过程很重要。 事件监听在 React.js 里面监听事件是很容易的事情，你只需要给需要监听事件的元素加上属性类似于 onClick、onKeyDown 这样的属性，例如我们现在要给 Title 加上点击的事件监听：1234567891011class Title extends Component &#123; handleClickOnTitle () &#123; console.log('Click on title.') &#125; render () &#123; return ( &lt;h1 onClick=&#123;this.handleClickOnTitle&#125;&gt;React 小书&lt;/h1&gt; ) &#125;&#125; 只需要给 h1 标签加上 onClick 的事件，onClick 紧跟着是一个表达式插入，这个表达式返回一个 Title 自己的一个实例方法。当用户点击 h1 的时候，React.js 就会调用这个方法，所以你在控制台就可以看到 Click on title. 打印出来。 在 React.js 不需要手动调用浏览器原生的 addEventListener 进行事件监听。React.js 帮我们封装好了一系列的 on 的属性，当你需要为某个元素监听某个事件的时候，只需要简单地给它加上 on 就可以了。而且你不需要考虑不同浏览器兼容性的问题，React.js 都帮我们封装好这些细节了。 React.js 封装了不同类型的事件:https://facebook.github.io/react/docs/events.html#supported-events 另外要注意的是，这些事件属性名都必须要用驼峰命名法。 这些 on* 的事件监听只能用在普通的 HTML 的标签上，而不能用在组件标签上。 event 对象和普通浏览器一样，事件监听函数会被自动传入一个 event 对象，这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致。不同的是 React.js 中的 event 对象并不是浏览器提供的，而是它自己内部所构建的。React.js 将浏览器原生的 event 对象封装了一下，对外提供统一的 API 和属性，这样你就不用考虑不同浏览器的兼容性问题。这个 event 对象是符合 W3C 标准（ W3C UI Events ）的，它具有类似于event.stopPropagation、event.preventDefault 这种常用的方法。 关于事件中的 this一般在某个类的实例方法里面的 this 指的是这个实例本身。但是你在上面的 handleClickOnTitle 中把 this 打印出来，你会看到 this 是 null 或者 undefined。12345... handleClickOnTitle (e) &#123; console.log(this) // =&gt; null or undefined &#125;... 这是因为 React.js 调用你所传给它的方法的时候，并不是通过对象方法的方式调用（this.handleClickOnTitle），而是直接通过函数调用 （handleClickOnTitle），所以事件监听函数内并不能通过 this 获取到实例。 如果你想在事件函数当中使用当前的实例，你需要手动地将实例方法 bind 到当前实例上再传入给 React.js。 bind 会把实例方法绑定到当前实例上，然后我们再把绑定后的函数传给 React.js 的 onClick 事件监听。 你也可以在 bind 的时候给事件监听函数传入一些参数：1234567891011class Title extends Component &#123; handleClickOnTitle (word, e) &#123; console.log(this, word) &#125; render () &#123; return ( &lt;h1 onClick=&#123;this.handleClickOnTitle.bind(this, 'Hello')&#125;&gt;React 小书&lt;/h1&gt; ) &#125;&#125; 这种 bind 模式在 React.js 的事件监听当中非常常见，bind 不仅可以帮我们把事件监听方法中的 this 绑定到当前组件实例上；还可以帮助我们在在渲染列表元素的时候，把列表元素传入事件监听函数当中——这个将在以后的章节提及。 如果有些同学对 JavaScript 的 this 模式或者 bind 函数的使用方式不是特别了解到话，可能会对这部分内容会有些迷惑，可以补充对 JavaScript 的 this 和 bind 相关的知识再来回顾这部分内容。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind 总结为 React 的组件添加事件监听是很简单的事情，你只需要使用 React.js 提供了一系列的 on* 方法即可。 React.js 会给每个事件监听传入一个 event 对象，这个对象提供的功能和浏览器提供的功能一致，而且它是兼容所有浏览器的。 React.js 的事件监听方法需要手动 bind 到当前实例，这种模式在 React.js 中非常常用。 组件的state和setState一个组件的显示形态是可以由它数据状态和配置参数决定的。一个组件可以拥有自己的状态，就像一个点赞按钮，可以有“已点赞”和“未点赞”状态，并且可以在这两种状态之间进行切换。React.js 的 state 就是用来存储这种可变化的状态的。12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react'import ReactDOM from 'react-dom'import './index.css'class LikeButton extends Component &#123; constructor () &#123; super() this.state = &#123; isLiked: false &#125; &#125; handleClickOnLikeButton () &#123; this.setState(&#123; isLiked: !this.state.isLiked &#125;) &#125; render () &#123; return ( &lt;button onClick=&#123;this.handleClickOnLikeButton.bind(this)&#125;&gt; &#123;this.state.isLiked ? '取消' : '点赞'&#125; ?? &lt;/button&gt; ) &#125;&#125;... isLiked 存放在实例的 state 对象当中，这个对象在构造函数里面初始化。这个组件的 render 函数内，会根据组件的 state 的中的isLiked不同显示“取消”或“点赞”内容。并且给 button 加上了点击的事件监听。 setState 接受对象参数setState 方法由父类 Component 所提供。当我们调用这个函数的时候，React.js 会更新组件的状态 state ，并且重新调用 render 方法，然后再把 render 方法所渲染的最新的内容显示到页面上。 注意，当我们要改变组件的状态的时候，不能直接用 this.state = xxx 这种方式来修改，如果这样做 React.js 就没办法知道你修改了组件的状态，它也就没有办法更新页面。所以，一定要使用 React.js 提供的 setState 方法，它接受一个对象或者函数作为参数。 传入一个对象的时候，这个对象表示该组件的新状态。但你只需要传入需要更新的部分就可以了，而不需要传入整个对象。123456789101112131415... constructor (props) &#123; super(props) this.state = &#123; name: 'Tomy', isLiked: false &#125; &#125; handleClickOnLikeButton () &#123; this.setState(&#123; isLiked: !this.state.isLiked &#125;) &#125;... 因为点击的时候我们并不需要修改 name，所以只需要传入 isLiked 就行了。Tomy 还是那个 Tomy，而 isLiked 已经不是那个 isLiked 了。 setState 接受函数参数这里还有要注意的是，当你调用 setState 的时候，React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。这一点要好好注意。可以体会一下下面的代码：123456789... handleClickOnLikeButton () &#123; console.log(this.state.isLiked) this.setState(&#123; isLiked: !this.state.isLiked &#125;) console.log(this.state.isLiked) &#125;... 你会发现两次打印的都是 false，即使我们中间已经 setState 过一次了。这并不是什么 bug，只是 React.js 的 setState 把你的传进来的状态缓存起来，稍后才会帮你更新到 state 上，所以你获取到的还是原来的 isLiked。 所以如果你想在 setState 之后使用新的 state 来做后续运算就做不到了，例如：1234567... handleClickOnLikeButton () &#123; this.setState(&#123; count: 0 &#125;) // =&gt; this.state.count 还是 undefined this.setState(&#123; count: this.state.count + 1&#125;) // =&gt; undefined + 1 = NaN this.setState(&#123; count: this.state.count + 2&#125;) // =&gt; NaN + 2 = NaN &#125;... 上面的代码的运行结果并不能达到我们的预期，我们希望 count 运行结果是 3 ，可是最后得到的是 NaN。但是这种后续操作依赖前一个 setState 的结果的情况并不罕见。 这里就自然地引出了 setState 的第二种使用方式，可以接受一个函数作为参数。React.js 会把上一个 setState 的结果传入这个函数，你就可以使用该结果进行运算、操作，然后返回一个对象作为更新 state 的对象：1234567891011121314... handleClickOnLikeButton () &#123; this.setState((prevState) =&gt; &#123; return &#123; count: 0 &#125; &#125;) this.setState((prevState) =&gt; &#123; return &#123; count: prevState.count + 1 &#125; // 上一个 setState 的返回是 count 为 0，当前返回 1 &#125;) this.setState((prevState) =&gt; &#123; return &#123; count: prevState.count + 2 &#125; // 上一个 setState 的返回是 count 为 1，当前返回 3 &#125;) // 最后的结果是 this.state.count 为 3 &#125;... 这样就可以达到上述的利用上一次 setState 结果进行运算的效果。 上面我们进行了三次 setState，但是实际上组件只会重新渲染一次，而不是三次；这是因为在 React.js 内部会把 JavaScript 事件循环中的消息队列的同一个消息中的 setState 都进行合并以后再重新渲染组件。 深层的原理并不需要过多纠结，你只需要记住的是：在使用 React.js 的时候，并不需要担心多次进行 setState 会带来性能问题。 配置组件的 props组件是相互独立、可复用的单元，一个组件可能在不同地方被用到。但是在不同的场景下对这个组件的需求可能会根据情况有所不同，例如一个点赞按钮组件，在我这里需要它显示的文本是“点赞”和“取消”，当别的同事拿过去用的时候，却需要它显示“赞”和“已赞”。如何让组件能适应不同场景下的需求，我们就要让组件具有一定的“可配置”性。 React.js 的 props 就可以帮助我们达到这个效果。每个组件都可以接受一个 props 参数，它是一个对象，包含了所有你对这个组件的配置。 下面的代码可以让它达到上述的可配置性：12345678910111213141516171819202122class LikeButton extends Component &#123; constructor () &#123; super() this.state = &#123; isLiked: false &#125; &#125; handleClickOnLikeButton () &#123; this.setState(&#123; isLiked: !this.state.isLiked &#125;) &#125; render () &#123; const likedText = this.props.likedText || '取消' const unlikedText = this.props.unlikedText || '点赞' return ( &lt;button onClick=&#123;this.handleClickOnLikeButton.bind(this)&#125;&gt; &#123;this.state.isLiked ? likedText : unlikedText&#125; ?? &lt;/button&gt; ) &#125;&#125; 从 render 函数可以看出来，组件内部是通过 this.props 的方式获取到组件的参数的，如果 this.props 里面有需要的属性我们就采用相应的属性，没有的话就用默认的属性。 那么怎么把 props 传进去呢？在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为 props 对象的键值：123456789class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;LikeButton likedText='已赞' unlikedText='赞' /&gt; &lt;/div&gt; ) &#125;&#125; 就像你在用普通的 HTML 标签的属性一样，可以把参数放在表示组件的标签上，组件内部就可以通过 this.props 来访问到这些配置参数了。 前面的章节我们说过，JSX 的表达式插入可以在标签属性上使用。所以其实可以把任何类型的数据作为组件的参数，包括字符串、数字、对象、数组、甚至是函数等等。例如现在我们把一个对象传给点赞组件作为参数：123456789class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;LikeButton wordings=&#123;&#123;likedText: '已赞', unlikedText: '赞'&#125;&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 现在我们把 likedText 和 unlikedText 这两个参数封装到一个叫 wordings 的对象参数内，然后传入点赞组件中。大家看到 这样的代码的时候，不要以为是什么新语法。之前讨论过，JSX 的 {} 内可以嵌入任何表达式， 这时候，点赞按钮的内部就要用 this.props.wordings 来获取到到参数了： 123456789101112131415161718192021222324class LikeButton extends Component &#123; constructor () &#123; super() this.state = &#123; isLiked: false &#125; &#125; handleClickOnLikeButton () &#123; this.setState(&#123; isLiked: !this.state.isLiked &#125;) &#125; render () &#123; const wordings = this.props.wordings || &#123; likedText: '取消', unlikedText: '点赞' &#125; return ( &lt;button onClick=&#123;this.handleClickOnLikeButton.bind(this)&#125;&gt; &#123;this.state.isLiked ? wordings.likedText : wordings.unlikedText&#125; ?? &lt;/button&gt; ) &#125;&#125; 甚至可以往组件内部传入函数作为参数：1234567891011class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;LikeButton wordings=&#123;&#123;likedText: '已赞', unlikedText: '赞'&#125;&#125; onClick=&#123;() =&gt; console.log('Click on like button!')&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 这样可以通过 this.props.onClick 获取到这个传进去的函数，修改 LikeButton 的 handleClickOnLikeButton 方法： 12345678910... handleClickOnLikeButton () &#123; this.setState(&#123; isLiked: !this.state.isLiked &#125;) if (this.props.onClick) &#123; this.props.onClick() &#125; &#125;... 当每次点击按钮的时候，控制台会显示 Click on like button! 。但这个行为不是点赞组件自己实现的，而是我们传进去的。所以，一个组件的行为、显示形态都可以用 props 来控制，就可以达到很好的可配置性。 默认配置 defaultProps上面的组件默认配置我们是通过 || 操作符来实现。这种需要默认配置的情况在 React.js 中非常常见，所以 React.js 也提供了一种方式 defaultProps，可以方便的做到默认配置。123456789101112131415161718192021222324252627class LikeButton extends Component &#123; static defaultProps = &#123; likedText: '取消', unlikedText: '点赞' &#125; constructor () &#123; super() this.state = &#123; isLiked: false &#125; &#125; handleClickOnLikeButton () &#123; this.setState(&#123; isLiked: !this.state.isLiked &#125;) &#125; render () &#123; return ( &lt;button onClick=&#123;this.handleClickOnLikeButton.bind(this)&#125;&gt; &#123;this.state.isLiked ? this.props.likedText : this.props.unlikedText&#125; ?? &lt;/button&gt; ) &#125;&#125; 注意，我们给点赞组件加上了以下的代码：1234static defaultProps = &#123; likedText: '取消', unlikedText: '点赞'&#125; defaultProps 作为点赞按钮组件的类属性，里面是对 props 中各个属性的默认配置。这样我们就不需要判断配置属性是否传进来了：如果没有传进来，会直接使用 defaultProps 中的默认属性。 所以可以看到，在 render 函数中，我们会直接使用 this.props 而不需要再做判断。 props 不可变props 一旦传入进来就不能改变。我们尝试改变 this.props.likedText，然后你会看到控制台报错了： 你不能改变一个组件被渲染的时候传进来的 props。React.js 希望一个组件在输入确定的 props 的时候，能够输出确定的 UI 显示形态。如果 props 渲染过程中可以被修改，那么就会导致这个组件显示形态和行为变得不可预测，这样会可能会给组件使用者带来困惑。 但这并不意味着由 props 决定的显示形态不能被修改。组件的使用者可以主动地通过重新渲染的方式把新的 props 传入组件当中，这样这个组件中由 props 决定的显示形态也会得到相应的改变。 修改上面的例子的 Index 组件：123456789101112131415161718192021222324252627282930class Index extends Component &#123; constructor () &#123; super() this.state = &#123; likedText: '已赞', unlikedText: '赞' &#125; &#125; handleClickOnChange () &#123; this.setState(&#123; likedText: '取消', unlikedText: '点赞' &#125;) &#125; render () &#123; return ( &lt;div&gt; &lt;LikeButton likedText=&#123;this.state.likedText&#125; unlikedText=&#123;this.state.unlikedText&#125; /&gt; &lt;div&gt; &lt;button onClick=&#123;this.handleClickOnChange.bind(this)&#125;&gt; 修改 wordings &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 在这里，我们把 Index 的 state 中的 likedText 和 unlikedText 传给 LikeButton 。Index 还有另外一个按钮，点击这个按钮会通过 setState 修改 Index 的 state 中的两个属性。 由于 setState 会导致 Index 重新渲染，所以 LikedButton 会接收到新的 props，并且重新渲染，于是它的显示形态也会得到更新。这就是通过重新渲染的方式来传入新的 props 从而达到修改 LikedButton 显示形态的效果。 总结为了使得组件的可定制性更强，在使用组件的时候，可以在标签上加属性来传入配置参数。组件可以在内部通过 this.props 获取到配置参数，组件可以根据 props 的不同来确定自己的显示形态，达到可配置的效果。可以通过给组件添加类属性 defaultProps 来配置默认参数。props 一旦传入，你就不可以在组件内部对它进行修改。但是你可以通过父组件主动重新渲染的方式来传入新的 props，从而达到更新的效果。 state vs propsstate 的主要作用是用于组件保存、控制、修改自己的可变状态。state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。state 中状态可以通过 this.setState 方法进行更新，setState 会导致组件的重新渲染。 props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props，否则组件的 props 永远保持不变。 state 和 props 有着千丝万缕的关系。它们都可以决定组件的行为和显示形态。一个组件的 state 中的数据可以通过 props 传给子组件，一个组件可以使用外部传入的 props 来初始化自己的 state。但是它们的职责其实非常明晰分明：state 是让组件控制自己的状态，props 是让外部对组件自己进行配置。 如果你觉得还是搞不清 state 和 props 的使用场景，那么请记住一个简单的规则：尽量少地用 state，尽量多地用 props。 没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。前端应用状态管理是一个复杂的问题，我们后续会继续讨论。 React.js 非常鼓励无状态组件，在 0.14 版本引入了函数式组件——一种定义不能使用 state 组件，例如一个原来这样写的组件： 123456789101112131415class HelloWorld extends Component &#123; constructor() &#123; super() &#125; sayHi () &#123; alert('Hello World') &#125; render () &#123; return ( &lt;div onClick=&#123;this.sayHi.bind(this)&#125;&gt;Hello World&lt;/div&gt; ) &#125;&#125; 用函数式组件的编写方式就是：123456const HelloWorld = (props) =&gt; &#123; const sayHi = (event) =&gt; alert('Hello World') return ( &lt;div onClick=&#123;sayHi&#125;&gt;Hello World&lt;/div&gt; )&#125; 以前一个组件是通过继承 Component 来构建，一个子类就是一个组件。而用函数式的组件编写方式是一个函数就是一个组件，你可以和以前一样通过 使用该组件。不同的是，函数式组件只能接受 props 而无法像跟类组件一样可以在 constructor 里面初始化 state。你可以理解函数式组件就是一种只能接受 props 和提供 render 方法的类组件。 渲染列表数据React.js 当然也允许我们处理列表数据，但在使用 React.js 处理列表数据的时候，需要掌握一些规则。 渲染存放 JSX 元素的数组假设现在我们有这么一个用户列表数据，存放在一个数组当中：123456const users = [ &#123; username: 'Jerry', age: 21, gender: 'male' &#125;, &#123; username: 'Tomy', age: 22, gender: 'male' &#125;, &#123; username: 'Lily', age: 19, gender: 'female' &#125;, &#123; username: 'Lucy', age: 20, gender: 'female' &#125;] React.js 把插入表达式数组里面的每一个 JSX 元素一个个罗列下来，渲染到页面上。所以这里有个关键点：如果你往 {} 放一个数组，React.js 会帮你把数组里面一个个元素罗列并且渲染出来。 使用 map 渲染列表数据知道这一点以后你就可以知道怎么用循环把元素渲染到页面上：循环上面用户数组里面的每一个用户，为每个用户数据构建一个 JSX，然后把 JSX 放到一个新的数组里面，再把新的数组插入 render 方法的 JSX 里面。看看代码怎么写：12345678910111213141516171819202122232425262728293031const users = [ &#123; username: 'Jerry', age: 21, gender: 'male' &#125;, &#123; username: 'Tomy', age: 22, gender: 'male' &#125;, &#123; username: 'Lily', age: 19, gender: 'female' &#125;, &#123; username: 'Lucy', age: 20, gender: 'female' &#125;]class Index extends Component &#123; render () &#123; const usersElements = [] // 保存每个用户渲染以后 JSX 的数组 for (let user of users) &#123; usersElements.push( // 循环每个用户，构建 JSX，push 到数组中 &lt;div&gt; &lt;div&gt;姓名：&#123;user.username&#125;&lt;/div&gt; &lt;div&gt;年龄：&#123;user.age&#125;&lt;/div&gt; &lt;div&gt;性别：&#123;user.gender&#125;&lt;/div&gt; &lt;hr /&gt; &lt;/div&gt; ) &#125; return ( &lt;div&gt;&#123;usersElements&#125;&lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById('root')) 这里用了一个新的数组 usersElements，然后循环 users 数组，为每个 user 构建一个 JSX 结构，然后 push 到 usersElements 中。然后直接用表达式插入，把这个 userElements 插到 return 的 JSX 当中。因为 React.js 会自动化帮我们把数组当中的 JSX 罗列渲染出来。 但我们一般不会手动写循环来构建列表的 JSX 结构，可以直接用 ES6 自带的 map（不了解 map 函数的同学可以先了解相关的知识再来回顾这里），代码可以简化成：123456789101112131415161718class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &#123;users.map((user) =&gt; &#123; return ( &lt;div&gt; &lt;div&gt;姓名：&#123;user.username&#125;&lt;/div&gt; &lt;div&gt;年龄：&#123;user.age&#125;&lt;/div&gt; &lt;div&gt;性别：&#123;user.gender&#125;&lt;/div&gt; &lt;hr /&gt; &lt;/div&gt; ) &#125;)&#125; &lt;/div&gt; ) &#125;&#125; 这样的模式在 JavaScript 中非常常见，一般来说，在 React.js 处理列表就是用 map 来处理、渲染的。现在进一步把渲染单独一个用户的结构抽离出来作为一个组件，继续优化代码：1234567891011121314151617181920212223242526272829303132333435const users = [ &#123; username: 'Jerry', age: 21, gender: 'male' &#125;, &#123; username: 'Tomy', age: 22, gender: 'male' &#125;, &#123; username: 'Lily', age: 19, gender: 'female' &#125;, &#123; username: 'Lucy', age: 20, gender: 'female' &#125;]class User extends Component &#123; render () &#123; const &#123; user &#125; = this.props return ( &lt;div&gt; &lt;div&gt;姓名：&#123;user.username&#125;&lt;/div&gt; &lt;div&gt;年龄：&#123;user.age&#125;&lt;/div&gt; &lt;div&gt;性别：&#123;user.gender&#125;&lt;/div&gt; &lt;hr /&gt; &lt;/div&gt; ) &#125;&#125;class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &#123;users.map((user) =&gt; &lt;User user=&#123;user&#125; /&gt;)&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById('root')) 这里把负责展示用户数据的 JSX 结构抽离成一个组件 User ，并且通过 props 把 user 数据作为组件的配置参数传进去；这样改写 Index 就非常清晰了，看一眼就知道负责渲染 users 列表，而用的组件是 User。 这样 React.js 就简单的通过 key 来判断出来，这两个列表元素只是交换了位置，可以尽量复用元素内部的结构。 这里没听懂没有关系，后面有机会会继续讲解这部分内容。现在只需要记住一个简单的规则：对于用表达式套数组罗列到页面上的元素，都要为每个元素加上 key 属性，这个 key 必须是每个元素唯一的标识。一般来说，key 的值可以直接后台数据返回的 id，因为后台的 id 都是唯一的。 记住一点：在实际项目当中，如果你的数据顺序可能发生变化，标准做法是最好是后台数据返回的 id 作为列表元素的 key。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F03%2F25%2Fgit-command%2F</url>
    <content type="text"><![CDATA[查看状态1$ git status 把项目添加到仓库1$ git add 【-A】|【文件名称】|$ git add . 提交代码1$ git commit -m &quot;文件描述&quot; 推送到默认分支1$ git push 推送到远程分支1$ git push origin master 将本地仓库和远程仓库进行关联1$ git remote add origin https://github.com/guyibang/TEST2.git 把本地仓库的项目推送到远程仓库1$ git push -u origin master 移除远程仓库1$ git remote rm origin 查看远程分支1$ git branch --remote 查看本地分支1$ git branch 查看所有远程分支1$ git branch -a 切换到 source-code 分支1git checkout source-code]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2018%2F03%2F25%2Fhexo-command%2F</url>
    <content type="text"><![CDATA[启动服务器（默认端口4000）1$ hexo server 或1$ hexo s 在指定端口（5000端口）上启动服务1$ hexo s -p 5000 清除缓存文件 (db.json) 和已生成的静态文件 (public)1$ hexo clean 生成静态文件1$ hexo g 部署网站1$ hexo d]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
